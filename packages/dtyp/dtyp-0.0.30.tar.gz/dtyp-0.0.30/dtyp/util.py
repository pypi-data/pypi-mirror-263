# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_util.ipynb.

# %% auto 0
__all__ = ['get_option', 'wrapper_signature_update', 'init_enum', 'getname', 'private', 'mangled', 'unmangle',
           'unmangled_annotations', 'in_lookup', 'sort_parameters', 'put_var_in_parameters']

# %% ../nbs/03_util.ipynb 6
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind, _empty as Empty
from functools import wraps, partial
from enum import EnumMeta

# %% ../nbs/03_util.ipynb 8
from types import NoneType, WrapperDescriptorType, FunctionType, MethodWrapperType
from typing import (
    Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict,
    ParamSpecArgs, ParamSpecKwargs, get_args, _UnionGenericAlias, get_type_hints
)

# %% ../nbs/03_util.ipynb 10
#| export


# %% ../nbs/03_util.ipynb 12
#| export


# %% ../nbs/03_util.ipynb 14
from .cons import (U1, U2, __NAME__, __QUALNAME__, __ANNOTATIONS__)
from .atyp import T, _ARGS, _KWDS
from dtyp.grds import (
    isoptional, isnone, notnone, isdict, hasvarg, hasvkws,
    isdunder, ismangled
)

# %% ../nbs/03_util.ipynb 17
def get_option(x, i: int = 0):
    "Check if `x` is an optional type"
    if not isoptional(x): return None
    args = get_args(x)
    dcks = getattr(x, '__ducktype__', None)
    if notnone(dcks): return x
    if len(args) == 0: return None
    return args[i if i < len(args) else -1] 

# %% ../nbs/03_util.ipynb 19
def wrapper_signature_update(
    wrapper: WrapperDescriptorType | FunctionType | MethodWrapperType, 
    __signature: Signature, 
    __callable: T,
    __annots: bool = True
) -> WrapperDescriptorType:
    wrapper.__signature__ = __signature
    if __annots: wrapper.__annotations__ = __callable.__annotations__
    try: wrapper.__doc__  = __callable.__doc__
    except: ...
    try: wrapper.__call__ = __callable.__call__
    except: ...
    try: wrapper.__init__.__signature__ = __signature
    except: ...
    try: 
        if __annots: wrapper.__init__.__annotations__ = __callable.__annotations__
    except: ...
    try:
        if __annots: wrapper.__annotations__ = __callable.__annotations__
    except: pass
    return wrapper

# %% ../nbs/03_util.ipynb 21
def init_enum(ecls: EnumMeta) -> EnumMeta | None:
    try: return ecls()
    except: ...
    try: return ecls._default_() if callable(ecls._default_) else ecls._default_
    except: ...
    try: return ecls._missing_(None)
    except: ...
    try: list(ecls.__members__.values())[0]
    except: ...
    try: return ecls(0)
    except: ...
    return None

# %% ../nbs/03_util.ipynb 23
def getname(obj) -> str:
    return getattr(obj, __NAME__, getattr(obj, __QUALNAME__, str(obj)))

def private(attr: str) -> str:
    '''A private attribute i.e. `_{attr}`'''
    return f'{U1}{attr.lstrip(U1)}'

def mangled(cls: object, attr: str) -> str:
    '''A mangled attribute i.e. `_{cls.__name__}__{attr}`'''
    return f'{private(getname(cls))}{U2}{attr.lstrip(U2)}'

def unmangle(cls: object, attr: str) -> str:
    '''Unmangle an attribute name i.e.  `_{cls.__name__}__{attr}` --> `__{attr}`'''
    return attr.split(private(getname(cls)))[-1]

# %% ../nbs/03_util.ipynb 24
def _not_class_key(key: str, cls: Callable | None = None) -> bool:
    '''Check if `key` is neither a dunder or a mangled class attribute.'''
    return not isdunder(key) and not ismangled(getattr(cls, __NAME__, ''), key)

def _get_class_keys(cls: Callable, annots_only: bool = False) -> list[str]:
    '''Get the non-dunder, non-mangled class attributes.'''
    filt = partial(_not_class_key, cls=cls)
    ukey = list(filter(filt, cls.__dict__))
    tkey = list(get_type_hints(cls))
    keys = set(tkey + ([] if annots_only else ukey))
    return sorted(keys)

# %% ../nbs/03_util.ipynb 26
def unmangled_annotations(cls: T) -> dict:
    return {unmangle(cls, k): v for k, v in get_annotations(cls).items()}

# %% ../nbs/03_util.ipynb 28
def in_lookup(key: str, ann: T, lookup: dict = {}) -> tuple[T, bool]:
    val = lookup.get(key, None)
    
    # handle ambigious bool values
    try: flag = bool(val)
    except: flag = False
    
    if notnone(val) and flag == True: 
        return val, flag
    
    for use in (val, ann):
        # check if val / ann in keys
        if not flag:
            try: 
                if use in lookup: 
                    return lookup.get(use), True
            except: ...
            
        # check if val / ann in values
        if not flag:
            try: 
                vals = list(lookup.values() if isdict(lookup) else lookup)
                if use in vals: 
                    return vals[vals.index(use)], True
            except: ...
            
            
    
    # check if anns in an instance of flag
    if not flag and notnone(val):
        try: 
            if ann == val:
                return ann, True
        except: ...
        
    # check if val / ann in an instance of val
    if not flag and notnone(val):
        try: 
            if isinstance(ann, val): 
                return val, True
        except: ...
            
    return val, flag

# %% ../nbs/03_util.ipynb 30
def _parameter_sort_tuple(p, order: list | None = None) -> tuple[int, int, bool, bool]:
    kinds = list(ParamKind)
    idx = order.index(p.name) if (order and p.name in order) else -1
    return (kinds.index(p.kind), idx, (p.default != Empty), (p.default == None))
    
def sort_parameters(
    __parameters: dict[str, Parameter] | list[Parameter],
    __idealorder: list | None = None
) -> list[Parameter]:
    sort = partial(_parameter_sort_tuple, order=__idealorder)
    prms = list(__parameters.values()) if isdict(__parameters) else __parameters
    return sorted(prms, key = sort)

def put_var_in_parameters(
    __parameters: dict[str, Parameter] | list[Parameter],
    __varpos: bool = True,
    __varkws: bool = True,
    __idealorder: list | None = None
) -> Signature:
    prms = list(__parameters.values()) if isdict(__parameters) else __parameters
    strs = set({p.name for p in prms})
    
    if not hasvarg(prms) and __varpos:
        vargs = _ARGS.replace()
        if vargs.name in strs: vargs = vargs.replace(name='__variadic_arguments')
        prms = prms + [vargs, ]
        
    if not hasvkws(prms) and __varkws: 
        vkwds = _KWDS.replace()
        if vkwds.name in strs: vkwds = vkwds.replace(name='__variadic_keywords')
        prms = prms + [vkwds, ]
        
    prms = sort_parameters(prms, __idealorder)
    return prms
