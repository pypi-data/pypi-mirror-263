# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_dcls.ipynb.

# %% auto 0
__all__ = ['annsdict', 'reducedict', 'dictdefs', 'dictsign', 'subdict', 'untype', 'inherit_annots', 'TypedDictMeta', 'TypeDict',
           'dtyp', 'typedict', 'tdict', 'tkws', 'TypeKwds', 'typekwds', 'new', 'setkeywords']

# %% ../nbs/04_dcls.ipynb 6
from functools import wraps, partial
from operator import attrgetter

# %% ../nbs/04_dcls.ipynb 8
from typing import (Self, Callable, TypedDict, get_type_hints, _TypedDictMeta)

# %% ../nbs/04_dcls.ipynb 10
#| export


# %% ../nbs/04_dcls.ipynb 12
#| export


# %% ../nbs/04_dcls.ipynb 14
from dtyp.cons import (
    __DOC__, __NEW__, __MODULE__, __DEFAULTS__, __TYPEDICT__, 
    __ANNOTATIONS__, __NAME__, __QUALNAME__, __SIGNATURE__
)
from .atyp import T, P, K, DictTypes
from .grds import (isnone, notnone, isdict, isdunder, )
from dtyp.util import (
    getname, totypeddict, dropnones,
    typed_dict_signature, reduce_dict_instances, dict_init_from_annot,
    typed_dict_defaults, get_typed_dict_keywords, prune_type_dict_keywords,
    _inherit_annots, _subdict, _untype
)

# %% ../nbs/04_dcls.ipynb 17
def annsdict(cls: type, **kwargs) -> dict:
    # dict_init_from_annot
    return dict_init_from_annot(cls, __locals=locals(), __globals=globals(), **kwargs)

def reducedict(cls: type, **kwargs) -> dict:
    # reduce_dict_instances
    return reduce_dict_instances(cls, __locals=locals(), __globals=globals(), **kwargs)

def dictdefs(cls: type, **kwargs) -> dict:
    # typed_dict_defaults
    return typed_dict_defaults(cls, __locals=locals(), __globals=globals(), **kwargs)

def dictsign(cls: type, **kwargs) -> dict:
    # typed_dict_signature
    return typed_dict_signature(cls, __locals=locals(), __globals=globals(), **kwargs)

def subdict(td: _TypedDictMeta, **kwargs) -> DictTypes:
    return _subdict(td, __locals=locals(), __globals=globals(), **kwargs)

def untype(td: _TypedDictMeta, **kwargs) -> DictTypes:
    return _untype(td, __locals=locals(), __globals=globals(), **kwargs)

def inherit_annots(cls, kls, **kwargs):
    return _inherit_annots(cls, kls, __locals=locals(), __globals=globals(), **kwargs)

# %% ../nbs/04_dcls.ipynb 19
class _getter:
    def __init__(self, attr, *attrs, __default=None):
        names = attr.split('.') + list(attrs)
        def func(obj, defs = __default):
            for name in names:
                obj = getattr(obj, name, __default=defs)
            return obj
        
        self.strs = names
        self.func = func
        self.defs = __default
        
    def __call__(self, obj, __default = None):
        return self.func(obj, __default or self.defs)

    def __repr__(self):
        return '%s.%s(%s)' % (self.__class__.__module__,
                              self.__class__.__qualname__,
                              ', '.join(map(repr, self.strs)))
        
        
def _gets(obj, attr, *attrs, __default=None):
    names = attr.split('.') + list(attrs)
    for name in names:
        obj = getattr(obj, name, __default)
    return obj

def _share_docs(cls, src, tdoc = None, ddoc = None):
    # try to get the class's TypedDict docs
    if tdoc is None:
        tdct = getattr(cls, __TYPEDICT__, dict())
        tdoc = getattr(tdct, __DOC__, None)
    # class docstring
    cdoc = getattr(cls, __DOC__, tdoc)
    if ddoc is None: ddoc = cdoc

    # source class default docs
    sdoc = getattr(src, __DOC__, cdoc)
    
    attrs = '__new__', '__init__', '__call__'
    for attr in attrs:
        fn = getattr(cls, attr, None)
        if isnone(fn): continue
        
        dc = getattr(fn, __DOC__, None)
        if isnone(dc):
            fdoc = _gets(src, attr, __DOC__, __default=ddoc)
            setattr(fn, __DOC__, fdoc)
    
    setattr(cls, __DOC__, sdoc)

# %% ../nbs/04_dcls.ipynb 20
class TypedDictMeta(type):
    __typedict__: dict
    '''The `TypedDict` created when subclassed''';
    
    __defaults__: dict = dict()
    '''Default values for the `TypeDict`''';
    
    def __subs__(cls) -> dict:
        return reducedict(cls)
    
    def __instancecheck__(cls, instance):
        if not isdict(instance): return False
        given = get_type_hints(cls)
        found = {k: type(v) for k, v in instance.items()}
        # Simplified type checking logic
        return all(given.get(k) == found.get(k) for k in given)
    
    def __new__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        # print('__new__', list(namespace), list(kwargs))
        namespace = namespace.copy()
        for k, v in kwargs.items():
            if isdunder(k):
               namespace.setdefault(k, v)
        new = super().__new__(cls, name, bases, namespace)
        return new
    
    def __defs__(cls, **kwargs: P.kwargs) -> dict:
        # all subclasses
        subs = cls.__subs__()
        
        # current annotations 
        anns = get_type_hints(cls)
        
        # signature with initiated default values
        sign = getattr(cls, __SIGNATURE__, None)
        # based keywords based on signature defaults, updated with kwargs
        base = dictdefs(cls.__typedict__, __sig=sign, **kwargs)
        
        # defaults from current class
        defs = cls() if issubclass(cls, dict) else dict()
        if isnone(defs): defs = dict()
                
        # keywords from class dict based on annotations
        akws = {k: v for k, v in cls.__dict__.items() if k in anns}
        
        # keywords from kwargs based on class signature
        kwds = {k: v for k, v in kwargs.items() if (k in set(list(base)))}
        
        vals = anns.copy()
        vals.update(subs)
        vals.update(defs)
        vals.update(base)
        vals.update(akws)
        vals.update(kwds)
        
        return vals
    
    def __init__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        # print('__ini__', list(namespace), list(kwargs))
        
        super().__init__(cls, name, bases)
        
        dget = lambda d: dict.get(d, __TYPEDICT__, None)
        tdoc = None
        for _dct in (namespace, kwargs):
            if notnone(tdct := dget(_dct)): 
                tdoc = getattr(tdct, __DOC__, None)
                break
        
        inhr = annsdict(tdct or dict, **kwargs)
            
        tdct = totypeddict(cls, )
        anns = get_type_hints(tdct)
        
        namespace.setdefault(__TYPEDICT__, tdct)
        setattr(cls, __TYPEDICT__, tdct)
        
        namespace.setdefault(__ANNOTATIONS__, anns)
        setattr(cls, __ANNOTATIONS__, anns)
                
        for k, v in kwargs.items():
            if k in anns:
                setattr(cls, k, v)
                
        # for k, v in namespace.items():
        #     if isdunder(k):
        #        setattr(cls, k, v)

        sign = dictsign(cls, **{**inhr, **kwargs})

        namespace.setdefault(__SIGNATURE__, sign)
        setattr(cls, __SIGNATURE__, sign)

        
        defs = cls.__defs__(**kwargs)
        setattr(cls, __DEFAULTS__, defs)
    
        attrs = '__new__', '__init__', '__call__'
        for attr in attrs:
            fn = getattr(cls, attr, None)
            
            if isnone(fn):  continue
            dc = getattr(fn, __DOC__, None)
            if isnone(dc):
                setattr(fn, __DOC__, getattr(cls, __DOC__, tdoc))
                setattr(cls, attr, fn)

# %% ../nbs/04_dcls.ipynb 22
class TypeDict(dict, metaclass=TypedDictMeta):
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__()
        # _share_docs(cls, cls)
        # _share_docs(cls, super(), ddoc=getattr(super(), __DOC__, cls.__doc__))
        base = getattr(cls, __DOC__, None)
        
        # super.__typedict__.__doc__
        stoc = _gets(super(), __TYPEDICT__, __DOC__, __default=base)
        # cls.__typedict__.__doc__
        tdoc = _gets(cls, __TYPEDICT__, __DOC__, __default=stoc)
        
        # class docstring
        cdoc = getattr(cls, __DOC__, tdoc)

        # super class default docs
        sdoc = _gets(super(), __DOC__, __default=cdoc)
        
        attrs = '__new__', '__init__', '__call__'
        for attr in attrs:
            fn = getattr(cls, attr, None)
            if isnone(fn): continue
            
            dc = getattr(fn, __DOC__, None)
            if isnone(dc):
                fdoc = _gets(super(), attr, __DOC__, __default=sdoc)
                setattr(fn, __DOC__, fdoc)
        
        setattr(cls, __DOC__, sdoc)

    def __new__(cls, *args: P.args, **kwargs: P.kwargs):
        inst = super().__new__(cls, *args, **kwargs)
        return inst
    
    def __init__(self, *args, **kwargs):
        tdct = self.__typedict__
        sign = self.__signature__
        both = {**type(self).__defaults__, **kwargs}
        kwds = dictdefs(tdct, __sig=sign, **both)
        super().__init__(*args, **kwds)
    
    def dropnones(self, inplace: bool = True):
        '''Removes keys with `None` values from the TypedDict instance.'''
        return type(self)(dropnones(self, inplace))
    
    @classmethod
    def reduce(cls, __dict: T | None) -> dict:
        return reducedict(__dict or cls)
        
    @classmethod
    def filter(cls, __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return get_typed_dict_keywords(tdict, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls, **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return prune_type_dict_keywords(tdict, **kwargs)

# %% ../nbs/04_dcls.ipynb 23
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class dtyp(TypeDict, __subclass=True):  ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typedict(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tdict(TypeDict, __subclass=True): ...
    

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tkws(TypeDict, __subclass=True): ...
    
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class TypeKwds(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typekwds(TypeDict, __subclass=True): ...

# %% ../nbs/04_dcls.ipynb 33
def new(d: T, **kwargs: K):
    def decorator(func: Callable):
        # signature = typed_dict_signature(d, **kwargs)
        # print(signature)
        inval = inherit_annots(d, func, **kwargs)
        # undct = _subdict(d, **kwargs)
        undct = untype(d, **kwargs)
        
        # bases = getattr(d, '__bases__', ())
        # bases = tuple(b for b in bases if not issubclass(b, TypeDict))
        # bases = bases + (TypeDict, )        
        anns = {**get_type_hints(undct), **get_type_hints(func)}
        nspc = dict(__annotations__=anns, __typedict__=d)
        # print('undct', undct())
        # print('deco', list(kwargs))
        subdict = type(getname(func), (undct, ), nspc, **inval)
        # for k, v, in func.__dict__.items():
        #     try: setattr(subdict, k, v)
        #     except:...
        return subdict
    return decorator

# %% ../nbs/04_dcls.ipynb 35
def setkeywords(d: T, **kwargs: K):
    def decorator(func: Callable):
        dropnones = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        construct = partial(typed_dict_defaults, d, __sig=signature, __non=dropnones)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__))
        def wrapper(**kwargs: type[d]) -> type[d]:
            kwds = construct(**kwargs)
            return d(**kwds)
        wrapper.__signature__ = signature
        return wrapper
    return decorator
