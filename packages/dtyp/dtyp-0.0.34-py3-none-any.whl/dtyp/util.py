# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_util.ipynb.

# %% auto 0
__all__ = ['get_option', 'init_enum', 'getname', 'private', 'mangled', 'unmangle', 'unmangled_annotations', 'kw_in_ann',
           'get_typed_dict_keywords', 'prune_type_dict_keywords', 'totypeddict', 'resolve_dict_classes', 'dropnones',
           'dictjoin', 'isdictlike', 'dictbases', 'in_lookup', 'sort_parameters', 'put_var_in_parameters',
           'init_from_annot', 'prep_parameter', 'dict_from_annot', 'dict_init_from_annot', 'signature_from_annotations',
           'typed_dict_signature', 'typed_dict_defaults', 'dictinit', 'reduce_dict_instances']

# %% ../nbs/03_util.ipynb 6
from enum import Enum, EnumMeta
from inspect import (
    getmro, isclass, get_annotations, 
    Signature, Parameter, _ParameterKind as ParamKind, _empty as Empty
)
from functools import wraps, partial, reduce

# %% ../nbs/03_util.ipynb 8
from typing import (Callable, TypedDict, TypeGuard, ForwardRef, get_args, get_type_hints, _TypedDictMeta)

# %% ../nbs/03_util.ipynb 10
#| export


# %% ../nbs/03_util.ipynb 12
#| export


# %% ../nbs/03_util.ipynb 14
from .cons import (U1, U2, NIL, ARGS, KWARGS, RETURN, __DOC__, __NAME__, __QUALNAME__, __ANNOTATIONS__, __DUCKTYPE__)
from .atyp import T, K, P, _ARGS, _KWDS, DictTypes, TDict, TDictMeta
from dtyp.grds import (
    isoptional, isnone, notnone, isdict, istype, hasvarg, hasvkws,
    not_class_key, isenum, ispsa, ispsk, istypeddictmeta,
)

# %% ../nbs/03_util.ipynb 17
def get_option(x, i: int = 0):
    "Check if `x` is an optional type"
    if not isoptional(x): return None
    args = get_args(x)
    dcks = getattr(x, __DUCKTYPE__, None)
    if notnone(dcks): return x
    if len(args) == 0: return None
    return args[i if i < len(args) else -1] 

# %% ../nbs/03_util.ipynb 19
def init_enum(ecls: EnumMeta) -> Enum | EnumMeta | None:
    try: return ecls()
    except: ...
    try: return ecls._default_() if callable(ecls._default_) else ecls._default_
    except: ...
    try: return ecls._missing_(None)
    except: ...
    try: list(ecls.__members__.values())[0]
    except: ...
    try: return ecls(0)
    except: ...
    return None

# %% ../nbs/03_util.ipynb 21
def getname(obj) -> str:
    return getattr(obj, __NAME__, getattr(obj, __QUALNAME__, str(obj)))

def private(attr: str) -> str:
    '''A private attribute i.e. `_{attr}`'''
    return f'{U1}{attr.lstrip(U1)}'

def mangled(cls: object, attr: str) -> str:
    '''A mangled attribute i.e. `_{cls.__name__}__{attr}`'''
    return f'{private(getname(cls))}{U2}{attr.lstrip(U2)}'

def unmangle(cls: object, attr: str) -> str:
    '''Unmangle an attribute name i.e.  `_{cls.__name__}__{attr}` --> `__{attr}`'''
    return attr.split(private(getname(cls)))[-1]

# %% ../nbs/03_util.ipynb 22
def _get_class_keys(cls: Callable, annots_only: bool = False) -> list[str]:
    '''Get the non-dunder, non-mangled class attributes.'''
    filt = partial( not_class_key, cls=cls)
    ukey = list(filter(filt, cls.__dict__))
    tkey = list(get_type_hints(cls))
    keys = set(tkey + ([] if annots_only else ukey))
    return sorted(keys)

# %% ../nbs/03_util.ipynb 24
def unmangled_annotations(cls: T) -> dict:
    return {unmangle(cls, k): v for k, v in get_annotations(cls).items()}

# %% ../nbs/03_util.ipynb 25
def kw_in_ann(keyword: str, mangled: str, annotations: dict, unmangled_annots: dict) -> bool:
    k_in_unmg = keyword in unmangled_annots # key is in the unmangled keywords
    k_in_anns = keyword in annotations  # key is a mangled keyword
    m_in_anns = mangled in annotations  # if the mangled keyword is in the annotations
    return any((k_in_unmg, k_in_anns, m_in_anns))

# %% ../nbs/03_util.ipynb 27
def get_typed_dict_keywords(
    __dct: T, 
    __pop_keyword: bool = True, 
    __defaults: T | None = None, 
    **kwargs: K
) -> T:
    '''Get the keywords arguments as specified in a `TypedDict`.
    
    Parameters
    ----------
    __pop_keyword : bool, default: True
        Whether to remove the keyword from the `kwargs` dictionary, by default True
        
    __defaults : T, optional
        The default values for the `TypedDict`, by default None
        
    kwargs : dict
        The keyword arguments to be added to the `TypedDict`
        
    Returns
    -------
    T
        The `TypedDict` with the keyword arguments added
    '''
    kwds = __defaults or {}
    anns = get_annotations(__dct)
    
    # unmangled annotation names
    unmg = unmangled_annotations(__dct)
    keys = list(kwargs.keys())
    for key in keys:
        mkw = mangled(__dct, key) # mangled keyword name
        if kw_in_ann(key, mkw, anns, unmg): 
            ukw = unmangle(__dct, key)    # unmangled the keyword name
            kwds[ukw] = kwargs.get(key) # add the unmangled keyword and its value to the result
            if __pop_keyword: kwargs.pop(key, None)
            continue
    return kwds

# %% ../nbs/03_util.ipynb 29
def prune_type_dict_keywords(__dct: T, **kwargs) -> T:
    keys = set()
    anns = get_annotations(__dct)
    unmg = unmangled_annotations(__dct)
    for key in kwargs:
        mkw = mangled(__dct, key)
        if kw_in_ann(key, mkw, anns, unmg):
            keys.add(key)
    return dict(((k, v) for k, v in kwargs.items() if k not in keys))

# %% ../nbs/03_util.ipynb 31
def _extract_mangled_keywords(
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return_annot: type | None = None,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs
) -> tuple[bool, bool, bool, type | None, dict | None, dict | None, bool]:
    __forced = kwargs.get('__force_defaults', __force_defaults)
    __varpos = kwargs.get('__varpos', __varpos)
    __varkws = kwargs.get('__varkws', __varkws)
    __return = kwargs.get('__return_annot', __return_annot)
    __ignore = kwargs.get('__ignore_values', __ignore_values or {})
    __rescue = kwargs.get('__rescue_values', __rescue_values or {})
    __useopt = kwargs.get('__use_optionals', __use_optionals)
    return (__forced, __varpos, __varkws, __return, __ignore, __rescue, __useopt)

def _update_mangled_keywords(
    **kwargs
) -> dict:
    (__forced, __varpos, __varkws, __return, __ignore, __rescue, __useopt) = _extract_mangled_keywords(**kwargs)
    kwargs.update(
        __force_defaults=__forced,
        __varpos=__varpos,
        __varkws=__varkws,
        __return_annot=__return,
        __ignore_values=__ignore,
        __rescue_values=__rescue,
        __use_optionals=__useopt,
    )
    return kwargs

# %% ../nbs/03_util.ipynb 33
def totypeddict(
    cls: Callable, 
    td: _TypedDictMeta | None = None, 
    name: str | None = NIL
) -> _TypedDictMeta:
    if isnone(td):
        if isnone(name) and notnone(td): 
            name = getname(td)
        return TypedDict( f'{name}_typeddict', get_type_hints(cls))
    return td

# %% ../nbs/03_util.ipynb 36
def _resolve(
    fref: ForwardRef, 
    __name: str | None = None,
    __type: type | None = None,
    __locals: dict | None = None,
    __globals: dict | None = None,
) -> T | None:
    if notnone(__type): return __type
    if isnone(__locals): __locals = locals()
    if isnone(__globals): __globals = globals()
    _cls, _str = None, (__name or getattr(fref, __NAME__, NIL))
    try: 
        _cls = __globals.get(_str, _cls)
        if istype(_cls): return _cls
    except Exception as err: ...
    
    try: 
        _cls = __locals.get(_str, _cls)
        if istype(_cls): return _cls
    except Exception as err: ...
    
    try: 
        _cls = fref._evaluate(__globals, __locals, set())
        if istype(_cls): return _cls
    except Exception as err: ...
    return _cls

# %% ../nbs/03_util.ipynb 37
def _get_typedict_class(
    __type: type | None = None, __locals: dict | None = None, __globals: dict | None = None
) -> TDict | None:
    return _resolve(TDict, 'TypeDict', __type=__type, __locals=__locals, __globals=__globals)
    
def _get_typeddictmeta_class(
    __type: type | None = None, __locals: dict | None = None, __globals: dict | None = None
) -> TDict | None:
    return _resolve(TDictMeta, 'TypedDictMeta', __type=__type, __locals=__locals, __globals=__globals)

# %% ../nbs/03_util.ipynb 38
def resolve_dict_classes(
    __dict: type | None = None, __meta: type | None = None,
    __locals: dict | None = None, __globals: dict | None = None,
) -> tuple[TDict | None, TDictMeta | None]:
    if isnone(__globals): __globals = globals()
    if isnone(__locals): __locals = locals()
    _d = _get_typedict_class(__type=__dict, __locals=__locals, __globals=__globals)
    _m = _get_typeddictmeta_class(__type=__meta, __locals=__locals, __globals=__globals)
    return _d, _m

# %% ../nbs/03_util.ipynb 40
def dropnones(dct: dict, inplace: bool = True) -> dict:
    new = {k: v for k, v in dct.items() if not isnone(v)}
    if not inplace: return new
    bad = set(list(dct.keys())) - set(list(new.keys()))
    for k in bad: dct.pop(k)
    return dct

# %% ../nbs/03_util.ipynb 42
def dictjoin(ini: dict = dict(), new: DictTypes | None = None) -> dict:
    return {**ini, **new}

# %% ../nbs/03_util.ipynb 44
def isdictlike(
    x, __dictclasses: tuple[DictTypes, ...] | None = None,
    __locals: dict | None = None, __globals: dict | None = None,
) -> TypeGuard[DictTypes]:
    dcls, mcls = resolve_dict_classes(__locals=__locals, __globals=__globals)
    dkls = __dictclasses or (dict, _TypedDictMeta, dcls, mcls,)
    dkls = tuple(filter(isclass, dkls))
    return isinstance(x, dkls) or issubclass(x, dkls)

# %% ../nbs/03_util.ipynb 46
def dictbases(
    cls: DictTypes, __dictclasses: tuple[DictTypes, ...] | None = None,
    __locals: dict | None = None, __globals: dict | None = None
) -> list[DictTypes]:
    isbase = partial(isdictlike, __dictclasses=__dictclasses, __locals=__locals, __globals=__globals)
    return list(filter(isbase, getmro(cls)))

# %% ../nbs/03_util.ipynb 49
def in_lookup(key: str, ann: T, lookup: dict = {}) -> tuple[T, bool]:
    val = lookup.get(key, None)
    
    # handle ambigious bool values
    try: flag = bool(val)
    except: flag = False
    
    if notnone(val) and flag == True: 
        return val, flag
    
    for use in (val, ann):
        # check if val / ann in keys
        if not flag:
            try: 
                if use in lookup: 
                    return lookup.get(use), True
            except: ...
            
        # check if val / ann in values
        if not flag:
            try: 
                vals = list(lookup.values() if isdict(lookup) else lookup)
                if use in vals: 
                    return vals[vals.index(use)], True
            except: ...
            
            
    
    # check if anns in an instance of flag
    if not flag and notnone(val):
        try: 
            if ann == val:
                return ann, True
        except: ...
        
    # check if val / ann in an instance of val
    if not flag and notnone(val):
        try: 
            if isinstance(ann, val): 
                return val, True
        except: ...
            
    return val, flag

# %% ../nbs/03_util.ipynb 51
def _parameter_sort_tuple(p, order: list | None = None) -> tuple[int, int, bool, bool]:
    kinds = list(ParamKind)
    idx = order.index(p.name) if (order and p.name in order) else -1
    return (kinds.index(p.kind), idx, (p.default != Empty), (p.default == None))
    
def sort_parameters(
    __parameters: dict[str, Parameter] | list[Parameter],
    __idealorder: list | None = None
) -> list[Parameter]:
    sort = partial(_parameter_sort_tuple, order=__idealorder)
    prms = list(__parameters.values()) if isdict(__parameters) else __parameters
    return sorted(prms, key = sort)


# %% ../nbs/03_util.ipynb 53
def put_var_in_parameters(
    __parameters: dict[str, Parameter] | list[Parameter],
    __varpos: bool = True,
    __varkws: bool = True,
    __idealorder: list | None = None
) -> Signature:
    prms = list(__parameters.values()) if isdict(__parameters) else __parameters
    strs = set({p.name for p in prms})
    
    if not hasvarg(prms) and __varpos:
        vargs = _ARGS.replace()
        if vargs.name in strs: vargs = vargs.replace(name='__variadic_arguments')
        prms = prms + [vargs, ]
        
    if not hasvkws(prms) and __varkws: 
        vkwds = _KWDS.replace()
        if vkwds.name in strs: vkwds = vkwds.replace(name='__variadic_keywords')
        prms = prms + [vkwds, ]
        
    prms = sort_parameters(prms, __idealorder)
    return prms

# %% ../nbs/03_util.ipynb 55
def init_from_annot(
    kwd: str, ann: type,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs
) -> tuple[T, bool]:
    __ignore = kwargs.get('__ignore_values', __ignore_values or {})
    __rescue = kwargs.get('__rescue_values', __rescue_values or {})
    __useopt = kwargs.get('__use_optionals', __use_optionals)
    if not isdict(__ignore): {getattr(v, __NAME__, v): v for v in __ignore}
    if not isdict(__rescue): {getattr(v, __NAME__, v): v for v in __rescue}
    

    # Check if the annotation is an Optional[type] or Duck.__species__ == Specise.OPT
    isopt = isoptional(ann)
    
    # Whether to use the optional value
    useopt = isopt and __useopt
    
    # Try and get the optional value from the annotation e.g. Optional[tensor] ---> tensor
    opt = get_option(ann)
    
    # The type to try and initalize
    typ = opt if useopt else ann
    
    # See if there is a default value in the keywords arguments
    val = kwargs.get(kwd, None)
    err = False
    
    # Whether the keyword `kwd` or type `typ` are in the provided values to ignore
    ign, ignore_ok = in_lookup(kwd, typ, __ignore)
    
    # Whether the keyword `kwd` or type `typ` are in the provided values to rescue
    res, rescue_ok = in_lookup(kwd, typ, __rescue)
    # print(kwd, ann, typ, ign, ignore_ok, res, rescue_ok, __ignore, __rescue)

    # If there is no default value, either the annotation is a type or an optional
    # type, and we are not to ignore this keyword / type
    if isnone(val) and (istype(ann) or isopt) and not ignore_ok:
        try: # try to instantiate the annotation 
            val = ann()
        except: # if it fails, set the default value to None
            err = True
            val = None
            
        # Optional paramter, use the first not None type to try and initalize an default value
        if useopt: 
            try: # try to instantiate the annotation 
                err = False
                val = opt()
            except: # if it fails, set the default value to None
                err = True
                val = None
                
        # Maybe we failed gracefully, but that was because we were working with
        # an enum type, so try a special init stragety
        if isenum(typ) and isnone(val): 
            try:
                err = False 
                val = init_enum(typ)
            except: 
                err = True
                val = None
    
    
    if rescue_ok and isnone(val):
        val = res
        
    return val, err

# %% ../nbs/03_util.ipynb 57
def _should_replace(
    ann: type, val: T, err: bool, pkind: ParamKind, __force_defaults: bool = False,
) -> bool:
    # None is ok if it is an Optional value
    optnone = isoptional(ann) and isnone(val) 
    
    # Some ParamKind's can't have defaults
    badkind = (pkind in (Parameter.VAR_POSITIONAL,) ) 
    
    # We have a default value or there was no error in trying to initiate the annotation
    goodval = notnone(val) or not err 
    
    replace = (
        # We are going to force the default value   
        (goodval or (__force_defaults and isnone(val))) or  
        # Optional is ok / ParamKind is allowed to have defaults
        optnone and not badkind
    )
    return replace

# %% ../nbs/03_util.ipynb 58
def prep_parameter(
    kwd: str, ann: type, val: T, err: bool, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    **kwargs
) -> Parameter:
    __force_defaults = kwargs.get('__force_defaults', __force_defaults)
    __varpos = kwargs.get('__varpos', __varpos)
    __varkws = kwargs.get('__varkws', __varkws)
    pkind = Parameter.POSITIONAL_OR_KEYWORD
    
    # if not isopt and isnone(val):
    #     pkind = Parameter.POSITIONAL_ONLY
    
    # if isopt and isnone(val):
    #     pkind = Parameter.KEYWORD_ONLY
        
    # variadic_args need `P.args` like type annotation to get here
    if kwd == ARGS and __varpos and (ispsa(ann) or isnone(ann)): 
        pkind = Parameter.VAR_POSITIONAL
        
    # variadic_kwargs need `P.kwargs` like type annotation to get here
    if kwd == KWARGS and __varkws and (ispsk(ann) or isnone(ann)): 
        pkind = Parameter.VAR_KEYWORD
    
    prm = Parameter(kwd, kind=pkind, annotation=ann)
    
    # print(kwd, ann, val, err, pkind, __force_defaults)
    if _should_replace(ann, val, err, pkind, __force_defaults):
        prm = prm.replace(default=val)
        
    return prm

# %% ../nbs/03_util.ipynb 60
def dict_from_annot(cls: DictTypes, **kwargs) -> dict:
    kwargs = _update_mangled_keywords(**kwargs)
    dct = dict()
    for kwd, ann in get_annotations(cls).items():
        if notnone(val := getattr(cls, kwd, None)):
            dct[kwd] = val
            continue
        
        val, _ = init_from_annot(kwd, ann, **kwargs)
        dct[kwd] = val
    return dct

# %% ../nbs/03_util.ipynb 61
def dict_init_from_annot(
    cls, __dictclasses: tuple[DictTypes, ...] | None = None, 
    __locals: dict | None = None, __globals: dict | None = None,
    **kwargs
) -> dict:
    getbases = partial(dictbases, __dictclasses=__dictclasses, __locals=__locals, __globals=__globals)
    dctbases = reversed(getbases(cls))
    dct = dict()
    for base in dctbases:
        if isdict(base): 
            dct.update(base)
        elif isdictlike(base): 
            new = dict_from_annot(base, **kwargs)
            dct.update(new)
        else: ...
    return dct

# %% ../nbs/03_util.ipynb 64
def signature_from_annotations(
    __dct: T,
    *, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return_annot: type | None = None,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs: P.kwargs
) -> Signature:
    '''Generate a function signature based on annotations and optionally specified defaults.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.
        
    **kwargs : P.kwargs
        Additional options to control the signature generation. These can include
        specific default values for some or all of the annotated parameters.
    
    Returns
    -------
    Signature
        A `Signature` object representing the generated signature for the function.
        
    See Also
    --------
    sigr.signature_from_annotations : Generate a function signature based on annotations.
    '''
    
    (__forced, __varpos, __varkws, __return, __ignore, __rescue, __useopt) = _extract_mangled_keywords(
        __force_defaults, __varpos, __varkws, __return_annot, __rescue_values, __ignore_values, __use_optionals,
        **kwargs
    )
    # print('signature_from_annotations', __return, __ignore, __rescue, __useopt)
    
    if not isdict(__ignore): 
        {getattr(v, __NAME__, v): v for v in __ignore}

    if not isdict(__rescue): 
        {getattr(v, __NAME__, v): v for v in __rescue}
    
    anns = get_annotations(__dct)
    return_annotation = __return or anns.pop(RETURN, __return if notnone(__return) else None)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        val, err = init_from_annot(
            kwd, ann, 
            __ignore_values = __ignore, 
            __rescue_values = __rescue, 
            __use_optionals = __useopt,
            **kwargs
        )
        
        prm = prep_parameter(
            kwd, ann, val, err,
            __force_defaults = __forced,
            __varpos = __varpos, 
            __varkws = __varkws,
            **kwargs
        )
        
        prms.append(prm)
        
    prms = put_var_in_parameters(prms, __varpos, __varkws, __idealorder=kwds)
    sig = Signature(prms, return_annotation=return_annotation)
    return sig

# %% ../nbs/03_util.ipynb 66
def typed_dict_signature(
    __dct: T, 
    __locals: dict | None = None, 
    __globals: dict | None = None,
    **kwargs: K
) -> Signature:
    '''Generates a Signature object representing the signature of a TypedDict.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the signature is generated
        .
    **kwargs : TypedDict
        Default values for the TypedDict fields, if any.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, default: `__dct`
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    Signature
        A Signature object representing the TypedDict's field names, types, and default values.
    '''
    kwargs.update(__return_annot=__dct)
    try: 
        base = dict_init_from_annot(__dct, __locals=__locals, __globals=__globals, **kwargs)
    except Exception as err: 
        base = dict()
    kwds = {**base, **kwargs}
    return signature_from_annotations(__dct=__dct, **kwds)

# %% ../nbs/03_util.ipynb 68
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    __locals: dict | None = None, __globals: dict | None = None,
    **kwargs: K
) -> T:
    '''Creates an instance of a TypedDict with default values specified either in the 
    signature or as keyword arguments.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the instance is created.
        
    __sig : Signature, optional
        A predefined Signature object for the TypedDict, if available.
        
    __non : bool, default: True
        If True, non-specified fields will be included with `None` values.
        
    **kwargs : TypedDict
        Overrides for default values specified in the signature.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    T
        An instance of the TypedDict with default values set.
    '''
    sig = __sig or typed_dict_signature(__dct, __locals=__locals, __globals=__globals, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

# %% ../nbs/03_util.ipynb 70
def dictinit(
    cls: DictTypes,
    __locals: dict | None = None, __globals: dict | None = None,
) -> dict:
    val = None
    dcls, mcls = resolve_dict_classes(__locals=__locals, __globals=__globals)
    if isdict(cls):
        val = cls
    try:
        if istypeddictmeta(cls) or isinstance(cls, _TypedDictMeta):
            val = typed_dict_defaults(cls, __locals=__locals, __globals=__globals)
    except: ...
    
    try:
        if isinstance(cls, mcls):
            val = cls()
    except: ...
    
    try:
        if issubclass(cls, dcls):
            val = cls()
    except: ...
    
    if isnone(val):
        val = dict()
    return val

# %% ../nbs/03_util.ipynb 71
def reduce_dict_instances(
    cls, __dictclasses: tuple[DictTypes, ...] | None = None,
    __locals: dict | None = None, __globals: dict | None = None,
) -> dict:
    getbases = partial(dictbases, __dictclasses=__dictclasses, __locals=__locals, __globals=__globals)
    return reduce(
        lambda old, new: dictjoin(old, dictinit(new, __locals=__locals, __globals=__globals)),
        reversed(getbases(cls)),
        dict()
    )

# %% ../nbs/03_util.ipynb 73
def _public_attrs(kls: type) -> dict:
    return dict((k, v) for k  in _get_class_keys(kls) if notnone(v := getattr(kls, k, None)))

def _inherit_annots(
    cls: Callable | _TypedDictMeta, kls: Callable | None = None, 
    __locals: dict | None = None, __globals: dict | None = None,
    **kwargs
) -> dict:
    anns = dict()
    if isnone(kls): kls = type(kls)
    
    anns.update(_public_attrs(kls))
    
    TD = _get_typedict_class(__locals=__locals, __globals=__globals)
    curr = getattr(cls, __ANNOTATIONS__, dict())
    miss = {k: v for k, v in TD.reduce(cls).items() if k not in curr}
    # print(
    #     'miss', list(v),
    #     'ckeys', list(ckeys), 'anns', list(annot), 'kwds', list(kwargs), sep='\n\t')
    anns.update(miss)
    anns.update(kwargs)
    
    if istypeddictmeta(cls): anns.update(__typedict__=cls)
    return anns

# %% ../nbs/03_util.ipynb 75
def _untype_dict(
    tdct: _TypedDictMeta, 
    __locals: dict | None = None, __globals: dict | None = None,
    **kwargs
) -> 'TypeDict':
    
    if not istypeddictmeta(tdct): 
        return tdct
    TD = _get_typedict_class(__locals=__locals, __globals=__globals)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct, __doc__=getattr(tdct, __DOC__, None))
    udct = type(
        f'{getname(tdct)}_untyped', 
        (TD, ), 
        nspc,
        **{**kwargs, **anns, **nspc}, 
    )
    return udct

def _subdict(
    tdct: _TypedDictMeta, 
    __locals: dict | None = None, __globals: dict | None = None,
    **kwargs
) -> 'TypeDict':
    if not istypeddictmeta(tdct): 
        return tdct
    TD = _get_typedict_class(__locals=__locals, __globals=__globals)
    inval = _inherit_annots(tdct, __locals=__locals, __globals=__globals, **kwargs)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct, __doc__=getattr(tdct, __DOC__, None))
    # print('subdict', list(inval))
    sdct = type(getname(tdct), (TD, ), nspc, **inval)
    return sdct

def _untype(
    tdct: _TypedDictMeta,
    __locals: dict | None = None, __globals: dict | None = None,
    **kwargs
) -> 'TypeDict':
    TD = _get_typedict_class(__locals=__locals, __globals=__globals)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct, __doc__=getattr(tdct, __DOC__, None))
    udct = type(getname(tdct), (TD, ), nspc, **kwargs)
    return udct
