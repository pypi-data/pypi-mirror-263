# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_dcls.ipynb.

# %% auto 0
__all__ = ['annsdict', 'reducedict', 'dictdefs', 'dictsign', 'subdict', 'untype', 'inherit_annots', 'TypedDictMeta', 'TypeDict',
           'dtyp', 'typedict', 'tdict', 'tkws', 'TypeKwds', 'typekwds', 'new', 'setkeywords']

# %% ../nbs/04_dcls.ipynb 6
from functools import wraps, partial

# %% ../nbs/04_dcls.ipynb 8
from typing import (Self, Callable, TypedDict, get_type_hints, _TypedDictMeta)

# %% ../nbs/04_dcls.ipynb 10
#| export


# %% ../nbs/04_dcls.ipynb 12
#| export


# %% ../nbs/04_dcls.ipynb 14
from dtyp.cons import (
    __DOC__, __NEW__, __MODULE__, __DEFAULTS__, __TYPEDICT__, 
    __ANNOTATIONS__, __NAME__, __QUALNAME__, __SIGNATURE__
)
from .atyp import T, P, K, DictTypes
from .grds import (isnone, notnone, isdict, isdunder, )
from dtyp.util import (
    getname, totypeddict, dropnones,
    typed_dict_signature, reduce_dict_instances, dict_init_from_annot,
    typed_dict_defaults, get_typed_dict_keywords, prune_type_dict_keywords,
    _inherit_annots, _subdict, _untype
)

# %% ../nbs/04_dcls.ipynb 17
def annsdict(cls: type, **kwargs) -> dict:
    # dict_init_from_annot
    return dict_init_from_annot(cls, __locals=locals(), __globals=globals(), **kwargs)

def reducedict(cls: type, **kwargs) -> dict:
    # reduce_dict_instances
    return reduce_dict_instances(cls, __locals=locals(), __globals=globals(), **kwargs)

def dictdefs(cls: type, **kwargs) -> dict:
    # typed_dict_defaults
    return typed_dict_defaults(cls, __locals=locals(), __globals=globals(), **kwargs)

def dictsign(cls: type, **kwargs) -> dict:
    # typed_dict_signature
    return typed_dict_signature(cls, __locals=locals(), __globals=globals(), **kwargs)

def subdict(td: _TypedDictMeta, **kwargs) -> DictTypes:
    return _subdict(td, __locals=locals(), __globals=globals(), **kwargs)

def untype(td: _TypedDictMeta, **kwargs) -> DictTypes:
    return _untype(td, __locals=locals(), __globals=globals(), **kwargs)

def inherit_annots(cls, kls, **kwargs):
    return _inherit_annots(cls, kls, __locals=locals(), __globals=globals(), **kwargs)

# %% ../nbs/04_dcls.ipynb 19
class TypedDictMeta(type):
    __typedict__: dict
    '''The `TypedDict` created when subclassed''';
    
    __defaults__: dict = dict()
    '''Default values for the `TypeDict`''';
    
    def __subs__(cls) -> dict:
        return reducedict(cls)
    
    def __instancecheck__(cls, instance):
        if not isdict(instance): return False
        given = get_type_hints(cls)
        found = {k: type(v) for k, v in instance.items()}
        # Simplified type checking logic
        return all(given.get(k) == found.get(k) for k in given)
    
    def __new__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        # print('__new__', list(namespace), list(kwargs))
        namespace = namespace.copy()
        for k, v in kwargs.items():
            if isdunder(k):
               namespace.setdefault(k, v)
        new = super().__new__(cls, name, bases, namespace)
        return new
    
    def __defs__(cls, **kwargs: P.kwargs) -> dict:
        # all subclasses
        subs = cls.__subs__()
        
        # current annotations 
        anns = get_type_hints(cls)
        
        # signature with initiated default values
        sign = getattr(cls, __SIGNATURE__, None)
        # based keywords based on signature defaults, updated with kwargs
        base = dictdefs(cls.__typedict__, __sig=sign, **kwargs)
        
        # defaults from current class
        defs = cls() if issubclass(cls, dict) else dict()
        if isnone(defs): defs = dict()
                
        # keywords from class dict based on annotations
        akws = {k: v for k, v in cls.__dict__.items() if k in anns}
        
        # keywords from kwargs based on class signature
        kwds = {k: v for k, v in kwargs.items() if (k in set(list(base)))}
        
        vals = anns.copy()
        vals.update(subs)
        vals.update(defs)
        vals.update(base)
        vals.update(akws)
        vals.update(kwds)
        
        return vals
    
    def __init__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        # print('__ini__', list(namespace), list(kwargs))
        
        super().__init__(cls, name, bases)
        
        dget = lambda d: dict.get(d, __TYPEDICT__, None)
        for _dct in (namespace, kwargs):
            if notnone(tdct := dget(_dct)): break
        
        inhr = annsdict(tdct or dict, **kwargs)
            
        tdct = totypeddict(cls, )
        anns = get_type_hints(tdct)
        
        namespace.setdefault(__TYPEDICT__, tdct)
        setattr(cls, __TYPEDICT__, tdct)
        
        namespace.setdefault(__ANNOTATIONS__, anns)
        setattr(cls, __ANNOTATIONS__, anns)
                
        for k, v in kwargs.items():
            if k in anns:
                setattr(cls, k, v)
                
        # for k, v in namespace.items():
        #     if isdunder(k):
        #        setattr(cls, k, v)

        sign = dictsign(cls, **{**inhr, **kwargs})

        namespace.setdefault(__SIGNATURE__, sign)
        setattr(cls, __SIGNATURE__, sign)

        
        defs = cls.__defs__(**kwargs)
        setattr(cls, __DEFAULTS__, defs)

# %% ../nbs/04_dcls.ipynb 21
class TypeDict(dict, metaclass=TypedDictMeta):
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__()

    def __new__(cls, *args: P.args, **kwargs: P.kwargs):
        inst = super().__new__(cls, *args, **kwargs)
        return inst
    
    def __init__(self, *args, **kwargs):
        tdct = self.__typedict__
        sign = self.__signature__
        both = {**type(self).__defaults__, **kwargs}
        kwds = dictdefs(tdct, __sig=sign, **both)
        super().__init__(*args, **kwds)
    
    def dropnones(self, inplace: bool = True):
        '''Removes keys with `None` values from the TypedDict instance.'''
        return type(self)(dropnones(self, inplace))
    
    @classmethod
    def reduce(cls, __dict: T | None) -> dict:
        return reducedict(__dict or cls)
        
    @classmethod
    def filter(cls, __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return get_typed_dict_keywords(tdict, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls, **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return prune_type_dict_keywords(tdict, **kwargs)

# %% ../nbs/04_dcls.ipynb 22
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class dtyp(TypeDict, __subclass=True):  ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typedict(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tdict(TypeDict, __subclass=True): ...
    

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tkws(TypeDict, __subclass=True): ...
    
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class TypeKwds(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typekwds(TypeDict, __subclass=True): ...

# %% ../nbs/04_dcls.ipynb 32
def new(d: T, **kwargs: K):
    def decorator(func: Callable):
        # signature = typed_dict_signature(d, **kwargs)
        # print(signature)
        inval = inherit_annots(d, func, **kwargs)
        # undct = _subdict(d, **kwargs)
        undct = untype(d, **kwargs)
        
        # bases = getattr(d, '__bases__', ())
        # bases = tuple(b for b in bases if not issubclass(b, TypeDict))
        # bases = bases + (TypeDict, )        
        anns = {**get_type_hints(undct), **get_type_hints(func)}
        nspc = dict(__annotations__=anns, __typedict__=d)
        # print('undct', undct())
        # print('deco', list(kwargs))
        subdict = type(getname(func), (undct, ), nspc, **inval)
        # for k, v, in func.__dict__.items():
        #     try: setattr(subdict, k, v)
        #     except:...
        return subdict
    return decorator

# %% ../nbs/04_dcls.ipynb 34
def setkeywords(d: T, **kwargs: K):
    def decorator(func: Callable):
        dropnones = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        construct = partial(typed_dict_defaults, d, __sig=signature, __non=dropnones)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__))
        def wrapper(**kwargs: type[d]) -> type[d]:
            kwds = construct(**kwargs)
            return d(**kwds)
        wrapper.__signature__ = signature
        return wrapper
    return decorator
