# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_sigs.ipynb.

# %% auto 0
__all__ = ['dict_from_annot', 'dict_init_from_annot', 'signature_from_annotations', 'typed_dict_signature', 'typed_dict_defaults',
           'dictinit', 'reduce_dict_instances', 'reduce_typedict', 'get_typed_dict_keywords']

# %% ../nbs/04_sigs.ipynb 6
from enum import Enum, EnumMeta
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind, _empty as Empty
from functools import wraps, partial, reduce

# %% ../nbs/04_sigs.ipynb 8
from types import NoneType, WrapperDescriptorType, FunctionType, MethodWrapperType
from typing import (
    Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict,
    ParamSpecArgs, ParamSpecKwargs, get_args, get_type_hints, 
    _UnionGenericAlias, _TypedDictMeta
)

# %% ../nbs/04_sigs.ipynb 10
#| export


# %% ../nbs/04_sigs.ipynb 12
#| export


# %% ../nbs/04_sigs.ipynb 14
from .cons import (ARGS, KWARGS, RETURN, __NAME__, __ANNOTATIONS__)
from .atyp import T, P, K, DictTypes
from dtyp.grds import (
    isdict, notnone, isnone, istypeddictmeta,
    resolve_dict_classes, _resolve_type_dict, isdictlike, needs_namespaces
)

from dtyp.util import (
    getname, dictbases, dictjoin, _get_class_keys,
    put_var_in_parameters, init_from_annot, prep_parameter,
    unmangled_annotations, mangled, kw_in_ann, unmangle,
)

# %% ../nbs/04_sigs.ipynb 16
def _extract_mangled_keywords(
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return_annot: type | None = None,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs
) -> tuple[bool, bool, bool, type | None, dict | None, dict | None, bool]:
    __forced = kwargs.get('__force_defaults', __force_defaults)
    __varpos = kwargs.get('__varpos', __varpos)
    __varkws = kwargs.get('__varkws', __varkws)
    __return = kwargs.get('__return_annot', __return_annot)
    __ignore = kwargs.get('__ignore_values', __ignore_values or {})
    __rescue = kwargs.get('__rescue_values', __rescue_values or {})
    __useopt = kwargs.get('__use_optionals', __use_optionals)
    return (__forced, __varpos, __varkws, __return, __ignore, __rescue, __useopt)

def _update_mangled_keywords(
    **kwargs
) -> dict:
    (__forced, __varpos, __varkws, __return, __ignore, __rescue, __useopt) = _extract_mangled_keywords(**kwargs)
    kwargs.update(
        __force_defaults=__forced,
        __varpos=__varpos,
        __varkws=__varkws,
        __return_annot=__return,
        __ignore_values=__ignore,
        __rescue_values=__rescue,
        __use_optionals=__useopt,
    )
    return kwargs

# %% ../nbs/04_sigs.ipynb 17
def dict_from_annot(cls: DictTypes, **kwargs) -> dict:
    kwargs = _update_mangled_keywords(**kwargs)
    dct = dict()
    for kwd, ann in get_annotations(cls).items():
        if notnone(val := getattr(cls, kwd, None)):
            dct[kwd] = val
            continue
        
        val, _ = init_from_annot(kwd, ann, **kwargs)
        dct[kwd] = val
    return dct

# %% ../nbs/04_sigs.ipynb 18
@needs_namespaces
def dict_init_from_annot(
    cls, __dictclasses: tuple[DictTypes, ...] | None = None, 
    __locs: dict | None = None, __glob: dict | None = None,
    **kwargs
) -> dict:
    getbases = partial(dictbases, __dictclasses=__dictclasses, __locs=__locs, __glob=__glob)
    dctbases = reversed(getbases(cls))
    dct = dict()
    for base in dctbases:
        if isdict(base): 
            dct.update(base)
        elif isdictlike(base): 
            new = dict_from_annot(base, **kwargs)
            dct.update(new)
        else: ...
    return dct

# %% ../nbs/04_sigs.ipynb 20
def signature_from_annotations(
    __dct: T,
    *, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return_annot: type | None = None,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs: P.kwargs
) -> Signature:
    '''Generate a function signature based on annotations and optionally specified defaults.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.
        
    **kwargs : P.kwargs
        Additional options to control the signature generation. These can include
        specific default values for some or all of the annotated parameters.
    
    Returns
    -------
    Signature
        A `Signature` object representing the generated signature for the function.
        
    See Also
    --------
    sigr.signature_from_annotations : Generate a function signature based on annotations.
    '''
    
    (__forced, __varpos, __varkws, __return, __ignore, __rescue, __useopt) = _extract_mangled_keywords(
        __force_defaults, __varpos, __varkws, __return_annot, __rescue_values, __ignore_values, __use_optionals,
        **kwargs
    )
    # print('signature_from_annotations', __return, __ignore, __rescue, __useopt)
    
    if not isdict(__ignore): 
        {getattr(v, __NAME__, v): v for v in __ignore}

    if not isdict(__rescue): 
        {getattr(v, __NAME__, v): v for v in __rescue}
    
    anns = get_annotations(__dct)
    return_annotation = __return or anns.pop(RETURN, __return if notnone(__return) else None)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        val, err = init_from_annot(
            kwd, ann, 
            __ignore_values = __ignore, 
            __rescue_values = __rescue, 
            __use_optionals = __useopt,
            **kwargs
        )
        
        prm = prep_parameter(
            kwd, ann, val, err,
            __force_defaults = __forced,
            __varpos = __varpos, 
            __varkws = __varkws,
            **kwargs
        )
        
        prms.append(prm)
        
    prms = put_var_in_parameters(prms, __varpos, __varkws, __idealorder=kwds)
    sig = Signature(prms, return_annotation=return_annotation)
    return sig

# %% ../nbs/04_sigs.ipynb 22
@needs_namespaces
def typed_dict_signature(
    __dct: T, 
    __locs: dict | None = None, 
    __glob: dict | None = None,
    **kwargs: K
) -> Signature:
    '''Generates a Signature object representing the signature of a TypedDict.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the signature is generated
        .
    **kwargs : TypedDict
        Default values for the TypedDict fields, if any.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, default: `__dct`
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    Signature
        A Signature object representing the TypedDict's field names, types, and default values.
    '''
    kwargs.update(__return_annot=__dct)
    try: base = dict_init_from_annot(__dct, __locs=__locs, __glob=__glob, **kwargs)
    except Exception as err: 
        base = dict()
        print(err)
    print('base', base)
    kwds = {**base, **kwargs}
    print('kwds', kwds)
    return signature_from_annotations(__dct=__dct, **kwds)

# %% ../nbs/04_sigs.ipynb 24
@needs_namespaces
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    __locs: dict | None = None, __glob: dict | None = None,
    **kwargs: K
) -> T:
    '''Creates an instance of a TypedDict with default values specified either in the 
    signature or as keyword arguments.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the instance is created.
        
    __sig : Signature, optional
        A predefined Signature object for the TypedDict, if available.
        
    __non : bool, default: True
        If True, non-specified fields will be included with `None` values.
        
    **kwargs : TypedDict
        Overrides for default values specified in the signature.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    T
        An instance of the TypedDict with default values set.
    '''
    sig = __sig or typed_dict_signature(__dct, __locs=__locs, __glob=__glob, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

# %% ../nbs/04_sigs.ipynb 26
@needs_namespaces
def dictinit(
    cls: DictTypes,
    __locs: dict | None = None, __glob: dict | None = None,
) -> dict:
    val = None
    dcls, mcls = resolve_dict_classes(__locs=__locs, __glob=__glob)
    if isdict(cls):
        val = cls
    try:
        if istypeddictmeta(cls) or isinstance(cls, _TypedDictMeta):
            val = typed_dict_defaults(cls, __locs=__locs, __glob=__glob)
    except: ...
    
    try:
        if isinstance(cls, mcls):
            val = cls()
    except: ...
    
    try:
        if issubclass(cls, dcls):
            val = cls()
    except: ...
    
    if isnone(val):
        val = dict()
    return val

# %% ../nbs/04_sigs.ipynb 27
@needs_namespaces
def reduce_dict_instances(
    cls, __dictclasses: tuple[DictTypes, ...] | None = None,
    __locs: dict | None = None, __glob: dict | None = None,
) -> dict:
    getbases = partial(dictbases, __dictclasses=__dictclasses, __locs=__locs, __glob=__glob)
    return reduce(
        lambda old, new: dictjoin(old, dictinit(new, __locs=__locs, __glob=__glob)),
        reversed(getbases(cls)),
        dict()
    )

# %% ../nbs/04_sigs.ipynb 28
@needs_namespaces
def reduce_typedict(cls, __locs: dict | None = None, __glob: dict | None = None) -> dict:
    merge = partial(
        reduce_dict_instances, __dictclasses=(dict, _TypedDictMeta, TypedDictMeta, TypeDict),
        __locs=__locs, __glob=__glob
    )
    return merge(cls)

# %% ../nbs/04_sigs.ipynb 30
@needs_namespaces
def _inherit_annots(
    cls: Callable | _TypedDictMeta, kls: Callable | None = None, 
    __locs: dict | None = None, __glob: dict | None = None,
    **kwargs
) -> dict:
    inher = dict()
    if isnone(kls): 
        kls = type(kls)
        
    ckeys = dict((k, v) for k  in _get_class_keys(kls) if notnone(v := getattr(kls, k, None)))
    inval = inher
    inval.update(ckeys)
    annot = getattr(cls, __ANNOTATIONS__, dict())
    TD = _resolve_type_dict(__locs=__locs, __glob=__glob)
    missing = {k: v for k, v in TD.reduce(cls).items() if k not in annot}
    # print(
    #     'missing', list(missing),
    #     'ckeys', list(ckeys), 'anns', list(annot), 'kwds', list(kwargs), sep='\n\t')
    inval.update(missing)
    inval.update(kwargs)
    
    if istypeddictmeta(cls): 
        inval.update(__typedict__=cls)
    return inval


# %% ../nbs/04_sigs.ipynb 32
@needs_namespaces
def _untype_dict(
    tdct: _TypedDictMeta, 
    __locs: dict | None = None, __glob: dict | None = None,
    **kwargs
) -> 'TypeDict':
    
    if not istypeddictmeta(tdct): 
        return tdct
    TD = _resolve_type_dict(__locs=__locs, __glob=__glob)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct)
    udct = type(
        f'{getname(tdct)}_untyped', 
        (TD, ), 
        nspc,
        **{**kwargs, **anns, **nspc}, 
    )
    return udct

@needs_namespaces
def _subdict(
    tdct: _TypedDictMeta, 
    __locs: dict | None = None, __glob: dict | None = None,
    **kwargs
) -> 'TypeDict':
    if not istypeddictmeta(tdct): 
        return tdct
    TD = _resolve_type_dict(__locs=__locs, __glob=__glob)
    inval = _inherit_annots(tdct, __locs=__locs, __glob=__glob, **kwargs)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct)
    print('subdict', list(inval))
    sdct = type(getname(tdct), (TD, ), nspc, **inval)
    return sdct

@needs_namespaces
def _untype(
    tdct: _TypedDictMeta,
    __locs: dict | None = None, __glob: dict | None = None,
    **kwargs
):
    TD = _resolve_type_dict(__locs=__locs, __glob=__glob)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct)
    udct = type(getname(tdct), (TD, ), nspc, **kwargs)
    return udct

# %% ../nbs/04_sigs.ipynb 34
def get_typed_dict_keywords(
    __dct: T, 
    __pop_keyword: bool = True, 
    __defaults: T | None = None, 
    **kwargs: K
) -> T:
    '''Get the keywords arguments as specified in a `TypedDict`.
    
    Parameters
    ----------
    __pop_keyword : bool, default: True
        Whether to remove the keyword from the `kwargs` dictionary, by default True
        
    __defaults : T, optional
        The default values for the `TypedDict`, by default None
        
    kwargs : dict
        The keyword arguments to be added to the `TypedDict`
        
    Returns
    -------
    T
        The `TypedDict` with the keyword arguments added
    '''
    kwds = __defaults or {}
    anns = get_annotations(__dct)
    
    # unmangled annotation names
    unmg = unmangled_annotations(__dct)
    keys = list(kwargs.keys())
    for key in keys:
        mkw = mangled(__dct, key) # mangled keyword name
        if kw_in_ann(key, mkw, anns, unmg): 
            ukw = unmangle(__dct, key)    # unmangled the keyword name
            kwds[ukw] = kwargs.get(key) # add the unmangled keyword and its value to the result
            if __pop_keyword: kwargs.pop(key, None)
            continue
    return kwds

# %% ../nbs/04_sigs.ipynb 36
def prune_type_dict_keywords(__dct: T, **kwargs) -> T:
    keys = set()
    anns = get_annotations(__dct)
    unmg = unmangled_annotations(__dct)
    for key in kwargs:
        mkw = mangled(__dct, key)
        if kw_in_ann(key, mkw, anns, unmg):
            keys.add(key)
    return dict(((k, v) for k, v in kwargs.items() if k not in keys))
