# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_ncls.ipynb.

# %% auto 0
__all__ = ['resolve_dict_classes', 'dictinit', 'dictjoin', 'isdictlike', 'dictbases', 'reduce_dict_instances', 'TypedDictMeta',
           'reduce_typedict', 'TypeDict', 'dtyp', 'typedict', 'tdict', 'tkws', 'TypeKwds', 'typekwds', 'new']

# %% ../nbs/10_ncls.ipynb 6
from inspect import getmro, isclass
from functools import wraps, partial, reduce

# %% ../nbs/10_ncls.ipynb 8
from typing import (Self, Union, Callable, TypeAlias, TypedDict, TypeGuard, get_type_hints, _TypedDictMeta)

# %% ../nbs/10_ncls.ipynb 10
#| export


# %% ../nbs/10_ncls.ipynb 12
#| export


# %% ../nbs/10_ncls.ipynb 14
from dtyp.cons import (
    __DOC__, __NEW__, __MODULE__, __DEFAULTS__, __TYPEDICT__, 
    __ANNOTATIONS__, __NAME__, __QUALNAME__, __SIGNATURE__
)
from .atyp import T, P, K, DictTypes, TDict, TDictMeta
from .grds import isnone, notnone, isdict, isdunder, ismangled, istypeddictmeta
from .util import getname, wrapper_signature_update, _get_class_keys
from .sigs import typed_dict_signature
from .tdct import (typed_dict_defaults, get_typed_dict_keywords, prune_type_dict_keywords)

# %% ../nbs/10_ncls.ipynb 16
def _totypeddict(cls: Callable, td: _TypedDictMeta | None = None, name: str | None = '') -> _TypedDictMeta:
    if isnone(td):
        if isnone(name) and notnone(td): name = getname(td)
        return TypedDict( f'{name}_typeddict', get_type_hints(cls))
    return td

# %% ../nbs/10_ncls.ipynb 17
def resolve_dict_classes() -> tuple[TDict | None, TDictMeta | None]:
    _d = None
    try: _d = TDict._evaluate(globals(), locals(), set())
    except: ...
    try: _d = TypeDict
    except: ...
    try: _d = globals().get('TypeDict', _d)
    except: ...
    try: _d = locals().get('TypeDict', _d)
    except: ...
    
    _m = None
    try: _m = TDictMeta._evaluate(globals(), locals(), set())
    except: ...
    try: _m = TypedDictMeta
    except: ...
    try: _m = globals().get('TypedDictMeta', _m)
    except: ...
    try: _m = locals().get('TypedDictMeta', _d)
    except: ...
    return _d, _m
        

def dictinit(cls: DictTypes) -> dict:
    val = None
    dcls, mcls = resolve_dict_classes()
    if isdict(cls):
        val = cls
    try:
        if istypeddictmeta(cls) or isinstance(cls, _TypedDictMeta):
            val = typed_dict_defaults(cls)
    except: ...
    
    try:
        # kls = TDictMeta._evaluate(globals(), locals(), set())
        # if isinstance(cls, TypedDictMeta):
        if isinstance(cls, mcls):
            val = cls()
    except: ...
    
    try:
        # kls = TDict._evaluate(globals(), locals(), set())
        # if issubclass(cls, TypeDict):
        if issubclass(cls, dcls):
            val = cls()
    except: ...
    
    if isnone(val):
        val = dict()
    return val

def dictjoin(ini: dict = dict(), new: DictTypes | None = None) -> dict:
    return {**ini, **new}

def isdictlike(
    x, __dictclasses: tuple[DictTypes, ...] | None
) -> TypeGuard[DictTypes]:
    dcls, mcls = resolve_dict_classes()
    dkls = __dictclasses or (
        dict, _TypedDictMeta,
        dcls, mcls,
        # TypeDict, TypedDictMeta,
    )
    dkls = tuple(filter(isclass, dkls))
    return isinstance(x, dkls) or issubclass(x, dkls)

def dictbases(cls: DictTypes, __dictclasses: tuple[DictTypes, ...] | None = None) -> list[DictTypes]:
    isbase = partial(isdictlike, __dictclasses=__dictclasses)
    return list(filter(isbase, getmro(cls)))

def reduce_dict_instances(cls, __dictclasses: tuple[DictTypes, ...] | None = None) -> dict:
    getbases = partial(dictbases, __dictclasses=__dictclasses)
    return reduce(
        lambda old, new: dictjoin(old, dictinit(new)),
        reversed(getbases(cls)),
        dict()
    )

# %% ../nbs/10_ncls.ipynb 19
class TypedDictMeta(type):
    __typedict__: dict
    '''The `TypedDict` created when subclassed''';
    
    __defaults__: dict = dict()
    '''Default values for the `TypeDict`''';
    
    def __subs__(cls) -> dict:
        return reduce_dict_instances(cls)#, (dict, TypedDictMeta, _TypedDictMeta))
    
    def __instancecheck__(cls, instance):
        if not isinstance(instance, dict): return False
        given = get_type_hints(cls)
        found = {k: type(v) for k, v in instance.items()}
        # Simplified type checking logic
        return all(given.get(k) == found.get(k) for k in given)
    
    def __new__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        print('__new__', list(namespace), list(kwargs))
        namespace = namespace.copy()
        for k, v in kwargs.items():
            if isdunder(k):
               namespace.setdefault(k, v)        
        new = super().__new__(cls, name, bases, namespace)
        return new
    
    def __defs__(cls, **kwargs: P.kwargs) -> dict:
        # all subclasses
        subs = cls.__subs__()
        
        # current annotations 
        anns = get_type_hints(cls)
        
        # signature with initiated default values
        sign = getattr(cls, __SIGNATURE__, None)
        # based keywords based on signature defaults, updated with kwargs
        base = typed_dict_defaults(cls.__typedict__, __sig=sign, **kwargs)
        
        # defaults from current class
        defs = cls() if issubclass(cls, dict) else dict()
        if isnone(defs): 
            print('twas none', cls, defs, sign, kwargs)
            defs = dict()
        # print(cls, issubclass(cls, dict), cls(), type(cls))
        
        
        # keywords from class dict based on annotations
        akws = {k: v for k, v in cls.__dict__.items() if k in anns}
        
        # keywords from kwargs based on class signature
        kwds = {k: v for k, v in kwargs.items() if (k in set(list(base)))}
        
        vals = anns.copy()
        vals.update(subs)
        vals.update(defs)
        vals.update(base)
        vals.update(akws)
        vals.update(kwds)
    
        # print(
        #     'anns', anns, 'base', base, 'defs', defs, 
        #     'akws', akws, 'kwds', kwds, 'vals', vals, sep='\n'
        # )
        return vals
    
    def __init__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        print('__ini__', list(namespace), list(kwargs))
        
        super().__init__(cls, name, bases)
        
        dget = lambda d: dict.get(d, __TYPEDICT__, None)
        for _dct in (namespace, kwargs):
            if notnone(tdct := dget(_dct)): break
            
        tdct = _totypeddict(cls, )
        sign = typed_dict_signature(cls, **kwargs)
        print(sign)

        namespace.setdefault(__ANNOTATIONS__, get_type_hints(tdct))
        namespace.setdefault(__SIGNATURE__, sign)
        
        setattr(cls, __TYPEDICT__, tdct)
        setattr(cls, __SIGNATURE__, sign)
        defs = cls.__defs__(**kwargs)
        setattr(cls, __DEFAULTS__, defs)

# %% ../nbs/10_ncls.ipynb 22
def reduce_typedict(cls) -> dict:
    merge = partial(reduce_dict_instances, __dictclasses=(dict, _TypedDictMeta, TypedDictMeta, TypeDict))
    return merge(cls)

# %% ../nbs/10_ncls.ipynb 23
class TypeDict(dict, metaclass=TypedDictMeta):
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__()
        # print('__sub__', cls, args, kwargs)

    def __new__(cls, *args: P.args, **kwargs: P.kwargs):
        inst = super().__new__(cls, *args, **kwargs)
        return inst
    
    def __init__(self, *args, **kwargs):
        tdct = self.__typedict__
        sign = self.__signature__
        both = {**type(self).__defaults__, **kwargs}
        kwds = typed_dict_defaults(tdct, __sig=sign, **both)
        super().__init__(*args, **kwds)
    
    def dropnones(self, inplace: bool = True):
        '''Removes keys with `None` values from the TypedDict instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def reduce(cls, __dict: T | None) -> dict:
        return reduce_dict_instances(__dict or cls)
        
    
    @classmethod
    def filter(cls, __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return get_typed_dict_keywords(tdict, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls, **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return prune_type_dict_keywords(tdict, **kwargs)

# %% ../nbs/10_ncls.ipynb 27
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class dtyp(TypeDict, __subclass=True):  ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typedict(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tdict(TypeDict, __subclass=True): ...
    

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tkws(TypeDict, __subclass=True): ...
    
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class TypeKwds(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typekwds(TypeDict, __subclass=True): ...

# %% ../nbs/10_ncls.ipynb 38
def _inherit_annots(cls: Callable | _TypedDictMeta, kls: Callable | None = None, **kwargs) -> dict:
    inher = dict()
    if isnone(kls): kls = type(kls)
    ckeys = dict((k, v) for k  in _get_class_keys(kls) if notnone(v := getattr(kls, k, None)))
    inval = inher
    inval.update(ckeys)
    annot = getattr(cls, __ANNOTATIONS__, dict())
    missing = {k: v for k, v in TypeDict.reduce(cls).items() if k not in annot}
    print(
        'missing', list(missing),
        'ckeys', list(ckeys), 'anns', list(annot), 'kwds', list(kwargs), sep='\n\t')
    # inval = {**annot, **inval}
    # inval = {**annot, **inval}
    inval.update(missing)
    inval.update(kwargs)
    
    if istypeddictmeta(cls): 
        inval.update(__typedict__=cls)
    return inval
    
def _untype_dict(tdct: _TypedDictMeta, **kwargs) -> 'TypeDict':
    if not istypeddictmeta(tdct): 
        return tdct
    
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct)
    udct = type(
        f'{getname(tdct)}_untyped', 
        (TypeDict, ), 
        nspc,
        **{**kwargs, **anns, **nspc}, 
    )
    return udct

def _subdict(tdct: _TypedDictMeta, **kwargs) -> 'TypeDict':
    if not istypeddictmeta(tdct): return tdct
    inval = _inherit_annots(tdct, **kwargs)
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct)
    print('subdict', list(inval))
    sdct = type(getname(tdct), (TypeDict, ), nspc, **inval)
    return sdct

def _untype(tdct: _TypedDictMeta, **kwargs):
    anns = get_type_hints(tdct)
    nspc = dict(__annotations__=anns, __typedict__=tdct)
    udct = type(getname(tdct), (TypeDict, ), nspc, **kwargs)
    print(_inherit_annots(tdct, **kwargs))
    return udct

# %% ../nbs/10_ncls.ipynb 42
def new(d: T, **kwargs: K):
    def decorator(func: Callable):
        signature = typed_dict_signature(d, **kwargs)
        # print(signature)
        inval = _inherit_annots(d, func, **kwargs)
        # undct = _subdict(d, **kwargs)
        undct = _untype(d, **kwargs)
        
        # bases = getattr(d, '__bases__', ())
        # bases = tuple(b for b in bases if not issubclass(b, TypeDict))
        # bases = bases + (TypeDict, )        
        anns = {**get_type_hints(undct), **get_type_hints(func)}
        nspc = dict(__annotations__=anns, __typedict__=d)
        print('undct', undct())
        print('deco', list(kwargs))
        subdict = type(getname(func), (undct, ), nspc, **inval)
        return subdict
    return decorator
