# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_sigs.ipynb.

# %% auto 0
__all__ = ['signature_from_annotations', 'typed_dict_signature']

# %% ../nbs/04_sigs.ipynb 6
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind, _empty as Empty
from functools import wraps, partial
from enum import EnumMeta

# %% ../nbs/04_sigs.ipynb 8
from types import NoneType, WrapperDescriptorType, FunctionType, MethodWrapperType
from typing import (
    Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict,
    ParamSpecArgs, ParamSpecKwargs, get_args, _UnionGenericAlias
)

# %% ../nbs/04_sigs.ipynb 10
#| export


# %% ../nbs/04_sigs.ipynb 12
#| export


# %% ../nbs/04_sigs.ipynb 14
from .cons import (ARGS, KWARGS, RETURN, __NAME__)
from .atyp import T, P, K
from .grds import (isdict, notnone, isoptional, isnone, istype, ispsa, ispsk)
from .util import (get_option, in_lookup, init_enum, put_var_in_parameters)

# %% ../nbs/04_sigs.ipynb 18
def signature_from_annotations(
    __dct: T,
    *, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return_annot: type | None = None,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs: P.kwargs
) -> Signature:
    '''Generate a function signature based on annotations and optionally specified defaults.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.
        
    **kwargs : P.kwargs
        Additional options to control the signature generation. These can include
        specific default values for some or all of the annotated parameters.
    
    Returns
    -------
    Signature
        A `Signature` object representing the generated signature for the function.
        
    See Also
    --------
    sigr.signature_from_annotations : Generate a function signature based on annotations.
    '''
    __return = kwargs.get('__return_annot', __return_annot)
    __ignore = kwargs.get('__ignore_values', __ignore_values or {})
    __rescue = kwargs.get('__rescue_values', __rescue_values or {})
    __useopt = kwargs.get('__use_optionals', __use_optionals)
    __force_defaults = kwargs.get('__force_defaults', __force_defaults)
    
    if not isdict(__ignore): {getattr(v, __NAME__, v): v for v in __ignore}
    if not isdict(__rescue): {getattr(v, __NAME__, v): v for v in __rescue}
    
    
    anns = get_annotations(__dct)
    return_annotation = __return or anns.pop(RETURN, __return if notnone(__return) else None)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        opt = get_option(ann)
        isopt = isoptional(ann)
        useopt = isopt and __useopt
        isenum = isinstance(opt if useopt else ann, EnumMeta)
                
        val = kwargs.get(kwd, None)
        err = False
        
        typ = opt if useopt else ann
        ign, ignore_ok = in_lookup(kwd, typ, __ignore)
        res, rescue_ok = in_lookup(kwd, typ, __rescue)
     
        # print(kwd, val, typ, __ignore)
        # print(isnone(val), (istype(ann) or isopt), not ignore_ok)

        if isnone(val) and (istype(ann) or isopt) and not ignore_ok:
            try: # try to instantiate the annotation 
                val = ann()
            except: # if it fails, set the default value to None
                err = True
                val = None
            
                
            if useopt: # Optional paramter, use the first not None type to try and initalize an default value
                try: # try to instantiate the annotation 
                    err = False
                    val = opt()
                except: # if it fails, set the default value to None
                    err = True
                    val = None
                    
            # Maybe we failed gracefully, but that was because we were working with
            # an enum type, so try a special init stragety
            if isenum and isnone(val): 
                try:
                    err = False 
                    val = init_enum(opt if isopt else ann)
                except: 
                    err = True
                    val = None
        
        
        if rescue_ok and isnone(val):
            val = res
        
        pkind = Parameter.POSITIONAL_OR_KEYWORD
        
        # if not isopt and isnone(val):
        #     pkind = Parameter.POSITIONAL_ONLY
        
        # if isopt and isnone(val):
        #     pkind = Parameter.KEYWORD_ONLY
            
        # variadic_args need `P.args` like type annotation to get here
        if kwd == ARGS and __varpos and (ispsa(ann) or isnone(ann)): 
            pkind = Parameter.VAR_POSITIONAL
            
        # variadic_kwargs need `P.kwargs` like type annotation to get here
        if kwd == KWARGS and __varkws and (ispsk(ann) or isnone(ann)): 
            pkind = Parameter.VAR_KEYWORD
        
        prm = Parameter(kwd, kind=pkind, annotation=ann)
        
        
        # booleans
        optnone = isopt and isnone(val) # None is ok if it is an Optional value
        badkind = (pkind in (Parameter.VAR_POSITIONAL,) ) # can't have defaults
        goodval = notnone(val) or not err # we have a default value or there was no error in trying to initiate the annotation
        if (            
            (goodval or (__force_defaults and isnone(val))) or  # we are going to force the default value   
            optnone and not badkind
        ):  
            prm = prm.replace(default=val)
            
        prms.append(prm)
        
    prms = put_var_in_parameters(prms, __varpos, __varkws, __idealorder=kwds)
    sig = Signature(prms, return_annotation=return_annotation)
    return sig

# %% ../nbs/04_sigs.ipynb 21
def typed_dict_signature(__dct: T, **kwargs: K) -> Signature:
    '''Generates a Signature object representing the signature of a TypedDict.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the signature is generated
        .
    **kwargs : TypedDict
        Default values for the TypedDict fields, if any.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, default: `__dct`
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    Signature
        A Signature object representing the TypedDict's field names, types, and default values.
    '''
    kwargs.update(__return_annot=__dct)
    return signature_from_annotations(__dct=__dct, **kwargs)
