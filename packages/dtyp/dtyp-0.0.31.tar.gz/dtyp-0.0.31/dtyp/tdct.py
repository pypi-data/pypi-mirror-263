# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_tdct.ipynb.

# %% auto 0
__all__ = ['typeddict_factory', 'typeddict_from_keywords', 'typed_dict_defaults', 'typed_dict_func', 'get_typed_dict_keywords']

# %% ../nbs/05_tdct.ipynb 6
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind, _empty as Empty
from functools import wraps, partial
from enum import EnumMeta

# %% ../nbs/05_tdct.ipynb 8
from types import NoneType, WrapperDescriptorType, FunctionType, MethodWrapperType
from typing import (
    Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict,
    ParamSpecArgs, ParamSpecKwargs, get_args, _UnionGenericAlias
)

# %% ../nbs/05_tdct.ipynb 10
#| export


# %% ../nbs/05_tdct.ipynb 12
#| export


# %% ../nbs/05_tdct.ipynb 14
from .cons import (__NAME__,)
from .atyp import T, P, K
from .grds import isnone
from .util import (unmangled_annotations, mangled, unmangle, getname)
from .sigs import typed_dict_signature

# %% ../nbs/05_tdct.ipynb 17
def typeddict_factory(
    cls: T, 
    __tdattr: str | None = '__dct',
    __tdname: str | None = None, 
    **kwargs
) -> dict:
    '''Creates a `TypedDict` instance utiliizing the annotations of `cls`.'''
    tdattr = __tdattr or '__dct'
    tdname = __tdname or f'{getname(cls)}_typeddict'
    tdinst = TypedDict(tdname, get_annotations(cls))
    return getattr(cls, tdattr, tdinst)
    
def typeddict_from_keywords(
    cls: T, 
    __tdattr: str | None = '__dct',
    __tdname: str | None = None, 
    **kwargs
) -> dict:
    '''Creates a `TypedDict` instance or retrieves it from `**kwargs`.'''
    tdattr = __tdattr or '__dct'
    tdinst = kwargs.get(tdattr, typeddict_factory(cls, __tdattr, __tdname, **kwargs))
    kwargs.setdefault(tdattr, tdinst)
    return kwargs

# %% ../nbs/05_tdct.ipynb 19
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    **kwargs: K
) -> T:
    '''Creates an instance of a TypedDict with default values specified either in the 
    signature or as keyword arguments.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the instance is created.
        
    __sig : Signature, optional
        A predefined Signature object for the TypedDict, if available.
        
    __non : bool, default: True
        If True, non-specified fields will be included with `None` values.
        
    **kwargs : TypedDict
        Overrides for default values specified in the signature.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    T
        An instance of the TypedDict with default values set.
    '''
    sig = __sig or typed_dict_signature(__dct, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

# %% ../nbs/05_tdct.ipynb 21
def typed_dict_func(
    __dct: T, 
    __sig: Signature | None = None,
    __non: bool = True, 
) -> Callable[[T, Signature], Callable[P, T]]:
    '''Returns a partial function for creating TypedDict instances with defaults 
    and potentially non-values excluded.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which instances will be created.
        
    __sig : Signature, optional
        The signature to use for the TypedDict. If not provided, it will be generated.
        
    __non : bool, default: True
        Determines whether non-values (None) should be included in the output.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

    Returns
    -------
    Callable
        A partial function that can be used to create instances of the TypedDict.
    '''
    return partial(typed_dict_defaults, __dct, __sig=__sig, __non=__non)

# %% ../nbs/05_tdct.ipynb 23
def _kw_in_ann(keyword: str, mangled: str, annotations: dict, unmangled_annots: dict) -> bool:
    k_in_unmg = keyword in unmangled_annots # key is in the unmangled keywords
    k_in_anns = keyword in annotations  # key is a mangled keyword
    m_in_anns = mangled in annotations  # if the mangled keyword is in the annotations
    return any((k_in_unmg, k_in_anns, m_in_anns))
    
def get_typed_dict_keywords(
    __dct: T, 
    __pop_keyword: bool = True, 
    __defaults: T | None = None, 
    **kwargs: K
) -> T:
    '''Get the keywords arguments as specified in a `TypedDict`.
    
    Parameters
    ----------
    __pop_keyword : bool, default: True
        Whether to remove the keyword from the `kwargs` dictionary, by default True
        
    __defaults : T, optional
        The default values for the `TypedDict`, by default None
        
    kwargs : dict
        The keyword arguments to be added to the `TypedDict`
        
    Returns
    -------
    T
        The `TypedDict` with the keyword arguments added
    '''
    kwds = __defaults or {}
    anns = get_annotations(__dct)
    
    # unmangled annotation names
    unmg = unmangled_annotations(__dct)
    keys = list(kwargs.keys())
    for key in keys:
        mkw = mangled(__dct, key) # mangled keyword name
        if _kw_in_ann(key, mkw, anns, unmg): 
            ukw = unmangle(__dct, key)    # unmangled the keyword name
            kwds[ukw] = kwargs.get(key) # add the unmangled keyword and its value to the result
            if __pop_keyword:  kwargs.pop(key, None)
            continue
    return kwds

# %% ../nbs/05_tdct.ipynb 25
def prune_type_dict_keywords(__dct: T, **kwargs) -> T:
    keys = set()
    anns = get_annotations(__dct)
    unmg = unmangled_annotations(__dct)
    for key in kwargs:
        mkw = mangled(__dct, key)
        if _kw_in_ann(key, mkw, anns, unmg):
            keys.add(key)
    return dict(((k, v) for k, v in kwargs.items() if k not in keys))
