# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_dcls.ipynb.

# %% auto 0
__all__ = ['typedict', 'dtyp', 'tdict', 'typekwds', 'tkws']

# %% ../nbs/06_dcls.ipynb 6
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind, _empty as Empty
from functools import wraps, partial
from enum import EnumMeta

# %% ../nbs/06_dcls.ipynb 8
from types import NoneType, WrapperDescriptorType, FunctionType, MethodWrapperType
from typing import (
    Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict,
    ParamSpecArgs, ParamSpecKwargs, get_args, _UnionGenericAlias
)

# %% ../nbs/06_dcls.ipynb 10
#| export


# %% ../nbs/06_dcls.ipynb 12
#| export


# %% ../nbs/06_dcls.ipynb 14
from .cons import (__MODULE__, __DOC__, __ANNOTATIONS__)
from .atyp import T, P, K
from .grds import isnone
from .sigs import typed_dict_signature
from .tdct import (typeddict_from_keywords, typed_dict_defaults, get_typed_dict_keywords, prune_type_dict_keywords)

# %% ../nbs/06_dcls.ipynb 16
class typedict(dict):
    '''A base class for creating TypedDict instances with default values and custom behaviors.'''
    
    def __init_subclass__(cls: Type[Self], **defs: K) -> None:
        '''
        Initializes a subclass with specified TypedDict defaults 
        and optional custom signature.

        Parameters
        ----------
        **defs : TypedDict
            Defaults and TypedDict specifications for the subclass.
            
        Other Parameters
        ----------------
        __force_defaults : bool, default: False
            Whether or not to force defaults, which includes setting `None` 
            for optional parameters.
            
        __varpos: bool, default: True
            Whether or not to include `*args` if not found in the annotations.

        __varkws: bool: default True
            Whether or not to include `**kwargs` if not found in the annotations.
            
        __return_annot: type, optional
            The type for the return value, which might not be specified in the 
            extracted annotaitons.
            
        __rescue_values: dict, optional
            The type or default value ot use if the attempt to initiate a default
            value from the type annotation fails.
            
        __ignore_values: dict, optional
            The parameter name or types to ignore when attempting to initiate a
            default value from the type annotation.
            
        __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.

        Raises
        ------
        KeyError
            If __dct is not provided in the subclass definition.
        '''
        super().__init_subclass__()
        sub = defs.pop('__subclass', False)
        defs = typeddict_from_keywords(cls, **defs)
        try:
            tdinst = defs.pop('__dct', None)
            cls.__dct = tdinst
            if isnone(cls.__dct): 
                raise KeyError('__dct')
            
            for k in get_annotations(tdinst):
                if k in defs:
                    setattr(cls, k, defs.get(k))
                
                if not hasattr(cls, k): 
                    continue
                
                defs.setdefault(k, getattr(cls, k))
                
            cls.__non = defs.pop('__non', True)
            cls.__sig = defs.pop('__sig', typed_dict_signature(cls.__dct, **defs))
            
        except (KeyError, AttributeError) as err:
            if not sub: 
                raise err
        return
    
    def __init__(self: Self, *args: P.args, **kwargs: P.kwargs):
        '''Initializes an instance of the subclass with default values 
        and optional overrides.

        Parameters
        ----------
        *args
            Unused, present to comply with the dict interface.
            
        **kwargs
            Field values that override the defaults specified in the subclass.
        '''
        kwargs.pop('__dct', None)
        kwargs.pop('__sig', None)
        __non = kwargs.pop('__non', True)
        kwds = typed_dict_defaults(type(self).__dct, __sig=type(self).__sig, __non=__non, **kwargs)
        super().__init__(*args, **kwds)
        
    def __instancecheck__(self, __instance) -> bool:
        '''Checks if the instance is of the TypedDict type specified in the subclass.

        Parameters
        ----------
        __instance
            The instance to check.

        Returns
        -------
        bool
            True if the instance is of the correct TypedDict type, False otherwise.
        '''
        return super().__instancecheck__(__instance) or isinstance(__instance, type(self).__dct)
    
    def dropnones(self: Self, inplace: bool = True) -> Self:
        '''Removes keys with `None` values from the TypedDict instance.

        Parameters
        ----------
        inplace : bool, default: True
            If True, modifies the instance in place; otherwise, 
            returns a new instance without `None` values.

        Returns
        -------
        Self
            The instance itself if inplace is True, otherwise a new instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def filter(cls: Type[Self], __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.

        Parameters
        ----------
        __defaults : T, optional
            The default values for the `TypedDict`, by default None
            
        kwargs : dict
            The keyword arguments to be added to the `TypedDict`
            
        Returns
        -------
        Self
            An instance of the `TypedDict` with the keyword arguments added
        '''
        return get_typed_dict_keywords(cls.__dct, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls: Type[Self], **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        return prune_type_dict_keywords(cls.__dct, **kwargs)

# %% ../nbs/06_dcls.ipynb 18
@wraps(typedict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class dtyp(typedict, __subclass=True): 
    ...

@wraps(typedict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tdict(typedict, __subclass=True): 
    ...
    
    
@wraps(typedict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typekwds(typedict, __subclass=True): 
    ...
    
@wraps(typedict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tkws(typedict, __subclass=True): 
    ...
