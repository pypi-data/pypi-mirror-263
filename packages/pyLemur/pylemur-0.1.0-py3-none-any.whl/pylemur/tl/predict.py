
import re
from typing import Any, Literal, Union
from collections.abc import Iterable, Mapping
import pandas as pd
import numpy as np
import formulaic
import warnings
from pylemur.tl.alignment import _reverse_linear_transformation

from pylemur.tl._design_matrix_utils import *
from pylemur.tl._grassmann import grassmann_map


def predict(fit, 
            embedding: Union[np.ndarray, None] = None,
            new_design: Union[str, list[str], np.ndarray, None] = None,
            new_condition: Union[np.ndarray, pd.DataFrame, None] = None, 
            obs_data: Union[pd.DataFrame, Mapping[str, Iterable[Any]], None] = None):
    """Predict the expression of cells in a specific condition
    
    Parameters
    ----------
    fit
        The AnnData object produced by `lemur`.
    embedding
        The coordinates of the cells in the shared embedding space. If None,
        the coordinates stored in `fit.obsm["embedding"]` are used.
    new_design
        Either a design formula parsed using `fit.obs` and `obs_data` or
        a design matrix defining the condition for each cell. If both `new_design`
        and `new_condition` are None, the original design matrix 
        (`fit.uns["lemur"]["design_matrix"]`) is used.
    new_condition
        A specification of the new condition that is applied to all cells. Typically,
        this is generated by `cond(...)`. 
    obs_data
        A DataFrame containing cell-wise annotations. It is only used if `new_design`
        contains a formulaic formula string.

    Returns
    -------
    array-like, shape (n_cells, n_genes)
        The predicted expression of the cells in the new condition.
    """

    if embedding is None:
        embedding = fit.obsm["embedding"]
    
    if new_condition is not None:
        if new_design is not None:
            warnings.warn("new_design is ignored if new_condition is provided.") 

        if isinstance(new_condition, pd.DataFrame):
            new_design = new_condition.to_numpy()
        elif isinstance(new_condition, np.ndarray):
            new_design = new_condition
        else:
            raise ValueError("new_condition must be a created using 'cond(...)' or a numpy array.")
        if new_design.shape[0] != 1:
            raise ValueError("new_condition must only have one row")
        # Repeat values row-wise
        new_design = np.ones((embedding.shape[0],1)) @ new_design
    elif new_design is None:
        new_design = fit.uns["lemur"]["design_matrix"]
    else:
        new_design, _ = handle_design_parameter(new_design, handle_obs_data(fit, obs_data))
    
    # Make prediciton
    approx = new_design @ fit.uns["lemur"]["linear_coefficients"]

    coef = fit.uns["lemur"]["coefficients"]
    al_coefs = fit.uns["lemur"]["alignment_coefficients"]
    des_row_groups, reduced_design_matrix, des_row_group_ids = row_groups(new_design, return_reduced_matrix=True,return_group_ids=True)
    for id in des_row_group_ids:
        covars = reduced_design_matrix[id,:]
        subspace = grassmann_map(np.dot(coef, covars).T, fit.uns["lemur"]["base_point"].T)
        alignment = _reverse_linear_transformation(al_coefs, covars)
        offset = np.dot(al_coefs[:,0,:], covars)
        approx[des_row_groups == id, :] += ((embedding[des_row_groups == id, :] - offset) @ alignment.T) @ subspace.T
    
    return approx


def cond(fit, **kwargs):
    """Define a condition for the `predict` function.

    Parameters
    ----------
    fit
        The AnnData object produced by `lemur`.
    kwargs
        Named arguments specifying the levels of the covariates from the
        design formula. If a covariate is not specified, the first level is
        used.

    Returns
    -------
    :class:`~pandas.DataFrame`
        A DataFrame with one row with the same columns as the design matrix.
    
    """

    # This is copied from https://github.com/scverse/multi-condition-comparisions/blob/main/src/multi_condition_comparisions/tl/de.py#L164
    def _get_var_from_colname(colname):
        regex = re.compile(r"^.+\[T\.(.+)\]$")
        return regex.search(colname).groups()[0]

    design_matrix = fit.uns["lemur"]["design_matrix"]
    variables = design_matrix.model_spec.variables_by_source["data"]

    if not isinstance(design_matrix, formulaic.ModelMatrix):
        raise RuntimeError(
            "Building contrasts with `cond` only works if you specified the model using a "
            "formulaic formula. Please manually provide a contrast vector."
        )
    cond_dict = kwargs
    for var in variables:
        var_type = design_matrix.model_spec.encoder_state[var][0].value
        if var_type == "categorical":
            all_categories = set(design_matrix.model_spec.encoder_state[var][1]["categories"])
        if var in kwargs:
            if var_type == "categorical" and kwargs[var] not in all_categories:
                raise ValueError(
                    f"You specified a non-existant category for {var}. Possible categories: {', '.join(all_categories)}"
                )
        else:
            # fill with default values
            if var_type != "categorical":
                cond_dict[var] = 0
            else:
                var_cols = design_matrix.columns[design_matrix.columns.str.startswith(f"{var}[")]

                present_categories = {_get_var_from_colname(x) for x in var_cols}
                dropped_category = all_categories - present_categories
                assert len(dropped_category) == 1
                cond_dict[var] = next(iter(dropped_category))

    df = pd.DataFrame([kwargs])

    return design_matrix.model_spec.get_model_matrix(df)
