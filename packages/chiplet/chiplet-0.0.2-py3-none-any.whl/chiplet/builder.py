import os
import logging
import subprocess
from typing import Dict, List, Union
from pathlib import Path

from jinja2 import Environment, FileSystemLoader

from chiplet.config import ChipletConfig
from chiplet.constants import CHIPLET_ENV, CHIPLET_TEMPLATE_DIR, CHIPLET_DOCKERFILE_TEMPLATE
from chiplet.render_options import DockerRenderContext

logging_level = os.environ.get("CHIPLET_LOGGING_LEVEL", "ERROR")
logging.basicConfig(level=logging.getLevelName(logging_level))
logger = logging.getLogger(__name__)


class Chiplet:
    def __init__(self, config: ChipletConfig):
        """Initialize the Chiplet instance."""
        self.config = config
        self.template_env = Environment(loader=FileSystemLoader(searchpath=CHIPLET_TEMPLATE_DIR))

    def _render_target(self, target: str, dk_context: DockerRenderContext) -> str:
        """Renders / generates a Dockerfile for the given target image.
        The Dockerfile is incrementally generated by appending to the output file.

        TODO(rob): Support writing out multiple target Dockerfiles instead of a single file.
        """
        template = self.template_env.get_template(CHIPLET_DOCKERFILE_TEMPLATE)
        template_vars = self.config.get_template_vars(target, dk_context)

        content = template.render(template_vars)

        output_filename = f"{dk_context.filename}"
        if not Path(output_filename).parent.exists():
            Path(output_filename).parent.mkdir(parents=True)
        try:
            mode = "w" if self.config.is_root(target) else "a"
            with open(str(Path(output_filename).absolute()), mode) as f:
                f.write(content)
        except Exception as e:
            raise Exception(f"Error writing Dockerfile to {output_filename}: {e}") from e

        return output_filename

    def render(self, dk_context: DockerRenderContext) -> Dict[str, str]:
        """Renders / generates Dockerfiles for all the images defined in the YAML configuration."""

        root = self.config.root()
        dockerfiles, pending = {}, {root}

        # TODO(rob) we can more effectively parallelize this with async scheduling
        while pending:
            target = pending.pop()
            if target in dockerfiles:
                continue

            filename = self._render_target(target, dk_context)
            dockerfiles[target] = filename

            children = self.config.children(target)
            if len(children):
                pending.update(children)

        return dockerfiles

    def build(
        self,
        dk_context: DockerRenderContext,
        target: str,
        tags: List[str] = None,
        push: bool = False,
    ) -> None:
        """Builds a Docker image using the generated Dockerfile.

        Args:
            dk_context (DockerRenderContext): Context used for generating the Dockerfile.
            target (str): Target image name.
            tags (List[str[]): Tag for the Docker image.
            push (bool): Push the Docker image to the container repository.
        """
        filename = str(dk_context.filename)
        image_target = self.config.images[target]
        if tags is not None:
            if isinstance(tags, str):
                tags = [tags]
            assert isinstance(tags, list), "tags must be a list of strings"
            image_tags = list(tags)
        else:
            image_tags = [f"{image_target.name}:{target}"]
        logger.debug(f"Image tags: {image_tags}")

        cmd = f"docker buildx build -f {filename} --target {target}"
        for tag in image_tags:
            cmd += f" -t {tag}"

        if dk_context.base_path:
            cmd += f" {str(dk_context.base_path)}"
        else:
            cmd += " ."

        cmd_env = os.environ.copy()
        cmd_env.update({"DOCKER_BUILDKIT": "1"})

        process = subprocess.run(cmd, env=cmd_env, shell=True)

        if process.returncode != 0:
            err_msg = f"Failed to build image [target={target}, e={process.stderr}]"
            logger.error(err_msg)
            raise Exception(err_msg)

        if push:
            self.push(image_tags)

    def lint(self, filename: str) -> bool:
        """Lint the generated Dockerfile using hadolint."""
        cmd = "docker pull hadolint/hadolint && "
        cmd += f"docker run --pull=always --rm -i hadolint/hadolint < {filename}"
        logger.info("Linting with hadolint")
        process = subprocess.run(cmd, shell=True)
        return process.returncode == 0

    def push(self, tags: List[str]) -> None:
        """Pushes Docker image tags to the container repository."""
        logger.info(f"ðŸš€ Pushing Docker images [{tags}]")
        for tag in tags:
            cmd = f"docker push {tag}"
            logger.debug(f"Running command: {cmd}")
            process = subprocess.run(cmd, shell=True)
            if process.returncode != 0:
                raise Exception(f"Failed to push image [tag={tag}]")
