import collections , os , csv , struct , math , functools , random , json , sys , re
if 82 - 82: Iii1i
if 87 - 87: Ii % i1i1i1111I . Oo / OooOoo * I1Ii1I1 - I1I
if 81 - 81: i1 + ooOOO / oOo0O00 * i1iiIII111 * IiIIii11Ii
if 84 - 84: ooo000 - Ooo0Ooo + iI1iII1I1I1i . IIiIIiIi11I1
if 98 - 98: I11iiIi11i1I % oOO
if 31 - 31: i1I
if 9 - 9: IiI11Ii111 / oOo0O00 / IiIIii11Ii - I11iiIi11i1I - iI1iII1I1I1i
if 16 - 16: i1i1i1111I / i1iiIII111
if 3 - 3: i1 % i1 % i1i1i1111I . Ii * i1
if 9 - 9: i1iiIII111
if 10 - 10: ooOOO / IIiIIiIi11I1 * oOO / i1I / i1I
if 61 - 61: Ooo0Ooo - I1I
if 13 - 13: Ooo0Ooo
if 46 - 46: iI1iII1I1I1i - Ii * Oo * Ii
if 52 - 52: Oo + I1I / oOO / OooOoo - I1Ii1I1 - ooOOO
if 60 - 60: iI1iII1I1I1i . oOO
if 13 - 13: oOO
if 2 - 2: i1
if 22 - 22: IIiIIiIi11I1 - ooo000 / I1Ii1I1 . ooo000
if 1 - 1: iI1iII1I1I1i + Ooo0Ooo + oOO * IIiIIiIi11I1
if 20 - 20: I1I + Ii
if 75 - 75: Ii % i1iiIII111 * Ii . IIiIIiIi11I1 % I11iiIi11i1I % I1Ii1I1
if 8 - 8: I1Ii1I1 . IiI11Ii111 . i1 . Oo - i1I
if 32 - 32: Ii % i1i1i1111I % i1I - I11iiIi11i1I % i1iiIII111
if 34 - 34: i1iiIII111 * i1
if 34 - 34: oOo0O00 / i1iiIII111 - Iii1i . iI1iII1I1I1i
if 80 - 80: i1i1i1111I . I1I % ooOOO % IiIIii11Ii / i1i1i1111I
if 32 - 32: I1Ii1I1 + oOO - oOo0O00
if 79 - 79: Iii1i % oOO * Oo + ooOOO / Oo . oOO
if 20 - 20: IiI11Ii111 + i1iiIII111 / I1I
if 88 - 88: I11iiIi11i1I + ooOOO - i1i1i1111I . Ooo0Ooo * Ii + Iii1i
if 43 - 43: ooOOO * I1Ii1I1
if 95 - 95: Ooo0Ooo % Iii1i % i1i1i1111I . OooOoo
if 70 - 70: IiIIii11Ii
if 75 - 75: Ooo0Ooo / Ii / IiIIii11Ii + IiIIii11Ii . I1I
if 88 - 88: Oo * IiIIii11Ii
if 100 - 100: IiI11Ii111 - OooOoo * I1Ii1I1 / Ooo0Ooo / Iii1i
if 23 - 23: Ooo0Ooo + i1 * I1Ii1I1 + Oo * Ii - IIiIIiIi11I1
if 29 - 29: IiIIii11Ii - oOo0O00
if 30 - 30: I1I . ooo000
if 43 - 43: ooOOO . I11iiIi11i1I + ooo000
if 87 - 87: Iii1i + ooOOO . i1I / Ii + Oo
if 77 - 77: i1iiIII111 + IiI11Ii111 - Oo % ooo000
if 74 - 74: Ii + Ooo0Ooo
if 1 - 1: I1I % Ooo0Ooo + i1iiIII111 . i1iiIII111 % Oo
if 93 - 93: oOo0O00 % Ooo0Ooo * i1iiIII111
if 52 - 52: oOO + I1I / ooo000 - I1Ii1I1 * i1I % oOo0O00
if 52 - 52: oOo0O00 . I1I + i1I - i1iiIII111 % iI1iII1I1I1i
if 57 - 57: I1I * IIiIIiIi11I1 % I1Ii1I1 * i1i1i1111I
if 37 - 37: IiI11Ii111 * i1i1i1111I + oOo0O00 / I1I / OooOoo
if 4 - 4: i1
if 61 - 61: iI1iII1I1I1i . i1I - ooo000 / ooo000 - i1
if 19 - 19: Iii1i * Ooo0Ooo . I1Ii1I1 / I11iiIi11i1I * Ii - oOO
if 32 - 32: iI1iII1I1I1i
if 18 - 18: I11iiIi11i1I * IiI11Ii111 % iI1iII1I1I1i + IiI11Ii111
if 93 - 93: oOO - I1Ii1I1 - IIiIIiIi11I1 * ooOOO - i1
if 82 - 82: IIiIIiIi11I1 % i1 * ooOOO
if 57 - 57: oOo0O00
if 31 - 31: i1iiIII111 + i1i1i1111I % OooOoo
if 20 - 20: OooOoo - I1I
import tensorflow as tf
from datetime import datetime
import numpy as np
from sklearn . metrics . cluster import normalized_mutual_info_score
from enum import Enum
from typing import Any , Type , List , Dict , Set , Tuple , Union , Callable , Iterable , Optional
from scipy import stats
from tensorflow . keras import layers
from tensorflow . keras import models
if 9 - 9: i1iiIII111 - iI1iII1I1I1i % Ii - I1I
O0o0OOoOOOO = sys . argv [ 0 ]
IIIIi = len ( O0o0OOoOOOO )
O0O0oOo00oO0 = O0o0OOoOOOO [ 0 : ( max ( O0o0OOoOOOO . rfind ( '/' ) , 0 ) or IIIIi ) ] [ 0 : ( max ( O0o0OOoOOOO . rfind ( '\\' ) , 0 ) or 0 ) ]
if ( len ( O0O0oOo00oO0 ) ) : os . chdir ( O0O0oOo00oO0 )
if 73 - 73: i1i1i1111I . Ooo0Ooo * iI1iII1I1I1i / Ii / ooo000 + i1iiIII111
random . seed ( )
if 28 - 28: i1iiIII111 + ooOOO - ooOOO - i1i1i1111I
if 61 - 61: oOO
class I1i1i :
 if 97 - 97: i1
 if 26 - 26: IiI11Ii111
 if 20 - 20: IIiIIiIi11I1 / Oo
 if 73 - 73: ooOOO - IiIIii11Ii
 if 22 - 22: Oo % oOo0O00 / i1I . oOo0O00 . i1I
 if 87 - 87: I1I - i1I . i1 * Oo
 if 90 - 90: IiI11Ii111 * i1I . Ii
 #: int: The initial data received from previous root data or @DataPreprocessing.Node.Config object.
 Input = 0
 if 45 - 45: IiIIii11Ii - I11iiIi11i1I . i1iiIII111 * Ooo0Ooo . IIiIIiIi11I1
 if 14 - 14: iI1iII1I1I1i + OooOoo * I1Ii1I1 - I11iiIi11i1I
 Transformed = 1
 if 84 - 84: oOO % iI1iII1I1I1i - Ooo0Ooo
 if 94 - 94: i1iiIII111 + i1i1i1111I / iI1iII1I1I1i + iI1iII1I1I1i / i1I
 Output = 10
 if 79 - 79: i1iiIII111 - IIiIIiIi11I1 . I1Ii1I1 + I1I - ooOOO + i1iiIII111
class Oo0ooo0OO0 :
 if 98 - 98: IIiIIiIi11I1 * IIiIIiIi11I1
 if 58 - 58: i1i1i1111I
 if 38 - 38: i1 - oOo0O00
 if 85 - 85: IIiIIiIi11I1 + I11iiIi11i1I % Ooo0Ooo + oOO * i1iiIII111
 if 46 - 46: ooOOO - ooOOO + Oo / I1I * Oo + oOO
 if 98 - 98: I1I / IIiIIiIi11I1 / i1I + IiI11Ii111 % Oo + I1I
 if 38 - 38: I1Ii1I1 + oOo0O00
 def __init__ ( self , instanceClass : 'DataPreprocessing.Node.Types' = None , dtype : 'tf.DType' = None , sourceCol = "None:None" , source : Union [ str , int , List [ str ] ] = None ) :
  if 2 - 2: OooOoo % Ii + oOO . OooOoo + IIiIIiIi11I1 * Oo
  if 2 - 2: IIiIIiIi11I1 + iI1iII1I1I1i - I1Ii1I1 + ooOOO . IIiIIiIi11I1
  if 15 - 15: ooo000
  if 63 - 63: i1I
  if 81 - 81: OooOoo . i1I / i1i1i1111I + Oo / Ooo0Ooo % IiI11Ii111
  if 77 - 77: I11iiIi11i1I / iI1iII1I1I1i - oOo0O00 - Ooo0Ooo % oOo0O00
  if 73 - 73: IiI11Ii111 . Oo * I1I / i1i1i1111I + I1Ii1I1
  if 31 - 31: i1i1i1111I % I1Ii1I1
  if 1 - 1: IiI11Ii111 - oOo0O00 - i1 . oOo0O00
  if 91 - 91: iI1iII1I1I1i * i1 . ooOOO
  if 81 - 81: I1I * Oo - i1 % OooOoo * ooOOO
  if 19 - 19: Ii
  if 22 - 22: i1I % iI1iII1I1I1i + Oo
  if 60 - 60: ooo000 + I11iiIi11i1I + IIiIIiIi11I1 % i1i1i1111I - Ii % Ooo0Ooo
  self . _instanceClass : OoiI1iiI11IIi1 = instanceClass
  if 56 - 56: i1i1i1111I - IiIIii11Ii - i1iiIII111 - Oo + i1iiIII111 / Ooo0Ooo
  if 89 - 89: ooo000 + Ii % i1i1i1111I - i1iiIII111
  self . source : List [ str , int , List [ str ] ] = None
  if 33 - 33: ooo000 . Iii1i % oOO
  if 60 - 60: I1I . IiIIii11Ii % IIiIIiIi11I1 % iI1iII1I1I1i
  self . sourceCol : str = sourceCol
  if 98 - 98: I1I
  if 35 - 35: oOo0O00 / IIiIIiIi11I1 - Iii1i . IiI11Ii111 * i1
  self . crops : Dict [ int , str ] = [ ]
  if 91 - 91: oOO + Iii1i
  if 71 - 71: i1 . iI1iII1I1I1i . OooOoo . IIiIIiIi11I1
  self . _epochSize : int = None
  if 92 - 92: ooOOO % IIiIIiIi11I1 - IIiIIiIi11I1
  if 32 - 32: OooOoo % I1I - I11iiIi11i1I % OooOoo
  self . _getDataMode : II1IiI1I = II1IiI1I . Propagate
  if 76 - 76: IIiIIiIi11I1 * iI1iII1I1I1i / IIiIIiIi11I1 % i1iiIII111 + oOO
  if 98 - 98: iI1iII1I1I1i - I1I + i1 * ooo000 % i1
  self . outputset : str = None
  if 100 - 100: i1iiIII111 . IIiIIiIi11I1 * ooo000 * ooo000
  if 85 - 85: IIiIIiIi11I1 / OooOoo . i1I % Oo + Oo - I11iiIi11i1I
  self . dtype : tf . DType = dtype
  if 59 - 59: OooOoo
  if 53 - 53: i1i1i1111I / ooOOO - IiI11Ii111 + ooo000 * i1i1i1111I * i1iiIII111
  self . _order : int = 0
  if 87 - 87: i1iiIII111 - IIiIIiIi11I1 * Ii % i1i1i1111I % i1
  if 81 - 81: i1 + i1i1i1111I * Oo - Oo * I1Ii1I1 - oOo0O00
  self . _shape : List [ int ] = None
  if 4 - 4: i1iiIII111
  if 8 - 8: IiIIii11Ii + OooOoo - i1
  self . transformations : List [ ooo0 ] = [ ]
  if 49 - 49: i1 * i1I - i1 / ooOOO - iI1iII1I1I1i
  if 33 - 33: iI1iII1I1I1i . oOO + i1i1i1111I / IiIIii11Ii - oOo0O00 % Ooo0Ooo
  self . preprocessInBatch : bool = True
  if 89 - 89: oOo0O00 - ooo000 / IIiIIiIi11I1
  if 14 - 14: i1I - IiIIii11Ii
  self . _dataShape : List [ int ] = None
  if 74 - 74: oOo0O00 * ooo000 . ooOOO
  if 2 - 2: Ii * IIiIIiIi11I1 % i1 + IiIIii11Ii % i1
  self . _train = None
  if 82 - 82: ooOOO % OooOoo
  if 81 - 81: Ii
  self . _fromNode : Union [ O0 , Oo0ooo0OO0 ] = None
  if 47 - 47: i1i1i1111I / i1iiIII111 + Ooo0Ooo * I1I / oOO / IiIIii11Ii
  if 68 - 68: I1Ii1I1 + IIiIIiIi11I1 + i1iiIII111 + iI1iII1I1I1i . i1i1i1111I
  self . _key : str = None
  if 19 - 19: ooo000 * oOO
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 47 - 47: ooo000
  if 2 - 2: Oo % IiIIii11Ii - ooOOO
  if 75 - 75: IiIIii11Ii * i1 . Iii1i - IiI11Ii111
  if 72 - 72: i1 % i1i1i1111I * iI1iII1I1I1i
  if 90 - 90: Ooo0Ooo * OooOoo . Ii
  if 5 - 5: Oo - i1 . oOO
  if 18 - 18: IiIIii11Ii - oOO * i1I - OooOoo
  if 54 - 54: IIiIIiIi11I1 . Ooo0Ooo % Ii + IiIIii11Ii * iI1iII1I1I1i / iI1iII1I1I1i
  if 31 - 31: IiIIii11Ii . IiIIii11Ii % Ii
  if 51 - 51: Oo / i1i1i1111I - I1I
  if 83 - 83: Iii1i % i1iiIII111 . OooOoo / I1I % oOO . I1I
  if 76 - 76: i1iiIII111 / OooOoo
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "transformations" :
    if 17 - 17: I11iiIi11i1I - i1i1i1111I . iI1iII1I1I1i - I11iiIi11i1I + Oo % iI1iII1I1I1i
    setattr ( self , Ii1I , [ Oo000oO00O . createFromJSON ( tx ) for tx in iiiiIi1IiiIi ] )
   elif Ii1I == "dtype" :
    if iiiiIi1IiiIi is not None :
     self . dtype = O0 . getDataType ( iiiiIi1IiiIi )
    else :
     self . dtype = None
   elif Ii1I == "source" :
    if type ( iiiiIi1IiiIi ) == str :
     if 65 - 65: Ii % I11iiIi11i1I
     iiiiIi1IiiIi = int ( iiiiIi1IiiIi . split ( ) [ - 1 ] )
    self . source = iiiiIi1IiiIi
    self . _train = train
    if 39 - 39: Iii1i * IIiIIiIi11I1 . Ooo0Ooo - Oo
    self . _fromNode = train . sources [ iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , int ) else [ train . dppNodes [ dppKey ] for dppKey in iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , list ) else train . dppNodes [ iiiiIi1IiiIi ]
   elif Ii1I == "_getDataMode" :
    setattr ( self , Ii1I , II1IiI1I [ iiiiIi1IiiIi ] )
   elif Ii1I == "crops" :
    self . crops = { idx : crop for idx , crop in enumerate ( iiiiIi1IiiIi ) if crop is not None }
   elif Ii1I in [ "sourceCol" , "_epochSize" , "outputset" , "_order" , "_shape" , "preprocessInBatch" , "_dataShape" , "_key" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 63 - 63: i1i1i1111I - i1iiIII111 . OooOoo % OooOoo . IiI11Ii111 + i1I
 @ property
 def getDataMode ( self ) -> 'DataPreprocessing.Node.GetDataMode' :
  if 71 - 71: ooo000 + I11iiIi11i1I % iI1iII1I1I1i + IiI11Ii111 % Oo - Oo
  if 84 - 84: I1I % iI1iII1I1I1i - Ooo0Ooo / iI1iII1I1I1i + Ooo0Ooo - Oo
  if 41 - 41: ooOOO + OooOoo + IIiIIiIi11I1 * i1i1i1111I
  if 12 - 12: i1i1i1111I
  if 56 - 56: IiIIii11Ii
  if 17 - 17: i1I . oOO % Oo + IiIIii11Ii - Ooo0Ooo
  if 93 - 93: oOo0O00
  if 77 - 77: Oo + I11iiIi11i1I % I1I
  if 20 - 20: i1 - IiIIii11Ii . IiIIii11Ii % ooOOO . i1 % Ooo0Ooo
  if 72 - 72: oOO % IiI11Ii111 . ooOOO * I1Ii1I1 . ooOOO
  return self . _getDataMode
  if 90 - 90: IiIIii11Ii + I1Ii1I1 . OooOoo
 @ property
 def hasHeader ( self ) -> bool :
  if 73 - 73: i1i1i1111I - Iii1i / I11iiIi11i1I . ooo000 / iI1iII1I1I1i - i1iiIII111
  if 21 - 21: i1iiIII111 + IiI11Ii111 % i1i1i1111I
  if 7 - 7: IiI11Ii111 / Ii
  if 87 - 87: ooOOO
  if 57 - 57: IIiIIiIi11I1 - iI1iII1I1I1i % ooOOO - I11iiIi11i1I / IiIIii11Ii . Ooo0Ooo
  if 15 - 15: i1I * I11iiIi11i1I - oOo0O00
  if 6 - 6: IiI11Ii111 - Ii
  if 1 - 1: I1I + OooOoo
  if 98 - 98: i1iiIII111 + Iii1i . IIiIIiIi11I1
  if 96 - 96: OooOoo / oOO - i1 * I11iiIi11i1I
  if 72 - 72: i1i1i1111I + Ii - Iii1i - i1i1i1111I - i1I + Ooo0Ooo
  if 74 - 74: Ooo0Ooo * Oo + Iii1i - i1iiIII111
  return all ( [ ( isinstance ( s , iiI1i11iii ) or ( isinstance ( s , o0ooo0oOoO ) and s . hasHeader ) ) for s in self . getRootSources ( ) ] )
  if 22 - 22: IiIIii11Ii - Ooo0Ooo . i1 . i1I - ooo000
 @ property
 def order ( self ) -> int :
  if 68 - 68: ooo000
  if 40 - 40: i1 + I1Ii1I1 + I11iiIi11i1I . Oo * I11iiIi11i1I % I1I
  if 100 - 100: OooOoo + Oo / OooOoo
  if 33 - 33: IiI11Ii111 / OooOoo
  if 98 - 98: I1Ii1I1 . IIiIIiIi11I1 * i1I - iI1iII1I1I1i % i1I * IiI11Ii111
  if 42 - 42: OooOoo + i1i1i1111I - iI1iII1I1I1i - oOo0O00 * i1I + Ii
  if 46 - 46: oOo0O00 . iI1iII1I1I1i - Ii . oOo0O00 + i1i1i1111I
  if 83 - 83: IiI11Ii111
  if 77 - 77: iI1iII1I1I1i - oOO % Ii * i1I - I1I
  if 42 - 42: I11iiIi11i1I - Ii / Oo - i1i1i1111I + I11iiIi11i1I
  return self . _order
  if 83 - 83: i1 . iI1iII1I1I1i
 @ property
 def train ( self ) -> 'Train' :
  if 57 - 57: IiI11Ii111 % IiIIii11Ii / oOo0O00 + Ooo0Ooo - i1iiIII111
  if 87 - 87: i1iiIII111 . i1iiIII111 . oOO . ooo000 * oOo0O00
  if 33 - 33: IiI11Ii111 * i1iiIII111 / i1I . OooOoo * oOo0O00 + ooo000
  if 17 - 17: i1i1i1111I * oOO + i1iiIII111 - I11iiIi11i1I / i1i1i1111I
  if 83 - 83: I11iiIi11i1I - Iii1i + oOo0O00 + I1I / IIiIIiIi11I1 + I1I
  if 29 - 29: i1i1i1111I / oOo0O00
  if 13 - 13: I11iiIi11i1I % i1iiIII111 . OooOoo % ooo000 % OooOoo
  if 21 - 21: IiI11Ii111 * I1Ii1I1
  if 93 - 93: Ooo0Ooo . i1 + IiI11Ii111 - oOo0O00
  if 97 - 97: i1 - i1 % IIiIIiIi11I1 + IiIIii11Ii / i1I * iI1iII1I1I1i
  return self . _train
  if 60 - 60: I11iiIi11i1I - Ooo0Ooo % I1Ii1I1
 @ property
 def fromNode ( self ) -> Union [ 'Source.Config' , 'DataPreprocessing.Node.Config' ] :
  if 26 - 26: ooOOO / IIiIIiIi11I1 . oOO + I11iiIi11i1I . Oo
  if 37 - 37: I1Ii1I1
  if 35 - 35: OooOoo % i1i1i1111I - iI1iII1I1I1i / IiIIii11Ii
  if 4 - 4: ooo000 . IiIIii11Ii % ooo000 / i1i1i1111I
  if 48 - 48: i1iiIII111 . Oo
  if 92 - 92: OooOoo + Ii / IIiIIiIi11I1 + OooOoo * IIiIIiIi11I1 * iI1iII1I1I1i
  if 79 - 79: i1i1i1111I
  if 3 - 3: OooOoo / IiI11Ii111 % I11iiIi11i1I
  if 55 - 55: oOo0O00
  if 31 - 31: Ii . Ooo0Ooo / IiI11Ii111
  return self . _fromNode
  if 59 - 59: Oo
 @ property
 def key ( self ) -> str :
  if 64 - 64: Iii1i % I11iiIi11i1I * i1 % OooOoo * oOo0O00
  if 55 - 55: IiI11Ii111
  if 46 - 46: Ooo0Ooo % I1Ii1I1
  if 86 - 86: I11iiIi11i1I . i1i1i1111I + oOO % I11iiIi11i1I % Iii1i % ooo000
  if 61 - 61: ooo000
  if 48 - 48: Iii1i * i1i1i1111I + IiIIii11Ii
  if 31 - 31: Oo * i1iiIII111 % Ii / oOO + I1Ii1I1 + iI1iII1I1I1i
  if 90 - 90: I1Ii1I1 * i1i1i1111I / iI1iII1I1I1i * Ii
  if 38 - 38: I1I . Ii
  if 41 - 41: ooo000 % IIiIIiIi11I1 % ooOOO
  return self . _key
  if 5 - 5: oOo0O00 / Ii + i1iiIII111 * Oo + Ooo0Ooo + ooo000
 @ property
 def dataShape ( self ) -> List [ int ] :
  if 96 - 96: i1iiIII111 - IIiIIiIi11I1 / IIiIIiIi11I1 * IiIIii11Ii
  if 67 - 67: Ooo0Ooo . Ooo0Ooo . IiI11Ii111
  if 24 - 24: i1iiIII111 + i1i1i1111I . oOo0O00 + iI1iII1I1I1i + IiI11Ii111
  if 92 - 92: iI1iII1I1I1i / iI1iII1I1I1i + IiIIii11Ii . IiI11Ii111
  if 56 - 56: Ii * ooo000 . IiIIii11Ii
  if 66 - 66: I1Ii1I1 * OooOoo . iI1iII1I1I1i % OooOoo . i1 . IiIIii11Ii
  if 47 - 47: Ii % OooOoo % iI1iII1I1I1i * IiIIii11Ii
  if 48 - 48: i1I . I11iiIi11i1I / ooo000 + i1iiIII111
  if 84 - 84: Oo / I1Ii1I1 . IIiIIiIi11I1
  if 67 - 67: Oo % ooOOO + iI1iII1I1I1i * I1I
  return self . _dataShape
  if 79 - 79: IIiIIiIi11I1 * Oo / OooOoo
 @ property
 def itemShape ( self ) :
  if 10 - 10: iI1iII1I1I1i / i1iiIII111 . IiIIii11Ii * i1i1i1111I
  if 71 - 71: oOo0O00 + I1Ii1I1 / I11iiIi11i1I + Oo / I1I
  if 18 - 18: Iii1i - IiIIii11Ii
  if 71 - 71: iI1iII1I1I1i + OooOoo % i1i1i1111I % oOo0O00 . ooo000
  if 92 - 92: I11iiIi11i1I - Ooo0Ooo - i1i1i1111I % i1iiIII111 / i1i1i1111I * iI1iII1I1I1i
  if 60 - 60: IiIIii11Ii % oOO / i1I * OooOoo / I11iiIi11i1I - Ii
  if 16 - 16: oOo0O00 / I1Ii1I1 / i1 + I11iiIi11i1I + oOo0O00
  if 11 - 11: oOO / OooOoo + oOo0O00
  if 79 - 79: I11iiIi11i1I . I1Ii1I1 * i1I % I1Ii1I1 / IiI11Ii111
  if 93 - 93: i1I + Iii1i . Ii . i1I * ooOOO
  return self . _shape
  if 84 - 84: Ooo0Ooo % IiI11Ii111
 @ property
 def instanceClass ( self ) :
  return self . _instanceClass
  if 82 - 82: IIiIIiIi11I1
  if 81 - 81: oOo0O00 + i1 - ooo000 * iI1iII1I1I1i + i1i1i1111I
  if 89 - 89: I1Ii1I1
  if 57 - 57: iI1iII1I1I1i - i1iiIII111 / OooOoo % i1iiIII111
  if 92 - 92: IiIIii11Ii * OooOoo - IiIIii11Ii
  if 66 - 66: i1iiIII111 . iI1iII1I1I1i / ooOOO . i1 - OooOoo
  if 13 - 13: oOo0O00
  if 50 - 50: i1 - i1iiIII111 / i1iiIII111 % I1Ii1I1 / IIiIIiIi11I1
  if 66 - 66: oOo0O00 - Iii1i - ooo000 . I11iiIi11i1I
  if 59 - 59: i1I / IiIIii11Ii
 @ property
 def epochSize ( self ) -> int :
  if 7 - 7: oOo0O00
  if 64 - 64: IIiIIiIi11I1 * oOO + Oo . OooOoo - ooOOO
  if 94 - 94: IiIIii11Ii - ooo000 . Ii
  if 73 - 73: IiIIii11Ii / oOo0O00 % ooo000 . iI1iII1I1I1i % oOO
  if 36 - 36: IiI11Ii111 * OooOoo . ooo000 . i1iiIII111 + oOO
  if 47 - 47: IiI11Ii111 / I11iiIi11i1I
  if 52 - 52: Ii . OooOoo . i1iiIII111 * I11iiIi11i1I - iI1iII1I1I1i
  if 20 - 20: OooOoo % IiI11Ii111 + I1Ii1I1 + IiI11Ii111 - oOo0O00
  if 76 - 76: I11iiIi11i1I % IIiIIiIi11I1 % i1I
  if 39 - 39: IiIIii11Ii . Oo + i1I - oOo0O00
  return self . _epochSize
  if 93 - 93: Iii1i * IIiIIiIi11I1 % i1I + i1 % Ii * i1I
 def getEpochSize ( self , refresh : bool = False ) -> int :
  if 62 - 62: IiI11Ii111 % ooo000
  if 19 - 19: Ii / Oo % Iii1i / i1iiIII111 - OooOoo - Ooo0Ooo
  if 89 - 89: I11iiIi11i1I - IiI11Ii111
  if 61 - 61: Ii * OooOoo * I1I % i1iiIII111 % IIiIIiIi11I1 * I11iiIi11i1I
  if 49 - 49: iI1iII1I1I1i / i1iiIII111 % oOO
  if 46 - 46: ooOOO * IIiIIiIi11I1 % i1 / oOO + i1 + oOo0O00
  if 99 - 99: I1I * IIiIIiIi11I1 * i1iiIII111
  if 62 - 62: ooOOO % Oo + i1I
  if 87 - 87: ooo000 - OooOoo + Ii + i1i1i1111I + IiIIii11Ii
  if 57 - 57: IIiIIiIi11I1 + I1I / ooOOO % ooOOO % Oo / IiI11Ii111
  if 95 - 95: i1 / I11iiIi11i1I . i1 / Oo . Ooo0Ooo
  if 43 - 43: Oo - OooOoo * oOO . Ooo0Ooo / IIiIIiIi11I1 * IIiIIiIi11I1
  if 84 - 84: i1iiIII111 + oOo0O00
  if 83 - 83: i1i1i1111I
  if self . epochSize is not None and not refresh :
   return self . epochSize
   if 84 - 84: oOO / Ii * Ooo0Ooo / Ii / ooo000
   if 64 - 64: oOo0O00 * Ii
  else :
   I1iIII111Ii = self . getRootSources ( )
   OoOo0 = [ s . epochSize for s in I1iIII111Ii ]
   self . _epochSize = [ * OoOo0 ] [ 0 ]
   return self . epochSize
   if 59 - 59: I1Ii1I1 + i1iiIII111 . i1I + I1I * IiI11Ii111 / ooo000
 def appendOn ( self , source : Union [ 'Source.Config' , 'DataPreprocessing.Node.Config' , List [ 'DataPreprocessing.Node.Config' ] ] , key : str , outputset : str = None ) -> 'DataPreprocessing.Node.Config' :
  if 55 - 55: i1i1i1111I + Oo - OooOoo / i1iiIII111 - i1
  if 1 - 1: i1 - ooOOO - i1iiIII111
  if 39 - 39: i1I * ooOOO . IiIIii11Ii * i1 * Ii
  if 86 - 86: iI1iII1I1I1i
  if 40 - 40: I11iiIi11i1I - oOo0O00
  if 89 - 89: oOo0O00
  if 48 - 48: i1 / IIiIIiIi11I1 / iI1iII1I1I1i / IiI11Ii111 * IiIIii11Ii
  if 54 - 54: IIiIIiIi11I1 % I1I % IiI11Ii111 / I11iiIi11i1I . I11iiIi11i1I - IiIIii11Ii
  if 10 - 10: Ii . I11iiIi11i1I % i1I / OooOoo % I1Ii1I1
  if 42 - 42: Oo - I1I * i1I * i1i1i1111I - I11iiIi11i1I
  if 58 - 58: iI1iII1I1I1i
  if 17 - 17: iI1iII1I1I1i - Ii % iI1iII1I1I1i % oOo0O00 * Iii1i
  if 51 - 51: I1I . i1i1i1111I % Ii
  if 55 - 55: i1i1i1111I * Ii % i1i1i1111I
  if 61 - 61: oOo0O00
  if 53 - 53: Ooo0Ooo / IiIIii11Ii
  if self . _fromNode is not None :
   raise ValueError ( "This data preprocessing node has been connected to anther item." )
   if 49 - 49: ooo000 - oOO . IiIIii11Ii / Oo
   if 23 - 23: I11iiIi11i1I - i1 / Iii1i . iI1iII1I1I1i + oOO
  if isinstance ( source , list ) :
   if any ( [ ( ( not isinstance ( s , Oo0ooo0OO0 ) ) or ( s . train is None ) or ( s . train != source [ 0 ] . train ) ) for s in source ] ) :
    raise ValueError ( "The item attaching to by this data preprocessing node is not included in any Train object." )
  elif source . train is None :
   raise ValueError ( "The item attaching to by this data preprocessing node is not included in any Train object." )
   if 55 - 55: i1 - iI1iII1I1I1i / OooOoo + I1I + Oo
   if 5 - 5: IiI11Ii111 - i1 . i1i1i1111I / IiI11Ii111 . iI1iII1I1I1i . IiI11Ii111
  if isinstance ( source , O0 ) :
   self . _train = source . train
   self . _fromNode = source
   self . source = source . sourceID
   self . outputset = outputset
  elif isinstance ( source , Oo0ooo0OO0 ) :
   self . _train = source . train
   self . _fromNode = source
   self . source = source . key
  elif isinstance ( source , list ) :
   self . _train = source [ 0 ] . train
   self . _fromNode = source
   self . source = [ s . key for s in source ]
  else :
   return None
   if 87 - 87: i1 . Ii * iI1iII1I1I1i - oOO / Ii / OooOoo
   if 65 - 65: i1I / i1I + IiI11Ii111
  source . train . dppNodes [ key ] = self
  self . _key = key
  if 99 - 99: i1 + OooOoo + I11iiIi11i1I * Ooo0Ooo / ooOOO + Ii
  if 72 - 72: I1Ii1I1 * Ooo0Ooo * IIiIIiIi11I1 % IiIIii11Ii . ooo000
  self . refreshDataShape ( )
  self . updateOrder ( )
  if 68 - 68: Ooo0Ooo * OooOoo - oOo0O00
  return self
  if 49 - 49: IIiIIiIi11I1 % i1
 def getRootSources ( self , rawGraph : bool = True ) -> List [ Union [ 'Source.Config' , 'DataPreprocess.Node.SourceLike' ] ] :
  if 29 - 29: OooOoo * Ii - oOO
  if 53 - 53: I11iiIi11i1I % ooo000 / ooOOO / I1I
  if 43 - 43: iI1iII1I1I1i . i1i1i1111I + I1I % ooOOO . IiI11Ii111 - IiI11Ii111
  if 6 - 6: I1I
  if 98 - 98: oOO * IIiIIiIi11I1 / i1iiIII111 / Iii1i + I1I
  if 25 - 25: IIiIIiIi11I1 . IiI11Ii111 / I1I * i1 - i1iiIII111 % oOo0O00
  if 49 - 49: IiIIii11Ii % ooOOO + I11iiIi11i1I + IIiIIiIi11I1
  if 60 - 60: IIiIIiIi11I1
  if 98 - 98: IiIIii11Ii / Ooo0Ooo + Ii
  if 73 - 73: OooOoo * Iii1i
  if 34 - 34: i1I % Ooo0Ooo * OooOoo + i1iiIII111 / i1
  if 49 - 49: IIiIIiIi11I1 / i1iiIII111 % IIiIIiIi11I1 + IIiIIiIi11I1 * iI1iII1I1I1i
  if 22 - 22: I1Ii1I1 + oOO / I1Ii1I1 - Ii % Ii % i1i1i1111I
  if 86 - 86: Iii1i
  I1iIII111Ii = set ( )
  if 53 - 53: i1 * i1i1i1111I
  if 91 - 91: I1I . I11iiIi11i1I
  if not rawGraph and self . getDataMode != II1IiI1I . Propagate :
   return [ self ]
   if 59 - 59: IiI11Ii111 . IiI11Ii111 * IIiIIiIi11I1
   if 85 - 85: Iii1i . oOO % Iii1i - Iii1i
  if isinstance ( self . fromNode , O0 ) :
   I1iIII111Ii . add ( self . fromNode )
  elif isinstance ( self . fromNode , Oo0ooo0OO0 ) :
   for O0oo0 in self . fromNode . getRootSources ( rawGraph = rawGraph ) :
    I1iIII111Ii . add ( O0oo0 )
  elif isinstance ( self . fromNode , list ) :
   for i11II in self . fromNode :
    for O0oo0 in i11II . getRootSources ( rawGraph = rawGraph ) :
     I1iIII111Ii . add ( O0oo0 )
     if 35 - 35: IiIIii11Ii . iI1iII1I1I1i - i1 % i1
     if 39 - 39: Ii . ooo000 . ooo000 - IIiIIiIi11I1 % Iii1i . I1Ii1I1
  return [ * I1iIII111Ii ]
  if 11 - 11: i1iiIII111 - Oo % Ii % i1
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) :
  if 28 - 28: IIiIIiIi11I1 % Ii + ooOOO . i1I % Ii * I1Ii1I1
  if 41 - 41: I1I
  if 76 - 76: ooo000 * i1i1i1111I
  if 39 - 39: i1 % i1I
  if 50 - 50: i1iiIII111 % OooOoo - i1i1i1111I * IiIIii11Ii % Oo . Ooo0Ooo
  if 30 - 30: i1iiIII111
  if 78 - 78: ooo000 % Iii1i + ooOOO * IIiIIiIi11I1 - i1
  if 46 - 46: Ooo0Ooo - i1I / ooo000 * IiI11Ii111 . oOo0O00
  if 32 - 32: i1i1i1111I . OooOoo + OooOoo - ooo000 * IiIIii11Ii + Oo
  if 12 - 12: oOo0O00
  if 57 - 57: Oo + i1i1i1111I / I1Ii1I1
  if self . getDataMode == II1IiI1I . Propagate :
   raise ValueError ( "Data cannot be collected by data preprocessing node if its .getDataMode is Propagate." )
  else :
   raise ValueError ( "This data preprocessing node should have .getNextBatch() method overwritten." )
   if 56 - 56: oOO % Ooo0Ooo % Iii1i . i1i1i1111I
 def copy ( self , node : 'DataPreprocessing.Node.Config' ) :
  if 46 - 46: IiI11Ii111 . i1iiIII111 % Iii1i - Ooo0Ooo + ooo000
  if 100 - 100: oOO
  if 32 - 32: I1Ii1I1 % ooo000 * OooOoo / oOo0O00 + ooOOO
  if 64 - 64: I1Ii1I1 . Ooo0Ooo
  if 36 - 36: IIiIIiIi11I1 + IiIIii11Ii . i1 + IIiIIiIi11I1
  if 77 - 77: iI1iII1I1I1i / OooOoo . Iii1i + i1iiIII111 - IiI11Ii111
  if 49 - 49: i1iiIII111 - IiI11Ii111 - OooOoo
  if 39 - 39: I1I % i1iiIII111 - I1Ii1I1
  if 51 - 51: IIiIIiIi11I1 + i1 % i1iiIII111
  if 49 - 49: IiIIii11Ii - i1I . I1I
  node . dtype = self . dtype
  node . transformations = [ tx . copy ( ) for tx in self . transformations ]
  node . setInputShape ( self . dataShape )
  node . source = self . source
  node . sourceCol = self . sourceCol
  node . updateOrder ( )
  if 76 - 76: oOO / iI1iII1I1I1i . I1I * oOo0O00 - i1i1i1111I
 def updateOrder ( self ) :
  if 53 - 53: OooOoo - oOo0O00 * ooOOO / OooOoo * Ooo0Ooo * ooo000
  if 10 - 10: IIiIIiIi11I1 % ooo000 % I11iiIi11i1I % Ooo0Ooo
  if 70 - 70: IiIIii11Ii
  if 90 - 90: i1i1i1111I % i1 . IiIIii11Ii * IiI11Ii111 / Ii
  if 73 - 73: ooo000 * Ooo0Ooo + Iii1i . ooOOO . I11iiIi11i1I / I11iiIi11i1I
  if 72 - 72: i1I * iI1iII1I1I1i / ooo000 + i1I - I11iiIi11i1I
  if 20 - 20: IIiIIiIi11I1 . oOo0O00 . Ooo0Ooo
  if isinstance ( self . source , int ) or self . source is None :
   self . _order = 0
  else :
   self . _order = self . train . dppNodes [ self . source ] . order + 1
   if 11 - 11: OooOoo
 def getShape ( self , refresh : bool = True ) -> List [ int ] :
  if 45 - 45: iI1iII1I1I1i + I11iiIi11i1I / IIiIIiIi11I1
  if 45 - 45: iI1iII1I1I1i . iI1iII1I1I1i * i1i1i1111I + oOo0O00
  if 6 - 6: Iii1i . Oo + I1Ii1I1 * i1 * I1Ii1I1 % oOO
  if 21 - 21: Ooo0Ooo % i1 - ooo000
  if 81 - 81: Ooo0Ooo / ooo000
  if 4 - 4: I1I % i1I - ooo000 - I1I . ooOOO / i1i1i1111I
  if 74 - 74: oOO
  if 24 - 24: I1I + Oo - ooOOO
  if 86 - 86: i1iiIII111 % ooo000 % ooo000 % i1I
  if 15 - 15: iI1iII1I1I1i + I1Ii1I1 % oOo0O00
  if 79 - 79: OooOoo . Oo + oOo0O00 / I1Ii1I1 . IiIIii11Ii
  if refresh :
   self . refreshDataShape ( )
   if 89 - 89: ooo000 % Ooo0Ooo
   if 77 - 77: ooo000 % Ooo0Ooo
  if self . _shape is None :
   self . refreshItemShape ( )
   if 24 - 24: oOO * I1Ii1I1 * I1Ii1I1 % IIiIIiIi11I1
  return [ None , * self . _shape ]
  if 37 - 37: i1iiIII111 / iI1iII1I1I1i
 def getInputShape ( self , refresh : bool = False ) -> List [ int ] :
  if 80 - 80: IiIIii11Ii
  if 2 - 2: I1I / oOO - IIiIIiIi11I1 % Ooo0Ooo
  if 88 - 88: iI1iII1I1I1i - I1Ii1I1 - i1I . Iii1i
  if 98 - 98: Ii + ooOOO
  if 29 - 29: I1Ii1I1 + i1I - IIiIIiIi11I1 * I11iiIi11i1I % Oo
  if 74 - 74: ooOOO
  if 100 - 100: oOO + iI1iII1I1I1i . I1I % Oo - i1
  if 39 - 39: iI1iII1I1I1i
  if 34 - 34: iI1iII1I1I1i . i1 . I1I
  if 95 - 95: IiIIii11Ii * IiI11Ii111 * Ooo0Ooo * IiI11Ii111 / OooOoo
  if 27 - 27: i1I . IiIIii11Ii
  if 69 - 69: oOO % i1iiIII111 / oOo0O00
  if 38 - 38: I11iiIi11i1I + Oo * Ooo0Ooo / ooOOO . OooOoo
  if 90 - 90: OooOoo / i1iiIII111
  if refresh :
   self . refreshDataShape ( )
   if 32 - 32: IIiIIiIi11I1 - i1I / ooOOO * Ooo0Ooo * iI1iII1I1I1i - i1i1i1111I
   if 82 - 82: ooo000
  return [ * self . _dataShape ]
  if 66 - 66: IiIIii11Ii + IIiIIiIi11I1 - i1I + i1i1i1111I . iI1iII1I1I1i * IiIIii11Ii
 def setItemShape ( self , shape : List [ int ] ) :
  if 9 - 9: I1I - I1I - ooOOO - oOo0O00 + i1iiIII111
  if 71 - 71: i1I / i1iiIII111 - Ii * Oo . iI1iII1I1I1i
  if 3 - 3: I1Ii1I1
  if 57 - 57: Ooo0Ooo . OooOoo / oOo0O00 * I1Ii1I1
  if 36 - 36: IiIIii11Ii
  if 33 - 33: IiIIii11Ii
  if 86 - 86: Ii / oOo0O00 - i1 * i1i1i1111I - Oo * Iii1i
  if 28 - 28: OooOoo . i1 % iI1iII1I1I1i % Iii1i
  if 2 - 2: Oo + OooOoo - i1i1i1111I - ooo000 / Oo . Oo
  if 41 - 41: OooOoo + OooOoo - OooOoo
  self . _shape = [ * shape ]
  if 9 - 9: Iii1i % I1Ii1I1 % IiIIii11Ii - I1I * OooOoo
 def setInputShape ( self , shape : List [ int ] ) :
  if 53 - 53: iI1iII1I1I1i * i1i1i1111I / OooOoo . i1I . ooo000
  if 45 - 45: OooOoo + ooOOO / i1i1i1111I * i1
  if 71 - 71: IiI11Ii111 % Iii1i + oOo0O00 * I11iiIi11i1I / IiI11Ii111
  if 66 - 66: ooo000 * oOo0O00
  if 83 - 83: i1
  if 64 - 64: i1 . IiI11Ii111 - I11iiIi11i1I . Iii1i
  if 47 - 47: ooo000 / Ooo0Ooo % IiIIii11Ii
  if 70 - 70: IIiIIiIi11I1 / Iii1i . i1i1i1111I % ooOOO . Ii / Ii
  if 51 - 51: I11iiIi11i1I + Ooo0Ooo - ooo000 * oOO . oOO
  if 79 - 79: i1i1i1111I + oOo0O00
  self . _dataShape = [ * shape ]
  self . refreshItemShape ( )
  if 11 - 11: OooOoo / i1iiIII111 % i1I - i1i1i1111I * oOo0O00
 def refreshItemShape ( self ) :
  if 90 - 90: i1 * i1 . Ooo0Ooo . Oo
  if 59 - 59: Ii % I1Ii1I1 + Iii1i . OooOoo * Iii1i
  if 21 - 21: I11iiIi11i1I + ooOOO % IiIIii11Ii / OooOoo
  if 96 - 96: Oo * i1iiIII111 . Ooo0Ooo
  if 35 - 35: ooOOO . i1I * i1i1i1111I * iI1iII1I1I1i - I11iiIi11i1I
  if 47 - 47: IIiIIiIi11I1
  if 73 - 73: I1Ii1I1 + ooOOO
  if 99 - 99: i1I
  if 87 - 87: i1 . I11iiIi11i1I * Ii . i1 . IIiIIiIi11I1 . IiIIii11Ii
  oo00 = self . getInputShape ( ) [ 1 : ]
  ooO0OOo = [ * oo00 [ : - 1 ] , len ( o0ooo0oOoO . getColList ( oo00 [ - 1 ] , self . sourceCol ) ) ]
  if 37 - 37: i1i1i1111I + iI1iII1I1I1i % Iii1i
  if 48 - 48: i1I + oOo0O00
  self . setItemShape ( [ * ooO0OOo ] )
  if 95 - 95: iI1iII1I1I1i / i1I + I1I - oOO * i1
 def refreshDataShape ( self ) :
  if 20 - 20: Ooo0Ooo
  if 4 - 4: IiIIii11Ii % Iii1i
  if 43 - 43: ooo000
  if 95 - 95: Oo + I11iiIi11i1I / Ooo0Ooo / Ii - ooOOO / i1i1i1111I
  if 6 - 6: Ooo0Ooo % IiIIii11Ii
  if 59 - 59: i1I . I11iiIi11i1I . ooo000 / i1I . Ii % Ooo0Ooo
  if 85 - 85: oOo0O00 / ooOOO
  if isinstance ( self . fromNode , O0 ) :
   self . setInputShape ( self . fromNode . getShape ( self . outputset ) )
   if 41 - 41: i1iiIII111 * iI1iII1I1I1i + i1 + i1i1i1111I
 def asType ( self , dtype : 'tf.DType' = tf . float32 ) :
  if 26 - 26: Oo % OooOoo
  if 14 - 14: iI1iII1I1I1i - i1iiIII111
  if 53 - 53: oOO
  if 46 - 46: oOo0O00 - iI1iII1I1I1i
  if 34 - 34: i1i1i1111I
  if 21 - 21: IiI11Ii111 + I1I . OooOoo + i1 . ooo000 + I11iiIi11i1I
  if 7 - 7: ooOOO + Iii1i / iI1iII1I1I1i - oOO % Oo / iI1iII1I1I1i
  if 14 - 14: Iii1i . Ii
  if 100 - 100: I1I / ooo000
  if 48 - 48: i1i1i1111I * i1I % i1i1i1111I + i1i1i1111I . iI1iII1I1I1i / OooOoo
  self . dtype = dtype
  if 12 - 12: Ii . Ii - I1Ii1I1
 def getHeader ( self , step : 'DataPreprocessing.Node.Image.StepEnum' = I1i1i . Output ) -> List [ str ] :
  if 74 - 74: ooo000 * Iii1i - Ooo0Ooo - I1Ii1I1
  if 46 - 46: ooOOO / ooOOO
  if 58 - 58: IiI11Ii111 . IiI11Ii111
  if 79 - 79: oOo0O00 * IIiIIiIi11I1
  if 53 - 53: Ii - ooOOO . OooOoo - I1I - I11iiIi11i1I
  if 32 - 32: Iii1i % IiIIii11Ii - oOO - IiIIii11Ii - I11iiIi11i1I % i1iiIII111
  if 50 - 50: Iii1i / IiI11Ii111 + i1
  if 4 - 4: IIiIIiIi11I1 . IiIIii11Ii % i1I
  if 30 - 30: i1 . i1
  if 35 - 35: Ii * i1I / IiIIii11Ii - I1Ii1I1 / i1
  if 76 - 76: IiIIii11Ii * Iii1i % IiIIii11Ii
  if 73 - 73: i1I / IIiIIiIi11I1 / oOo0O00 % IIiIIiIi11I1 / Ii
  if 12 - 12: i1
  if 78 - 78: I11iiIi11i1I . IIiIIiIi11I1
  if 1 - 1: I1I % i1iiIII111 / I1Ii1I1
  oo = self . fromNode . getHeader ( ) if isinstance ( self . fromNode , Oo0ooo0OO0 ) else self . fromNode . getHeader ( self . outputset )
  if 76 - 76: Oo / IiIIii11Ii % IiIIii11Ii . ooo000 * Oo % i1iiIII111
  if 39 - 39: I1Ii1I1 / Ooo0Ooo * IIiIIiIi11I1
  o000Oo00oOO00 = o0ooo0oOoO . arraySlice ( [ oo ] , self . sourceCol ) [ 0 ] . tolist ( )
  if 38 - 38: Iii1i / i1I
  if 51 - 51: I1Ii1I1 . i1iiIII111 % i1 % i1I * Oo
  return o000Oo00oOO00
  if 64 - 64: i1i1i1111I + i1
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 45 - 45: i1i1i1111I / i1iiIII111 * iI1iII1I1I1i
  if 2 - 2: i1 / i1i1i1111I * IiIIii11Ii
  if 33 - 33: Iii1i
  if 7 - 7: Ooo0Ooo - Ooo0Ooo / ooo000 - IiIIii11Ii
  if 70 - 70: IIiIIiIi11I1 . i1 % iI1iII1I1I1i / i1i1i1111I
  if 5 - 5: i1iiIII111 . Oo + i1i1i1111I
  if 44 - 44: I1Ii1I1 - i1i1i1111I
  if 71 - 71: i1iiIII111
  if 77 - 77: Iii1i - I1Ii1I1 - Ooo0Ooo % Ii / Oo
  if 43 - 43: Ooo0Ooo / oOO
  if 93 - 93: ooOOO % oOo0O00 * i1 + Ii . i1I - oOO
  if 63 - 63: IiIIii11Ii . Iii1i
  if 55 - 55: oOo0O00
  if 85 - 85: IIiIIiIi11I1 % Oo / I1I . oOo0O00 / IIiIIiIi11I1 . Oo
  if 40 - 40: IIiIIiIi11I1 - ooOOO * oOO . ooo000
  if 24 - 24: IiIIii11Ii - iI1iII1I1I1i / Ii
  if 34 - 34: ooOOO - ooOOO / Ii % OooOoo
  if 97 - 97: Oo * IiIIii11Ii . Ooo0Ooo % i1 % Ii % ooo000
  if 67 - 67: IIiIIiIi11I1 % i1 % oOo0O00 - i1i1i1111I
  if 51 - 51: I11iiIi11i1I . I11iiIi11i1I % IiI11Ii111 % Oo / I1Ii1I1 - I1Ii1I1
  if 28 - 28: Ii / Ooo0Ooo
  if 11 - 11: I1I - OooOoo * ooOOO % i1i1i1111I + ooo000 . oOO
  if 51 - 51: ooOOO + iI1iII1I1I1i % IiI11Ii111 . I11iiIi11i1I % Ooo0Ooo
  if 15 - 15: OooOoo / i1I % Oo % Oo
  pass
  if 73 - 73: oOo0O00
 def getClassCount ( self ) -> int :
  if 69 - 69: ooOOO - IIiIIiIi11I1 - i1I
  if 78 - 78: I1Ii1I1 . ooo000 + IiI11Ii111 / IiI11Ii111
  if 88 - 88: Ii - i1iiIII111 - i1 * IIiIIiIi11I1 . IiIIii11Ii + Iii1i
  if 44 - 44: ooOOO + Oo - i1
  if 18 - 18: iI1iII1I1I1i * ooOOO + Ooo0Ooo
  if 78 - 78: I1I . I1I - IIiIIiIi11I1 - IiIIii11Ii % I11iiIi11i1I . I1Ii1I1
  if 9 - 9: I11iiIi11i1I * OooOoo - I11iiIi11i1I
  pass
  if 73 - 73: I1Ii1I1
 def setTransform ( self , transformationConfig : 'DataPreprocessing.Transformation.Config' = None ) :
  if 25 - 25: i1 . Ii
  if 59 - 59: IiIIii11Ii
  if 91 - 91: IiIIii11Ii + iI1iII1I1I1i
  if 65 - 65: Oo * Iii1i * IiIIii11Ii / IIiIIiIi11I1
  if 77 - 77: IIiIIiIi11I1 / oOO % IiIIii11Ii + I1Ii1I1
  if 34 - 34: i1i1i1111I * Iii1i + Ii - i1I / i1 / i1
  if 87 - 87: Ooo0Ooo + I11iiIi11i1I
  if 3 - 3: IIiIIiIi11I1 . I1Ii1I1 / Iii1i % ooOOO / oOo0O00 % ooOOO
  if 55 - 55: iI1iII1I1I1i + I1I + oOo0O00 - I11iiIi11i1I
  if 80 - 80: Oo % I11iiIi11i1I . IiIIii11Ii * oOO
  if 83 - 83: oOo0O00 % Oo + i1i1i1111I - ooOOO + i1iiIII111
  if transformationConfig is None :
   raise ValueError ( "No Transforamtion Config is given" )
   if 36 - 36: oOo0O00 * OooOoo / I11iiIi11i1I
   if 98 - 98: IiI11Ii111 . ooo000
  if isinstance ( transformationConfig , oo0OOOOOO0o00 ) and transformationConfig . requirePreExtraction :
   if 74 - 74: i1 + oOO
   OOo00oOoOo = self . getInputShape ( )
   if 95 - 95: oOO * i1iiIII111 / i1i1i1111I
   if 29 - 29: oOo0O00 / i1iiIII111 - IiIIii11Ii
   OOo00oOoOo = [ * OOo00oOoOo [ 0 : - 1 ] , len ( OoOo0000o . parse ( OOo00oOoOo [ - 1 ] , self . sourceCol ) ) ]
   if 61 - 61: Oo % ooo000
   if 68 - 68: Ii - OooOoo / I1I
   OOoO0ooOO0o = OOo00oOoOo [ - 1 ]
   if 41 - 41: Iii1i . ooOOO - I1Ii1I1 / I1Ii1I1 % i1i1i1111I - OooOoo
   if 79 - 79: Ooo0Ooo * Ooo0Ooo - ooo000 - Iii1i
   iIiI1ii1i11ii = OoOo0000o . parse ( OOoO0ooOO0o , transformationConfig . colSel )
   if 89 - 89: OooOoo + ooo000 . I11iiIi11i1I
   if 76 - 76: i1i1i1111I / oOo0O00 . oOo0O00
   for O0oOOOoo in self . transformations :
    oo0oo = OoOo0000o . parse ( OOoO0ooOO0o , O0oOOOoo . colSel )
    if 94 - 94: i1I
    if 65 - 65: IiIIii11Ii . Ii
    if any ( [ ( idx in oo0oo ) for idx in iIiI1ii1i11ii ] ) :
     raise ValueError ( "Transformation reapplied error." )
     if 49 - 49: oOO + Ii % Ii % Oo * Iii1i * Ii
     if 89 - 89: Ooo0Ooo
  self . transformations . append ( transformationConfig )
  if 57 - 57: oOO . IIiIIiIi11I1 + OooOoo * I1I
 def clearTransform ( self ) :
  if 89 - 89: Iii1i * Ooo0Ooo + Oo * I11iiIi11i1I * IiI11Ii111 + IiI11Ii111
  if 90 - 90: Oo - I11iiIi11i1I
  if 93 - 93: oOo0O00 . Oo . I1I - I1I % ooOOO
  if 67 - 67: Ooo0Ooo + oOo0O00
  if 21 - 21: oOO
  if 64 - 64: IIiIIiIi11I1 * i1iiIII111
  if 31 - 31: Iii1i
  self . transformations = [ ]
  if 86 - 86: Oo
 def _processData ( self , data : 'np.ndarray' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 74 - 74: OooOoo - I11iiIi11i1I . Oo . i1 + oOo0O00 - ooOOO
  if 60 - 60: Oo
  if 23 - 23: oOo0O00
  if 47 - 47: Ooo0Ooo + Oo * Ii . OooOoo . I1Ii1I1 * i1iiIII111
  if 46 - 46: ooOOO % i1i1i1111I * i1iiIII111 + I1Ii1I1
  if 15 - 15: iI1iII1I1I1i - ooo000 + IIiIIiIi11I1 * Ooo0Ooo
  if 84 - 84: OooOoo . Ii
  if 21 - 21: Ooo0Ooo
  if 76 - 76: iI1iII1I1I1i % IiI11Ii111 / IiIIii11Ii - IiI11Ii111
  if 4 - 4: OooOoo * IIiIIiIi11I1 - Ooo0Ooo . Ii - ooOOO . i1iiIII111
  if 2 - 2: I11iiIi11i1I * i1I * i1I * i1iiIII111 / I11iiIi11i1I % IiI11Ii111
  if 13 - 13: i1 * IiIIii11Ii - ooo000 * OooOoo
  if 72 - 72: Iii1i . I1Ii1I1 * IIiIIiIi11I1 % I1Ii1I1 - i1i1i1111I
  if 97 - 97: i1 + ooOOO + I11iiIi11i1I . i1
  pass
  if 71 - 71: ooo000 - i1i1i1111I / iI1iII1I1I1i - iI1iII1I1I1i % IIiIIiIi11I1 . iI1iII1I1I1i
 def _processDataToShow ( self , data : 'np.ndarray' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 41 - 41: IIiIIiIi11I1
  if 96 - 96: Oo . Ooo0Ooo - oOO . Iii1i % IiI11Ii111 . IiI11Ii111
  if 82 - 82: oOO % iI1iII1I1I1i / i1iiIII111
  if 47 - 47: i1
  if 59 - 59: IiI11Ii111 % IIiIIiIi11I1 % IiIIii11Ii
  if 92 - 92: Oo . i1 * i1iiIII111 . IiIIii11Ii
  if 82 - 82: I11iiIi11i1I % Oo + Ii
  if 22 - 22: Ooo0Ooo / ooOOO . I1I % I1I
  if 16 - 16: iI1iII1I1I1i / i1iiIII111 / Ooo0Ooo . Ii
  if 82 - 82: Oo % iI1iII1I1I1i - i1I * OooOoo % Iii1i - I11iiIi11i1I
  if 95 - 95: oOO
  if 56 - 56: I11iiIi11i1I - i1I / OooOoo / ooo000 . IiI11Ii111
  if 78 - 78: ooo000 % IiI11Ii111 - i1
  if 36 - 36: oOo0O00 + OooOoo - Ooo0Ooo / IiI11Ii111
  pass
  if 90 - 90: oOo0O00 % oOO * oOO + I1I * I1I / IiI11Ii111
 def processData ( self , data : Union [ 'np.ndarray' , 'tf.Tensor' ] , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> Union [ 'np.ndarray' , 'tf.Tensor' ] :
  if 92 - 92: IiIIii11Ii * OooOoo * I1Ii1I1
  if 65 - 65: i1iiIII111 * Oo * oOO + i1I - i1I
  if 86 - 86: oOO - Ooo0Ooo + I11iiIi11i1I . Iii1i . OooOoo - Ii
  if 86 - 86: I1I
  if 35 - 35: ooOOO + OooOoo
  if 8 - 8: I1I + Ii % iI1iII1I1I1i + IiI11Ii111 . oOO * i1
  if 96 - 96: ooo000 % I11iiIi11i1I / oOo0O00 * Ii * ooo000 - Ooo0Ooo
  if 88 - 88: Ii % ooOOO . I1I
  if 80 - 80: IiIIii11Ii / oOO % IiI11Ii111 * I1I
  if 100 - 100: oOo0O00 / I1Ii1I1 - i1i1i1111I * I1Ii1I1 / I11iiIi11i1I * Oo
  if 49 - 49: Ooo0Ooo
  if 36 - 36: OooOoo + i1I / Iii1i + iI1iII1I1I1i + OooOoo
  if 6 - 6: IiI11Ii111 + Ii
  if 100 - 100: oOo0O00 % i1I - IiIIii11Ii % i1iiIII111 . i1 % I1Ii1I1
  if isinstance ( data , np . ndarray ) :
   return self . _processData ( data , step )
  elif isinstance ( data , tf . Tensor ) :
   return self . processDataTensor ( data , step )
  else :
   raise ValueError ( "Data type not supported." )
   if 67 - 67: I11iiIi11i1I
 def processDataToShow ( self , data : Union [ 'np.ndarray' , 'tf.Tensor' ] , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> Union [ 'np.ndarray' , 'tf.Tensor' ] :
  if 21 - 21: oOO % i1i1i1111I - i1 + I1I
  if 85 - 85: IiIIii11Ii + I1I + IiI11Ii111
  if 68 - 68: Iii1i % IiIIii11Ii . i1 - IiI11Ii111
  if 80 - 80: i1iiIII111 . ooo000
  if 15 - 15: oOO + oOo0O00 * I11iiIi11i1I . IiIIii11Ii
  if 66 - 66: IIiIIiIi11I1 - oOo0O00 . I1I * I11iiIi11i1I + i1i1i1111I
  if 13 - 13: oOO % Iii1i
  if 81 - 81: I1I
  if 86 - 86: Ooo0Ooo / I1I . Ooo0Ooo % i1i1i1111I * OooOoo * Iii1i
  if 59 - 59: Ii + i1i1i1111I . I1Ii1I1 . oOO + i1I . i1
  if 34 - 34: iI1iII1I1I1i - ooo000 * i1iiIII111 - Iii1i
  if 50 - 50: oOO . IiI11Ii111 . i1I . i1i1i1111I . I11iiIi11i1I + Oo
  if 38 - 38: IiI11Ii111 + oOo0O00 . ooo000 - Iii1i - I1Ii1I1 - oOO
  if 29 - 29: ooo000 * oOO
  if isinstance ( data , np . ndarray ) :
   return self . _processDataToShow ( data , step )
  elif isinstance ( data , tf . Tensor ) :
   return self . processDataTensor ( data , step )
  else :
   raise ValueError ( "Data type not supported." )
   if 38 - 38: oOo0O00 / IiIIii11Ii * oOO . OooOoo % Ii . Iii1i
 def processDataNPArray ( self , data : 'np.ndarray' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 74 - 74: oOO - i1i1i1111I % I1I + IiIIii11Ii * I1I
  if 53 - 53: OooOoo % I1Ii1I1 / IiI11Ii111 / I1I + I1Ii1I1 . i1I
  if 7 - 7: oOO - oOo0O00 . i1i1i1111I * Oo + I1I
  if 93 - 93: i1iiIII111 - OooOoo + i1 * oOo0O00 . IiI11Ii111
  if 9 - 9: IIiIIiIi11I1 + iI1iII1I1I1i
  if 43 - 43: oOo0O00 * i1I * i1I / IiIIii11Ii % i1iiIII111
  if 55 - 55: i1iiIII111 . i1
  if 29 - 29: Ooo0Ooo * IiIIii11Ii + i1iiIII111 / iI1iII1I1I1i - IiIIii11Ii - oOo0O00
  if 63 - 63: I1Ii1I1 . IiI11Ii111 * ooOOO . oOO / I1I
  if 34 - 34: i1i1i1111I * i1i1i1111I * I11iiIi11i1I . Iii1i * i1I % ooo000
  if 99 - 99: Ii / ooOOO % oOO % OooOoo - IiIIii11Ii
  if 51 - 51: oOo0O00 % OooOoo
  if 60 - 60: i1i1i1111I % IiIIii11Ii - Iii1i % i1 * IiI11Ii111
  if 88 - 88: OooOoo % iI1iII1I1I1i
  return self . _processData ( data , step )
  if 21 - 21: i1I % OooOoo
 def processDataTensor ( self , data : 'tf.Tensor' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'tf.Tensor' :
  if 95 - 95: IiIIii11Ii - i1 . i1 - ooOOO . i1 + Ii
  if 86 - 86: IiIIii11Ii % ooo000
  if 61 - 61: Ii . i1iiIII111 * I11iiIi11i1I . ooOOO
  if 95 - 95: oOO % I1Ii1I1 % ooo000
  if 84 - 84: i1I + i1i1i1111I * ooOOO % ooo000
  if 29 - 29: IiIIii11Ii - IIiIIiIi11I1 + IiI11Ii111 - I11iiIi11i1I . OooOoo
  if 57 - 57: i1i1i1111I / I11iiIi11i1I
  if 83 - 83: OooOoo / I1Ii1I1 / IiIIii11Ii
  if 78 - 78: i1 . i1iiIII111 - Oo * IIiIIiIi11I1 - I1I - i1I
  if 21 - 21: Iii1i - Ii / i1I / I1Ii1I1 % I11iiIi11i1I / Ii
  if 74 - 74: I1Ii1I1 . ooOOO
  if 24 - 24: IiI11Ii111 - Iii1i % oOo0O00 * I1I . iI1iII1I1I1i
  if 78 - 78: I1Ii1I1 - Ooo0Ooo / OooOoo % i1I
  if 99 - 99: I11iiIi11i1I % ooOOO
  return tf . convert_to_tensor ( self . _processData ( np . array ( data ) , step ) )
  if 22 - 22: i1iiIII111 * IiI11Ii111 - i1i1i1111I % ooo000 / OooOoo - Oo
 def getProcessedData ( self , rootData : 'Train.RootData' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 3 - 3: I11iiIi11i1I % Ooo0Ooo
  if 20 - 20: I1Ii1I1 . IiI11Ii111 - Ii % I11iiIi11i1I % Oo
  if 12 - 12: OooOoo * oOO % Ooo0Ooo . I11iiIi11i1I
  if 54 - 54: I11iiIi11i1I . i1 - IIiIIiIi11I1
  if 99 - 99: i1I + i1I * Ooo0Ooo . OooOoo
  if 33 - 33: i1i1i1111I / IiI11Ii111 + Ooo0Ooo % ooOOO
  if 25 - 25: Iii1i
  if 74 - 74: I11iiIi11i1I . ooo000 . I1I * i1iiIII111 * Ooo0Ooo
  if 47 - 47: OooOoo
  if 55 - 55: ooOOO % oOO + i1I - IiI11Ii111 + ooo000 + I1I
  if 53 - 53: IIiIIiIi11I1 % IiIIii11Ii / oOO % ooOOO - oOo0O00
  if 74 - 74: ooo000 * OooOoo * Oo
  if 96 - 96: I1Ii1I1 - Oo
  if 28 - 28: i1iiIII111 - IiI11Ii111 % Ii * ooo000 / Iii1i
  if self . key in rootData . dppNodes :
   if step != I1i1i . Output :
    raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
   return rootData . dppNodes [ self . key ]
   if 12 - 12: IiI11Ii111 - Ooo0Ooo
   if 12 - 12: ooOOO
  I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProcessedData ( rootData )
  if 93 - 93: IiI11Ii111 - I11iiIi11i1I * IiI11Ii111 + Ii
  if 100 - 100: IIiIIiIi11I1 * iI1iII1I1I1i
  return self . processData ( I1i , step = step )
  if 2 - 2: I11iiIi11i1I * oOo0O00
 def getProcessedDataToShow ( self , rootData : 'Train.RootData' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 25 - 25: IiI11Ii111
  if self . key in rootData . dppNodes :
   if 66 - 66: i1 * I1Ii1I1 % Ii * i1 + Iii1i
   if 21 - 21: ooOOO
   if 100 - 100: ooo000 + i1I - I11iiIi11i1I / Iii1i
   if 95 - 95: i1i1i1111I . oOo0O00 % oOO * IiIIii11Ii % ooOOO + i1
   if 78 - 78: ooo000 - i1I
   if 1 - 1: Ooo0Ooo / Oo % oOO
   if 10 - 10: i1iiIII111 + I11iiIi11i1I . oOO + ooOOO % iI1iII1I1I1i
   if 49 - 49: i1 - iI1iII1I1I1i + iI1iII1I1I1i * Iii1i % IIiIIiIi11I1
   if 15 - 15: ooo000 . i1 * i1
   if 41 - 41: I11iiIi11i1I + Iii1i % ooOOO * i1
   if 37 - 37: ooo000
   if 87 - 87: i1i1i1111I + I1Ii1I1 % i1iiIII111 - I1I + ooOOO % I1Ii1I1
   if step != I1i1i . Output :
    raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
   return rootData . dppNodes [ self . key ]
   if 96 - 96: IIiIIiIi11I1 / I1I * i1 / I1I + I1I / i1
   if 80 - 80: Oo / i1i1i1111I . IIiIIiIi11I1
  I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProcessedData ( rootData )
  if 79 - 79: oOO
  if 6 - 6: IiI11Ii111 + IIiIIiIi11I1 + ooOOO % IIiIIiIi11I1
  return self . processDataToShow ( I1i , step = step )
  if 24 - 24: ooo000 + i1I / Ii / Ooo0Ooo % IIiIIiIi11I1
 def recoverToRawData ( self , items : 'np.ndarray|list[*+]' , selCols : str = "None:None" ) -> 'np.ndarray' :
  if 70 - 70: I11iiIi11i1I
  if 45 - 45: I1Ii1I1 * Oo - I11iiIi11i1I * iI1iII1I1I1i
  if 41 - 41: Iii1i . I1I * i1I - i1iiIII111 . IiI11Ii111 + ooOOO
  if 24 - 24: i1 + IIiIIiIi11I1 + i1iiIII111 % I1Ii1I1 + IIiIIiIi11I1
  if 55 - 55: IiIIii11Ii - IiIIii11Ii
  if 52 - 52: I1Ii1I1 - OooOoo % i1I
  if 88 - 88: ooOOO . i1
  if 72 - 72: I1I - OooOoo / Iii1i - I1Ii1I1
  if 54 - 54: I11iiIi11i1I / i1iiIII111 % oOo0O00 - ooOOO
  if 72 - 72: ooo000 . I1Ii1I1 . I1I . IIiIIiIi11I1 + Oo
  if 58 - 58: ooOOO + IiIIii11Ii + oOO % IiIIii11Ii + Ooo0Ooo . Oo
  if 45 - 45: I1I % i1I % oOO * oOo0O00 / i1iiIII111 + I11iiIi11i1I
  if 63 - 63: i1i1i1111I - IiI11Ii111 - iI1iII1I1I1i + OooOoo * i1iiIII111 / Ooo0Ooo
  if 81 - 81: ooo000 % i1i1i1111I . i1iiIII111 / i1iiIII111 / i1iiIII111
  pass
  if 84 - 84: ooOOO * ooo000 % ooOOO
 def getTensor ( self ) -> 'tf.Tensor' :
  if 57 - 57: i1I * iI1iII1I1I1i % Ooo0Ooo
  if 22 - 22: OooOoo . i1
  if 85 - 85: i1i1i1111I * I1Ii1I1 / ooo000
  if 14 - 14: i1i1i1111I
  if 61 - 61: Iii1i . I11iiIi11i1I - Oo . IiI11Ii111 + OooOoo
  if 11 - 11: oOo0O00 - i1 / oOo0O00 * OooOoo - I11iiIi11i1I / I1Ii1I1
  if 4 - 4: IiIIii11Ii
  if 42 - 42: oOO - oOO + OooOoo - oOO
  if 23 - 23: iI1iII1I1I1i % i1I * I11iiIi11i1I - oOO * oOo0O00
  if 45 - 45: i1 % iI1iII1I1I1i . IiIIii11Ii + Ooo0Ooo
  return tf . compat . v1 . placeholder ( tf . float32 if self . dtype is None else self . dtype , shape = ( [ None , * self . getShape ( ) [ 1 : ] ] ) )
  if 34 - 34: Iii1i + Iii1i
class II1i1I ( Enum ) :
 @ classmethod
 def getName ( cls , value : int ) -> str :
  if 97 - 97: Iii1i + oOo0O00 - i1 % Iii1i
  if 71 - 71: Ooo0Ooo / Ooo0Ooo % ooo000
  if 32 - 32: ooo000 * ooo000
  if 29 - 29: Ooo0Ooo . i1 * I11iiIi11i1I
  if 98 - 98: ooOOO * oOO + Ooo0Ooo + i1i1i1111I / I1Ii1I1
  if 18 - 18: iI1iII1I1I1i . iI1iII1I1I1i % ooOOO
  if 90 - 90: I1I - Iii1i + Ii / Iii1i % I1Ii1I1
  if 14 - 14: OooOoo + iI1iII1I1I1i * Iii1i
  if 30 - 30: OooOoo
  if 2 - 2: i1iiIII111 / oOo0O00 - IiIIii11Ii - iI1iII1I1I1i
  if 90 - 90: i1iiIII111
  if 11 - 11: ooOOO . ooo000
  if 10 - 10: I1Ii1I1 - ooOOO / Iii1i - i1 . ooo000
  for oooO0o00oOO0O in cls :
   if oooO0o00oOO0O . value == value :
    return oooO0o00oOO0O . name
    if 42 - 42: Ii * oOO
 @ classmethod
 def getValue ( cls , name : str ) -> int :
  if 67 - 67: ooOOO
  if 62 - 62: I1I + Ii + I1I * i1 . Ooo0Ooo * i1iiIII111
  if 2 - 2: i1I + Oo
  if 51 - 51: Ii . i1I
  if 89 - 89: IiI11Ii111 * IiIIii11Ii / i1 . I1Ii1I1
  if 64 - 64: IiI11Ii111
  if 44 - 44: Ii . OooOoo + oOO * OooOoo . i1 - i1iiIII111
  if 72 - 72: iI1iII1I1I1i + I1I * ooo000 . OooOoo + Ii + IIiIIiIi11I1
  if 91 - 91: oOo0O00 % IIiIIiIi11I1 % i1I / I1Ii1I1
  if 70 - 70: iI1iII1I1I1i + IiI11Ii111 + oOO
  if 21 - 21: I11iiIi11i1I
  if 20 - 20: ooOOO + IiIIii11Ii % Iii1i - I11iiIi11i1I
  if 49 - 49: Iii1i / IiIIii11Ii % i1 % i1i1i1111I + oOO * ooo000
  return getattr ( cls , name ) . value
  if 25 - 25: IIiIIiIi11I1 * OooOoo % oOo0O00 % Ooo0Ooo + i1iiIII111
 @ classmethod
 def parse ( cls , value : Union [ int , str ] ) -> 'Enumeration' :
  if 15 - 15: I11iiIi11i1I
  if 85 - 85: Ii
  if 17 - 17: I1I . Oo
  if 63 - 63: Ii . i1I
  if 83 - 83: IIiIIiIi11I1 * IiI11Ii111 % i1I * ooOOO
  if 7 - 7: IiI11Ii111 / i1i1i1111I * Iii1i
  if 27 - 27: i1i1i1111I - Ii - oOO + Ooo0Ooo * Ii + IiI11Ii111
  if 35 - 35: i1i1i1111I . i1i1i1111I + I11iiIi11i1I / Oo . i1
  if 69 - 69: I1I / i1 % I1Ii1I1 % oOO
  if 96 - 96: Oo - i1I * iI1iII1I1I1i + Ooo0Ooo * Oo
  if 22 - 22: ooo000 % I11iiIi11i1I
  if 44 - 44: oOO / iI1iII1I1I1i % i1iiIII111 + i1iiIII111 % Ooo0Ooo + Ooo0Ooo
  if 93 - 93: i1 % oOO % I1I
  if isinstance ( value , str ) :
   return getattr ( cls , value )
  else :
   return getattr ( cls , cls . getName ( value ) )
   if 49 - 49: ooOOO * iI1iII1I1I1i + ooo000 - Ii . oOo0O00
class OoiI1iiI11IIi1 ( II1i1I ) :
 if 77 - 77: I11iiIi11i1I
 if 18 - 18: oOo0O00 . I1I / i1iiIII111
 if 3 - 3: oOO + oOO % i1I % Oo / iI1iII1I1I1i . IiIIii11Ii
 if 20 - 20: IiIIii11Ii + i1I
 if 32 - 32: oOo0O00 + i1i1i1111I
 if 74 - 74: I1I % i1i1i1111I * i1iiIII111 * IIiIIiIi11I1
 if 23 - 23: i1I * IiI11Ii111 . oOo0O00 * Ii
 if 94 - 94: i1i1i1111I - i1iiIII111 . Ooo0Ooo + Oo - i1
 Config = 0
 if 96 - 96: Iii1i % ooo000 * oOo0O00 . Ii % oOO + i1I
 if 20 - 20: i1 % Ii / ooo000
 Columns = 1
 if 58 - 58: I11iiIi11i1I % i1 . oOo0O00 - OooOoo - OooOoo
 if 44 - 44: IIiIIiIi11I1
 Image = 2
 if 74 - 74: oOO . ooOOO - ooo000 . Ooo0Ooo % OooOoo * OooOoo
 if 62 - 62: IIiIIiIi11I1 / i1I - oOO / I11iiIi11i1I % i1
 SourceLike = 100
 if 32 - 32: ooOOO
 if 100 - 100: i1I + Oo . Ooo0Ooo * Ooo0Ooo
 TimeSeries = 101
 if 47 - 47: i1iiIII111 / IiI11Ii111 + Iii1i
 if 99 - 99: IiIIii11Ii / iI1iII1I1I1i % IiI11Ii111
 Noise = 102
 if 19 - 19: i1 . IiIIii11Ii / i1i1i1111I / Oo
 if 95 - 95: i1
 BERT = 103
 if 80 - 80: Iii1i + i1iiIII111
 if 89 - 89: oOo0O00
 TXT = 104
 if 58 - 58: i1iiIII111 . oOO / I1I / oOO
class O0o000oO000 ( Oo0ooo0OO0 ) :
 if 6 - 6: Ii / I1I + IiI11Ii111
 if 35 - 35: iI1iII1I1I1i
 if 84 - 84: i1i1i1111I
 if 50 - 50: IiIIii11Ii + Iii1i . ooo000 + ooo000 / Oo % i1iiIII111
 if 63 - 63: i1i1i1111I % I1I / iI1iII1I1I1i % Iii1i % Ii
 if 32 - 32: i1iiIII111 + ooo000 - I1Ii1I1 * IiIIii11Ii . IiIIii11Ii
 if 46 - 46: i1 + ooOOO % ooOOO . Iii1i - ooOOO % i1
 class StepEnum ( I1i1i ) :
  if 20 - 20: OooOoo - ooo000 . I11iiIi11i1I
  if 87 - 87: i1 * i1 - OooOoo % oOo0O00 - IiI11Ii111
  if 43 - 43: OooOoo % OooOoo / oOO % I1I
  if 18 - 18: I11iiIi11i1I * Ooo0Ooo / OooOoo
  if 84 - 84: i1iiIII111 / oOO . Oo % i1iiIII111 / OooOoo
  if 94 - 94: i1iiIII111
  if 53 - 53: iI1iII1I1I1i + ooOOO * I1I / Oo
  if 17 - 17: IiI11Ii111 . IiI11Ii111
  RawInput = - 1
  if 35 - 35: IiI11Ii111 % IiI11Ii111 / i1 / Iii1i * IiIIii11Ii
  if 11 - 11: OooOoo - IiI11Ii111 % IiIIii11Ii - ooo000 / IIiIIiIi11I1 - OooOoo
  Input = 0
  if 21 - 21: Ii / Ooo0Ooo
  if 98 - 98: ooOOO
  DataGenerated = 1
  if 53 - 53: I1I * I1I
  if 9 - 9: IiI11Ii111 - IIiIIiIi11I1
  Transformed = 2
  if 89 - 89: i1 - ooo000 - Ii
  if 78 - 78: i1iiIII111 - IiI11Ii111 - i1I * oOO % Ii % I11iiIi11i1I
  Output = 10
  if 14 - 14: Ii - I11iiIi11i1I / ooo000 % Ii
 def __init__ ( self , instanceClass : 'DataPreprocessing.Node.Types' = None , sourceCol : str = "None:None" , dtype : 'tf.DType' = None ) :
  if 72 - 72: Ii % oOo0O00 / ooo000 - oOo0O00
  if 100 - 100: I1Ii1I1 - oOo0O00 - IiI11Ii111
  if 7 - 7: OooOoo % iI1iII1I1I1i - I11iiIi11i1I . I1Ii1I1 . oOO % OooOoo
  if 51 - 51: iI1iII1I1I1i + I1Ii1I1 . i1I - I1I
  if 59 - 59: ooOOO
  if 42 - 42: I1Ii1I1 * Oo * Oo . iI1iII1I1I1i * IiIIii11Ii * i1i1i1111I
  if 68 - 68: I11iiIi11i1I - I1Ii1I1 % oOO - Ii - i1iiIII111 / i1I
  if 85 - 85: OooOoo / I1Ii1I1
  if 99 - 99: Ooo0Ooo . oOo0O00 + iI1iII1I1I1i * I1Ii1I1 + OooOoo . I1I
  if 1 - 1: Iii1i + IIiIIiIi11I1 - oOO - IiI11Ii111 . IIiIIiIi11I1
  if 31 - 31: IIiIIiIi11I1 % iI1iII1I1I1i
  if 53 - 53: IiI11Ii111 . Iii1i % oOO / ooOOO
  super ( ) . __init__ ( instanceClass = ( instanceClass or OoiI1iiI11IIi1 . SourceLike ) , dtype = dtype , sourceCol = sourceCol )
  if 80 - 80: I1I % I1Ii1I1 . Ii / IiIIii11Ii * OooOoo . Ii
  if 86 - 86: oOo0O00 % i1i1i1111I + Oo . I1Ii1I1 - I1Ii1I1
  self . splittable : bool = False
  if 87 - 87: IiI11Ii111 % oOO % I1Ii1I1
  if 59 - 59: IiIIii11Ii % i1i1i1111I . i1iiIII111 + ooo000 + Ooo0Ooo . oOO
  self . _getDataMode : II1IiI1I = II1IiI1I . Current
  if 9 - 9: OooOoo - ooOOO . i1iiIII111
  if 68 - 68: I1I % I1I * Ii % Oo
  self . generatorController : I111II1II111I . Controller = None
  if 17 - 17: IIiIIiIi11I1 % IIiIIiIi11I1 % I1Ii1I1 - i1 % oOo0O00
 @ property
 def batchSize ( self ) -> int :
  if 25 - 25: Oo
  if 4 - 4: Oo * I1I * Ooo0Ooo % Ooo0Ooo
  if 6 - 6: oOO + I1I * Iii1i
  if 82 - 82: oOo0O00 * ooOOO
  if 9 - 9: I11iiIi11i1I + i1iiIII111 % Iii1i
  if 15 - 15: i1iiIII111 + i1I - Iii1i % I1I / i1iiIII111 + IIiIIiIi11I1
  if 61 - 61: OooOoo
  if 62 - 62: iI1iII1I1I1i * oOO
  if 43 - 43: Ii - oOo0O00 % i1iiIII111 % oOO
  if 69 - 69: I1I
  if self . train is None :
   raise ValueError ( "This source is not attached to a Train object yet. No batch size can be determined." )
   if 74 - 74: IiIIii11Ii + OooOoo . Iii1i + ooo000 + oOO * I1Ii1I1
  return self . train . buildConfigs [ self . train . buildNo ] . batchSize
  if 74 - 74: I1Ii1I1 - Oo % i1iiIII111 + Ii * ooOOO
 @ property
 def batchCountPerEpoch ( self ) -> int :
  if 53 - 53: IIiIIiIi11I1
  if 31 - 31: oOo0O00 - I11iiIi11i1I / oOo0O00
  if 23 - 23: IiIIii11Ii
  if 5 - 5: iI1iII1I1I1i . I11iiIi11i1I
  if 4 - 4: OooOoo % i1iiIII111 / I11iiIi11i1I - oOo0O00
  if 100 - 100: Oo / OooOoo % I1I
  if 93 - 93: iI1iII1I1I1i
  if 50 - 50: Oo % oOo0O00 . IiI11Ii111 . i1iiIII111 . Ii - Oo
  if 67 - 67: oOo0O00 * i1I . I1I + I1I + oOo0O00 / ooOOO
  if 69 - 69: Oo - OooOoo + I1Ii1I1
  return self . generatorController [ self . train . currentSourceDataset ] . batchCountPerEpoch
  if 36 - 36: Iii1i
 @ property
 def epochSize ( self ) -> int :
  if 80 - 80: Oo % oOO / oOO + ooOOO + OooOoo
  if 91 - 91: i1 % i1i1i1111I / oOo0O00
  if 79 - 79: iI1iII1I1I1i % OooOoo . Iii1i
  if 61 - 61: Oo . Ii - Ooo0Ooo . I1Ii1I1 - IiI11Ii111 * i1I
  if 81 - 81: iI1iII1I1I1i * IiIIii11Ii % i1iiIII111 + oOO / iI1iII1I1I1i . i1I
  if 17 - 17: iI1iII1I1I1i
  if 13 - 13: iI1iII1I1I1i + i1 - OooOoo / IiI11Ii111
  if 34 - 34: I1Ii1I1 - i1iiIII111 * i1iiIII111
  if 59 - 59: i1i1i1111I . Oo - IIiIIiIi11I1 + iI1iII1I1I1i
  if 22 - 22: IiI11Ii111 + OooOoo % I11iiIi11i1I
  return self . generatorController [ self . train . currentSourceDataset ] . epochSize
  if 14 - 14: Oo * oOO + i1i1i1111I * oOo0O00
 @ property
 def testRatio ( self ) -> int :
  if 69 - 69: i1I - i1 - i1 % oOO
  if 21 - 21: i1i1i1111I - I1I + i1I * Ooo0Ooo
  if 56 - 56: oOO + i1 * i1i1i1111I / i1I * IIiIIiIi11I1
  if 15 - 15: iI1iII1I1I1i % oOO + iI1iII1I1I1i . oOo0O00 / ooo000
  if 9 - 9: IiI11Ii111 . i1iiIII111 - Ii - I1I . OooOoo
  if 75 - 75: OooOoo . OooOoo * oOO - ooo000 + i1I % iI1iII1I1I1i
  if 26 - 26: i1iiIII111 * oOo0O00
  if 73 - 73: Ooo0Ooo + IiIIii11Ii * i1I . IiI11Ii111 . ooo000 % OooOoo
  if 38 - 38: IiIIii11Ii
  if 71 - 71: Iii1i
  if self . train is None :
   raise ValueError ( "This source is not attached to a Train object yet. No test ratio can be determined." )
   if 91 - 91: Oo + Iii1i + Ooo0Ooo / i1I * ooo000
  return self . train . testRatio
  if 81 - 81: ooo000 * ooo000 - Ooo0Ooo
 @ property
 def shuffle ( self ) -> bool :
  if 70 - 70: I1Ii1I1 * IIiIIiIi11I1
  if 18 - 18: ooo000 % IiIIii11Ii
  if 54 - 54: OooOoo + OooOoo
  if 2 - 2: Iii1i
  if 19 - 19: Ooo0Ooo - i1i1i1111I / Ooo0Ooo / IiI11Ii111 - IiI11Ii111 - I1Ii1I1
  if 59 - 59: oOO - ooo000 - i1 + Ooo0Ooo / IiI11Ii111
  if 1 - 1: i1 - I11iiIi11i1I * Ooo0Ooo + i1I % IiIIii11Ii
  if 5 - 5: i1I
  if 62 - 62: Oo + IIiIIiIi11I1 % i1i1i1111I * I11iiIi11i1I / iI1iII1I1I1i + I11iiIi11i1I
  if 11 - 11: i1i1i1111I % IIiIIiIi11I1 / i1i1i1111I * oOO * i1I
  if self . train is None :
   raise ValueError ( "This source is not attached to a Train object yet. No shuffle can be determined." )
   if 40 - 40: i1iiIII111 . Iii1i % iI1iII1I1I1i - IIiIIiIi11I1 % i1I
  return self . train . buildConfigs [ self . train . buildNo ] . shuffle
  if 94 - 94: IiIIii11Ii - oOo0O00 + I1Ii1I1
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 5 - 5: oOo0O00 % i1I * Ii + IIiIIiIi11I1 * I1Ii1I1 % i1I
  if 7 - 7: IiI11Ii111 + oOo0O00 . i1i1i1111I - I11iiIi11i1I / ooOOO . ooOOO
  if 17 - 17: ooOOO + Iii1i + Oo * I1Ii1I1 % i1I
  if 95 - 95: iI1iII1I1I1i * IiIIii11Ii
  if 23 - 23: i1 * I1Ii1I1 - I11iiIi11i1I
  if 5 - 5: OooOoo . OooOoo % IIiIIiIi11I1
  if 97 - 97: i1 - iI1iII1I1I1i * I1Ii1I1 * I1I
  if 74 - 74: Ii + ooOOO * Ii . iI1iII1I1I1i / IIiIIiIi11I1 - oOo0O00
  if 61 - 61: i1 % ooo000 - ooOOO - I11iiIi11i1I / Iii1i - oOo0O00
  if 58 - 58: i1iiIII111 * Ii % oOO . IiIIii11Ii
  if 56 - 56: ooOOO * ooOOO + Oo + i1I + ooo000
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "generatorController" :
    if 60 - 60: i1 * i1I * I11iiIi11i1I / I1Ii1I1 + oOO + Iii1i
    self . generatorController . parseFromJSON ( iiiiIi1IiiIi )
   elif Ii1I == "source" :
    if type ( iiiiIi1IiiIi ) == str :
     iiiiIi1IiiIi = int ( iiiiIi1IiiIi . split ( ) [ - 1 ] )
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 87 - 87: i1i1i1111I
    self . _train = train
    self . _fromNode = train . sources [ iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , int ) else train . dppNodes [ iiiiIi1IiiIi ]
   elif Ii1I == "transformations" :
    if 2 - 2: I11iiIi11i1I . iI1iII1I1I1i . i1 + oOo0O00
    setattr ( self , Ii1I , [ ( Oo000oO00O . createFromJSON ( tx ) if "_instanceClass" in tx else tx ) for tx in iiiiIi1IiiIi ] )
   elif Ii1I == "dtype" :
    if 33 - 33: Iii1i . IiI11Ii111
    if iiiiIi1IiiIi is not None :
     self . dtype = O0 . getDataType ( iiiiIi1IiiIi )
   elif Ii1I == "_getDataMode" :
    setattr ( self , Ii1I , II1IiI1I [ iiiiIi1IiiIi ] )
   elif Ii1I == "crops" :
    self . crops = { idx : crop for idx , crop in enumerate ( iiiiIi1IiiIi ) if crop is not None }
   elif Ii1I not in [ "train" , "fromNode" , "_instanceClass" , "order" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 12 - 12: IiI11Ii111
 def getData ( self , step : 'DataPreprocessing.Node.SourceLike.StepEnum' = StepEnum . Output ,
 sourceDataset : 'DataGenerator.Dataset.Types' = None ,
 start : int = None , end : int = None ) -> List [ List [ int ] ] :
  if 85 - 85: Oo % Oo
  if 12 - 12: ooo000 / i1I * Oo / I1Ii1I1 * ooOOO
  if 38 - 38: i1i1i1111I * iI1iII1I1I1i * Ooo0Ooo + i1iiIII111
  if 33 - 33: ooOOO . Ii
  if 49 - 49: Ii + ooOOO + iI1iII1I1I1i / i1i1i1111I
  if 63 - 63: ooo000 % I1Ii1I1
  if 83 - 83: OooOoo . Ooo0Ooo % IiI11Ii111 / Oo
  if 57 - 57: Oo + i1i1i1111I . i1I . ooOOO * Iii1i - IIiIIiIi11I1
  if 20 - 20: Iii1i * ooo000 . OooOoo + i1iiIII111 * i1I - Iii1i
  if 66 - 66: IIiIIiIi11I1 - ooo000 - i1i1i1111I * i1 % ooo000 . IIiIIiIi11I1
  if 16 - 16: IiIIii11Ii % oOo0O00 + Ii - i1i1i1111I * IiIIii11Ii
  if 69 - 69: iI1iII1I1I1i . I1I + I1Ii1I1
  if 71 - 71: ooo000
  if 85 - 85: ooo000 + Oo
  if 81 - 81: IIiIIiIi11I1 + iI1iII1I1I1i . I1I * Ii / Iii1i / i1I
  if 31 - 31: i1i1i1111I - oOo0O00 % oOO - iI1iII1I1I1i
  iiI1iIi : I1i11iii1iI1
  if step == O0o000oO000 . StepEnum . RawInput :
   if 3 - 3: Ii % OooOoo / I1Ii1I1 . Ii
   o0o0oooO0 : iII11 . RootSources = iII11 . RootSources ( self , self . getRootSources ( ) , sourceDataset )
   if 52 - 52: i1I . OooOoo % i1iiIII111
   if 28 - 28: i1I
   iiI1iIi = o0o0oooO0 . getData ( start , end )
  else :
   iiI1iIi = self . generatorController . get ( sourceDataset or self . train . currentSourceDataset ) . getData ( start , end )
   if 23 - 23: Oo . OooOoo + Ooo0Ooo
   if 22 - 22: oOO + iI1iII1I1I1i / i1I / OooOoo . IiI11Ii111 . ooo000
  return self . getProcessedData ( iiI1iIi , step )
  if 100 - 100: IIiIIiIi11I1 . i1i1i1111I
 def getProcessedData ( self , rootData : 'Train.RootData|list<*>' , step : 'DataPreprocessing.Node.SourceLike.StepEnum' = StepEnum . Output ) -> 'list<*>' :
  if 1 - 1: I1Ii1I1
  if 12 - 12: i1I * Ooo0Ooo + IIiIIiIi11I1 * OooOoo * OooOoo / ooOOO
  if 67 - 67: i1 - IiI11Ii111 / Ii * IiI11Ii111
  if 24 - 24: IiI11Ii111 - oOo0O00 . Ooo0Ooo + oOO . I1I / Oo
  if 68 - 68: IiI11Ii111
  if 47 - 47: i1 % I1I - Ii + Oo / OooOoo
  if 88 - 88: I1Ii1I1 - Ii / IiIIii11Ii . oOo0O00
  if 27 - 27: i1iiIII111 + iI1iII1I1I1i % Oo . Ii
  if 69 - 69: Iii1i / IIiIIiIi11I1
  if 66 - 66: i1i1i1111I
  if 31 - 31: i1I - i1iiIII111 % I1I - i1iiIII111 * Oo / i1iiIII111
  if 30 - 30: i1
  if 95 - 95: ooo000 / i1i1i1111I / i1I - IIiIIiIi11I1
  if 7 - 7: I1I / iI1iII1I1I1i % ooo000 / IiIIii11Ii
  if 18 - 18: I1I * IiIIii11Ii * I1I + i1iiIII111
  if step == O0o000oO000 . StepEnum . RawInput :
   if isinstance ( rootData , list ) :
    raise ValueError ( "When raw input is requested for source like data preprocessing node, root data must not root data of the train object." )
   if self . key in [ * rootData . dppNodes . keys ( ) ] :
    raise ValueError ( "When raw input is requested for source like data preprocessing node, root data must not include itself." )
    if 17 - 17: i1I
    if 8 - 8: Oo / iI1iII1I1I1i - Ooo0Ooo
   I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProccessedData ( rootData )
   if 22 - 22: oOo0O00 / I1Ii1I1 % IiI11Ii111
   return I1i
   if 22 - 22: i1 % Ooo0Ooo . IIiIIiIi11I1 % i1I / IIiIIiIi11I1
  if isinstance ( rootData , iII11 . RootData ) :
   if 60 - 60: Ooo0Ooo . i1 * i1
   if self . key in [ * rootData . dppNodes . keys ( ) ] :
    if step == O0o000oO000 . StepEnum . RawInput :
     return rootData . dppNodes [ self . key ]
    elif step != O0o000oO000 . StepEnum . Output :
     raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
    else :
     rootData = rootData . dppNodes [ self . key ]
   else :
    raise ValueError ( "Root Data cannot be found for data preprocessing" )
    if 42 - 42: i1 % OooOoo % Iii1i % Ooo0Ooo
    if 6 - 6: IIiIIiIi11I1
  return self . processData ( rootData , step )
  if 94 - 94: Ooo0Ooo . ooo000 % Oo - IIiIIiIi11I1 - i1
 def getProcessedDataToShow ( self , rootData : 'Train.RootData|list<*>' , step : 'DataPreprocessing.Node.SourceLike.StepEnum' = StepEnum . Output ) -> 'list<*>' :
  return self . getProcessedData ( rootData , step )
  if 11 - 11: Ooo0Ooo . OooOoo / oOo0O00 + i1i1i1111I / Iii1i
  if 62 - 62: I1Ii1I1 + iI1iII1I1I1i * i1I % iI1iII1I1I1i . OooOoo - ooo000
  if 24 - 24: iI1iII1I1I1i * Iii1i * i1i1i1111I
  if 50 - 50: I11iiIi11i1I + oOo0O00 . ooOOO - IiI11Ii111 * i1I % I1I
  if 88 - 88: IiI11Ii111
  if 43 - 43: I11iiIi11i1I . IiIIii11Ii * Oo . IiIIii11Ii - IiI11Ii111 - Ii
  if 47 - 47: oOO / i1i1i1111I * oOO
  if 91 - 91: i1iiIII111 / i1
  if 70 - 70: IIiIIiIi11I1
  if 95 - 95: I1I * i1 * IiIIii11Ii + I11iiIi11i1I + Ooo0Ooo
  if 36 - 36: i1i1i1111I
  if 48 - 48: IIiIIiIi11I1 - I11iiIi11i1I % Oo
  if 61 - 61: oOO % iI1iII1I1I1i + IiIIii11Ii % i1i1i1111I * iI1iII1I1I1i / i1i1i1111I
  if 11 - 11: oOo0O00 / Oo . ooOOO / Oo
 def _processData ( self , data : 'np.ndarray' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 90 - 90: OooOoo - I1I
  if 67 - 67: oOo0O00 . oOO - IIiIIiIi11I1 / Ooo0Ooo + Iii1i - oOo0O00
  if 25 - 25: Iii1i
  if 30 - 30: i1iiIII111 * i1I - i1iiIII111 + i1I - I11iiIi11i1I
  if 71 - 71: oOo0O00 - OooOoo % I1Ii1I1 + ooOOO
  if 30 - 30: oOo0O00 + OooOoo . oOo0O00 + iI1iII1I1I1i
  if 22 - 22: oOO / I1Ii1I1 + OooOoo / i1 / Oo
  if 6 - 6: OooOoo % ooOOO - IiIIii11Ii
  if 24 - 24: Ii % i1iiIII111
  if 45 - 45: iI1iII1I1I1i + oOO
  if 21 - 21: Oo + ooo000 . OooOoo - i1iiIII111 - OooOoo
  if 1 - 1: I11iiIi11i1I % oOo0O00 + oOo0O00 - OooOoo % iI1iII1I1I1i % i1iiIII111
  if 89 - 89: IIiIIiIi11I1
  if 6 - 6: oOO * Oo
  pass
  if 40 - 40: ooo000
 def processData ( self , data : Union [ 'np.ndarray' , 'tf.Tensor' ] , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> Union [ 'np.ndarray' , 'tf.Tensor' ] :
  if 80 - 80: IiIIii11Ii - i1i1i1111I
  if 42 - 42: IiI11Ii111
  if 83 - 83: I11iiIi11i1I % i1
  if 99 - 99: Iii1i / oOO . iI1iII1I1I1i
  if 87 - 87: I11iiIi11i1I . I1I - i1iiIII111 - IiI11Ii111 % Ii % IiIIii11Ii
  if 51 - 51: Ooo0Ooo * IiIIii11Ii
  if 50 - 50: oOo0O00 . IiIIii11Ii + oOo0O00
  if 58 - 58: I1I . iI1iII1I1I1i * Ooo0Ooo * oOo0O00 - I1Ii1I1
  if 94 - 94: Ooo0Ooo * i1I / i1i1i1111I % OooOoo
  if 27 - 27: I11iiIi11i1I - i1i1i1111I + i1I
  if 97 - 97: Iii1i . ooOOO - I1Ii1I1 - oOO
  if 60 - 60: OooOoo % I1Ii1I1 / oOo0O00 - IIiIIiIi11I1 % oOo0O00 . i1I
  if 39 - 39: iI1iII1I1I1i % Iii1i / OooOoo . ooOOO
  if 39 - 39: IIiIIiIi11I1 * oOo0O00 . I1Ii1I1 - i1 - Oo . ooOOO
  if isinstance ( data , np . ndarray ) :
   return self . _processData ( data , step )
  elif isinstance ( data , tf . Tensor ) :
   return self . processDataTensor ( data , step )
  else :
   raise ValueError ( "Data type not supported." )
   if 64 - 64: IiI11Ii111
 def processDataNPArray ( self , data : 'np.ndarray' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 96 - 96: IIiIIiIi11I1 % Ooo0Ooo % ooOOO
  if 81 - 81: Oo - I11iiIi11i1I + i1I * ooOOO . i1I / Ii
  if 19 - 19: OooOoo - I1Ii1I1 + Ii
  if 35 - 35: IiIIii11Ii - oOo0O00 . oOo0O00
  if 68 - 68: I11iiIi11i1I . I1Ii1I1 / IiI11Ii111 . oOO / i1iiIII111 + oOo0O00
  if 35 - 35: IiIIii11Ii * oOO . IiIIii11Ii % Iii1i / I11iiIi11i1I / oOo0O00
  if 48 - 48: i1iiIII111 - Oo / OooOoo / I11iiIi11i1I
  if 29 - 29: IiI11Ii111 % I11iiIi11i1I
  if 69 - 69: Oo % iI1iII1I1I1i - Oo . Iii1i / IiIIii11Ii - oOo0O00
  if 89 - 89: iI1iII1I1I1i / I11iiIi11i1I % i1iiIII111
  if 23 - 23: Iii1i + Oo * OooOoo / OooOoo * i1 * oOo0O00
  if 17 - 17: i1i1i1111I / Ooo0Ooo
  if 89 - 89: i1i1i1111I
  if 3 - 3: Ii - Oo / I11iiIi11i1I . i1I
  return self . _processData ( data , step )
  if 8 - 8: ooOOO . i1i1i1111I . Iii1i + Oo
 def processDataTensor ( self , data : 'tf.Tensor' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'tf.Tensor' :
  if 16 - 16: i1I / I1Ii1I1 / IiIIii11Ii * i1i1i1111I . OooOoo
  if 96 - 96: IiIIii11Ii % I1Ii1I1 + I11iiIi11i1I
  if 100 - 100: i1 % i1I % Oo . Iii1i % I1I % I1I
  if 37 - 37: Iii1i % Oo
  if 28 - 28: IIiIIiIi11I1 * i1I + iI1iII1I1I1i / Oo * I1Ii1I1
  if 46 - 46: I1I - i1 % Oo - i1iiIII111
  if 16 - 16: I11iiIi11i1I . IIiIIiIi11I1 / oOo0O00 + oOO
  if 93 - 93: i1i1i1111I
  if 42 - 42: ooo000 . iI1iII1I1I1i + oOo0O00 % iI1iII1I1I1i
  if 29 - 29: oOo0O00 - I1I - IIiIIiIi11I1 . IiIIii11Ii * I1Ii1I1
  if 2 - 2: Oo - iI1iII1I1I1i - i1i1i1111I % OooOoo . ooo000 - i1I
  if 14 - 14: i1i1i1111I / I1I + I1I + ooo000 % i1 . Ooo0Ooo
  if 93 - 93: i1I + ooOOO % ooo000 * IiIIii11Ii
  if 61 - 61: ooo000 % I11iiIi11i1I - OooOoo + Oo - ooOOO . IIiIIiIi11I1
  return tf . convert_to_tensor ( self . _processData ( np . array ( data ) , step ) )
  if 64 - 64: OooOoo * Iii1i
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> Any :
  if 13 - 13: i1i1i1111I . Iii1i - ooo000 / i1iiIII111 % oOo0O00 / IiI11Ii111
  if 80 - 80: i1i1i1111I
  if 85 - 85: iI1iII1I1I1i - oOo0O00 / IIiIIiIi11I1 * I11iiIi11i1I - ooOOO
  if 70 - 70: oOO % Ii . Ooo0Ooo
  if 16 - 16: i1iiIII111 - iI1iII1I1I1i - Ii - Ii
  if 23 - 23: oOo0O00 * I1Ii1I1 * Ooo0Ooo - oOo0O00 / ooo000
  if 63 - 63: i1I
  if 87 - 87: oOO * oOO * IIiIIiIi11I1 % IIiIIiIi11I1
  if 72 - 72: Ii % ooo000
  if 34 - 34: ooo000 % IiIIii11Ii % i1iiIII111 + Ii
  if 4 - 4: OooOoo . IiIIii11Ii + i1I * i1iiIII111 . ooo000
  if 13 - 13: IiIIii11Ii + IiIIii11Ii - i1 . i1
  if 31 - 31: i1I + i1i1i1111I . Oo + I1Ii1I1 + oOO . i1iiIII111
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getNextBatch ( )
  if 5 - 5: Ooo0Ooo * I11iiIi11i1I % ooOOO - Iii1i
 def getRandItems ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None , randomSeed : int = None , randomCount : int = None ) :
  if 90 - 90: Iii1i % ooo000 + ooo000 % i1iiIII111
  if 74 - 74: IIiIIiIi11I1
  if 13 - 13: I1I * IIiIIiIi11I1 + i1iiIII111 % IiI11Ii111 / IiIIii11Ii + Ooo0Ooo
  if 26 - 26: i1i1i1111I * I1I % ooOOO + Ii
  if 39 - 39: i1 - i1i1i1111I % i1I * i1I . i1iiIII111
  if 35 - 35: i1I
  if 68 - 68: I1I - i1i1i1111I + oOo0O00 * I11iiIi11i1I
  if 39 - 39: oOO * I1I + ooo000 - ooOOO
  if 80 - 80: oOO - Iii1i / I11iiIi11i1I * i1I / IIiIIiIi11I1
  if 28 - 28: iI1iII1I1I1i * oOO + Ooo0Ooo % Ii % I1I % IiIIii11Ii
  if 60 - 60: OooOoo / oOo0O00
  if 56 - 56: i1i1i1111I + I1I * ooOOO - oOo0O00
  if 83 - 83: IiI11Ii111 + i1
  if 52 - 52: OooOoo . I1I
  if 4 - 4: iI1iII1I1I1i + IIiIIiIi11I1
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getRandItems ( randomSeed , randomCount )
  if 72 - 72: Ii - I1Ii1I1 / OooOoo + Iii1i
class I111II1II111I :
 if 34 - 34: oOO * Ii / IIiIIiIi11I1
 if 3 - 3: i1i1i1111I
 if 41 - 41: i1i1i1111I + IiIIii11Ii - i1i1i1111I * OooOoo - i1
 if 15 - 15: I11iiIi11i1I * I11iiIi11i1I . i1I * ooOOO % IIiIIiIi11I1
 if 12 - 12: Oo % i1iiIII111
 if 43 - 43: ooo000 * i1 * I1I - Oo / I1Ii1I1
 if 28 - 28: Ooo0Ooo - i1I + Ii
 class Dataset :
  if 63 - 63: Oo + oOO + IIiIIiIi11I1 - i1 * ooOOO
  if 19 - 19: IiIIii11Ii - Iii1i + IiI11Ii111
  if 5 - 5: Ii * i1 * oOO + oOo0O00 - IiIIii11Ii * Oo
  if 69 - 69: ooo000 - Iii1i
  if 51 - 51: i1i1i1111I + oOo0O00 / I1I
  if 21 - 21: i1iiIII111 * Ooo0Ooo * ooOOO . i1i1i1111I
  if 100 - 100: Ooo0Ooo - Ooo0Ooo + I1Ii1I1 . ooOOO
  class Types ( II1i1I ) :
   if 65 - 65: IiIIii11Ii
   if 54 - 54: oOO * i1iiIII111 * Iii1i - I1Ii1I1 . iI1iII1I1I1i
   if 83 - 83: ooo000 . I1I
   if 81 - 81: i1I + Oo . I1Ii1I1
   if 32 - 32: OooOoo * Ooo0Ooo % iI1iII1I1I1i + OooOoo - ooOOO
   if 23 - 23: i1iiIII111 % I1I + Ooo0Ooo . I1Ii1I1 + ooo000 - i1I
   if 29 - 29: Iii1i
   if 72 - 72: i1 % iI1iII1I1I1i . ooOOO / I1Ii1I1 * ooo000 . IiI11Ii111
   Train = 0
   if 55 - 55: OooOoo + IiIIii11Ii . i1I / Iii1i . I11iiIi11i1I
   if 56 - 56: IIiIIiIi11I1 * i1 . I1I * I1I
   ValidationTrain = 1
   if 35 - 35: IIiIIiIi11I1 * OooOoo - Ooo0Ooo
   if 27 - 27: oOo0O00 / I1I * I1Ii1I1 - OooOoo - Iii1i
   Validation = 2
   if 38 - 38: IiI11Ii111 / i1 - IiIIii11Ii
   if 75 - 75: iI1iII1I1I1i * Iii1i . OooOoo - ooo000 + I1I * ooo000
   Test = 3
   if 91 - 91: IiI11Ii111 * i1i1i1111I + oOO . Ii
   if 7 - 7: IIiIIiIi11I1 / IiI11Ii111 + IiI11Ii111
   Prediction = 4
   if 91 - 91: Iii1i . I11iiIi11i1I + ooo000 % ooo000 + IiIIii11Ii * OooOoo
  class TestSource ( II1i1I ) :
   if 72 - 72: i1I
   if 23 - 23: I11iiIi11i1I / i1iiIII111 - iI1iII1I1I1i
   if 17 - 17: i1iiIII111
   if 91 - 91: OooOoo - Oo + Ii + IIiIIiIi11I1 / ooOOO
   if 96 - 96: oOo0O00 - IiI11Ii111 + ooOOO
   if 67 - 67: I1Ii1I1 - IIiIIiIi11I1 + OooOoo
   if 72 - 72: iI1iII1I1I1i * I1I . Ii / I1Ii1I1 / IIiIIiIi11I1 . ooOOO
   if 21 - 21: Ooo0Ooo - IIiIIiIi11I1 . iI1iII1I1I1i . oOO + iI1iII1I1I1i - IIiIIiIi11I1
   Split = 0
   if 15 - 15: Oo / i1i1i1111I + oOo0O00 / I1Ii1I1 / I11iiIi11i1I * ooOOO
   if 73 - 73: I1I % Iii1i % i1I % Ooo0Ooo / i1 . IIiIIiIi11I1
   Assign = 1
   if 87 - 87: i1iiIII111
 class Detail :
  if 4 - 4: Oo * IiIIii11Ii - i1I
  if 14 - 14: Iii1i / iI1iII1I1I1i . IIiIIiIi11I1
  if 59 - 59: IiI11Ii111 + Iii1i * Ii + IiI11Ii111 * i1iiIII111 - i1I
  if 17 - 17: oOo0O00 . i1iiIII111
  if 8 - 8: oOO . ooo000 % ooo000 . I1Ii1I1 + ooo000 / i1i1i1111I
  if 3 - 3: ooo000 / ooo000
  if 37 - 37: OooOoo * oOo0O00 . Ooo0Ooo - oOo0O00 * IiI11Ii111 * OooOoo
  def __init__ ( self , controller : 'DataGenerator.Controller' ) :
   if 46 - 46: IiIIii11Ii . I1I % iI1iII1I1I1i - IIiIIiIi11I1 - i1I + IiI11Ii111
   if 55 - 55: Ooo0Ooo
   if 48 - 48: Ooo0Ooo / Ooo0Ooo * Ii . i1iiIII111 % iI1iII1I1I1i
   if 87 - 87: OooOoo * IIiIIiIi11I1
   if 68 - 68: I11iiIi11i1I * oOo0O00 . Ooo0Ooo - IIiIIiIi11I1 . OooOoo + OooOoo
   if 88 - 88: I11iiIi11i1I / oOo0O00 - i1I
   if 7 - 7: Ii . Oo % Ooo0Ooo % Oo - iI1iII1I1I1i
   if 85 - 85: ooOOO % ooOOO + i1i1i1111I % Iii1i % iI1iII1I1I1i . I1Ii1I1
   if 24 - 24: i1i1i1111I . oOo0O00 - i1I + iI1iII1I1I1i
   if 97 - 97: IiI11Ii111 - i1iiIII111 + I1I / i1i1i1111I / IiI11Ii111 * ooOOO
   if 87 - 87: Ooo0Ooo
   self . _initialized : bool = False
   if 69 - 69: Iii1i
   if 51 - 51: Iii1i
   self . _epochSize : int = None
   if 22 - 22: iI1iII1I1I1i - ooo000 * IiI11Ii111 * IIiIIiIi11I1 * IiI11Ii111 + IiI11Ii111
   if 47 - 47: ooo000 * i1i1i1111I + OooOoo / I1I . Iii1i . I1I
   self . _oriShape : List [ int ] = None
   if 4 - 4: OooOoo - i1
   if 56 - 56: I1I % oOo0O00 . OooOoo - Ooo0Ooo - Oo . I1Ii1I1
   self . _controller : I111II1II111I . Controller = controller
   if 20 - 20: iI1iII1I1I1i * IIiIIiIi11I1 - iI1iII1I1I1i . i1 % oOo0O00 / i1I
   if 51 - 51: i1iiIII111
   self . _itrIdx : int = None
   if 2 - 2: Ooo0Ooo
   if 54 - 54: i1I * oOO % Ii + IIiIIiIi11I1
   self . _batchSize : int = None
   if 52 - 52: i1I % IiI11Ii111 * IIiIIiIi11I1 * i1
   if 92 - 92: I11iiIi11i1I
   self . _shuffle : bool = None
   if 3 - 3: i1iiIII111 % i1i1i1111I % Ooo0Ooo + IIiIIiIi11I1
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 15 - 15: IiIIii11Ii % Ooo0Ooo - I1Ii1I1 . oOo0O00
   if 93 - 93: IiIIii11Ii - iI1iII1I1I1i
   if 30 - 30: i1I / i1iiIII111 * iI1iII1I1I1i % oOo0O00 / ooo000
   if 54 - 54: IiIIii11Ii * I1Ii1I1 - I1I % i1i1i1111I + IIiIIiIi11I1 * OooOoo
   if 23 - 23: IiI11Ii111 / IIiIIiIi11I1
   if 13 - 13: oOo0O00 - I1I / Ii % Iii1i
   if 46 - 46: I1Ii1I1 + I11iiIi11i1I / Ii
   if 9 - 9: Oo - i1 % Oo
   if 72 - 72: ooOOO - i1iiIII111
   if 46 - 46: oOO
   if 35 - 35: I11iiIi11i1I * IiI11Ii111
   for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
    if Ii1I not in [ "_controller" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 86 - 86: Ii
  def overrideConfig ( self , configs : Dict [ str , Any ] ) :
   if 57 - 57: Oo . IiI11Ii111 % oOO . Ii
   if 65 - 65: I1Ii1I1
   if 81 - 81: I1I
   if 47 - 47: oOo0O00 * iI1iII1I1I1i
   if 98 - 98: Oo - IiIIii11Ii / OooOoo + I1I . iI1iII1I1I1i
   if 54 - 54: i1
   if 61 - 61: I11iiIi11i1I + i1i1i1111I / ooOOO
   if 48 - 48: IiIIii11Ii - i1 * I11iiIi11i1I / i1 - Ooo0Ooo / Ooo0Ooo
   if 53 - 53: IiIIii11Ii % iI1iII1I1I1i . Iii1i / I11iiIi11i1I
   if 9 - 9: i1iiIII111
   if 41 - 41: Ooo0Ooo / ooo000 . OooOoo . i1I
   for Ii1I , iiiiIi1IiiIi in configs . items ( ) :
    if Ii1I in [ "shuffle" , "batchSize" ] :
     setattr ( self , "_" + Ii1I , iiiiIi1IiiIi )
     if 8 - 8: I11iiIi11i1I * Ooo0Ooo + oOO - i1iiIII111 + Iii1i + ooOOO
  def copy ( self ) -> 'DatasetGenerator.Detail' :
   if 68 - 68: ooo000 / I1I - IiI11Ii111 % iI1iII1I1I1i % IiIIii11Ii
   if 84 - 84: oOo0O00 / Ii . i1iiIII111 % ooo000
   if 93 - 93: OooOoo * oOO % I1I + I11iiIi11i1I . oOo0O00 % I11iiIi11i1I
   if 44 - 44: Iii1i / oOO . ooOOO % oOo0O00 / Ooo0Ooo * I11iiIi11i1I
   if 15 - 15: IiIIii11Ii . I11iiIi11i1I + Oo + Oo . oOo0O00 - i1I
   if 95 - 95: iI1iII1I1I1i
   if 44 - 44: i1I * i1I
   if 92 - 92: oOO * i1 % oOo0O00 + i1I + OooOoo * ooo000
   if 67 - 67: Oo / I11iiIi11i1I + I1I % iI1iII1I1I1i + OooOoo . Ooo0Ooo
   if 53 - 53: i1i1i1111I
   pass
   if 8 - 8: IIiIIiIi11I1 / iI1iII1I1I1i / IiIIii11Ii . I11iiIi11i1I
  @ property
  def initialized ( self ) -> bool :
   if 52 - 52: I11iiIi11i1I % ooOOO - IIiIIiIi11I1 % Ooo0Ooo * iI1iII1I1I1i
   if 89 - 89: Ooo0Ooo * OooOoo / OooOoo % IIiIIiIi11I1
   if 92 - 92: I11iiIi11i1I / Oo % I1I * iI1iII1I1I1i
   if 61 - 61: I1Ii1I1
   if 72 - 72: IiI11Ii111 . Oo - Oo
   if 48 - 48: Ii + OooOoo % IiIIii11Ii . IiIIii11Ii + oOo0O00
   if 38 - 38: OooOoo . i1I / Ii - oOo0O00
   if 37 - 37: IIiIIiIi11I1 / Iii1i
   if 16 - 16: i1i1i1111I + Ooo0Ooo . i1I - i1I + iI1iII1I1I1i
   if 44 - 44: IiI11Ii111 - OooOoo / iI1iII1I1I1i % iI1iII1I1I1i
   return self . _initialized
   if 86 - 86: i1iiIII111 / IiI11Ii111 . IiI11Ii111 * Ooo0Ooo
  @ property
  def epochSize ( self ) -> int :
   if 50 - 50: i1iiIII111 - oOO
   if 6 - 6: ooOOO - i1i1i1111I * Iii1i / oOo0O00 % Oo % oOO
   if 11 - 11: oOO % i1I
   if 97 - 97: i1I
   if 67 - 67: I11iiIi11i1I - Iii1i
   if 16 - 16: I1Ii1I1 % ooOOO . i1 / i1I * i1i1i1111I - oOO
   if 78 - 78: i1I - IIiIIiIi11I1 . Iii1i
   if 44 - 44: Ooo0Ooo / I11iiIi11i1I . ooo000 + ooOOO
   if 12 - 12: Oo
   if 70 - 70: OooOoo + I1Ii1I1
   return self . _epochSize
   if 33 - 33: OooOoo
  @ property
  def oriShape ( self ) -> List [ int ] :
   if 40 - 40: I1Ii1I1 * IiI11Ii111 . I1Ii1I1 + Iii1i
   if 92 - 92: oOo0O00
   if 50 - 50: i1iiIII111
   if 19 - 19: ooOOO + Oo - I1I . i1
   if 97 - 97: i1 % I11iiIi11i1I - ooo000 % ooOOO . Ii
   if 41 - 41: Ooo0Ooo % IIiIIiIi11I1 . Ooo0Ooo . i1
   if 3 - 3: i1I % Oo * i1
   if 98 - 98: OooOoo * i1I + iI1iII1I1I1i - I11iiIi11i1I . I1I
   if 19 - 19: I1Ii1I1 % oOO / Ooo0Ooo
   if 72 - 72: Iii1i . IiI11Ii111 - I1Ii1I1 + Iii1i
   return self . _oriShape
   if 8 - 8: IiI11Ii111 + ooo000 + I1I + i1I
  @ property
  def controller ( self ) -> 'Dataset.Controller' :
   if 66 - 66: I1Ii1I1 . oOO * i1I
   if 9 - 9: ooo000 . Oo * OooOoo
   if 93 - 93: Ooo0Ooo + IiI11Ii111 / i1iiIII111 % i1iiIII111 * ooOOO
   if 97 - 97: ooOOO - i1iiIII111 / I1I + IiI11Ii111 - Iii1i + OooOoo
   if 83 - 83: IiI11Ii111
   if 61 - 61: Iii1i
   if 87 - 87: oOO - IIiIIiIi11I1
   if 98 - 98: i1i1i1111I % i1i1i1111I * Iii1i % iI1iII1I1I1i
   if 87 - 87: IiIIii11Ii
   if 49 - 49: ooo000 + Iii1i / iI1iII1I1I1i . I1I + iI1iII1I1I1i
   return self . _controller
   if 2 - 2: Iii1i * ooOOO
  @ property
  def attachObject ( self ) -> Union [ 'Source.Config' , 'ModelNode.Config' ] :
   if 88 - 88: I1I + IiI11Ii111 . oOo0O00 * i1 * IIiIIiIi11I1 / IiIIii11Ii
   if 5 - 5: IiI11Ii111 - Iii1i / I1I
   if 82 - 82: ooOOO . I11iiIi11i1I % I1Ii1I1 - oOO
   if 25 - 25: i1I * IiI11Ii111 * I1Ii1I1 % i1I . i1i1i1111I / OooOoo
   if 34 - 34: I11iiIi11i1I / ooOOO * Iii1i / oOO * IiI11Ii111
   if 33 - 33: iI1iII1I1I1i % Ooo0Ooo . Ii * Ooo0Ooo + ooOOO - Oo
   if 88 - 88: IIiIIiIi11I1 - I11iiIi11i1I + i1 . ooOOO . Ooo0Ooo
   if 69 - 69: Iii1i + I1I - i1i1i1111I + i1I
   if 4 - 4: Ooo0Ooo / i1 . I1Ii1I1 / oOo0O00 + Oo . Iii1i
   if 62 - 62: i1I . i1iiIII111 * i1 + Oo
   return self . controller . attachObject
   if 61 - 61: Ii + i1iiIII111
  @ property
  def batchSize ( self ) -> int :
   if 67 - 67: IiI11Ii111 . IiI11Ii111
   if 57 - 57: iI1iII1I1I1i
   if 75 - 75: i1i1i1111I
   if 8 - 8: ooo000
   if 41 - 41: OooOoo . iI1iII1I1I1i . oOo0O00 . Ooo0Ooo % Oo . Ii
   if 72 - 72: oOo0O00
   if 49 - 49: IiI11Ii111 . i1 - IiI11Ii111 % Iii1i
   if 59 - 59: Ooo0Ooo - IiI11Ii111 % i1iiIII111 . Iii1i
   if 59 - 59: i1I + Oo / Iii1i . i1i1i1111I % i1I
   if 25 - 25: I11iiIi11i1I / IiIIii11Ii + IIiIIiIi11I1 - IiI11Ii111 * iI1iII1I1I1i
   return self . attachObject . batchSize if self . _batchSize is None else self . _batchSize
   if 24 - 24: Ii / Ii
  @ property
  def dropRemainder ( self ) -> bool :
   if 17 - 17: Ooo0Ooo % IiIIii11Ii % oOo0O00
   if 75 - 75: OooOoo / oOo0O00 - i1iiIII111 % IiIIii11Ii + Iii1i
   if 67 - 67: OooOoo * i1 . oOO % Ooo0Ooo . IiIIii11Ii
   if 26 - 26: I1I * i1i1i1111I
   if 44 - 44: IIiIIiIi11I1 * iI1iII1I1I1i
   if 77 - 77: i1I + i1iiIII111 % oOo0O00 % i1iiIII111 - Oo / iI1iII1I1I1i
   if 6 - 6: Iii1i / i1 * i1 * iI1iII1I1I1i
   if 80 - 80: IIiIIiIi11I1 / i1iiIII111
   if 95 - 95: ooo000 / Iii1i / Iii1i + i1i1i1111I
   if 46 - 46: oOO
   return self . controller . attachObject . train . currentBuildConfig . dropRemainder
   if 15 - 15: iI1iII1I1I1i + I1I
  @ property
  def batchCountPerEpoch ( self ) -> int :
   if 81 - 81: Ii + I1I . oOo0O00 / i1 / ooOOO
   if 93 - 93: oOO + i1
   if 23 - 23: I1Ii1I1 . ooOOO
   if 13 - 13: OooOoo
   if 49 - 49: i1iiIII111 . oOo0O00 / i1 - IiIIii11Ii + I1Ii1I1 * I11iiIi11i1I
   if 80 - 80: i1i1i1111I * OooOoo . I1I / I1I
   if 69 - 69: IiIIii11Ii * IiI11Ii111 + i1 - Ii
   if 98 - 98: I1I % oOo0O00 % i1iiIII111 / Ii / ooOOO
   if 17 - 17: IIiIIiIi11I1 % i1i1i1111I / IiI11Ii111 - I1Ii1I1 . I11iiIi11i1I
   if 50 - 50: IiIIii11Ii % I11iiIi11i1I - I1Ii1I1 - IiIIii11Ii + IIiIIiIi11I1 % IIiIIiIi11I1
   return max ( self . epochSize // self . batchSize , 1 ) if self . dropRemainder else max ( math . ceil ( self . epochSize / self . batchSize ) , 1 )
   if 61 - 61: ooo000 % i1I * Ii
  @ property
  def shuffle ( self ) -> bool :
   if 27 - 27: iI1iII1I1I1i / i1
   if 51 - 51: Ooo0Ooo + ooo000
   if 74 - 74: ooOOO + oOO
   if 11 - 11: oOo0O00 . iI1iII1I1I1i
   if 67 - 67: i1I / iI1iII1I1I1i . I11iiIi11i1I
   if 80 - 80: iI1iII1I1I1i - Ooo0Ooo - Ooo0Ooo
   if 48 - 48: ooOOO + Iii1i - iI1iII1I1I1i / i1
   if 34 - 34: IiIIii11Ii . oOo0O00 . I11iiIi11i1I % i1i1i1111I % i1 + Oo
   if 16 - 16: IiIIii11Ii
   if 5 - 5: i1iiIII111 / i1iiIII111 / oOo0O00 + ooOOO * I1I
   return self . attachObject . shuffle if self . _shuffle is None else self . _shuffle
   if 91 - 91: oOO / Iii1i + oOo0O00 + ooo000 + ooo000
  def __len__ ( self ) -> int :
   if 75 - 75: IIiIIiIi11I1 . I11iiIi11i1I * ooo000 / i1 / I1I * IIiIIiIi11I1
   if 30 - 30: oOO % iI1iII1I1I1i - i1i1i1111I + I1I + Ooo0Ooo
   if 99 - 99: I1I - iI1iII1I1I1i - Iii1i % OooOoo + OooOoo % oOo0O00
   if 95 - 95: IIiIIiIi11I1
   if 85 - 85: i1 + Ooo0Ooo - ooo000
   if 98 - 98: oOo0O00 % i1I + i1I . OooOoo . i1iiIII111 / i1I
   if 81 - 81: i1I % ooo000 - ooo000 / oOO . ooo000
   if 25 - 25: i1iiIII111 . iI1iII1I1I1i % oOo0O00 * i1i1i1111I
   if 22 - 22: oOO
   if 23 - 23: IiI11Ii111
   return self . _epochSize
   if 63 - 63: I1Ii1I1
  @ property
  def batchIdx ( self ) -> int :
   if 26 - 26: ooo000
   if 37 - 37: oOo0O00 / I11iiIi11i1I
   if 9 - 9: IiIIii11Ii . Iii1i % i1iiIII111 / Ooo0Ooo
   if 51 - 51: OooOoo . oOO
   if 54 - 54: i1i1i1111I * I1I - I1I / oOo0O00
   if 56 - 56: IIiIIiIi11I1 * IiI11Ii111 / oOo0O00 % I1I % iI1iII1I1I1i % ooOOO
   if 26 - 26: OooOoo
   if 58 - 58: ooo000
   if 78 - 78: i1iiIII111 % i1I
   if 63 - 63: i1I - i1i1i1111I . iI1iII1I1I1i + IiIIii11Ii
   return self . _itrIdx
   if 90 - 90: ooo000 + I1Ii1I1 % i1 - IiI11Ii111 / Ooo0Ooo * iI1iII1I1I1i
  def batchIdxIncrement ( self ) :
   if 50 - 50: i1I / ooo000 . Ii * I1Ii1I1 / oOO + oOo0O00
   if 86 - 86: I1I
   if 64 - 64: Oo % i1i1i1111I + I11iiIi11i1I . i1iiIII111
   if 53 - 53: ooOOO / I11iiIi11i1I / iI1iII1I1I1i . Iii1i
   if 10 - 10: iI1iII1I1I1i * i1iiIII111 - ooo000 * ooo000 / Iii1i . ooOOO
   if 15 - 15: i1iiIII111 / iI1iII1I1I1i * iI1iII1I1I1i - i1i1i1111I . i1 % iI1iII1I1I1i
   if 18 - 18: I1Ii1I1 + Iii1i / Oo % I1Ii1I1
   self . _itrIdx += 1
   if 38 - 38: oOO
  def batchIdxReset ( self ) :
   if 95 - 95: i1i1i1111I / Iii1i * ooOOO * OooOoo
   if 57 - 57: I1I / Ii * oOO
   if 28 - 28: Ii * I11iiIi11i1I * Oo * ooo000
   if 89 - 89: Ii - Iii1i % Ii
   if 99 - 99: i1 / i1 + i1i1i1111I / Iii1i
   if 54 - 54: Iii1i
   if 44 - 44: i1i1i1111I * i1
   self . _itrIdx = 0
   if 13 - 13: I1Ii1I1 / Ooo0Ooo . Oo % i1iiIII111 + I1I % IiI11Ii111
  def getLocations ( self ) -> List [ str ] :
   if 27 - 27: Ooo0Ooo - i1 . Oo / i1iiIII111 + I1Ii1I1
   if 2 - 2: i1iiIII111 * ooo000 . iI1iII1I1I1i / i1
   if 9 - 9: IiI11Ii111 + Ii + I1I . oOo0O00 - IIiIIiIi11I1 % Oo
   if 92 - 92: I1Ii1I1 % Oo + i1iiIII111 % ooo000 * OooOoo
   if 43 - 43: i1iiIII111 * IIiIIiIi11I1
   if 9 - 9: IiI11Ii111 . iI1iII1I1I1i % ooo000
   if 66 - 66: i1 * i1I % Iii1i * Iii1i / Oo % oOo0O00
   if 31 - 31: i1 - i1i1i1111I % OooOoo . IIiIIiIi11I1 + I1I + OooOoo
   if 49 - 49: Ii * i1
   if 93 - 93: i1iiIII111 - ooOOO / Ii + Ooo0Ooo % oOo0O00
   return [ ]
   if 97 - 97: i1
  def initialize ( self ) :
   if 94 - 94: i1 + oOO / Ii
   if 86 - 86: i1 * IiI11Ii111
   if 49 - 49: I1Ii1I1 + Iii1i - IIiIIiIi11I1 . I1I . Ii
   if 82 - 82: OooOoo / i1i1i1111I
   if 23 - 23: I1I % I11iiIi11i1I / Ooo0Ooo . iI1iII1I1I1i * oOo0O00
   if 22 - 22: i1 / I1Ii1I1 - i1 % oOo0O00 + iI1iII1I1I1i % I1I
   if 35 - 35: IiIIii11Ii . ooo000 - IIiIIiIi11I1 / iI1iII1I1I1i
   self . _initialized = True
   if 55 - 55: Ooo0Ooo % IIiIIiIi11I1 / ooo000 . i1i1i1111I - oOo0O00
  def prepareIteration ( self ) :
   if 77 - 77: oOO / I1Ii1I1 * ooo000 + oOo0O00 - iI1iII1I1I1i
   if 37 - 37: IiI11Ii111 % i1i1i1111I - OooOoo + IIiIIiIi11I1
   if 26 - 26: Iii1i / Iii1i
   if 65 - 65: IiIIii11Ii * ooo000 - ooo000 - IiIIii11Ii * IIiIIiIi11I1 - oOo0O00
   if 83 - 83: Ooo0Ooo . Oo . i1I - I1I / Ooo0Ooo
   if 33 - 33: I11iiIi11i1I + IIiIIiIi11I1 * IiIIii11Ii * Ii * ooo000 * Ooo0Ooo
   if 95 - 95: IIiIIiIi11I1 / Ii
   pass
   if 47 - 47: Iii1i * OooOoo * IiI11Ii111 + OooOoo - i1 + IiI11Ii111
  def getNextBatch ( self ) -> Any :
   if 75 - 75: Iii1i / i1i1i1111I . ooo000 * i1I - I11iiIi11i1I . I1I
   if 55 - 55: ooOOO - oOo0O00
   if 65 - 65: ooo000 * oOo0O00 % Ooo0Ooo * i1i1i1111I * Oo
   if 82 - 82: OooOoo + I1I + ooo000 * oOo0O00 * Iii1i
   if 22 - 22: Oo . Ooo0Ooo . Ooo0Ooo % oOo0O00
   if 94 - 94: I1Ii1I1 / I1Ii1I1 + OooOoo * I1I
   if 63 - 63: Oo % iI1iII1I1I1i
   if 73 - 73: I1I / Ii
   if 96 - 96: ooOOO / Ooo0Ooo
   if 57 - 57: Oo % I1Ii1I1 * oOo0O00 . ooo000 . ooOOO . i1i1i1111I
   pass
   if 44 - 44: i1I
  def __next__ ( self ) -> Any :
   if 31 - 31: Oo - Ii . Iii1i + i1I
   if 6 - 6: I1I
   if 67 - 67: ooo000
   if 78 - 78: IIiIIiIi11I1 + i1iiIII111 - Ooo0Ooo % IiIIii11Ii + i1iiIII111
   if 41 - 41: ooo000 + ooo000
   if 79 - 79: IiIIii11Ii
   if 43 - 43: Iii1i
   if 59 - 59: OooOoo - IiI11Ii111 . I11iiIi11i1I . i1 + iI1iII1I1I1i + IiI11Ii111
   if 88 - 88: I11iiIi11i1I - I1I - i1iiIII111 . IiIIii11Ii . i1iiIII111 . iI1iII1I1I1i
   if 30 - 30: ooo000 - IiI11Ii111 * IiIIii11Ii . IIiIIiIi11I1 - Oo
   return self . getNextBatch ( )
   if 94 - 94: IiI11Ii111 + OooOoo / i1I % I11iiIi11i1I
  def close ( self ) :
   if 5 - 5: i1i1i1111I - oOo0O00
   if 87 - 87: I1Ii1I1 - Oo - oOO - i1 / I1I
   if 22 - 22: i1i1i1111I * Ooo0Ooo . Iii1i * i1iiIII111 / ooOOO - i1
   if 93 - 93: IIiIIiIi11I1 * Oo * OooOoo
   if 69 - 69: IIiIIiIi11I1 * i1iiIII111 . i1I / i1i1i1111I % i1iiIII111 * ooo000
   if 92 - 92: ooo000 * oOO * i1 - ooOOO / oOo0O00 . i1i1i1111I
   if 15 - 15: i1iiIII111
   self . _initialized = False
   if 95 - 95: Oo / IiIIii11Ii % i1iiIII111 / i1I - Iii1i
  def getData ( self , start : int = None , end : int = None , indexes : List [ int ] = None ) -> Any :
   if 40 - 40: i1I
   if 69 - 69: Ooo0Ooo - i1iiIII111
   if 99 - 99: OooOoo * IiI11Ii111 % i1I
   if 29 - 29: ooo000
   if 2 - 2: i1iiIII111 - oOo0O00 / IIiIIiIi11I1 / iI1iII1I1I1i * OooOoo
   if 77 - 77: Ii / i1iiIII111 % oOo0O00
   if 65 - 65: ooOOO . i1I * I1I - oOo0O00 - ooo000 * Ii
   if 43 - 43: I1I * i1
   if 90 - 90: I1Ii1I1 . ooo000 - I1Ii1I1 + oOO . i1iiIII111 - Ooo0Ooo
   if 87 - 87: ooo000 + i1i1i1111I - oOo0O00 % oOo0O00
   if 90 - 90: oOO * ooo000
   if 13 - 13: i1I + Ii
   if 91 - 91: I1Ii1I1 - OooOoo % iI1iII1I1I1i
   if 90 - 90: OooOoo + I1I / I1I * Iii1i
   if 47 - 47: Oo % OooOoo * Ooo0Ooo - I1Ii1I1 * Oo . IiIIii11Ii
   pass
   if 61 - 61: Oo . I11iiIi11i1I
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> Any :
   if 84 - 84: Ooo0Ooo % ooo000 / i1
   if 5 - 5: i1
   if 51 - 51: IiI11Ii111 + ooo000 / i1i1i1111I * iI1iII1I1I1i
   if 84 - 84: iI1iII1I1I1i + Iii1i + Oo . i1i1i1111I
   if 16 - 16: I11iiIi11i1I * Iii1i / i1I % i1I
   if 62 - 62: Oo * I1Ii1I1 % ooo000
   if 62 - 62: Ooo0Ooo * i1I + Oo / i1i1i1111I + oOO * I1Ii1I1
   if 52 - 52: ooo000 . oOO % IIiIIiIi11I1 % I11iiIi11i1I . oOO % Oo
   if 97 - 97: Oo * I1Ii1I1
   if 77 - 77: Iii1i / iI1iII1I1I1i % Oo + OooOoo . I1I % I1Ii1I1
   if 12 - 12: Ii + Oo . oOo0O00 % oOO + I1Ii1I1
   if 55 - 55: i1 . Ii + oOo0O00 % oOO * OooOoo - i1I
   if 63 - 63: I11iiIi11i1I + IiI11Ii111 + I11iiIi11i1I % Oo / Ii * i1
   if 5 - 5: oOo0O00 / I1I
   pass
   if 18 - 18: I1I % IiIIii11Ii % OooOoo + IiI11Ii111 * Ooo0Ooo
  def partition ( self , assignTo : 'DataGenerator.Dataset.Types' , prop : float = 0.2 , shuffle : float = False ) :
   if 10 - 10: ooOOO + I1Ii1I1 - iI1iII1I1I1i - ooOOO . Ooo0Ooo
   if 89 - 89: I1I % i1i1i1111I
   if 81 - 81: I1I + IiIIii11Ii * I11iiIi11i1I % I1Ii1I1 % OooOoo - i1iiIII111
   if 56 - 56: IiI11Ii111 . i1i1i1111I / Oo + oOO
   if 15 - 15: Ooo0Ooo % i1iiIII111 . i1i1i1111I * i1iiIII111 + OooOoo + i1
   if 36 - 36: Oo
   if 49 - 49: Oo - Oo
   if 23 - 23: oOo0O00 * IIiIIiIi11I1 % I11iiIi11i1I . i1I + oOo0O00
   if 71 - 71: Oo % I1Ii1I1 . i1iiIII111
   if 97 - 97: IiIIii11Ii / oOO * IiI11Ii111 % ooo000
   if 62 - 62: ooOOO / I11iiIi11i1I . OooOoo * OooOoo * OooOoo
   if 49 - 49: ooOOO * IiIIii11Ii . i1 * IiI11Ii111 * Ooo0Ooo
   pass
   if 91 - 91: iI1iII1I1I1i / iI1iII1I1I1i + oOo0O00 % ooOOO
 class Controller :
  if 55 - 55: i1 * i1i1i1111I + Ooo0Ooo + i1i1i1111I + i1i1i1111I
  if 10 - 10: i1i1i1111I / i1I / i1i1i1111I . oOo0O00 * IIiIIiIi11I1 % Iii1i
  if 55 - 55: OooOoo % IIiIIiIi11I1 - oOO % Oo * Iii1i - IiI11Ii111
  if 25 - 25: Ooo0Ooo . oOO * IiIIii11Ii * I11iiIi11i1I / IiI11Ii111 * Ii
  if 78 - 78: I11iiIi11i1I / I1Ii1I1 / IiIIii11Ii . OooOoo
  if 66 - 66: Ooo0Ooo . ooo000 - I1Ii1I1
  if 48 - 48: i1iiIII111
  def __init__ ( self , attachObject : Union [ 'Source.Config' , 'DataPreprocessing.Node.SourceLike' ] = None ) :
   if 87 - 87: Oo % oOo0O00
   if 39 - 39: ooOOO + Iii1i / i1I * ooo000
   if 28 - 28: I11iiIi11i1I * iI1iII1I1I1i . IiI11Ii111
   if 63 - 63: IiIIii11Ii
   if 1 - 1: i1iiIII111 - IiIIii11Ii + Iii1i . I1Ii1I1 + ooo000
   if 46 - 46: Oo
   if 56 - 56: i1i1i1111I / I11iiIi11i1I % Ooo0Ooo / Oo
   if 63 - 63: OooOoo
   if 99 - 99: i1 + ooo000 - oOo0O00 + Ooo0Ooo + oOO / ooOOO
   if 14 - 14: iI1iII1I1I1i * OooOoo / Ooo0Ooo + Iii1i
   if 46 - 46: Oo / oOo0O00 / OooOoo . Ooo0Ooo - i1iiIII111 * Ii
   self . _datasets = { }
   if 21 - 21: IIiIIiIi11I1 / ooOOO * Ooo0Ooo . oOO - OooOoo - i1iiIII111
   if 97 - 97: ooo000 % Oo / Iii1i . OooOoo
   self . validationTime = 0
   if 20 - 20: Iii1i % i1 * Ii
   if 87 - 87: IiI11Ii111 - Iii1i * Ooo0Ooo
   self . _attachObject = attachObject
   if 62 - 62: IIiIIiIi11I1 + Ooo0Ooo . i1
   if 80 - 80: I11iiIi11i1I * I1Ii1I1
   for II1 in I111II1II111I . Dataset . Types :
    self . _datasets [ II1 ] = self . detailType ( self )
    if 32 - 32: I1I - Oo - I11iiIi11i1I * I1Ii1I1 % i1I / OooOoo
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 30 - 30: OooOoo
   if 52 - 52: ooOOO
   if 25 - 25: Iii1i - IiI11Ii111
   if 26 - 26: Ii
   if 49 - 49: oOo0O00 % i1 * i1iiIII111 / Ooo0Ooo
   if 62 - 62: I11iiIi11i1I
   if 55 - 55: oOo0O00 . ooOOO . ooOOO + Ooo0Ooo + i1iiIII111 / Ii
   if 24 - 24: Iii1i
   if 7 - 7: i1iiIII111 * oOo0O00 / ooOOO - Oo % I1Ii1I1 - ooOOO
   if 63 - 63: oOo0O00 + Oo . Iii1i
   for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
    if 88 - 88: i1iiIII111 / IiIIii11Ii + i1I * IiI11Ii111 % IiIIii11Ii
    if Ii1I == "_datasets" :
     for I1Iii , i1iIii11II1Ii11 in iiiiIi1IiiIi . items ( ) :
      iiI1 = I111II1II111I . Dataset . Types . parse ( I1Iii )
      if iiI1 not in self :
       self [ iiI1 ] = self [ I111II1II111I . Dataset . Types . Train ] . copy ( )
      self [ iiI1 ] . parseFromJSON ( i1iIii11II1Ii11 )
      if 92 - 92: IiIIii11Ii % iI1iII1I1I1i + Oo
      if 56 - 56: IIiIIiIi11I1
    elif Ii1I not in [ "_attachObject" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 54 - 54: Iii1i % IiI11Ii111 / OooOoo + Ii + i1I
  @ property
  def attachObject ( self ) -> Union [ 'Source.Config' , 'DataPreprocessing.Node.SourceLike' ] :
   if 8 - 8: ooo000 / oOO - i1i1i1111I % iI1iII1I1I1i / ooo000 % oOO
   if 100 - 100: IiI11Ii111 - I1I + Iii1i / I1Ii1I1
   if 74 - 74: Iii1i % I11iiIi11i1I
   if 59 - 59: I11iiIi11i1I * oOo0O00 + oOo0O00 / ooOOO * oOO
   if 16 - 16: Ii / oOO
   if 31 - 31: OooOoo . OooOoo + ooOOO
   if 7 - 7: I1I / Oo % IiIIii11Ii . IiI11Ii111 * i1iiIII111 + i1i1i1111I
   if 91 - 91: OooOoo + IiI11Ii111 - i1iiIII111 + Iii1i . IiIIii11Ii
   if 29 - 29: I1Ii1I1 + Iii1i + i1I % ooo000 . ooOOO * IiI11Ii111
   if 71 - 71: i1 - i1iiIII111
   return self . _attachObject
   if 35 - 35: ooo000 % OooOoo
  @ property
  def detailType ( self ) -> Callable [ ... , 'DataGenerator.Detail' ] :
   if 58 - 58: Ooo0Ooo * IiIIii11Ii
   if 19 - 19: IIiIIiIi11I1 . iI1iII1I1I1i / I1Ii1I1 / I1I
   if 73 - 73: I1Ii1I1 * oOo0O00 * oOo0O00 . I1Ii1I1
   if 23 - 23: IiI11Ii111 * i1i1i1111I / i1i1i1111I / Ooo0Ooo
   if 32 - 32: ooo000 * I11iiIi11i1I . Iii1i / IiI11Ii111
   if 13 - 13: Iii1i - Iii1i . Ii * OooOoo
   if 32 - 32: ooOOO
   if 19 - 19: Iii1i % Oo . i1iiIII111 % i1i1i1111I * OooOoo / IIiIIiIi11I1
   if 98 - 98: I1Ii1I1 - i1iiIII111 + OooOoo - Ii / oOO
   if 89 - 89: oOO * Iii1i . Ii
   return I111II1II111I . Detail
   if 14 - 14: Oo + Ooo0Ooo % Iii1i / Iii1i / i1
  def getLocations ( self ) -> List [ str ] :
   if 55 - 55: IiIIii11Ii / oOo0O00 * ooo000 / Oo
   if 63 - 63: i1 . Oo
   if 37 - 37: IiI11Ii111 . Oo + IiIIii11Ii
   if 11 - 11: IiI11Ii111
   if 20 - 20: I11iiIi11i1I - i1iiIII111
   if 77 - 77: Ooo0Ooo * OooOoo
   if 86 - 86: IiI11Ii111 + IiIIii11Ii + ooOOO . IiIIii11Ii - i1i1i1111I + Iii1i
   if 20 - 20: i1iiIII111 / ooo000 / IIiIIiIi11I1 - Oo . Ooo0Ooo % ooOOO
   if 19 - 19: i1iiIII111
   if 17 - 17: IiIIii11Ii - i1iiIII111
   return sum ( [ detail . getLocations ( ) for detail in self ] , [ ] )
   if 64 - 64: Ooo0Ooo - i1iiIII111 % i1 / ooo000
  def __getitem__ ( self , datasetType : 'DataGenerator.Dataset.Types' ) -> 'DataGenerator.Detail' :
   if 54 - 54: oOO - IIiIIiIi11I1 % oOO % ooo000 / i1i1i1111I
   if 75 - 75: I11iiIi11i1I - i1 % i1i1i1111I * IiIIii11Ii / I1I . Iii1i
   if 47 - 47: OooOoo - Ii . IiIIii11Ii + oOo0O00 / iI1iII1I1I1i
   if 19 - 19: i1 - i1 / OooOoo . OooOoo . ooo000
   if 94 - 94: Ooo0Ooo
   if 48 - 48: Oo
   if 85 - 85: IIiIIiIi11I1 . I1Ii1I1 % OooOoo . OooOoo + i1i1i1111I
   if 32 - 32: Iii1i
   if 73 - 73: I1Ii1I1 / OooOoo - I11iiIi11i1I * oOo0O00
   if 61 - 61: i1iiIII111 * Iii1i - Oo + OooOoo
   if 8 - 8: IiI11Ii111 . I11iiIi11i1I / Iii1i / Ooo0Ooo - iI1iII1I1I1i * oOO
   if 92 - 92: I11iiIi11i1I % i1 + Ooo0Ooo
   if 21 - 21: I11iiIi11i1I . OooOoo - I1I
   return self . _datasets [ datasetType ]
   if 52 - 52: i1 . I1Ii1I1 - oOO * i1i1i1111I % iI1iII1I1I1i
  def __setitem__ ( self , datasetType : 'DataGenerator.Dataset.Types' , detail : 'DataGenerator.Detail' ) :
   if 62 - 62: ooo000 * I1Ii1I1 - Ii
   if 48 - 48: I1I - Oo + i1i1i1111I . IiI11Ii111 + Iii1i + i1
   if 37 - 37: Oo % i1i1i1111I
   if 28 - 28: oOo0O00 . oOO / Ii / ooOOO / i1i1i1111I
   if 73 - 73: i1I . Ii - i1iiIII111 . oOo0O00 . Iii1i
   if 46 - 46: I11iiIi11i1I - i1iiIII111 / ooo000
   if 93 - 93: Oo / Ooo0Ooo + I11iiIi11i1I
   if 13 - 13: Iii1i / ooo000 % i1I - oOo0O00 . I1Ii1I1
   if 20 - 20: i1i1i1111I - i1i1i1111I * i1 * OooOoo / I1Ii1I1 * I11iiIi11i1I
   if 67 - 67: I11iiIi11i1I % iI1iII1I1I1i + i1iiIII111 / IiIIii11Ii + Ooo0Ooo % Ii
   if 92 - 92: i1 - IiI11Ii111 / i1i1i1111I % i1I / IIiIIiIi11I1 * Oo
   self . _datasets [ datasetType ] = detail
   if 2 - 2: oOO + i1i1i1111I
  def __iter__ ( self ) -> Iterable [ str ] :
   if 64 - 64: iI1iII1I1I1i
   if 41 - 41: I1Ii1I1 + i1i1i1111I
   if 36 - 36: IiIIii11Ii + i1i1i1111I . iI1iII1I1I1i / IIiIIiIi11I1 + ooOOO
   if 98 - 98: OooOoo * i1I . Ii - IiIIii11Ii
   if 37 - 37: IiI11Ii111 - OooOoo * IiIIii11Ii - I11iiIi11i1I
   if 80 - 80: i1i1i1111I + Ooo0Ooo * I11iiIi11i1I
   if 58 - 58: Ii * Ii % i1
   if 90 - 90: OooOoo . oOo0O00 . I1Ii1I1 - ooo000 % i1i1i1111I
   if 29 - 29: i1i1i1111I - iI1iII1I1I1i + oOO - iI1iII1I1I1i
   if 14 - 14: I1Ii1I1
   return self . _datasets . __iter__ ( )
   if 94 - 94: ooo000
  def __values__ ( self ) -> Iterable [ 'DataGenerator.Detail' ] :
   if 99 - 99: ooo000 / i1i1i1111I + i1iiIII111 + IiI11Ii111
   if 63 - 63: IIiIIiIi11I1 * Oo
   if 36 - 36: oOO . IIiIIiIi11I1 / I1I / i1iiIII111
   if 73 - 73: IiI11Ii111
   if 100 - 100: IiIIii11Ii . IIiIIiIi11I1 - Ii / I1I
   if 3 - 3: ooOOO - I1Ii1I1 + OooOoo . ooOOO . i1i1i1111I - oOo0O00
   if 92 - 92: I11iiIi11i1I - ooOOO / Ii / i1i1i1111I
   if 55 - 55: I1Ii1I1 + IiIIii11Ii / Ooo0Ooo
   if 62 - 62: I1Ii1I1 % Ooo0Ooo * i1I + ooo000
   if 2 - 2: I1I % i1I . OooOoo % i1iiIII111 + Iii1i
   return self . _datasets . values ( )
   if 20 - 20: IIiIIiIi11I1 / Oo + Ooo0Ooo * ooOOO
  def values ( self ) -> Iterable [ 'DataGenerator.Details' ] :
   if 67 - 67: iI1iII1I1I1i . iI1iII1I1I1i / i1I * Ii . I1I / Ooo0Ooo
   if 90 - 90: IiI11Ii111 / I1I - I1I + i1I / Iii1i
   if 48 - 48: oOo0O00 . I11iiIi11i1I + Oo
   if 90 - 90: iI1iII1I1I1i * Ooo0Ooo - IiIIii11Ii + oOO
   if 55 - 55: Oo + iI1iII1I1I1i / IiIIii11Ii - oOO / IiI11Ii111
   if 21 - 21: ooo000 - Ooo0Ooo + oOo0O00 * IiI11Ii111 * Oo
   if 12 - 12: i1i1i1111I
   if 84 - 84: IiI11Ii111
   if 53 - 53: IIiIIiIi11I1
   if 96 - 96: Oo % iI1iII1I1I1i * i1I % oOo0O00 . Ooo0Ooo
   return self . _datasets . values ( )
   if 28 - 28: oOO - ooo000
  def keys ( self ) -> Iterable [ 'DataGenerator.Dataset.Type' ] :
   if 15 - 15: Oo - IiIIii11Ii
   if 60 - 60: ooo000 * IiIIii11Ii . I11iiIi11i1I / oOo0O00
   if 35 - 35: oOo0O00 + i1 - Ooo0Ooo . Iii1i . OooOoo . IiIIii11Ii
   if 67 - 67: i1iiIII111 % I1Ii1I1 + Ooo0Ooo % oOO / I1I - IiI11Ii111
   if 83 - 83: i1I . OooOoo - ooo000 * I1Ii1I1
   if 52 - 52: I1Ii1I1 % i1 - Oo
   if 91 - 91: Oo % i1I
   if 51 - 51: oOO + i1iiIII111 / i1i1i1111I / Iii1i . Iii1i - i1I
   if 20 - 20: IiI11Ii111
   if 91 - 91: i1I . Iii1i - OooOoo * IiIIii11Ii - I1Ii1I1
   return self . _datasets . keys ( )
   if 31 - 31: oOo0O00 / oOO / ooo000 / Ii + i1i1i1111I + OooOoo
  def initialize ( self , datasetType : 'DataGenerator.Dataset.Types' ) :
   if 81 - 81: i1I
   if 14 - 14: iI1iII1I1I1i
   if 77 - 77: Oo
   if 19 - 19: I1Ii1I1 + i1i1i1111I . IIiIIiIi11I1
   if 47 - 47: Oo - IIiIIiIi11I1
   if 3 - 3: IIiIIiIi11I1 . i1i1i1111I * Ooo0Ooo / ooo000
   if 41 - 41: I1Ii1I1 - oOo0O00 / I1Ii1I1 . i1I * IiI11Ii111 * Ii
   if 16 - 16: IIiIIiIi11I1 + IiI11Ii111 % oOO
   if 1 - 1: ooOOO % Oo
   if 25 - 25: oOO . I11iiIi11i1I . OooOoo % IiIIii11Ii / Oo
   self [ datasetType ] . initialize ( )
   if 28 - 28: i1iiIII111
  def getNextBatch ( self , datasetType : 'DataGenerator.Dataset.Types' ) -> 'np.ndarray' :
   if 18 - 18: OooOoo . ooOOO
   if 36 - 36: i1i1i1111I / oOO + oOo0O00 * iI1iII1I1I1i
   if 96 - 96: I11iiIi11i1I - I1I - I1Ii1I1 + I1I
   if 88 - 88: ooo000 + i1I . oOo0O00 % I1I / IIiIIiIi11I1 * Ooo0Ooo
   if 58 - 58: ooOOO % IiI11Ii111 + IiI11Ii111 . ooo000
   if 55 - 55: IiIIii11Ii % IiIIii11Ii
   if 81 - 81: iI1iII1I1I1i
   if 22 - 22: I11iiIi11i1I
   if 33 - 33: oOo0O00 - I11iiIi11i1I % ooo000 + Oo . I1Ii1I1
   if 42 - 42: IiIIii11Ii / i1i1i1111I / IiIIii11Ii / IiIIii11Ii
   if 19 - 19: Iii1i . Iii1i + i1iiIII111
   if 28 - 28: i1iiIII111 % oOO / ooo000 . oOo0O00
   if 78 - 78: I1I % Oo
   return self [ datasetType ] . getNextBatch ( )
   if 72 - 72: IiI11Ii111 * i1i1i1111I * i1I
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 83 - 83: Ooo0Ooo * i1iiIII111 + I1I / Ii
   if 64 - 64: ooOOO . Oo - iI1iII1I1I1i . I1Ii1I1
   if 77 - 77: ooo000 % i1I / Iii1i
   if 37 - 37: i1I
   if 1 - 1: OooOoo + Ii - I11iiIi11i1I % Ii
   if 44 - 44: i1i1i1111I . Oo - oOo0O00 - i1iiIII111 + ooo000 + i1i1i1111I
   if 72 - 72: IiI11Ii111 - ooo000 . oOo0O00
   if 90 - 90: Oo - IiI11Ii111 + Iii1i . i1
   if 7 - 7: OooOoo
   if 14 - 14: Ooo0Ooo * I1Ii1I1 / i1i1i1111I
   if 25 - 25: oOO + Ii . Ii + Ii . i1i1i1111I + ooOOO
   pass
   if 43 - 43: ooo000 % I1Ii1I1 + i1I / Oo - i1iiIII111 / OooOoo
  def splitTestDataset ( self , test : float = 0.2 , shuffle : float = False ) :
   if 97 - 97: iI1iII1I1I1i - Oo * I11iiIi11i1I % i1I / IIiIIiIi11I1
   if 85 - 85: i1iiIII111 + IIiIIiIi11I1 * i1i1i1111I / ooOOO
   if 99 - 99: i1i1i1111I * oOO + i1
   if 85 - 85: I1I * i1i1i1111I * IIiIIiIi11I1 . I1I . I1I . iI1iII1I1I1i
   if 50 - 50: Oo - i1iiIII111
   if 27 - 27: I11iiIi11i1I % oOo0O00 + iI1iII1I1I1i * OooOoo * I11iiIi11i1I
   if 14 - 14: IiIIii11Ii / ooo000
   if 58 - 58: I1I % I1I - ooOOO . I1Ii1I1 - oOo0O00
   if 74 - 74: OooOoo . Oo - Oo * Iii1i / I1Ii1I1 - ooOOO
   if 4 - 4: I11iiIi11i1I * IiIIii11Ii - Oo + oOO
   if 11 - 11: I1I - ooo000 / I11iiIi11i1I
   pass
   if 56 - 56: Ii + ooOOO - Oo + ooo000 . Ooo0Ooo
  def close ( self , datasetType : 'DataGenerator.Dataset.Types' ) :
   if 25 - 25: ooo000 / IiI11Ii111 / ooOOO
   if 68 - 68: I11iiIi11i1I - Oo - Ii * i1 * Oo
   if 29 - 29: Ii
   if 5 - 5: i1 + oOO . ooOOO . IiI11Ii111 / ooo000
   if 51 - 51: i1 . ooOOO * I1I - I1Ii1I1
   if 27 - 27: oOo0O00 * IiI11Ii111 * oOo0O00
   if 94 - 94: Oo
   if 24 - 24: IiI11Ii111 * oOo0O00 - i1 * i1iiIII111 / i1i1i1111I
   if 22 - 22: iI1iII1I1I1i + OooOoo
   if 2 - 2: Ooo0Ooo - Iii1i + ooOOO / I1Ii1I1 . Iii1i * IiI11Ii111
   self [ datasetType ] . close ( )
   if 46 - 46: Iii1i % i1 - Oo - Ii
class I11ii ( Oo0ooo0OO0 ) :
 if 100 - 100: Oo
 if 39 - 39: iI1iII1I1I1i + IiIIii11Ii - ooOOO % IIiIIiIi11I1 * IiIIii11Ii + iI1iII1I1I1i
 if 2 - 2: i1iiIII111 + IiI11Ii111 % IIiIIiIi11I1
 if 15 - 15: I11iiIi11i1I * Iii1i * OooOoo
 if 53 - 53: OooOoo * IiIIii11Ii
 if 64 - 64: i1
 if 74 - 74: Ooo0Ooo * I1I + i1i1i1111I * ooo000 / Oo * ooOOO
 class StepEnum ( I1i1i ) :
  if 81 - 81: iI1iII1I1I1i % I1Ii1I1 % IiIIii11Ii + ooo000 + Ooo0Ooo % ooOOO
  if 40 - 40: i1I . I11iiIi11i1I
  if 90 - 90: Oo % iI1iII1I1I1i - i1I
  if 45 - 45: Iii1i . OooOoo - iI1iII1I1I1i
  if 88 - 88: oOo0O00 % IiI11Ii111
  if 72 - 72: oOo0O00 / oOo0O00 - oOo0O00 . iI1iII1I1I1i . I1I . oOo0O00
  if 76 - 76: Ii
  if 63 - 63: Ooo0Ooo . Iii1i + Ii
  CircularDataDefined = 2
  if 33 - 33: oOo0O00 + I11iiIi11i1I
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 86 - 86: i1i1i1111I / ooOOO * I1I / i1I - i1i1i1111I
  if 38 - 38: IIiIIiIi11I1 . IiIIii11Ii
  if 32 - 32: ooo000 * ooo000 - ooOOO . IiI11Ii111 + I1Ii1I1 + i1I
  if 56 - 56: i1I + I1I / OooOoo + oOO - oOo0O00 / oOo0O00
  if 11 - 11: iI1iII1I1I1i % I1Ii1I1 % ooo000
  if 56 - 56: OooOoo
  if 68 - 68: i1iiIII111 * IiIIii11Ii % IiIIii11Ii - Ooo0Ooo
  def __init__ ( self , controller : 'DataPreprocessing.Node.BERT.GeneratorController' ) :
   if 60 - 60: iI1iII1I1I1i - oOO . Ooo0Ooo . i1i1i1111I
   if 97 - 97: oOo0O00 % i1
   if 75 - 75: OooOoo + oOO % oOo0O00 % ooo000 . OooOoo
   if 52 - 52: iI1iII1I1I1i . iI1iII1I1I1i % i1i1i1111I . ooOOO . Oo * i1iiIII111
   if 77 - 77: oOo0O00
   if 73 - 73: i1iiIII111 * Oo . i1I * I11iiIi11i1I
   if 95 - 95: I1I . OooOoo % IIiIIiIi11I1 % i1 / OooOoo * oOo0O00
   if 81 - 81: Iii1i * IiI11Ii111 - I1I
   if 15 - 15: Iii1i
   if 20 - 20: I11iiIi11i1I . i1 . Oo / Iii1i - I11iiIi11i1I
   super ( ) . __init__ ( controller )
   if 57 - 57: Oo . ooo000 + I1Ii1I1 - i1
   if 70 - 70: iI1iII1I1I1i % IiI11Ii111 * Oo
   self . _referenceIndexes : List [ int ] = [ ]
   if 56 - 56: Iii1i * I1Ii1I1
   if 19 - 19: i1 * I11iiIi11i1I / oOO * IIiIIiIi11I1 / oOo0O00 - oOo0O00
   self . _cacheInput : List [ Any ] = [ ]
   if 86 - 86: i1I
  @ property
  def epochSize ( self ) -> int :
   if 64 - 64: ooOOO * ooo000 - Oo
   if 60 - 60: OooOoo - oOo0O00 . Oo - i1I
   if 50 - 50: i1I
   if 39 - 39: IiI11Ii111
   if 57 - 57: IiIIii11Ii
   if 18 - 18: iI1iII1I1I1i * Iii1i + IiIIii11Ii / I11iiIi11i1I
   if 65 - 65: I11iiIi11i1I + ooo000
   if 66 - 66: I1Ii1I1
   if 84 - 84: i1I + i1iiIII111
   if 59 - 59: ooOOO / oOo0O00 * i1i1i1111I - IIiIIiIi11I1 * IIiIIiIi11I1 - IiI11Ii111
   return ( len ( self . _referenceIndexes ) if len ( self . _referenceIndexes ) else None ) if self . _epochSize is None else self . _epochSize
   if 85 - 85: I11iiIi11i1I % I11iiIi11i1I
  def getEpochSize ( self , refresh : bool = False ) -> int :
   if 34 - 34: i1iiIII111 * i1I
   if 75 - 75: IiI11Ii111 % i1i1i1111I - Ii
   if 4 - 4: i1 / Oo . IIiIIiIi11I1 - i1 + i1 * Oo
   if 23 - 23: Ooo0Ooo - Ii . ooOOO % Ii . i1i1i1111I * iI1iII1I1I1i
   if 98 - 98: Iii1i % i1iiIII111 / Oo
   if 90 - 90: OooOoo - i1I * I1I % I1I
   if 33 - 33: oOo0O00 - I1I / I1Ii1I1 * Ooo0Ooo
   if 68 - 68: i1I . Iii1i
   if 81 - 81: I1I . OooOoo . IiIIii11Ii . i1I - i1i1i1111I % i1iiIII111
   if 24 - 24: I11iiIi11i1I * I1I - i1I / I11iiIi11i1I - IiIIii11Ii + IiI11Ii111
   if 72 - 72: iI1iII1I1I1i . Ooo0Ooo
   if 81 - 81: i1I . OooOoo . oOo0O00 % Oo
   if 16 - 16: Ii / oOO % Iii1i + i1
   return self . epochSize
   if 38 - 38: IiIIii11Ii - I1Ii1I1 . oOo0O00
  def copy ( self ) -> 'DataPreprocessing.Node.BERT.GeneratorDetail' :
   if 10 - 10: i1 % IiI11Ii111 % oOo0O00 % IiI11Ii111 - Ii
   if 70 - 70: i1I . ooOOO - Iii1i * i1iiIII111 . ooOOO - I1I
   if 43 - 43: OooOoo
   if 27 - 27: i1iiIII111 * Ii * IIiIIiIi11I1 / i1I . IiI11Ii111
   if 90 - 90: IiIIii11Ii
   if 10 - 10: IiI11Ii111 % oOO . OooOoo - ooOOO
   if 93 - 93: Oo
   if 5 - 5: i1 % IiIIii11Ii * IIiIIiIi11I1 - oOo0O00
   if 30 - 30: Ii
   if 4 - 4: IiI11Ii111 % ooo000
   if 88 - 88: Iii1i * IIiIIiIi11I1 % ooo000 . OooOoo - Ooo0Ooo - oOO
   ii1IIiIIi : I11ii . GeneratorDetail = I11ii . GeneratorDetail ( self . controller )
   if 31 - 31: i1I . Iii1i
   if 30 - 30: oOO * Ii % i1 . Ii
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_referenceIndexes" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 10 - 10: OooOoo
   return ii1IIiIIi
   if 57 - 57: Ii + i1iiIII111
  def initialize ( self ) :
   if 45 - 45: i1 * OooOoo + ooo000 % Oo - i1i1i1111I
   if 10 - 10: I1I % IiIIii11Ii - i1
   if 57 - 57: IiIIii11Ii + oOo0O00 % i1 * ooOOO % oOO + I11iiIi11i1I
   if 14 - 14: IiIIii11Ii
   if 53 - 53: IIiIIiIi11I1 % i1i1i1111I + OooOoo / i1 % oOO + I1I
   if 16 - 16: OooOoo * i1 . iI1iII1I1I1i
   if 84 - 84: Iii1i . Ii - ooOOO + i1I
   super ( ) . initialize ( )
   if 50 - 50: Ii . IiI11Ii111 + ooo000
   if 64 - 64: ooo000
   if len ( self . _referenceIndexes ) == 0 :
    if 50 - 50: i1 . ooo000 / Ooo0Ooo / oOO
    I1 : I11ii = self . controller . attachObject
    if 98 - 98: IiI11Ii111 . ooOOO + i1I
    if 28 - 28: i1iiIII111
    O0oo0O00O0OO0 : int = I1 . getRootSources ( ) [ 0 ] . epochSize
    if O0oo0O00O0OO0 is None :
     return
     if 93 - 93: ooOOO % ooo000 / i1 - Iii1i / ooOOO
     if 88 - 88: i1 . oOo0O00 % i1iiIII111
    self . _referenceIndexes = [ i for i in range ( 0 , O0oo0O00O0OO0 - ( I1 . seriesLen - 1 ) ) ]
    if 74 - 74: IiI11Ii111 . IiIIii11Ii + ooOOO + IiI11Ii111
    if 2 - 2: oOo0O00
    if I1 . seriesLabel is not None :
     if 73 - 73: ooOOO + iI1iII1I1I1i / Iii1i - Iii1i - Ii - IiIIii11Ii
     oo0oO00O : int = I1 . seriesLabel
     o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
     if 9 - 9: ooOOO / ooOOO + OooOoo - i1
     if 81 - 81: IiI11Ii111 / Ii
     if o0o0oooO0 [ 0 ] . splittable :
      if 30 - 30: Ii
      IIi11ii1IIi : List [ Any ] = o0o0oooO0 [ 0 ] . getData ( )
      if 87 - 87: Ii % i1 % IiIIii11Ii
      if 14 - 14: I11iiIi11i1I
      if I1 . seriesLabelParser == "n" :
       self . _referenceIndexes . sort ( key = lambda ooooO0O0Oo : float ( IIi11ii1IIi [ ooooO0O0Oo ] [ oo0oO00O ] ) )
      else :
       self . _referenceIndexes . sort ( key = lambda ooooO0O0Oo : IIi11ii1IIi [ ooooO0O0Oo ] [ oo0oO00O ] )
       if 83 - 83: OooOoo + i1iiIII111 . IiIIii11Ii % i1iiIII111
       if 53 - 53: IIiIIiIi11I1 + IiI11Ii111 + I1Ii1I1 . Ii + OooOoo + i1I
    if isinstance ( I1 . fromNode , Oo0ooo0OO0 ) :
     if 4 - 4: IiI11Ii111
     o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
     if 28 - 28: I11iiIi11i1I % IiIIii11Ii % I1I
     if 49 - 49: OooOoo . i1i1i1111I - i1 . I11iiIi11i1I % i1I
     if o0o0oooO0 [ 0 ] . splittable :
      if 81 - 81: Ooo0Ooo * Oo % Ii % IIiIIiIi11I1 % I11iiIi11i1I
      IIi11ii1IIi : np . ndarray = o0o0oooO0 [ 0 ] . getData ( )
      if 67 - 67: ooOOO + i1I / i1 + i1iiIII111
      if 32 - 32: iI1iII1I1I1i / Oo + i1
      self . _cacheInput = I1 . fromNode . processData ( IIi11ii1IIi )
      if 57 - 57: IiIIii11Ii - IiIIii11Ii . I11iiIi11i1I % IiIIii11Ii . IIiIIiIi11I1 * IiI11Ii111
      if 30 - 30: i1 - OooOoo % i1 % Ooo0Ooo
    if I1 . reversed :
     self . _referenceIndexes = [ index + I1 . seriesLen - 1 for index in self . _referenceIndexes ]
     if 87 - 87: OooOoo * ooOOO % i1iiIII111 + Oo + i1i1i1111I
  def getCacheInput ( self , start : int = None , end : int = None , indexes : List [ int ] = None ) -> 'np.ndarray<*>' :
   if 53 - 53: OooOoo % IIiIIiIi11I1 % I1I * I1Ii1I1
   if 59 - 59: I1Ii1I1
   if 16 - 16: oOO + IIiIIiIi11I1 * Oo * OooOoo
   if 5 - 5: I1Ii1I1 . OooOoo . I11iiIi11i1I % ooo000
   if 55 - 55: ooo000 / oOO * i1
   if 92 - 92: i1iiIII111 . i1I + IiI11Ii111
   if 79 - 79: Ii
   if 10 - 10: iI1iII1I1I1i + iI1iII1I1I1i - Ooo0Ooo * IIiIIiIi11I1 + OooOoo * I1Ii1I1
   if 93 - 93: i1i1i1111I % Iii1i / i1I % iI1iII1I1I1i + ooo000
   if 42 - 42: I11iiIi11i1I / i1I * Oo + i1
   if 39 - 39: Ii + I11iiIi11i1I % i1I % I11iiIi11i1I
   if 55 - 55: ooo000 + I1Ii1I1 + OooOoo
   if 6 - 6: I1I * I11iiIi11i1I - i1I + i1iiIII111 % IiIIii11Ii . oOo0O00
   if 22 - 22: oOo0O00
   if 36 - 36: i1 - oOo0O00 / IiI11Ii111 + Oo
   if 30 - 30: OooOoo + I1I . I11iiIi11i1I % Iii1i / Ii % oOO
   if start == "None" :
    start = None
   if end == "None" :
    end = None
    if 69 - 69: IIiIIiIi11I1 . Iii1i
    if 48 - 48: i1I + Ooo0Ooo
   if start is not None or end is not None :
    return self . _cacheInput [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= len ( self . _cacheInput ) or idx < - len ( self . _cacheInput ) ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    return self . _cacheInput [ indexes ]
   else :
    return self . _cacheInput [ : ]
    if 94 - 94: OooOoo % oOo0O00 - Oo . iI1iII1I1I1i
  def prepareIteration ( self ) :
   if 56 - 56: i1i1i1111I + ooOOO / Oo * IiIIii11Ii
   if 11 - 11: i1i1i1111I / I1Ii1I1 + i1iiIII111 % iI1iII1I1I1i + I11iiIi11i1I * i1i1i1111I
   if 91 - 91: Ii + Oo - I11iiIi11i1I * I1I + Ii % Iii1i
   if 32 - 32: ooo000 % i1
   if 87 - 87: IIiIIiIi11I1 + OooOoo
   if 63 - 63: IIiIIiIi11I1 * oOo0O00
   if 17 - 17: i1i1i1111I * I11iiIi11i1I
   if 93 - 93: Iii1i / i1i1i1111I - oOO - I1I % I1Ii1I1 * Ii
   if not self . initialized :
    self . initialize ( )
    if 54 - 54: IiI11Ii111 + i1I - IiIIii11Ii / I11iiIi11i1I - I1Ii1I1 * oOo0O00
    if 30 - 30: IIiIIiIi11I1 * ooo000 - IiI11Ii111
   self . batchIdxReset ( )
   if 46 - 46: oOo0O00 - i1 . oOo0O00 . iI1iII1I1I1i - i1iiIII111
   if 32 - 32: Oo - iI1iII1I1I1i / Oo + ooo000 + OooOoo * IIiIIiIi11I1
   if self . shuffle :
    self . _shuffleData ( )
    if 63 - 63: i1 - oOo0O00 . I11iiIi11i1I + Ooo0Ooo / Ii
  def _shuffleData ( self ) :
   if 72 - 72: i1iiIII111 + ooo000 - iI1iII1I1I1i
   if 55 - 55: Ii + IIiIIiIi11I1 + i1 * i1iiIII111
   if 82 - 82: oOo0O00
   if 58 - 58: i1I / oOO / Oo / IiI11Ii111
   if 79 - 79: IiI11Ii111 / Iii1i % Iii1i
   if 49 - 49: i1iiIII111
   if 46 - 46: Ii . I1I % oOO + I1Ii1I1 / oOO
   if 51 - 51: oOo0O00 / IiIIii11Ii / Ooo0Ooo + oOO / i1 * Iii1i
   np . random . shuffle ( self . _referenceIndexes )
   if 5 - 5: I11iiIi11i1I
  def setData ( self , inputArray : Union [ list ] = [ ] , outputArray : None = None , hasHeader : None = None ) :
   if 14 - 14: IIiIIiIi11I1 - I1Ii1I1 . oOo0O00 + i1 . i1
   if 5 - 5: Oo * ooo000 - OooOoo
   if 95 - 95: i1i1i1111I . I11iiIi11i1I . Ooo0Ooo
   if 3 - 3: oOO
   if 78 - 78: i1I . ooo000
   if 25 - 25: i1iiIII111 + I11iiIi11i1I - Iii1i * ooOOO + iI1iII1I1I1i
   if 26 - 26: ooOOO
   if 84 - 84: ooo000 - Ooo0Ooo + i1 . oOO - ooOOO
   if 62 - 62: oOO * i1 % ooo000
   if 3 - 3: ooo000 * oOO + Oo * iI1iII1I1I1i
   if 29 - 29: ooo000 . iI1iII1I1I1i / IIiIIiIi11I1 + Oo % oOo0O00
   if 43 - 43: i1i1i1111I * Oo
   if 72 - 72: IIiIIiIi11I1 / i1I
   iI1I = list ( inputArray )
   if 67 - 67: i1 % IIiIIiIi11I1 . Ooo0Ooo + i1iiIII111 + Ii / i1iiIII111
   if 89 - 89: Ooo0Ooo % ooOOO . I1I * IIiIIiIi11I1 % oOO
   if len ( np . shape ( iI1I ) ) != 1 :
    raise ValueError ( "Input Shape must be a 1-dimensional list." )
    if 64 - 64: i1 * iI1iII1I1I1i + IIiIIiIi11I1
    if 66 - 66: i1i1i1111I * Ooo0Ooo . i1i1i1111I * OooOoo - Iii1i
   if len ( iI1I ) == 0 :
    raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
    if 21 - 21: Oo * I1I / Oo - Ooo0Ooo . IIiIIiIi11I1
    if 22 - 22: IIiIIiIi11I1 % oOO / ooo000 - oOo0O00 . Ooo0Ooo . oOo0O00
   self . _referenceIndexes = iI1I
   if 93 - 93: I11iiIi11i1I + IiI11Ii111 + i1I + I1Ii1I1 * oOo0O00 / I11iiIi11i1I
  def getData ( self , start : int = None , end : int = None , indexes : int = None ) -> 'np.ndarray<*>' :
   if 88 - 88: IiIIii11Ii % I11iiIi11i1I
   if 78 - 78: iI1iII1I1I1i - i1iiIII111 / OooOoo
   if 22 - 22: IIiIIiIi11I1 * i1iiIII111 . I1Ii1I1 - IIiIIiIi11I1 / i1i1i1111I
   if 1 - 1: I1I * Oo / oOO
   if 59 - 59: Ii . iI1iII1I1I1i % IiI11Ii111
   if 21 - 21: IiIIii11Ii
   if 82 - 82: IiIIii11Ii / Iii1i * ooOOO / Ooo0Ooo + i1I
   if 94 - 94: IiI11Ii111 + ooOOO - oOO
   if 70 - 70: I1I * i1I . Oo / I1I * I1Ii1I1 + ooOOO
   if 73 - 73: OooOoo
   if 67 - 67: ooo000 * i1I + IiI11Ii111 % IiI11Ii111 + IIiIIiIi11I1
   if 27 - 27: i1 . I1I
   if 12 - 12: OooOoo / IIiIIiIi11I1 / i1iiIII111 . Ii . OooOoo
   if 66 - 66: IIiIIiIi11I1 - oOo0O00 + Oo % i1
   if 72 - 72: ooo000 - IIiIIiIi11I1 * oOo0O00 + I11iiIi11i1I
   if 41 - 41: IiI11Ii111 . I1Ii1I1 / ooOOO * OooOoo * Ooo0Ooo
   if not self . initialized :
    self . initialize ( )
    if 72 - 72: ooOOO - Oo * Ooo0Ooo % IiIIii11Ii
    if 23 - 23: IiIIii11Ii
   I1 : I11ii = self . controller . attachObject
   if 60 - 60: Ooo0Ooo + IiI11Ii111 / I1I % IiIIii11Ii - Iii1i / I1I
   if 57 - 57: I1I % i1I . oOo0O00
   if I1 . getEpochSize ( True ) is None :
    return [ ]
    if 43 - 43: IiIIii11Ii
    if 33 - 33: IiI11Ii111 . Ii + ooOOO * IIiIIiIi11I1 * ooo000
   o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
   if 6 - 6: ooOOO * Ii + Iii1i % IIiIIiIi11I1 * iI1iII1I1I1i % IIiIIiIi11I1
   if 23 - 23: oOO * Ii . Iii1i + IiI11Ii111
   if start == "None" or start is None :
    start = 0
   if end == "None" or end is None :
    end = len ( self . _referenceIndexes )
    if 92 - 92: I1Ii1I1 * OooOoo
    if 11 - 11: Ii . Ii - Oo + oOO
   o00oO0O0o00O : List [ int ]
   if start is not None or end is not None :
    o00oO0O0o00O = self . _referenceIndexes [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= end or idx < - end ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    indexes = [ ( idx if idx >= 0 else ( len ( self . _referenceIndexes ) + idx ) ) for idx in indexes ]
    if 67 - 67: ooo000
    oo0 : List [ Any ] = [ ]
    for IiI in indexes :
     oo0 . append ( self . _referenceIndexes [ IiI ] )
    o00oO0O0o00O = oo0
   else :
    o00oO0O0o00O = self . _referenceIndexes [ : ]
    if 6 - 6: I1I % I11iiIi11i1I * Ooo0Ooo
    if 23 - 23: Iii1i * ooOOO + IiIIii11Ii % i1iiIII111 . i1I - i1i1i1111I
   if not o0o0oooO0 [ 0 ] . splittable :
    raise ValueError ( "Time Series data preprocessing node currenly only supports for splittable data sources." )
    if 73 - 73: Oo . I1Ii1I1 . i1i1i1111I * I1Ii1I1
    if 41 - 41: Iii1i * Iii1i / IiIIii11Ii / i1i1i1111I - i1
   if isinstance ( I1 . fromNode , list ) :
    raise ValueError ( "Multiple from node is detected from a time series data source" )
    if 40 - 40: I1I * OooOoo * Ii + oOo0O00 - ooOOO / OooOoo
    if 73 - 73: i1 - ooOOO / I1I
   I1IIiI : List [ np . ndarray ] = [ ]
   O00O00o : List [ int ] = None
   I11i : int = - 1 if I1 . reversed else 1
   if 90 - 90: oOo0O00 + i1iiIII111 / I11iiIi11i1I * oOO
   for ooOoOOoo00 in range ( 0 , I1 . seriesLen ) :
    II1I : np . ndarray
    if 48 - 48: i1I - i1iiIII111 . Oo * IiIIii11Ii * Iii1i
    if self . _cacheInput and len ( self . _cacheInput ) :
     II1I = self . getCacheInput ( indexes = o00oO0O0o00O )
     if 21 - 21: i1iiIII111 - Oo + IiIIii11Ii / oOo0O00
    else :
     II1I = I1 . fromNode . getData ( indexes = o00oO0O0o00O )
     if 21 - 21: I1Ii1I1 % iI1iII1I1I1i . iI1iII1I1I1i % i1I
     if 74 - 74: ooo000 - i1 - IiIIii11Ii + i1iiIII111 % ooo000 - oOo0O00
    O00O00o = np . shape ( II1I ) if O00O00o is None else O00O00o
    iiIII1I1ii : np . ndarray = II1I [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( I1 . crops [ idx ] ) if idx in I1 . crops else slice ( None , None ) ) for idx , v in enumerate ( O00O00o [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( I1 . sourceCol ) ) ]
    I1IIiI . append ( iiIII1I1ii [ : , np . newaxis ] )
    o00oO0O0o00O = [ ( batchIndex + I11i ) for batchIndex in o00oO0O0o00O ]
    if 66 - 66: IiI11Ii111 + I11iiIi11i1I
    if 26 - 26: OooOoo / i1iiIII111 * i1i1i1111I . OooOoo + IiIIii11Ii
   return np . concatenate ( I1IIiI , axis = 1 )
   if 59 - 59: iI1iII1I1I1i / OooOoo . I1Ii1I1 / oOo0O00
  def getNextBatch ( self ) -> 'np.ndarray' :
   if 40 - 40: I1Ii1I1
   if 31 - 31: i1i1i1111I - i1
   if 20 - 20: IiIIii11Ii % IIiIIiIi11I1 . IiIIii11Ii / IIiIIiIi11I1 . ooo000 % I1I
   if 61 - 61: iI1iII1I1I1i - i1 * ooo000 . i1iiIII111 / ooo000 / i1iiIII111
   if 37 - 37: Ooo0Ooo * ooo000 % i1i1i1111I % IIiIIiIi11I1 + i1I * Iii1i
   if 29 - 29: i1 / IiIIii11Ii + I11iiIi11i1I + IiI11Ii111 . IiI11Ii111
   if 97 - 97: i1 . IIiIIiIi11I1 / Ii / I1I
   if 39 - 39: i1iiIII111 . I1Ii1I1 - OooOoo - oOo0O00
   if 40 - 40: IIiIIiIi11I1 * ooOOO . I1Ii1I1 - I1Ii1I1
   if 51 - 51: Oo % i1i1i1111I - Oo + ooo000 * I1Ii1I1 . i1iiIII111
   if 17 - 17: ooo000 % iI1iII1I1I1i * IIiIIiIi11I1 . ooo000 * Ooo0Ooo
   if not self . initialized :
    self . initialize ( )
    if 99 - 99: oOo0O00
    if 55 - 55: Oo * iI1iII1I1I1i % I11iiIi11i1I
   if self . batchIdx is None :
    self . prepareIteration ( )
    if 48 - 48: i1iiIII111 * IiIIii11Ii % I1Ii1I1 . Ooo0Ooo
    if 69 - 69: i1i1i1111I * Iii1i / i1I + ooOOO
   IiIIiiII : int = self . batchIdx
   o0OOOO0Oo0O : int = self . batchSize
   if 23 - 23: Ooo0Ooo + iI1iII1I1I1i . i1iiIII111
   if 39 - 39: IiI11Ii111 . IiIIii11Ii . Ii * ooo000 % I1Ii1I1 / i1i1i1111I
   if ( self . dropRemainder and ( IiIIiiII + 1 ) * o0OOOO0Oo0O > self . epochSize ) or ( ( not self . dropRemainder ) and IiIIiiII * o0OOOO0Oo0O >= self . epochSize ) :
    self . prepareIteration ( )
    IiIIiiII = self . batchIdx
    if 69 - 69: OooOoo
    if 94 - 94: IIiIIiIi11I1 * Ooo0Ooo
   O00o000Oo : np . ndarray = self . getData ( start = IiIIiiII * o0OOOO0Oo0O , end = ( IiIIiiII + 1 ) * o0OOOO0Oo0O )
   if 10 - 10: Ii + IiI11Ii111 / Oo
   if 49 - 49: i1i1i1111I * oOo0O00 + ooo000 - I1Ii1I1 . ooOOO
   self . batchIdxIncrement ( )
   if 93 - 93: i1i1i1111I * Oo - i1I / oOo0O00 + I11iiIi11i1I % oOO
   return O00o000Oo
   if 32 - 32: IiIIii11Ii . IIiIIiIi11I1 % Ooo0Ooo / I1Ii1I1 + I11iiIi11i1I + Ii
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> 'np.ndarray' :
   if 78 - 78: oOo0O00 / Iii1i + I1I - Iii1i
   if 54 - 54: ooOOO / iI1iII1I1I1i + i1iiIII111 % i1 . Iii1i / i1iiIII111
   if 29 - 29: IiI11Ii111
   if 37 - 37: IiI11Ii111 * i1I - IiI11Ii111 - oOO + IIiIIiIi11I1 - oOO
   if 2 - 2: i1iiIII111 + iI1iII1I1I1i + OooOoo
   if 60 - 60: I1I - I1Ii1I1 % ooo000 * ooo000 + i1I . i1i1i1111I
   if 81 - 81: IiIIii11Ii % I1I . I11iiIi11i1I * IiIIii11Ii
   if 39 - 39: iI1iII1I1I1i + iI1iII1I1I1i * Iii1i
   if 20 - 20: I1Ii1I1 % IiIIii11Ii % Ooo0Ooo % Iii1i - oOo0O00
   if 72 - 72: i1 - oOO - ooo000 / Oo % ooo000 . I1I
   if 28 - 28: i1I
   if 38 - 38: ooo000 / oOO
   if 53 - 53: Ooo0Ooo / ooOOO % i1iiIII111
   if 99 - 99: Oo * i1iiIII111 * I11iiIi11i1I
   if 69 - 69: i1 - IIiIIiIi11I1 - oOo0O00 - I1Ii1I1 - I1Ii1I1
   if len ( self . _referenceIndexes ) == 0 :
    return np . array ( [ ] )
    if 52 - 52: oOO . iI1iII1I1I1i + I1Ii1I1
    if 88 - 88: ooo000
   Oo0o0oo0 : np . ndarray = np . arange ( len ( self . _referenceIndexes ) )
   np . random . seed ( randomSeed )
   np . random . shuffle ( Oo0o0oo0 )
   np . random . seed ( )
   if 80 - 80: IiI11Ii111 . Ooo0Ooo % i1iiIII111 . i1 % I1Ii1I1
   if 73 - 73: i1i1i1111I - Iii1i + IiI11Ii111 * ooo000 * I11iiIi11i1I % I1I
   O00o000Oo : np . ndarray = self . getData ( indexes = Oo0o0oo0 )
   if 21 - 21: i1 + IIiIIiIi11I1 / I1I * i1iiIII111
   if 17 - 17: Iii1i . i1I / iI1iII1I1I1i
   return O00o000Oo . copy ( )
   if 59 - 59: IiI11Ii111 * iI1iII1I1I1i
  def partition ( self , prop : float = 0.2 , shuffle : float = False ) -> Tuple [ 'np.ndarray' , 'np.ndarray' ] :
   if 31 - 31: I11iiIi11i1I - Oo
   if 78 - 78: i1 / i1i1i1111I - Iii1i
   if 96 - 96: Ooo0Ooo
   if 67 - 67: i1i1i1111I - ooOOO - oOO * Oo
   if 92 - 92: oOO * Iii1i * IIiIIiIi11I1 - Ii * oOo0O00
   if 51 - 51: IiIIii11Ii . I11iiIi11i1I - iI1iII1I1I1i * Oo - OooOoo . ooOOO
   if 98 - 98: I1Ii1I1 . Ooo0Ooo + i1iiIII111 * i1 / IIiIIiIi11I1
   if 27 - 27: i1iiIII111 . i1i1i1111I * iI1iII1I1I1i
   if 91 - 91: ooOOO / oOo0O00 + iI1iII1I1I1i * i1iiIII111
   if 58 - 58: i1I + IiI11Ii111 + OooOoo . I11iiIi11i1I / Iii1i + i1
   if 48 - 48: oOo0O00 + I1Ii1I1 + oOo0O00 % iI1iII1I1I1i - oOo0O00
   if 20 - 20: OooOoo * IiI11Ii111 / ooo000 + i1 + I1I . i1I
   if 39 - 39: Iii1i % ooOOO
   if 47 - 47: I11iiIi11i1I % IIiIIiIi11I1 - I1Ii1I1 % OooOoo + I11iiIi11i1I % i1iiIII111
   if 67 - 67: IIiIIiIi11I1 - I1Ii1I1 * I11iiIi11i1I
   if not self . initialized :
    self . initialize ( )
    if 62 - 62: ooo000 - Iii1i
    if 86 - 86: i1iiIII111
   IiiI1 = len ( self . _referenceIndexes )
   iII11i1 = math . floor ( IiiI1 * prop )
   i1iI1iI = self . _referenceIndexes [ : ]
   if 65 - 65: ooOOO
   if 71 - 71: oOO * Ii . i1I - i1 % i1
   if shuffle :
    np . random . shuffle ( i1iI1iI )
    if 33 - 33: i1 / iI1iII1I1I1i / Ii / ooOOO % ooOOO % i1i1i1111I
    if 96 - 96: i1i1i1111I * OooOoo
   ooo00 = i1iI1iI [ iII11i1 : ]
   O0o = i1iI1iI [ : iII11i1 ]
   if 41 - 41: I1I . Oo - i1i1i1111I - I1I - oOO . i1I
   if 28 - 28: oOo0O00 - Iii1i % Ooo0Ooo % iI1iII1I1I1i . I1I
   return ooo00 , O0o
   if 76 - 76: iI1iII1I1I1i % ooOOO . IiI11Ii111 - IIiIIiIi11I1 + I1Ii1I1 * i1iiIII111
 class GeneratorController ( I111II1II111I . Controller ) :
  if 65 - 65: oOo0O00 % oOo0O00 * oOO + i1
  if 44 - 44: oOO * oOo0O00 % iI1iII1I1I1i
  if 15 - 15: Iii1i - i1iiIII111
  if 66 - 66: I1Ii1I1 - i1i1i1111I / oOo0O00 - Oo
  if 57 - 57: oOO * I1I / Oo
  if 98 - 98: oOo0O00 / I11iiIi11i1I
  if 40 - 40: IIiIIiIi11I1 % oOo0O00 . IiI11Ii111
  def __init__ ( self , attachObject : 'DataPreprocessing.Node.BERT' ) :
   if 27 - 27: OooOoo * I1Ii1I1 + ooo000 / I1Ii1I1 / IiI11Ii111
   if 85 - 85: I11iiIi11i1I + IIiIIiIi11I1
   if 84 - 84: ooOOO - ooOOO / oOo0O00 - OooOoo + oOo0O00
   if 43 - 43: i1iiIII111 + oOo0O00 - i1I - Ooo0Ooo - ooo000 . Ii
   if 53 - 53: OooOoo * ooOOO - Iii1i
   if 91 - 91: ooOOO / oOo0O00
   if 48 - 48: i1iiIII111
   if 55 - 55: oOO + I1I % IiI11Ii111 / I11iiIi11i1I
   if 57 - 57: i1i1i1111I . I1Ii1I1 / i1iiIII111
   if 93 - 93: i1I * Ii - ooo000 * IIiIIiIi11I1
   super ( ) . __init__ ( attachObject = attachObject )
   if 32 - 32: i1I % Ii - Oo
  @ property
  def detailType ( self ) -> Callable [ ... , 'DataPreprocessing.Node.BERT.GeneratorDetail' ] :
   if 8 - 8: ooOOO + IiIIii11Ii % oOo0O00 - IIiIIiIi11I1 . i1i1i1111I / i1iiIII111
   if 100 - 100: OooOoo - i1I / i1I + oOO / iI1iII1I1I1i . i1
   if 42 - 42: ooOOO % I11iiIi11i1I % Iii1i + i1i1i1111I / i1iiIII111
   if 47 - 47: I1I * i1iiIII111 / i1 - iI1iII1I1I1i
   if 47 - 47: ooOOO / IiI11Ii111 + Iii1i
   if 18 - 18: Ooo0Ooo
   if 55 - 55: Ii - Ii % IiIIii11Ii % Iii1i
   if 73 - 73: I11iiIi11i1I . oOO + oOo0O00 - i1I
   if 43 - 43: i1i1i1111I . i1i1i1111I % Oo % I1Ii1I1 % i1i1i1111I % i1I
   if 60 - 60: I1I * Ooo0Ooo . iI1iII1I1I1i + OooOoo - i1iiIII111
   return I11ii . GeneratorDetail
   if 10 - 10: i1I * i1iiIII111
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 59 - 59: Ooo0Ooo * ooo000 . oOo0O00 % IiI11Ii111 . ooo000
   if 3 - 3: i1
   if 42 - 42: ooOOO / i1I / i1iiIII111 * oOO
   if 59 - 59: I1I * IiIIii11Ii % i1I * I1I / I1I / oOo0O00
   if 24 - 24: Iii1i
   if 69 - 69: OooOoo . IiIIii11Ii % i1iiIII111 . i1 + I1I
   if 26 - 26: Ooo0Ooo / i1 + I1I
   if 99 - 99: OooOoo . Oo - ooo000
   if 4 - 4: I1I * Ii - iI1iII1I1I1i - ooo000
   if 26 - 26: i1I - Oo
   if 12 - 12: i1I % I11iiIi11i1I
   if 16 - 16: Oo / IIiIIiIi11I1
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   IiOoOOOoO0 = Oooo0OOO . epochSize
   if 39 - 39: i1i1i1111I * ooo000
   if 61 - 61: ooOOO
   if 94 - 94: Ii + i1 / i1I / OooOoo . OooOoo % OooOoo
   if randomFold :
    ( o0 , I1IiIii ) = Oooo0OOO . partition ( prop = validation , shuffle = True )
    if 67 - 67: I1Ii1I1 * IiIIii11Ii
    if 15 - 15: IIiIIiIi11I1 . I1I
   else :
    if 40 - 40: IiIIii11Ii * IiI11Ii111 + Iii1i + Iii1i
    oo0oOo0O0 = math . floor ( 1 / validation )
    IiIIiiII = self . validationTime % oo0oOo0O0
    IIi11ii1IIi = Oooo0OOO . oriData . copy ( ) [ 1 : ] if Oooo0OOO . hasHeader else Oooo0OOO . oriData . copy ( )
    if 93 - 93: I1Ii1I1 / Iii1i . i1 + Ooo0Ooo . i1i1i1111I
    if 15 - 15: Ooo0Ooo - iI1iII1I1I1i % IiI11Ii111 / Iii1i
    if IiIIiiII == 0 and Oooo0OOO . shuffle :
     np . random . shuffle ( IIi11ii1IIi )
     if 40 - 40: ooOOO - i1iiIII111 / oOO * IiIIii11Ii
     if 79 - 79: Oo * IIiIIiIi11I1 - i1I * OooOoo / I11iiIi11i1I / OooOoo
    ii1i1II1iiiI = math . ceil ( IiOoOOOoO0 / oo0oOo0O0 )
    I1I1111 = IiIIiiII * ii1i1II1iiiI
    oOO0o00 = ( IiIIiiII + 1 ) * ii1i1II1iiiI
    o0 = np . vstack ( ( IIi11ii1IIi [ : I1I1111 ] , IIi11ii1IIi [ oOO0o00 : ] ) )
    I1IiIii = IIi11ii1IIi [ I1I1111 : oOO0o00 ]
    if 5 - 5: Ii - I1Ii1I1 / OooOoo . Ii * I1Ii1I1 / ooo000
    if 42 - 42: i1I
   self [ I111II1II111I . Dataset . Types . ValidationTrain ] . setData ( inputArray = o0 )
   self [ I111II1II111I . Dataset . Types . Validation ] . setData ( inputArray = I1IiIii )
   if 62 - 62: I1I + i1I * iI1iII1I1I1i - I1I
   if 59 - 59: oOO + Oo - ooOOO * I11iiIi11i1I * i1iiIII111
   o0o0oooO0 = self . attachObject . getRootSources ( )
   for oOO0O0 in o0o0oooO0 :
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Validation ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . ValidationTrain ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    if 13 - 13: I11iiIi11i1I + i1i1i1111I + Ooo0Ooo + Iii1i * OooOoo % Oo
    if 30 - 30: Oo . oOo0O00 % IiIIii11Ii / oOo0O00
   self . validationTime += 1
   if 58 - 58: i1i1i1111I % I1Ii1I1 % I11iiIi11i1I - I1I
  def splitTestDataset ( self , test : float = 0.2 , shuffle : float = False ) :
   if 19 - 19: Iii1i / IiIIii11Ii / IiI11Ii111 % i1I / I11iiIi11i1I % Ii
   if 69 - 69: i1 % I11iiIi11i1I * I1Ii1I1
   if 48 - 48: I1Ii1I1 . IiI11Ii111
   if 29 - 29: oOO / Ooo0Ooo % ooOOO / ooo000 . ooo000 + I11iiIi11i1I
   if 54 - 54: i1iiIII111 - oOo0O00 / i1i1i1111I . ooOOO
   if 91 - 91: oOo0O00 * IiI11Ii111 / i1i1i1111I % Ooo0Ooo . OooOoo
   if 19 - 19: i1 / I1Ii1I1 - Ooo0Ooo * ooo000
   if 76 - 76: IiIIii11Ii / i1i1i1111I
   if 29 - 29: ooo000 / i1I . OooOoo
   if 27 - 27: ooOOO / Iii1i + Oo * I11iiIi11i1I
   if 40 - 40: IiI11Ii111 . i1 - iI1iII1I1I1i * Oo + oOO
   if 96 - 96: OooOoo - i1iiIII111 . Ii + ooOOO - Oo
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   ( o0 , Oo00OOo0oo0 ) = Oooo0OOO . partition ( prop = test , shuffle = shuffle )
   if 78 - 78: i1 + IIiIIiIi11I1 * Ooo0Ooo * Ii - Oo
   if 99 - 99: ooOOO * I11iiIi11i1I + i1iiIII111
   self [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = o0 )
   self [ I111II1II111I . Dataset . Types . Test ] . setData ( inputArray = Oo00OOo0oo0 )
   if 54 - 54: IiIIii11Ii + Iii1i . IIiIIiIi11I1 . i1I / i1 - i1I
   if 56 - 56: Oo + IIiIIiIi11I1 * IiI11Ii111 % ooo000 % I11iiIi11i1I % ooo000
   o0o0oooO0 = self . attachObject . getRootSources ( )
   for oOO0O0 in o0o0oooO0 :
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Test ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    if 6 - 6: i1I . Oo * Oo % i1 . IiIIii11Ii
 def __init__ ( self , sourceCol : str = "None:None" , dtype : 'tf.DType' = None , source : str = None , order : int = 0 ) :
  if 75 - 75: IiI11Ii111 * ooo000 - Ii * iI1iII1I1I1i + i1I - I11iiIi11i1I
  if 5 - 5: Ooo0Ooo * Iii1i * i1I / I1Ii1I1
  if 4 - 4: Oo + Ooo0Ooo + iI1iII1I1I1i . IiIIii11Ii + IiIIii11Ii * IiIIii11Ii
  if 32 - 32: Ii - iI1iII1I1I1i + ooOOO
  if 99 - 99: oOO / oOO
  if 83 - 83: ooo000 * I1Ii1I1 + IIiIIiIi11I1
  if 12 - 12: IiI11Ii111 + i1 % i1iiIII111
  if 40 - 40: i1i1i1111I
  if 82 - 82: IiI11Ii111 + I1Ii1I1 - I1I - ooOOO
  if 91 - 91: i1iiIII111 + IiIIii11Ii - I1Ii1I1 / i1iiIII111
  if 3 - 3: I1I
  if 75 - 75: oOO % oOO + oOO
  if 23 - 23: i1i1i1111I % i1i1i1111I / IiI11Ii111 . ooo000
  super ( ) . __init__ ( instanceClass = OoiI1iiI11IIi1 . BERT , sourceCol = sourceCol , dtype = dtype )
  if 34 - 34: i1iiIII111 * oOO
  if 46 - 46: ooo000 / oOo0O00 . i1I % i1i1i1111I
  self . oneHotColumns : Dict [ int , Set [ str ] ] = { }
  if 42 - 42: Ii - i1
  if 71 - 71: ooOOO * Iii1i
  self . transformations : List [ oo0OOOOOO0o00 ] = [ ]
  if 64 - 64: i1 * i1
  if 29 - 29: I1I * Iii1i / i1 + Iii1i
  self . circular : List [ O000oOo0 ] = [ ]
  if 75 - 75: i1I * ooOOO - IiIIii11Ii * ooOOO
  if 56 - 56: i1 + oOO + IiIIii11Ii
  self . _colToCircular : Dict [ int , int ] = { }
  if 10 - 10: i1iiIII111 / i1 * i1I % Oo / IIiIIiIi11I1 % oOO
  if 41 - 41: IiI11Ii111
  self . preprocessInBatch : bool = True
  if 30 - 30: oOO + iI1iII1I1I1i / i1I + iI1iII1I1I1i . iI1iII1I1I1i % IIiIIiIi11I1
  if 76 - 76: I1Ii1I1 . oOO . oOO - Ii
  self . _classCount : int = None
  if 45 - 45: OooOoo * IiIIii11Ii . ooOOO . i1I
  if 33 - 33: IiI11Ii111 . Ooo0Ooo - OooOoo * I1I - iI1iII1I1I1i * oOo0O00
  self . separator : str = None
  if 69 - 69: oOo0O00 * i1 + I11iiIi11i1I % OooOoo - i1I % i1iiIII111
  if 1 - 1: IiIIii11Ii . Oo % IiI11Ii111 . I11iiIi11i1I . Ooo0Ooo
  self . tokenSource : str = None
  if 94 - 94: I1I * i1
  if 77 - 77: Iii1i / IIiIIiIi11I1
  self . preprocessSource : str = None
  if 94 - 94: i1iiIII111
  if 12 - 12: ooo000
  self . generatorController : I11ii . GeneratorController = I11ii . GeneratorController ( self )
  if 74 - 74: ooo000 * ooo000 - IIiIIiIi11I1 * i1iiIII111 / Oo / oOo0O00
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 46 - 46: Ooo0Ooo * ooOOO
  if 64 - 64: I1Ii1I1
  if 34 - 34: i1 / i1i1i1111I + iI1iII1I1I1i + Oo
  if 68 - 68: IiI11Ii111 . oOO . Ii
  if 88 - 88: I1Ii1I1 . I11iiIi11i1I . Iii1i
  if 1 - 1: oOo0O00 - i1I . i1I
  if 48 - 48: I1Ii1I1
  if 25 - 25: IIiIIiIi11I1 % oOO / IiIIii11Ii / OooOoo . IiIIii11Ii % i1I
  if 23 - 23: I1Ii1I1 * OooOoo % Iii1i - IiI11Ii111
  if 5 - 5: oOo0O00 . Oo + I1Ii1I1 + I11iiIi11i1I % I1Ii1I1
  if 13 - 13: IiI11Ii111 / IiI11Ii111 / iI1iII1I1I1i + oOO
  if 50 - 50: oOO . i1iiIII111 . IiIIii11Ii / OooOoo
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "transformations" :
    if 31 - 31: ooo000 / IiIIii11Ii . IIiIIiIi11I1 . i1I
    setattr ( self , Ii1I , [ Oo000oO00O . createFromJSON ( tx ) for tx in iiiiIi1IiiIi ] )
   elif Ii1I == "dtype" :
    if iiiiIi1IiiIi is not None :
     self . dtype = O0 . getDataType ( iiiiIi1IiiIi )
    else :
     self . dtype = None
   elif Ii1I == "source" :
    if type ( iiiiIi1IiiIi ) == str :
     iiiiIi1IiiIi = int ( iiiiIi1IiiIi . replace ( "Image " , "" ) . replace ( "Table " , "" ) )
    self . source = iiiiIi1IiiIi
    self . _train = train
    if 13 - 13: i1iiIII111 . i1I % oOO % ooo000 % oOO
    self . _fromNode = train . sources [ iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , int ) else [ train . dppNodes [ dppKey ] for dppKey in iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , list ) else train . dppNodes [ iiiiIi1IiiIi ]
   elif Ii1I == "_getDataMode" :
    setattr ( self , Ii1I , II1IiI1I [ iiiiIi1IiiIi ] )
   elif Ii1I == "crops" :
    self . crops = { idx : crop for idx , crop in enumerate ( iiiiIi1IiiIi ) if crop is not None }
   elif Ii1I in [ "sourceCol" , "_epochSize" , "outputset" , "_order" , "_shape" , "preprocessInBatch" , "_dataShape" , "_key" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
   elif ( Ii1I not in [ "train" , "fromNode" , "_instanceClass" , "order" ] ) :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 83 - 83: i1iiIII111 + OooOoo
 def getEpochSize ( self , refresh : bool = False ) -> int :
  if 58 - 58: Ooo0Ooo + ooo000
  if 56 - 56: IIiIIiIi11I1 . IIiIIiIi11I1 . i1iiIII111 . oOO
  if 62 - 62: oOo0O00 - oOo0O00 - Ii * Ii % I1I
  if 12 - 12: i1I % I1Ii1I1 % i1iiIII111
  if 95 - 95: oOO
  if 4 - 4: oOo0O00
  if 50 - 50: oOO + Ii
  if 88 - 88: I11iiIi11i1I * I1Ii1I1 % IiIIii11Ii % Ii
  if 28 - 28: iI1iII1I1I1i
  if 24 - 24: i1iiIII111 * i1i1i1111I
  if 92 - 92: I1I - i1I
  if 82 - 82: Ii . I1I - Oo * Iii1i + i1
  if 85 - 85: ooo000 / IiIIii11Ii / ooo000
  return self . generatorController [ self . train . currentSourceDataset ] . getEpochSize ( refresh = refresh )
  if 6 - 6: IiI11Ii111 / i1
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 80 - 80: Ooo0Ooo + i1I * oOo0O00 * ooOOO / Iii1i - Ooo0Ooo
  if 53 - 53: I1I + ooOOO - Iii1i % ooo000
  if 6 - 6: OooOoo - i1 * Oo . I1Ii1I1 . i1i1i1111I - I1Ii1I1
  if 69 - 69: ooOOO / ooo000 * oOo0O00
  if 69 - 69: i1I + Oo + Oo
  if 51 - 51: oOO . IIiIIiIi11I1
  if 26 - 26: Ii % IIiIIiIi11I1
  if 62 - 62: Oo
  if 30 - 30: ooo000
  if 24 - 24: i1i1i1111I
  if 31 - 31: IiIIii11Ii % OooOoo - IiI11Ii111 - Ii
  if 85 - 85: I1I / i1iiIII111 * i1I . OooOoo . i1iiIII111
  if 33 - 33: iI1iII1I1I1i + I1I
  if 83 - 83: ooo000
  if 49 - 49: I11iiIi11i1I + i1i1i1111I
  if 29 - 29: I1I * i1iiIII111
  if 85 - 85: Iii1i - i1i1i1111I - IiI11Ii111 / oOo0O00 % I1Ii1I1 % OooOoo
  o0o0oooO0 = o0o ( self . train , self . getRootSources ( False ) , sourceDataset = sourceDataset )
  if 53 - 53: Iii1i % I1Ii1I1 % i1iiIII111 * Ii + OooOoo
  if 14 - 14: Iii1i / Iii1i - Ii % i1I - i1 . Ii
  iiI1iIi = o0o0oooO0 . getData ( start = start , end = end )
  if 73 - 73: Iii1i . IIiIIiIi11I1 * ooo000 % IiI11Ii111 + ooo000
  if 58 - 58: IIiIIiIi11I1 / ooOOO % iI1iII1I1I1i + OooOoo - oOO - IiIIii11Ii
  return self . getProcessedData ( iiI1iIi , step = step )
  if 29 - 29: I1Ii1I1 + ooo000
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> 'np.ndarray' :
  if 33 - 33: Iii1i + Ooo0Ooo
  if 39 - 39: iI1iII1I1I1i . Ooo0Ooo
  if 91 - 91: ooo000 / IiIIii11Ii / ooo000 / Ooo0Ooo - iI1iII1I1I1i
  if 94 - 94: ooo000 - IiIIii11Ii - i1iiIII111 + ooo000
  if 18 - 18: I1I % I1I / I1I * I1I % IiI11Ii111 * IiIIii11Ii
  if 60 - 60: IiIIii11Ii - oOo0O00 * ooo000 / IIiIIiIi11I1 / Oo
  if 70 - 70: oOo0O00 - Ooo0Ooo % I1I . i1iiIII111 / I1Ii1I1 % ooo000
  if 67 - 67: iI1iII1I1I1i / I1I . i1I - I1Ii1I1
  if 35 - 35: i1I * ooo000 / I1I % Ooo0Ooo / iI1iII1I1I1i + i1
  if 95 - 95: i1iiIII111 - IiI11Ii111
  return self . generatorController . getNextBatch ( datasetType = ( sourceDataset or self . train . currentSourceDataset ) )
  if 98 - 98: Ii % Oo * i1i1i1111I . Iii1i . Ii
 def copy ( self , node : 'DataPreprocessing.Node.BERT' ) -> 'DataPreprocessing.Node.BERT' :
  if 43 - 43: i1iiIII111
  if 46 - 46: OooOoo * I1I
  if 40 - 40: IiIIii11Ii
  if 80 - 80: iI1iII1I1I1i % i1iiIII111 - I1Ii1I1
  if 38 - 38: oOO . OooOoo / I1Ii1I1
  if 54 - 54: oOO
  if 80 - 80: oOO / IIiIIiIi11I1 % ooOOO * i1
  if 15 - 15: iI1iII1I1I1i / Ii . ooo000 / ooo000 - I1Ii1I1 - Iii1i
  if 76 - 76: iI1iII1I1I1i + i1I % iI1iII1I1I1i / IIiIIiIi11I1 . i1I * IiIIii11Ii
  if 44 - 44: IiIIii11Ii
  super ( ) . copy ( node )
  node . oneHotColumns = { idx : set ( [ * oneHotSet ] ) for idx , oneHotSet in self . oneHotColumns . items ( ) }
  if 9 - 9: IiI11Ii111 / oOo0O00
 def refreshItemShape ( self ) :
  if 87 - 87: Oo / I1I * i1iiIII111 * oOo0O00
  if 92 - 92: IiIIii11Ii
  if 78 - 78: IiI11Ii111 . Ooo0Ooo % IiIIii11Ii / ooOOO
  if 25 - 25: I11iiIi11i1I + IIiIIiIi11I1 . I1Ii1I1 + i1 . oOo0O00
  if 34 - 34: i1iiIII111 - ooOOO . iI1iII1I1I1i * i1i1i1111I
  if 43 - 43: OooOoo . Iii1i % i1I * oOo0O00 . ooo000
  if 26 - 26: ooo000 - ooOOO . ooo000 * i1iiIII111
  if 47 - 47: Ooo0Ooo - i1iiIII111 * IiIIii11Ii / ooOOO * oOO
  oo00 = self . getInputShape ( ) [ 1 : ]
  ooO0OOo = [ * oo00 [ : - 1 ] , len ( o0ooo0oOoO . getColList ( oo00 [ - 1 ] , self . sourceCol ) ) ]
  if 25 - 25: ooOOO + iI1iII1I1I1i . i1i1i1111I * i1iiIII111
  if 66 - 66: Iii1i
  if len ( self . oneHotColumns ) :
   ooO0OOo [ - 1 ] += sum ( [ max ( [ 1 , len ( oneHotSet ) ] ) for oneHotSet in self . oneHotColumns . values ( ) ] ) - len ( self . oneHotColumns )
   if 17 - 17: i1
   if 10 - 10: i1i1i1111I + OooOoo
  self . setItemShape ( [ * ooO0OOo ] )
  if 74 - 74: i1i1i1111I . Iii1i
 def _processData ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 93 - 93: i1iiIII111
  if 80 - 80: OooOoo
  if 75 - 75: i1iiIII111 - Oo * Oo % OooOoo . i1i1i1111I / I1Ii1I1
  if 12 - 12: Iii1i . i1 - Ii / i1i1i1111I * i1iiIII111 - I11iiIi11i1I
  if 25 - 25: IIiIIiIi11I1 / I1Ii1I1 % oOo0O00 - i1I
  if 8 - 8: I11iiIi11i1I / i1i1i1111I . I1I / ooOOO
  if 19 - 19: I1I % Oo * i1i1i1111I * I1Ii1I1 / i1iiIII111
  if 97 - 97: ooo000 / i1I
  if 38 - 38: I11iiIi11i1I - oOo0O00 * Ooo0Ooo / IiIIii11Ii + i1
  if 68 - 68: ooOOO
  if 37 - 37: Ii . i1i1i1111I
  if 64 - 64: Ii * Ooo0Ooo % i1i1i1111I
  if 87 - 87: Iii1i - i1i1i1111I * i1I + IiI11Ii111 + i1i1i1111I * i1I
  if 34 - 34: iI1iII1I1I1i + IIiIIiIi11I1 + IIiIIiIi11I1 + IIiIIiIi11I1 + oOO + I1I
  if 30 - 30: Ii / IiIIii11Ii * iI1iII1I1I1i - i1iiIII111 - ooo000
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 49 - 49: ooo000 / Iii1i + I1Ii1I1 - i1I / I1I / Oo
  if 3 - 3: OooOoo - i1iiIII111 + Iii1i / IIiIIiIi11I1
  if step == self . StepEnum . Input :
   return Ooo0OOooO
   if 51 - 51: oOO + ooOOO
   if 30 - 30: IiI11Ii111 - IIiIIiIi11I1
  OO0o = None
  if 46 - 46: i1i1i1111I
  if 42 - 42: IiI11Ii111 - OooOoo + I11iiIi11i1I / I1I - IIiIIiIi11I1 - Iii1i
  for O0oOOOoo in self . transformations :
   if 40 - 40: i1iiIII111 / oOo0O00 * IiI11Ii111 * IiI11Ii111 - IiI11Ii111 . OooOoo
   if O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch :
    if 68 - 68: IiIIii11Ii + OooOoo * IiIIii11Ii
    if OO0o is None :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 73 - 73: Iii1i . IiIIii11Ii - i1 - I1I
     if 42 - 42: i1iiIII111 / IIiIIiIi11I1 * oOO + i1I + I1I + OooOoo
    O0oOOOoo . preExtract ( OO0o )
    if 42 - 42: i1 % i1I * i1 % IIiIIiIi11I1 / IIiIIiIi11I1 % Iii1i
    if 41 - 41: ooo000 . IiI11Ii111 / i1i1i1111I + IIiIIiIi11I1 % iI1iII1I1I1i
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 78 - 78: i1i1i1111I + ooo000 - ooOOO / OooOoo * Ii + IIiIIiIi11I1
  if step == self . StepEnum . Transformed :
   return Ooo0OOooO
   if 32 - 32: Iii1i * i1iiIII111
   if 46 - 46: oOO - ooOOO / IIiIIiIi11I1 + IiI11Ii111 + oOO
  for cc in self . circular :
   minV , maxV , rangeV = cc . min , cc . max , cc . range
   cirSlicer = OoOo0000o . toIndexer ( cc . colSel )
   Ooo0OOooO [ ... , cirSlicer ] = np . mod ( ( Ooo0OOooO [ ... , cirSlicer ] . astype ( float ) - minV ) , rangeV )
   if 26 - 26: IiI11Ii111 / Oo % Ii + I1I * I11iiIi11i1I % oOo0O00
  if step == self . StepEnum . CircularDataDefined :
   return Ooo0OOooO
   if 32 - 32: Iii1i - ooOOO + OooOoo / oOo0O00
   if 4 - 4: Ooo0Ooo
  if len ( self . oneHotColumns ) > 0 :
   if 11 - 11: OooOoo - ooo000 - oOO
   allCols = [ ]
   if 21 - 21: i1iiIII111 - ooOOO . ooOOO - IiI11Ii111 / iI1iII1I1I1i
   for ooOoooO0OOo in range ( 0 , len ( Ooo0OOooO [ 0 ] ) ) :
    if ooOoooO0OOo in self . oneHotColumns :
     newCol = Ooo0OOooO [ : , [ ooOoooO0OOo ] ]
     newCol = o0ooo0oOoO . convertCatToNumbers ( newCol , True , { v : ooOoooO0OOo for ooOoooO0OOo , v in enumerate ( self . oneHotColumns [ ooOoooO0OOo ] ) } ) [ "data" ]
     allCols . extend ( newCol )
    else :
     allCols . append ( Ooo0OOooO [ : , [ ooOoooO0OOo ] ] )
     if 41 - 41: oOO - Ooo0Ooo . i1iiIII111 * I1Ii1I1 - IiI11Ii111 + Ii
     if 83 - 83: i1I + Ii % I11iiIi11i1I
   Ooo0OOooO = np . column_stack ( allCols )
   if 8 - 8: OooOoo * i1i1i1111I - OooOoo . Oo / I1Ii1I1 % i1
   if 12 - 12: i1iiIII111 + Ooo0Ooo . i1iiIII111
  if self . dtype is not None :
   Ooo0OOooO = Ooo0OOooO . astype ( self . dtype . as_numpy_dtype )
  else :
   Ooo0OOooO = Ooo0OOooO . astype ( float )
   if 97 - 97: IIiIIiIi11I1
   if 52 - 52: I11iiIi11i1I . ooo000 - OooOoo * i1i1i1111I % I1I
  return Ooo0OOooO
  if 58 - 58: ooOOO . i1
 def recoverToRawData ( self , items : 'np.ndarray|list[*+]' , revealedIdxs : List [ int ] = None ) -> 'np.ndarray' :
  if 31 - 31: oOO
  if 4 - 4: i1
  if 62 - 62: Ii
  if 29 - 29: OooOoo / I11iiIi11i1I
  if 41 - 41: ooo000 - I11iiIi11i1I . oOo0O00
  if 64 - 64: Ooo0Ooo
  if 71 - 71: Ii
  if 26 - 26: I1I . i1I / Iii1i - i1i1i1111I + i1I
  if 48 - 48: ooo000 / OooOoo / Iii1i % IiI11Ii111 * oOo0O00
  if 35 - 35: I11iiIi11i1I + I1Ii1I1 - IiI11Ii111 / i1iiIII111 + I1I
  if 42 - 42: Oo - oOo0O00 * iI1iII1I1I1i
  if 4 - 4: I11iiIi11i1I % I1I - Oo / Ii
  if 50 - 50: I1I
  if 26 - 26: oOo0O00 * I1I * oOo0O00 % iI1iII1I1I1i + Ii
  if 83 - 83: i1I / I1I + Iii1i % Iii1i + I1Ii1I1 / i1iiIII111
  items = np . array ( items )
  if 27 - 27: ooo000 * i1iiIII111 * ooo000 - IiI11Ii111
  if 97 - 97: IIiIIiIi11I1 - oOO
  if revealedIdxs is None :
   revealedIdxs = [ * range ( 0 , items . shape [ - 1 ] ) ]
   if 77 - 77: i1 * IiI11Ii111 . Oo
   if 1 - 1: IiI11Ii111
  iiIII1 = [ ]
  if 73 - 73: Ii . IiIIii11Ii
  if 28 - 28: Ooo0Ooo / IiIIii11Ii * ooOOO . Iii1i - Ii + Oo
  if len ( self . oneHotColumns ) > 0 :
   if 39 - 39: iI1iII1I1I1i + I1I
   iiiii1iI1 = [ * self . oneHotColumns . keys ( ) ]
   iiiii1iI1 . sort ( )
   if 89 - 89: ooOOO + i1I . i1i1i1111I - OooOoo * I1I
   if 9 - 9: ooo000 * Ii . Ooo0Ooo - iI1iII1I1I1i
   o0i1I1Ii = [ ]
   oOoo0Oo0o0O0 = 0
   o0oOOo0OOO0oO = 0
   if 85 - 85: oOO * OooOoo % i1iiIII111
   for ooOoooO0OOo in range ( 0 , len ( self . getShape ( ) ) ) :
    if ooOoooO0OOo == oOoo0Oo0o0O0 :
     if ooOoooO0OOo in iiiii1iI1 :
      if 95 - 95: Ooo0Ooo + i1I / IiIIii11Ii - IiIIii11Ii - OooOoo + IIiIIiIi11I1
      Oo0OoOO0 = self . oneHotColumns [ ooOoooO0OOo ]
      O0ooO00o0O = len ( Oo0OoOO0 )
      oOoo0Oo0o0O0 += O0ooO00o0O
      o0oOOo0OOO0oO += 1
      if 70 - 70: I1Ii1I1 * OooOoo % ooo000 / Ooo0Ooo . I11iiIi11i1I . oOO
      if all ( [ ooOoooO0OOo in revealedIdxs for i in range ( ooOoooO0OOo , ooOoooO0OOo + O0ooO00o0O ) ] ) :
       if 6 - 6: i1I . ooOOO . I1Ii1I1 % i1 * i1iiIII111
       o0O0O00 = items [ ... , ooOoooO0OOo : ooOoooO0OOo + O0ooO00o0O ]
       oO0O0oo00Oo = np . argmax ( o0O0O00 , axis = - 1 )
       iiIii1IiII = { i : v for i , v in enumerate ( Oo0OoOO0 ) }
       o0i1I1Ii . append ( np . reshape ( np . frompyfunc ( lambda IiIIiiII : iiIii1IiII [ IiIIiiII ] , 1 , 1 ) ( oO0O0oo00Oo ) , [ * o0O0O00 . shape [ : - 1 ] , 1 ] ) )
       iiIII1 . append ( o0oOOo0OOO0oO - 1 )
      else :
       raise ValueError ( "Column selection not covered all one-hot indices cannot perform recovering data." )
     else :
      oOoo0Oo0o0O0 += 1
      o0oOOo0OOO0oO += 1
      if ooOoooO0OOo in revealedIdxs :
       o0i1I1Ii . append ( items [ : , [ ooOoooO0OOo ] ] )
       iiIII1 . append ( o0oOOo0OOO0oO - 1 )
       if 27 - 27: Oo * Iii1i / Iii1i . Oo + I1I
       if 24 - 24: i1i1i1111I . iI1iII1I1I1i + Ooo0Ooo . ooo000 + IiI11Ii111 . oOo0O00
   items = np . column_stack ( o0i1I1Ii )
   if 44 - 44: I1I + Ooo0Ooo + i1I % IIiIIiIi11I1
   if 82 - 82: Ii % IIiIIiIi11I1 * IIiIIiIi11I1 . IiIIii11Ii + Iii1i
  oo00 = self . getInputShape ( )
  O0oO000O = OoOo0000o . parse ( oo00 [ - 1 ] , self . sourceCol )
  if 88 - 88: ooo000 . IIiIIiIi11I1 . IIiIIiIi11I1 . ooOOO
  if 70 - 70: i1i1i1111I
  for iI1Ii1IiI in self . circular :
   O0Ooo , iIi1iII11I , Ii11IiIIiiI = iI1Ii1IiI . min , iI1Ii1IiI . max , iI1Ii1IiI . range
   O0oiIiiI11iI = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , iI1Ii1IiI . colSel ) if i in iiIII1 ]
   items [ ... , O0oiIiiI11iI ] = np . mod ( ( items [ ... , O0oiIiiI11iI ] . astype ( float ) - O0Ooo ) , Ii11IiIIiiI )
   if 6 - 6: i1 / i1I + IIiIIiIi11I1
   if 30 - 30: Oo - I1Ii1I1 . OooOoo / IiI11Ii111 * Iii1i % iI1iII1I1I1i
  if len ( self . transformations ) :
   if 64 - 64: Ooo0Ooo * I11iiIi11i1I . IiIIii11Ii
   for O0oOOOoo in reversed ( self . transformations ) :
    if 82 - 82: Ooo0Ooo . Ii - Ooo0Ooo + Ooo0Ooo % i1i1i1111I
    i1III1 = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , O0oOOOoo . colSel ) if i in iiIII1 ]
    items [ ... , i1III1 ] = np . vectorize ( O0oOOOoo . transformFrom ) ( items [ ... , i1III1 ] )
    if 32 - 32: Iii1i . I1Ii1I1
    if 12 - 12: I1I / oOO - oOO + IIiIIiIi11I1 + i1i1i1111I
  return items if isinstance ( self . fromNode , O0 ) else self . fromNode . recoverToRawData ( items , O0oO000O )
  if 85 - 85: Ooo0Ooo % Oo
 def getPrintableItems ( self , items , recovered = True ) :
  if 72 - 72: i1
  if 26 - 26: OooOoo + ooo000
  if 2 - 2: I11iiIi11i1I . Oo . I11iiIi11i1I
  if 86 - 86: I11iiIi11i1I % oOo0O00 . OooOoo
  if 41 - 41: I1I - I1I
  if 85 - 85: IIiIIiIi11I1 - Oo / ooo000 / oOO
  if 82 - 82: i1i1i1111I % OooOoo / OooOoo % IIiIIiIi11I1 . i1i1i1111I % i1I
  if 22 - 22: Ooo0Ooo * IiIIii11Ii
  if 29 - 29: Ii - Ii - i1iiIII111
  if 100 - 100: I1I . IiIIii11Ii * iI1iII1I1I1i - IiI11Ii111
  if 29 - 29: IIiIIiIi11I1 / I11iiIi11i1I % I1Ii1I1 - IiI11Ii111 / oOo0O00 % IIiIIiIi11I1
  if 99 - 99: Ooo0Ooo
  if 77 - 77: Ooo0Ooo
  if 9 - 9: OooOoo . Ii * ooOOO + ooOOO - iI1iII1I1I1i
  if 84 - 84: oOO + i1iiIII111 % oOo0O00
  O0000000 = ( Ii1II11 ( items ) . tolist ( ) if isinstance ( items , np . ndarray ) else items ) if recovered else self . recoverToRawData ( items ) . tolist ( )
  if 79 - 79: ooOOO . ooOOO * oOo0O00 + I11iiIi11i1I % i1iiIII111 / i1iiIII111
  if 31 - 31: IiIIii11Ii / I1I + I11iiIi11i1I + Ooo0Ooo * ooOOO
  O0o0o0Oo00O0 = isinstance ( O0000000 [ 0 ] , list )
  if 70 - 70: I1I + i1I - I1Ii1I1 % oOo0O00 . i1
  if not O0o0o0Oo00O0 :
   if 27 - 27: i1iiIII111 * IIiIIiIi11I1 / i1 + IIiIIiIi11I1 - ooOOO
   OO0oo0OoooOO = "Value"
  elif len ( O0000000 [ 0 ] ) == 1 :
   if 59 - 59: ooOOO % i1I % I1I - Ii + Ooo0Ooo
   OO0oo0OoooOO = "Value"
   O0000000 = [ c [ 0 ] for c in O0000000 ]
  else :
   if 81 - 81: Oo % Ooo0Ooo - i1iiIII111 - Oo
   OO0oo0OoooOO = "Table"
   if 18 - 18: IiIIii11Ii . Ii
   if 6 - 6: ooOOO
  return [ [ OO0oo0OoooOO , json . dumps ( i ) ] for i in O0000000 ]
  if 14 - 14: ooOOO % Oo / Ooo0Ooo * Ii / i1I
 def getProcessedData ( self , rootData : 'Train.RootData' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 8 - 8: Oo
  if 44 - 44: ooOOO * Ooo0Ooo + i1 / IiI11Ii111 / IiI11Ii111
  if 74 - 74: IiIIii11Ii % OooOoo / Iii1i
  if 71 - 71: i1 + ooo000 / oOO / Iii1i % I1Ii1I1
  if 12 - 12: IiI11Ii111 * IIiIIiIi11I1 + Oo . Ooo0Ooo / i1
  if 31 - 31: I1Ii1I1 % i1 / Oo + Iii1i
  if 31 - 31: Ooo0Ooo + IiI11Ii111 % iI1iII1I1I1i - i1 / i1i1i1111I . Ooo0Ooo
  if 92 - 92: OooOoo - ooo000 * ooo000 % Iii1i
  if 70 - 70: IIiIIiIi11I1 / I11iiIi11i1I - i1iiIII111
  if 42 - 42: IIiIIiIi11I1
  if 65 - 65: iI1iII1I1I1i - I1I % OooOoo + i1i1i1111I * IiI11Ii111
  if self . key in rootData . dppNodes :
   if step != I1i1i . Output :
    raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
   return rootData . dppNodes [ self . key ]
   if 90 - 90: I1Ii1I1 - I1I - i1iiIII111 / ooo000 + i1 + oOo0O00
   if 30 - 30: IIiIIiIi11I1 % i1I . i1i1i1111I / iI1iII1I1I1i
  I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProcessedData ( rootData )
  if 92 - 92: ooo000
  if 74 - 74: ooo000 + IIiIIiIi11I1 . Ooo0Ooo
  return self . processData ( I1i , step = step )
  if 93 - 93: i1i1i1111I - ooOOO - i1 + ooOOO
 def getProcessedDataToShow ( self , rootData : 'Train.RootData' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 47 - 47: I1Ii1I1 - i1 / i1I
  if 83 - 83: I11iiIi11i1I % Ii / IiIIii11Ii - i1 . i1i1i1111I
  if 91 - 91: IiI11Ii111 . oOO
  if 7 - 7: I11iiIi11i1I . iI1iII1I1I1i + OooOoo
  if 38 - 38: ooOOO - I1Ii1I1
  if 30 - 30: I1Ii1I1 + i1i1i1111I % i1i1i1111I / IiI11Ii111
  if 7 - 7: I1Ii1I1 * oOO + Ooo0Ooo - i1 / Iii1i
  if 26 - 26: i1i1i1111I * Oo . I1Ii1I1 + Oo % iI1iII1I1I1i
  if 71 - 71: I1Ii1I1 * oOO / I1Ii1I1
  if 32 - 32: i1iiIII111
  if 22 - 22: Iii1i % I11iiIi11i1I % Ii
  if self . key in rootData . dppNodes :
   if step != I1i1i . Output :
    raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
   return rootData . dppNodes [ self . key ]
   if 51 - 51: Ii / IIiIIiIi11I1
   if 20 - 20: IiI11Ii111 / IiIIii11Ii
  I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProcessedData ( rootData )
  if 74 - 74: i1 - I1Ii1I1 - Oo
  if 92 - 92: IiI11Ii111 / Ii
  return self . processDataToShow ( I1i , step = step )
  if 9 - 9: Iii1i / iI1iII1I1I1i + IIiIIiIi11I1 % ooo000
  if 71 - 71: ooo000 * iI1iII1I1I1i % I11iiIi11i1I * IiI11Ii111 + i1I
  if 92 - 92: ooOOO - Ooo0Ooo % I11iiIi11i1I / OooOoo - I1I . i1i1i1111I
 def _processData_old ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 77 - 77: Oo + Ooo0Ooo % ooo000
  if 49 - 49: Iii1i + IIiIIiIi11I1 + I1I
  if 97 - 97: I1I
  if 56 - 56: iI1iII1I1I1i / OooOoo % oOo0O00 * i1 - Iii1i / i1
  if 57 - 57: ooo000 - iI1iII1I1I1i - IiIIii11Ii
  if 27 - 27: Ooo0Ooo / i1 . Oo / oOo0O00
  if 48 - 48: IiIIii11Ii
  if 60 - 60: Ooo0Ooo * IiI11Ii111 . IiIIii11Ii + I11iiIi11i1I
  if 71 - 71: IIiIIiIi11I1 . IiIIii11Ii . I1I + oOo0O00
  if 65 - 65: Oo . OooOoo
  if 96 - 96: ooOOO % Iii1i . I1I % I11iiIi11i1I * Iii1i + iI1iII1I1I1i
  if 52 - 52: iI1iII1I1I1i % IiI11Ii111 + i1iiIII111
  if 37 - 37: I11iiIi11i1I . Oo % iI1iII1I1I1i
  if 98 - 98: I11iiIi11i1I - oOO . i1I * I11iiIi11i1I
  if 9 - 9: i1iiIII111 - iI1iII1I1I1i
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  OOo00oOoOo : List [ int ] = np . shape ( data )
  Ooo0OOooO : np . ndarray = data [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( self . crops [ ooOoooO0OOo ] ) if ooOoooO0OOo in self . crops else slice ( None , None ) ) for ooOoooO0OOo , v in enumerate ( OOo00oOoOo [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( self . sourceCol ) ) ]
  if 94 - 94: ooOOO * OooOoo / i1i1i1111I / ooo000 % ooo000 + i1
  if 6 - 6: oOo0O00
  if step == self . StepEnum . Input :
   return Ooo0OOooO
   if 2 - 2: Ooo0Ooo / i1I
   if 25 - 25: Ooo0Ooo / i1I % I1I + Iii1i
  OO0o = None
  if 9 - 9: ooOOO . IIiIIiIi11I1
  if 9 - 9: I1Ii1I1 - IIiIIiIi11I1
  for O0oOOOoo in self . transformations :
   if 15 - 15: iI1iII1I1I1i
   if O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch :
    if 44 - 44: IiIIii11Ii * ooOOO - oOO % i1iiIII111 % i1iiIII111
    if OO0o is None :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 68 - 68: i1I * I11iiIi11i1I
     if 88 - 88: i1 % Iii1i / Ooo0Ooo
    O0oOOOoo . preExtract ( OO0o )
    if 62 - 62: I11iiIi11i1I + IIiIIiIi11I1 + ooo000
    if 7 - 7: ooOOO + OooOoo . i1 % i1 / iI1iII1I1I1i
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 20 - 20: oOO
  if step == self . StepEnum . Transformed :
   return Ooo0OOooO
   if 65 - 65: ooo000 - i1I - i1iiIII111
   if 39 - 39: i1
  IiIiIIIiIIiI : str = self . separator
  ooOOO0 : str = self . tokenSource
  IiIi1iIi = [ ]
  Ooo = ''
  if IiIiIIIiIIiI is not None :
   for ooOoooO0OOo in range ( len ( Ooo0OOooO ) ) :
    if 11 - 11: OooOoo . Ooo0Ooo % i1i1i1111I - OooOoo * Iii1i . IIiIIiIi11I1
    IiIi1iIi . append ( ( IiIiIIIiIIiI . join ( Ooo0OOooO [ ooOoooO0OOo ] ) ) . split ( IiIiIIIiIIiI ) )
  else :
   IiIi1iIi = list ( Ooo0OOooO )
   if 23 - 23: OooOoo
   if 38 - 38: IiIIii11Ii * i1I * i1i1i1111I
  import tensorflow_hub as hub
  import tokenization
  iIii1i = 512
  iiIIi = hub . KerasLayer ( ooOOO0 , trainable = True )
  O0o0OooO0Oo = iiIIi . resolved_object . vocab_file . asset_path . numpy ( )
  Ii1IiII1i1I = iiIIi . resolved_object . do_lower_case . numpy ( )
  OOO00OOoO0 = tokenization . FullTokenizer ( O0o0OooO0Oo , Ii1IiII1i1I )
  oOo0o = [ ]
  i1iIi = [ ]
  iI1I1i = [ ]
  Oo000000 = np . zeros ( iIii1i , dtype = np . int32 )
  o0oOoOoOo = [ ]
  for data in IiIi1iIi :
   if 7 - 7: ooOOO
   i1iIi = [ '[CLS]' ] + sum ( [ OOO00OOoO0 . tokenize ( sent ) + [ '[SEP]' ] for sent in data ] , [ ] )
   i1iIi = i1iIi [ : iIii1i - 1 ] + [ '[SEP]' ] if len ( i1iIi ) > iIii1i else i1iIi
   if 50 - 50: iI1iII1I1I1i - ooo000
   Oo000000 = np . zeros ( iIii1i , dtype = np . int32 )
   Oo000000 [ 0 : len ( i1iIi ) ] = 1
   iI1I1i . append ( Oo000000 )
   if 91 - 91: OooOoo - Ooo0Ooo + i1iiIII111
   Oo000000 = np . zeros ( iIii1i , dtype = np . int32 )
   Oo000000 [ i1iIi . index ( '[SEP]' ) : len ( i1iIi ) ] = 1
   o0oOoOoOo . append ( Oo000000 )
   if 97 - 97: I1Ii1I1 * I1Ii1I1 . Ooo0Ooo + IIiIIiIi11I1 . i1iiIII111
   i1iIi = OOO00OOoO0 . convert_tokens_to_ids ( i1iIi )
   i1iIi = i1iIi + [ 0 ] * ( iIii1i - len ( i1iIi ) )
   oOo0o . append ( i1iIi )
  return [ np . array ( oOo0o , dtype = np . int32 ) , np . array ( iI1I1i , dtype = np . int32 ) , np . array ( o0oOoOoOo , dtype = np . int32 ) ]
  if 19 - 19: OooOoo
  if 31 - 31: IIiIIiIi11I1 % I1I + I1Ii1I1 * Ii - Iii1i
  if self . dtype is not None :
   Ooo0OOooO = Ooo0OOooO . astype ( self . dtype . as_numpy_dtype )
  else :
   Ooo0OOooO = Ooo0OOooO . astype ( float )
   if 81 - 81: i1iiIII111 * IiIIii11Ii % i1iiIII111
   if 1 - 1: IIiIIiIi11I1
  return Ooo0OOooO
  if 99 - 99: I1I / i1iiIII111 / I11iiIi11i1I * I11iiIi11i1I + ooo000
 def _processData ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 68 - 68: IiI11Ii111 % Ooo0Ooo / Ii * i1I - oOO
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 38 - 38: Ii - i1iiIII111 + Ooo0Ooo . i1i1i1111I % IIiIIiIi11I1
  if 54 - 54: i1I % i1iiIII111 / i1 % iI1iII1I1I1i
  if 34 - 34: Ii * i1I / ooOOO
  if 51 - 51: I11iiIi11i1I . Ii / i1
  if 58 - 58: Iii1i - Ooo0Ooo
  if 7 - 7: ooOOO
  if 69 - 69: Iii1i - oOo0O00 % Ii % i1I - I1I
  if 69 - 69: oOo0O00 % i1 . oOO - i1iiIII111 * oOO / I1I
  if 2 - 2: i1i1i1111I - i1 + Iii1i - OooOoo . ooOOO * I1Ii1I1
  if 85 - 85: ooOOO * I1Ii1I1 - Ooo0Ooo
  if 27 - 27: IiIIii11Ii / oOo0O00 . oOO + oOO * i1i1i1111I * i1i1i1111I
  if 20 - 20: Iii1i
  if 31 - 31: ooOOO
  if 23 - 23: iI1iII1I1I1i
  if 44 - 44: I11iiIi11i1I
  OOo00oOoOo : List [ int ] = np . shape ( data )
  Ooo0OOooO : np . ndarray = data [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( self . crops [ ooOoooO0OOo ] ) if ooOoooO0OOo in self . crops else slice ( None , None ) ) for ooOoooO0OOo , v in enumerate ( OOo00oOoOo [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( self . sourceCol ) ) ]
  if 99 - 99: I11iiIi11i1I - IIiIIiIi11I1 . IiI11Ii111 * i1i1i1111I + IiIIii11Ii
  if 12 - 12: ooo000 / oOO / ooOOO
  if ( step == self . StepEnum . Input ) :
   return Ooo0OOooO
   if 93 - 93: IiI11Ii111
   if 99 - 99: i1i1i1111I
  OO0o = None
  if 21 - 21: I1Ii1I1 + I11iiIi11i1I
  if 89 - 89: IIiIIiIi11I1 / IiIIii11Ii * i1iiIII111 . Ooo0Ooo - Oo
  for O0oOOOoo in self . transformations :
   if 66 - 66: I1Ii1I1 / IiI11Ii111 / IIiIIiIi11I1 * i1I
   if ( O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch ) :
    if 96 - 96: i1 . IIiIIiIi11I1 * iI1iII1I1I1i % i1iiIII111 - IiIIii11Ii * I1I
    if ( OO0o is None ) :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 6 - 6: iI1iII1I1I1i
     if 25 - 25: i1I
    O0oOOOoo . preExtract ( OO0o )
    if 46 - 46: IiIIii11Ii
    if 84 - 84: Iii1i - iI1iII1I1I1i + i1i1i1111I
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 18 - 18: IiI11Ii111
  if ( step == self . StepEnum . Transformed ) :
   return Ooo0OOooO
   if 67 - 67: i1I . IIiIIiIi11I1 / oOO - i1iiIII111 % Oo
   if 80 - 80: i1iiIII111
  IiIiIIIiIIiI : str = self . separator
  ooOOO0 : str = self . tokenSource
  IIIiiiI1i1 : str = self . preprocessSource
  OOOO = [ ]
  if 10 - 10: i1i1i1111I + oOo0O00 - oOo0O00 * Iii1i - Iii1i
  for ooOoooO0OOo in range ( len ( Ooo0OOooO ) ) :
   if ( IiIiIIIiIIiI is not None ) :
    OOOO . append ( ( IiIiIIIiIIiI . join ( Ooo0OOooO [ ooOoooO0OOo ] ) ) . replace ( IiIiIIIiIIiI , ' ' ) )
   else :
    OOOO . append ( ' ' . join ( Ooo0OOooO [ ooOoooO0OOo ] ) )
    if 37 - 37: i1i1i1111I / I11iiIi11i1I / IiI11Ii111
    if 77 - 77: IiIIii11Ii
  import tensorflow_hub as hub
  import tensorflow_text as text
  if 15 - 15: ooOOO
  if 99 - 99: Oo + i1I / I1I
  iI = hub . KerasLayer ( IIIiiiI1i1 )
  o0000O00OoOoO = iI ( OOOO )
  oOO0oooo0ooO = hub . KerasLayer ( ooOOO0 , trainable = True )
  II1iIi1 = oOO0oooo0ooO ( o0000O00OoOoO )
  if 72 - 72: i1iiIII111 . I1Ii1I1
  if 24 - 24: Oo % Iii1i * I1I - OooOoo * I11iiIi11i1I / i1
  return II1iIi1 [ "pooled_output" ]
  if 53 - 53: I11iiIi11i1I
 def _processDataToShow ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 35 - 35: I1I * oOO - Ii / I1I - IiI11Ii111
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 86 - 86: I11iiIi11i1I / IiIIii11Ii + ooo000 / i1I
  if 53 - 53: ooOOO + IiI11Ii111 / Ooo0Ooo . IiI11Ii111 + IIiIIiIi11I1
  if 1 - 1: ooo000
  if 76 - 76: ooOOO * OooOoo
  if 74 - 74: i1I * Oo
  if 86 - 86: Ii / i1
  if 32 - 32: i1i1i1111I . ooo000 * I1I / Oo + Iii1i % I1I
  if 92 - 92: Iii1i
  if 53 - 53: i1iiIII111
  if 27 - 27: OooOoo / Oo * i1iiIII111 + Ooo0Ooo
  if 49 - 49: ooOOO % I1I - OooOoo * ooo000 / I1I + i1
  if 63 - 63: Ooo0Ooo + ooOOO . Ooo0Ooo . iI1iII1I1I1i
  if 21 - 21: Ii
  if 96 - 96: oOo0O00 % Ooo0Ooo / oOo0O00 . OooOoo
  if 37 - 37: Ooo0Ooo / IIiIIiIi11I1 . I11iiIi11i1I
  OOo00oOoOo : List [ int ] = np . shape ( data )
  Ooo0OOooO : np . ndarray = data [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( self . crops [ ooOoooO0OOo ] ) if ooOoooO0OOo in self . crops else slice ( None , None ) ) for ooOoooO0OOo , v in enumerate ( OOo00oOoOo [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( self . sourceCol ) ) ]
  if 9 - 9: IiIIii11Ii - i1 + I1I - ooOOO * IIiIIiIi11I1
  if 50 - 50: IIiIIiIi11I1 / iI1iII1I1I1i / OooOoo
  if ( step == self . StepEnum . Input ) :
   return Ooo0OOooO
   if 3 - 3: IIiIIiIi11I1 * ooo000
   if 29 - 29: OooOoo % ooOOO . IiIIii11Ii * ooOOO % Oo
  OO0o = None
  if 35 - 35: oOo0O00 % ooo000 * i1i1i1111I . Oo % oOo0O00 / ooOOO
  if 32 - 32: IiI11Ii111 % I11iiIi11i1I % IIiIIiIi11I1 / Iii1i % Iii1i / i1iiIII111
  for O0oOOOoo in self . transformations :
   if 99 - 99: Ooo0Ooo % i1iiIII111 % IIiIIiIi11I1 . I1Ii1I1 / oOo0O00 . Ooo0Ooo
   if ( O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch ) :
    if 33 - 33: i1I + ooo000 / IiI11Ii111 * i1I % Oo + ooo000
    if ( OO0o is None ) :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 61 - 61: i1 / Ii + IiIIii11Ii + i1 - oOO
     if 43 - 43: Ooo0Ooo / Iii1i % i1i1i1111I * Oo
    O0oOOOoo . preExtract ( OO0o )
    if 73 - 73: Ooo0Ooo / Ii
    if 27 - 27: oOO - i1i1i1111I * oOO . iI1iII1I1I1i
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 92 - 92: I1I / I1I
  if ( step == self . StepEnum . Transformed ) :
   return Ooo0OOooO
   if 48 - 48: Ii
   if 33 - 33: i1I
  IiIiIIIiIIiI : str = self . separator
  ooOOO0 : str = self . tokenSource
  IIIiiiI1i1 : str = self . preprocessSource
  OOOO = [ ]
  if 53 - 53: ooOOO
  for ooOoooO0OOo in range ( len ( Ooo0OOooO ) ) :
   if ( IiIiIIIiIIiI is not None ) :
    OOOO . append ( ( IiIiIIIiIIiI . join ( Ooo0OOooO [ ooOoooO0OOo ] ) ) . replace ( IiIiIIIiIIiI , ' ' ) )
   else :
    OOOO . append ( ' ' . join ( Ooo0OOooO [ ooOoooO0OOo ] ) )
    if 83 - 83: I1I - i1iiIII111 . IiI11Ii111 / i1i1i1111I . ooOOO
    if 77 - 77: i1 * IIiIIiIi11I1 . ooOOO * I1Ii1I1 % Iii1i
  import tensorflow_hub as hub
  import tensorflow_text as text
  if 63 - 63: i1iiIII111 - Oo
  if 12 - 12: i1 % ooOOO % Ooo0Ooo . IiIIii11Ii * IiIIii11Ii
  iI = hub . KerasLayer ( IIIiiiI1i1 )
  o0000O00OoOoO = iI ( OOOO )
  oOO0oooo0ooO = hub . KerasLayer ( ooOOO0 , trainable = True )
  II1iIi1 = oOO0oooo0ooO ( o0000O00OoOoO )
  if 97 - 97: I1Ii1I1 % Oo . i1I * Iii1i
  if 86 - 86: I1Ii1I1 / i1 / Ii
  return II1iIi1 [ "pooled_output" ]
  if 94 - 94: I1I / I1I
class Ii1Ii1iii ( Oo0ooo0OO0 ) :
 if 93 - 93: IiIIii11Ii / oOo0O00 * Ooo0Ooo * i1i1i1111I / IIiIIiIi11I1 / ooo000
 if 1 - 1: Ii + oOO
 if 23 - 23: Oo - I1Ii1I1 . i1i1i1111I / Ooo0Ooo / Ooo0Ooo . i1
 if 90 - 90: I11iiIi11i1I + oOO
 if 87 - 87: i1I % iI1iII1I1I1i + IiI11Ii111 / i1I % I1I
 if 58 - 58: IiI11Ii111 / ooOOO - ooOOO + IiI11Ii111
 if 28 - 28: I1I . oOo0O00 - oOO - i1i1i1111I - Oo % OooOoo
 class StepEnum ( I1i1i ) :
  if 7 - 7: oOO * Oo
  if 72 - 72: i1I - OooOoo * I11iiIi11i1I . I1Ii1I1
  if 69 - 69: i1 / Ii
  if 66 - 66: i1i1i1111I % oOO / i1i1i1111I % I11iiIi11i1I + oOO
  if 12 - 12: i1iiIII111 + OooOoo % I1Ii1I1
  if 6 - 6: I1I - i1 / i1i1i1111I * I11iiIi11i1I
  if 19 - 19: i1i1i1111I - oOO - i1iiIII111 . I1Ii1I1 - ooOOO
  if 44 - 44: Ii
  CircularDataDefined = 2
  if 98 - 98: Iii1i
 def __init__ ( self , sourceCol : str = "None:None" , dtype : 'tf.DType' = None , source : str = None , order : int = 0 ) :
  if 100 - 100: Iii1i * Iii1i * i1iiIII111 . i1I / i1i1i1111I . I1I
  if 62 - 62: iI1iII1I1I1i
  if 69 - 69: Ii + IiI11Ii111 * OooOoo . i1iiIII111 + Oo - I11iiIi11i1I
  if 83 - 83: ooOOO + i1i1i1111I / oOO
  if 19 - 19: i1I * IIiIIiIi11I1 % IIiIIiIi11I1 + i1i1i1111I % OooOoo
  if 23 - 23: IiI11Ii111 % i1iiIII111 . ooo000
  if 61 - 61: I11iiIi11i1I
  if 56 - 56: Ii . Ii % ooOOO . i1
  if 49 - 49: i1iiIII111 * IiIIii11Ii . I11iiIi11i1I
  if 36 - 36: ooo000 / i1I - i1 . OooOoo - ooOOO
  if 66 - 66: IiIIii11Ii + Ii
  if 47 - 47: i1I / Ii - oOO
  if 92 - 92: IIiIIiIi11I1
  super ( ) . __init__ ( instanceClass = OoiI1iiI11IIi1 . Columns , dtype = dtype , sourceCol = sourceCol )
  if 7 - 7: i1 / IiI11Ii111 - oOO % iI1iII1I1I1i
  if 80 - 80: IiI11Ii111 . I11iiIi11i1I * I1Ii1I1
  self . oneHotColumns : Dict [ int , Set [ str ] ] = { }
  if 17 - 17: Ii
  if 35 - 35: Oo
  self . transformations : List [ Oo000oO00O . Columns . Config ] = [ ]
  if 83 - 83: IIiIIiIi11I1 % IIiIIiIi11I1
  if 32 - 32: ooo000 / I1I * i1i1i1111I % ooOOO - i1
  self . circular : List [ O000oOo0 ] = [ ]
  if 20 - 20: OooOoo . ooo000 * oOo0O00 % I1Ii1I1 * i1I % oOo0O00
  if 53 - 53: Iii1i / Ooo0Ooo / OooOoo
  self . _colToCircular : Dict [ int , int ] = { }
  if 48 - 48: I11iiIi11i1I * I1I - oOo0O00 . i1i1i1111I + Ii - ooo000
  if 38 - 38: I1Ii1I1 - IiIIii11Ii + Ii + ooo000 / IiIIii11Ii / i1iiIII111
  self . preprocessInBatch : bool = True
  if 70 - 70: oOo0O00 / Iii1i / i1i1i1111I * ooo000 - Ooo0Ooo + ooOOO
  if 38 - 38: I11iiIi11i1I % Iii1i % Oo / i1 + oOO
  self . _classCount : int = None
  if 90 - 90: I1Ii1I1 % i1iiIII111 + OooOoo * IiI11Ii111 - Ii
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 87 - 87: Ii + Ii + i1 + I1I / IiIIii11Ii / I1I
  if 68 - 68: i1iiIII111 % Oo * ooo000
  if 94 - 94: Oo / i1i1i1111I
  if 13 - 13: iI1iII1I1I1i % iI1iII1I1I1i % Oo * Ii % I1I % i1
  if 76 - 76: I1I
  if 64 - 64: ooo000 / i1iiIII111
  if 29 - 29: Ooo0Ooo
  if 5 - 5: i1i1i1111I . I11iiIi11i1I % i1iiIII111 - Oo - I11iiIi11i1I - Ooo0Ooo
  if 100 - 100: I11iiIi11i1I * Iii1i . I1I / Iii1i . i1I
  if 14 - 14: Oo - OooOoo % IiI11Ii111
  if 68 - 68: i1
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "source" :
    if type ( iiiiIi1IiiIi ) == str :
     iiiiIi1IiiIi = int ( iiiiIi1IiiIi . split ( ) [ - 1 ] )
     if 89 - 89: IIiIIiIi11I1 + IIiIIiIi11I1 * oOo0O00 + IiI11Ii111
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 16 - 16: Iii1i - I1I % IiIIii11Ii - IiIIii11Ii % Ii / i1i1i1111I
    self . _train = train
    self . _fromNode = train . sources [ iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , int ) else train . dppNodes [ iiiiIi1IiiIi ]
   elif Ii1I == "oneHotColumns" :
    if 40 - 40: Oo . i1I % Oo + oOo0O00 % i1
    for ( IIIi1iIii1 , i11iiiIIIII ) in iiiiIi1IiiIi :
     self . oneHotColumns [ IIIi1iIii1 ] = set ( i11iiiIIIII )
   elif Ii1I == "transformations" :
    if 10 - 10: ooOOO
    setattr ( self , Ii1I , [ ( Oo000oO00O . createFromJSON ( tx ) if "_instanceClass" in tx else tx ) for tx in iiiiIi1IiiIi ] )
   elif Ii1I == "circular" :
    if 5 - 5: oOo0O00 * I11iiIi11i1I / Ooo0Ooo % Ii * Iii1i + i1iiIII111
    setattr ( self , Ii1I , [ O000oOo0 . createFromJSON ( ci ) for ci in iiiiIi1IiiIi ] )
    if 31 - 31: Ooo0Ooo - Ii - Oo % Oo
    if 96 - 96: Iii1i - Ii
    self . updateColToCircular ( )
   elif Ii1I == "dtype" :
    if 25 - 25: I11iiIi11i1I
    if iiiiIi1IiiIi is not None :
     self . dtype = O0 . getDataType ( iiiiIi1IiiIi )
   elif Ii1I == "_getDataMode" :
    setattr ( self , Ii1I , II1IiI1I [ iiiiIi1IiiIi ] )
   elif Ii1I == "crops" :
    self . crops = { idx : crop for idx , crop in enumerate ( iiiiIi1IiiIi ) if crop is not None }
   elif Ii1I in [ "sourceCol" , "_epochSize" , "outputset" , "_order" , "_shape" , "preprocessInBatch" , "_dataShape" , "_key" , "_classCount" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 27 - 27: ooo000 - i1i1i1111I % Iii1i
 def copy ( self , node : 'DataPreprocessing.Node.Columns' ) -> 'DataPreprocessing.Node.Columns' :
  if 50 - 50: iI1iII1I1I1i * i1i1i1111I
  if 42 - 42: Oo / I1I / i1iiIII111 + Ii + I11iiIi11i1I - oOO
  if 24 - 24: Oo % IIiIIiIi11I1 - oOO - OooOoo
  if 80 - 80: ooOOO % oOo0O00
  if 96 - 96: Oo
  if 31 - 31: Iii1i % iI1iII1I1I1i % I1I
  if 44 - 44: IIiIIiIi11I1 / oOO * I11iiIi11i1I
  if 18 - 18: I1I . IiIIii11Ii / Oo % Ii
  if 14 - 14: iI1iII1I1I1i + Iii1i * Ii % IiIIii11Ii % i1I % i1i1i1111I
  if 38 - 38: I1Ii1I1 % iI1iII1I1I1i . ooOOO
  if 75 - 75: IiI11Ii111 - i1I
  if 80 - 80: IiI11Ii111 - ooo000 % oOo0O00 * IiI11Ii111 % iI1iII1I1I1i % i1i1i1111I
  if 67 - 67: oOO / i1I + ooo000
  super ( ) . copy ( node )
  node . oneHotColumns = { idx : set ( [ * oneHotSet ] ) for idx , oneHotSet in self . oneHotColumns . items ( ) }
  node . circular = [ cir . copy ( ) for cir in self . circular ]
  if 82 - 82: OooOoo / i1I + oOo0O00 . I11iiIi11i1I . oOo0O00
 @ property
 def colToCircular ( self ) -> Dict [ int , int ] :
  if 73 - 73: I1Ii1I1 / Oo / i1 / OooOoo + Ooo0Ooo
  if 52 - 52: Ii % IiI11Ii111 - Iii1i * IIiIIiIi11I1 % OooOoo
  if 51 - 51: iI1iII1I1I1i . Iii1i - iI1iII1I1I1i * I1I / oOO + i1
  if 67 - 67: i1iiIII111 / IiI11Ii111 * i1 + OooOoo % oOO
  if 97 - 97: oOo0O00
  if 1 - 1: Oo - i1I / IiI11Ii111
  if 56 - 56: oOO . ooo000 / i1I
  if 98 - 98: OooOoo % ooOOO - i1i1i1111I
  if 71 - 71: ooo000 % Ooo0Ooo + i1i1i1111I * I1I
  if 2 - 2: Ooo0Ooo - OooOoo . I11iiIi11i1I / i1I + i1iiIII111
  return self . _colToCircular
  if 97 - 97: ooOOO
 @ property
 def hasData ( self ) -> bool :
  if 25 - 25: oOO - i1 / i1I
  if 99 - 99: ooOOO % Ii * Iii1i
  if 22 - 22: Iii1i / I11iiIi11i1I . IiI11Ii111 - ooo000
  if 50 - 50: Ii
  if 15 - 15: I1I % i1i1i1111I . I1I * IiI11Ii111
  if 43 - 43: Ii
  if 9 - 9: Ii % ooOOO % oOo0O00 . IiI11Ii111
  if 10 - 10: Ii + Ooo0Ooo - I11iiIi11i1I / i1I / Ooo0Ooo - OooOoo
  if 7 - 7: i1 + ooOOO * Iii1i + iI1iII1I1I1i - IiI11Ii111 - oOo0O00
  if 51 - 51: iI1iII1I1I1i . OooOoo
  if 93 - 93: OooOoo - OooOoo % Iii1i + oOO
  for O0oo0 in self . getRootSources ( ) :
   if isinstance ( O0oo0 , o0ooo0oOoO ) :
    O0oo0 : o0ooo0oOoO
    if not ( O0oo0 . hasData ( ) ) :
     return False
   else :
    return False
  return True
  if 12 - 12: IIiIIiIi11I1 - Ii - i1I / IiI11Ii111 * ooOOO . Iii1i
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 51 - 51: oOO * i1i1i1111I + I1I / iI1iII1I1I1i / i1
  if 12 - 12: IiIIii11Ii + I1Ii1I1
  if 26 - 26: Oo - oOO - i1i1i1111I
  if 60 - 60: I1I
  if 22 - 22: i1i1i1111I . I1Ii1I1 % ooo000 . i1 . i1 - I11iiIi11i1I
  if 86 - 86: iI1iII1I1I1i / oOO - i1I
  if 45 - 45: I1I . iI1iII1I1I1i / oOO . oOo0O00
  if 40 - 40: Ii % I1Ii1I1 * i1I
  if 42 - 42: OooOoo
  if 51 - 51: Ii % Ooo0Ooo . ooOOO
  if 37 - 37: i1
  if 58 - 58: ooOOO * Oo
  if 51 - 51: Oo % iI1iII1I1I1i / IIiIIiIi11I1 * I11iiIi11i1I
  if 22 - 22: Iii1i . I1Ii1I1
  if 82 - 82: IIiIIiIi11I1
  if 76 - 76: Oo / I1I * I11iiIi11i1I + I1Ii1I1 - i1I
  if 70 - 70: IIiIIiIi11I1 * IiI11Ii111 * iI1iII1I1I1i
  o0o0oooO0 = o0o ( self . train , self . getRootSources ( False ) , sourceDataset = sourceDataset )
  if 30 - 30: oOO / Oo / I1Ii1I1 % oOO
  if 88 - 88: Iii1i - i1 + i1I
  iiI1iIi = o0o0oooO0 . getData ( start = start , end = end )
  if 97 - 97: Iii1i * i1I - Ooo0Ooo % ooo000
  if 88 - 88: iI1iII1I1I1i
  return self . getProcessedData ( iiI1iIi , step = step )
  if 62 - 62: ooo000 . i1 - I11iiIi11i1I - Iii1i / Iii1i + ooo000
 def refreshItemShape ( self ) :
  if 70 - 70: I1Ii1I1 . I1Ii1I1
  if 29 - 29: i1iiIII111 + I1Ii1I1 * ooo000 . IiIIii11Ii * i1iiIII111 . oOO
  if 58 - 58: ooOOO
  if 52 - 52: i1i1i1111I / I1Ii1I1 % i1I . i1iiIII111 / i1I
  if 51 - 51: Ii % i1I % ooOOO % i1
  if 56 - 56: oOO % oOO + I1Ii1I1 . Ii / i1iiIII111
  if 5 - 5: i1 * oOO * IiI11Ii111 - ooOOO * I11iiIi11i1I
  if 38 - 38: oOo0O00 / i1iiIII111 % IiI11Ii111 * oOO % i1i1i1111I * i1i1i1111I
  if 37 - 37: oOO - iI1iII1I1I1i % Ii
  oo00 = self . getInputShape ( ) [ 1 : ]
  ooO0OOo = [ * oo00 [ : - 1 ] , len ( o0ooo0oOoO . getColList ( oo00 [ - 1 ] , self . sourceCol ) ) ]
  if 89 - 89: i1i1i1111I - I1Ii1I1 + oOO / iI1iII1I1I1i - IIiIIiIi11I1 - I1I
  if 70 - 70: Iii1i / iI1iII1I1I1i % ooo000 + IiI11Ii111 . iI1iII1I1I1i . IIiIIiIi11I1
  if len ( self . oneHotColumns ) :
   ooO0OOo [ - 1 ] += sum ( [ max ( [ 1 , len ( oneHotSet ) ] ) for oneHotSet in self . oneHotColumns . values ( ) ] ) - len ( self . oneHotColumns )
   if 79 - 79: ooo000 - OooOoo % i1I % I11iiIi11i1I - IIiIIiIi11I1
   if 92 - 92: i1iiIII111 / I11iiIi11i1I
  self . setItemShape ( [ * ooO0OOo ] )
  if 74 - 74: Ii - oOO
 def setClassCount ( self , classCount : int ) :
  if 41 - 41: Iii1i % I1Ii1I1 - i1 * Ii + ooOOO * Iii1i
  if 85 - 85: ooo000 - IiI11Ii111 * i1iiIII111
  if 88 - 88: Ii % Oo . ooOOO / oOO
  if 23 - 23: IiIIii11Ii + ooOOO + I11iiIi11i1I / iI1iII1I1I1i - ooo000 % I1I
  if 18 - 18: oOo0O00 % i1 / OooOoo
  if 88 - 88: i1I * ooo000 + I1I / i1I % Oo
  if 44 - 44: ooOOO / i1iiIII111 . oOO / i1iiIII111
  if 93 - 93: i1iiIII111 / I1Ii1I1 - I1Ii1I1 % ooo000
  if 76 - 76: i1 * i1iiIII111
  if 68 - 68: IiIIii11Ii * i1 . Oo % ooo000 % IiIIii11Ii
  self . _classCount = classCount
  if 47 - 47: IIiIIiIi11I1
 def getClassCount ( self ) -> int :
  if 67 - 67: oOO - Iii1i + IiI11Ii111
  if 42 - 42: oOo0O00 * i1 + I1I . oOo0O00
  if 81 - 81: I11iiIi11i1I . i1i1i1111I % IIiIIiIi11I1 . IIiIIiIi11I1 % I1Ii1I1
  if 7 - 7: i1iiIII111 % i1I
  if 31 - 31: i1i1i1111I . I1I + ooo000
  if 40 - 40: i1iiIII111
  if 38 - 38: i1iiIII111 . I1I + I1I . I1Ii1I1
  if 47 - 47: Ooo0Ooo / I11iiIi11i1I - i1 . iI1iII1I1I1i - i1iiIII111
  if 6 - 6: IiI11Ii111
  if 35 - 35: Oo * oOo0O00
  if 99 - 99: Ii
  if 100 - 100: iI1iII1I1I1i / IiI11Ii111 - I11iiIi11i1I
  if self . _classCount is not None :
   return self . _classCount
   if 16 - 16: I11iiIi11i1I % oOO - IiI11Ii111 . OooOoo * Iii1i - ooOOO
   if 47 - 47: I11iiIi11i1I / I11iiIi11i1I
  OoO0 = self . getData ( sourceDataset = I111II1II111I . Dataset . Types . Train )
  if 100 - 100: Ii - i1I + Ooo0Ooo % iI1iII1I1I1i
  if 69 - 69: oOo0O00 + OooOoo / i1iiIII111 - I11iiIi11i1I
  if ( isinstance ( OoO0 , list ) or isinstance ( OoO0 , np . ndarray ) ) and len ( OoO0 ) > 0 :
   O0O00OOO00 = o0ooo0oOoO . getDataClassCount ( OoO0 )
   self . setClassCount ( O0O00OOO00 )
   return O0O00OOO00
  else :
   raise ValueError ( "There is error in getting a valid preprocessing data." )
   if 37 - 37: OooOoo % oOo0O00
 def setCircularOutput ( self , cols : str = "None:None" , minV : float = 0 , maxV : float = 360 ) :
  if 79 - 79: i1i1i1111I
  if 89 - 89: Iii1i + Iii1i / Ii . OooOoo
  if 40 - 40: i1 * i1 % i1i1i1111I
  if 31 - 31: Oo * i1iiIII111
  if 41 - 41: I1I
  if 1 - 1: IIiIIiIi11I1 + I11iiIi11i1I . I1I
  if 82 - 82: oOO - I1Ii1I1 * Oo * oOo0O00 + I11iiIi11i1I + I11iiIi11i1I
  if 79 - 79: i1I - IIiIIiIi11I1 % IIiIIiIi11I1 / i1
  if 55 - 55: iI1iII1I1I1i * oOo0O00 * Ooo0Ooo * OooOoo
  if 96 - 96: OooOoo
  if 47 - 47: I1Ii1I1 * oOo0O00 + i1i1i1111I / I1I % I1Ii1I1
  if 91 - 91: OooOoo . i1i1i1111I / I1I / OooOoo % Iii1i
  if 81 - 81: i1i1i1111I % ooo000 . Iii1i
  if 12 - 12: Ooo0Ooo / IIiIIiIi11I1 + I1I / oOO * iI1iII1I1I1i
  ooOO00o0Oo = o0ooo0oOoO . getColList ( self . getInputShape ( ) [ - 1 ] , self . sourceCol )
  IIII1I11I = o0ooo0oOoO . getColList ( len ( ooOO00o0Oo ) , cols )
  if 62 - 62: OooOoo - i1I
  if 5 - 5: IiI11Ii111 / I11iiIi11i1I . iI1iII1I1I1i
  ooOo0o0Oo0Ooo = set ( )
  for iI1Ii1IiI in self . circular :
   for ooOoooO0OOo in OoOo0000o . parse ( len ( ooOO00o0Oo ) , iI1Ii1IiI . colSel ) :
    ooOo0o0Oo0Ooo . add ( ooOoooO0OOo )
    if 59 - 59: I1I / I1I - i1I % Iii1i / I1Ii1I1 + I1Ii1I1
  if any ( [ ( ooOoooO0OOo in ooOo0o0Oo0Ooo ) for ooOoooO0OOo in IIII1I11I ] ) :
   raise ValueError ( "There has been circular definition on some of the requested columns." )
  elif not len ( OoOo0000o . parse ( len ( ooOO00o0Oo ) , cols ) ) :
   raise ValueError ( "here must be some columns selected." )
  else :
   if 20 - 20: IiI11Ii111 % Ooo0Ooo / Oo / Ooo0Ooo * i1iiIII111
   self . circular . append ( O000oOo0 ( cols , minV , maxV ) )
   if 85 - 85: oOo0O00 . oOO / OooOoo % I1Ii1I1 / i1iiIII111
 def updateColToCircular ( self ) :
  if 84 - 84: i1 * oOO % I1I
  if 41 - 41: ooOOO + Oo - iI1iII1I1I1i - IIiIIiIi11I1 * i1
  ooOO00o0Oo = o0ooo0oOoO . getColList ( self . getInputShape ( ) [ - 1 ] , self . sourceCol )
  if 21 - 21: i1 + i1I . ooOOO + ooOOO
  if 74 - 74: Oo % iI1iII1I1I1i / i1I % iI1iII1I1I1i
  if 1 - 1: I1Ii1I1 % iI1iII1I1I1i
  if 9 - 9: i1iiIII111 . i1
  if 86 - 86: I11iiIi11i1I - Oo - IIiIIiIi11I1 / i1iiIII111 * OooOoo
  if 75 - 75: i1 % OooOoo / Oo . IiIIii11Ii / ooo000
  if 94 - 94: oOO . I1Ii1I1 / Ii . oOO + IiI11Ii111 - iI1iII1I1I1i
  if 67 - 67: i1I % IiIIii11Ii - I1I * IiIIii11Ii * I11iiIi11i1I
  ooOo0o0Oo0Ooo = dict ( )
  for ( o00Oo , iI1Ii1IiI ) in enumerate ( self . circular ) :
   for ooOoooO0OOo in OoOo0000o . parse ( len ( ooOO00o0Oo ) , iI1Ii1IiI . colSel ) :
    ooOo0o0Oo0Ooo [ ooOoooO0OOo ] = o00Oo
  self . _colToCircular = ooOo0o0Oo0Ooo
  if 97 - 97: I1I
 def setOneHot ( self , cols : str = "None:None" ) :
  if 3 - 3: i1 + i1i1i1111I - i1I
  if 74 - 74: iI1iII1I1I1i . IiIIii11Ii . I1Ii1I1
  if 27 - 27: i1i1i1111I % OooOoo . i1I * i1I / IiIIii11Ii * Iii1i
  if 12 - 12: IIiIIiIi11I1 / I11iiIi11i1I + I1I
  if 8 - 8: Iii1i / Ooo0Ooo % i1i1i1111I - i1I / IIiIIiIi11I1
  if 12 - 12: OooOoo . Ii - OooOoo * OooOoo * Oo
  if 27 - 27: iI1iII1I1I1i . Ooo0Ooo
  if 60 - 60: Ii / IiI11Ii111 . i1i1i1111I * Oo . ooo000 - Oo
  if 17 - 17: Oo . IiI11Ii111
  if 93 - 93: iI1iII1I1I1i
  if 18 - 18: I11iiIi11i1I + i1 - IiI11Ii111 / I1I * oOo0O00 . i1I
  if 25 - 25: i1iiIII111 - oOO / I1Ii1I1 . iI1iII1I1I1i
  ooOO00o0Oo = o0ooo0oOoO . getColList ( self . getInputShape ( ) [ - 1 ] , self . sourceCol )
  IIII1I11I = o0ooo0oOoO . getColList ( len ( ooOO00o0Oo ) , cols )
  if 84 - 84: I11iiIi11i1I + OooOoo . I1Ii1I1 + i1i1i1111I . Iii1i + oOO
  if 88 - 88: I11iiIi11i1I * i1iiIII111 / i1I . i1iiIII111
  iIIii1i1II1 = self . oneHotColumns
  self . oneHotColumns = { }
  if 49 - 49: Iii1i
  if 28 - 28: i1I * IiIIii11Ii % i1I / Iii1i - i1 . iI1iII1I1I1i
  iiII1I = self . getData ( step = self . StepEnum . Transformed )
  OoooOo = len ( iiII1I )
  iIiI = [ ]
  if 16 - 16: I1Ii1I1 % i1 - oOO
  if 64 - 64: I1Ii1I1 . IiI11Ii111 % Ii
  for ooOoooO0OOo in IIII1I11I :
   oO0oOooo = set ( iiII1I [ : , ooOoooO0OOo ] )
   if len ( oO0oOooo ) > OoooOo / 2 :
    iIiI . append ( ooOoooO0OOo )
   self . oneHotColumns [ ooOoooO0OOo ] = oO0oOooo
   if 37 - 37: Oo * i1iiIII111 + I1Ii1I1 + Iii1i * i1
   if 90 - 90: Ii + Ii / Iii1i . IiIIii11Ii % IIiIIiIi11I1 - i1I
  if len ( iIiI ) :
   raise ValueError ( "The requested column(s) will incur too many categories. Please double-check if you have select the right columns with categorical values." )
   if 99 - 99: IiIIii11Ii - oOo0O00 - i1i1i1111I % iI1iII1I1I1i + IiIIii11Ii % IiIIii11Ii
   if 37 - 37: i1 / IIiIIiIi11I1 + OooOoo . ooOOO
  self . refreshItemShape ( )
  if 60 - 60: Oo . oOO . Oo . I11iiIi11i1I
 def getHeader ( self , step = StepEnum . Output ) -> List [ str ] :
  if 16 - 16: I1I
  if 4 - 4: oOO - Oo / ooo000 - i1i1i1111I + I1Ii1I1 - Ooo0Ooo
  if 67 - 67: oOO
  if 2 - 2: IiIIii11Ii . Oo - i1I / Oo . i1iiIII111
  if 91 - 91: iI1iII1I1I1i
  if 11 - 11: Ii % Ooo0Ooo
  if 58 - 58: i1
  if 7 - 7: i1 * i1i1i1111I + oOo0O00 . IiIIii11Ii
  if 68 - 68: oOo0O00 - ooo000 / I1Ii1I1
  if 15 - 15: Iii1i / i1I . I1Ii1I1 - oOO + IiIIii11Ii % iI1iII1I1I1i
  if 55 - 55: IiI11Ii111 - IIiIIiIi11I1 + I1I . oOO . i1iiIII111 . I1I
  if 86 - 86: ooo000 % I1Ii1I1
  oo = self . fromNode . getHeader ( ) if isinstance ( self . fromNode , Oo0ooo0OO0 ) else self . fromNode . getHeader ( self . outputset )
  if 57 - 57: ooo000 - OooOoo - i1i1i1111I
  if 46 - 46: I11iiIi11i1I . OooOoo / IIiIIiIi11I1 * Ii . Ii
  o000Oo00oOO00 = o0ooo0oOoO . arraySlice ( [ oo ] , self . sourceCol ) [ 0 ] . tolist ( )
  if 35 - 35: Ooo0Ooo - oOo0O00 . i1I + Iii1i
  if 97 - 97: Oo
  if step not in [ self . StepEnum . Output ] :
   return o000Oo00oOO00
   if 7 - 7: IIiIIiIi11I1 % iI1iII1I1I1i * ooOOO . Ii
   if 3 - 3: ooOOO * i1 % oOO % i1I . ooOOO * i1I
  I11iI = self . oneHotColumns
  if len ( I11iI ) > 0 :
   i111i1 = [ ]
   for ooOoooO0OOo , O00O0o0o in enumerate ( o000Oo00oOO00 ) :
    if ooOoooO0OOo in I11iI :
     if 26 - 26: iI1iII1I1I1i % Oo * ooo000 - IiI11Ii111
     for oOoooOOo in I11iI [ ooOoooO0OOo ] :
      i111i1 . append ( O00O0o0o + " (" + oOoooOOo + ") " )
    else :
     i111i1 . append ( O00O0o0o )
   return i111i1
  else :
   return o000Oo00oOO00
   if 63 - 63: ooOOO % i1 / i1iiIII111 / Ooo0Ooo
 def _processData ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 24 - 24: I11iiIi11i1I * i1I
  if 77 - 77: i1I % IiI11Ii111 . iI1iII1I1I1i
  if 2 - 2: ooOOO
  if 22 - 22: OooOoo * I1I . Ii - I11iiIi11i1I
  if 59 - 59: Oo / Ooo0Ooo . I1Ii1I1 . Iii1i * ooOOO
  if 13 - 13: i1 . IiI11Ii111 + I11iiIi11i1I % I11iiIi11i1I % i1I
  if 58 - 58: i1i1i1111I . iI1iII1I1I1i
  if 3 - 3: I11iiIi11i1I % i1I * I11iiIi11i1I + i1i1i1111I . ooo000 % ooOOO
  if 39 - 39: I1Ii1I1 / iI1iII1I1I1i . I11iiIi11i1I + i1 % i1I
  if 57 - 57: iI1iII1I1I1i + oOO . Ii / ooOOO . oOO
  if 6 - 6: i1iiIII111 - i1i1i1111I - I1I / ooo000
  if 73 - 73: oOo0O00
  if 77 - 77: i1i1i1111I . I11iiIi11i1I / i1I - ooOOO
  if 22 - 22: Ooo0Ooo * I11iiIi11i1I % iI1iII1I1I1i / ooo000 * i1I
  if 86 - 86: Ii * Ii + IiIIii11Ii % i1
  if 92 - 92: ooOOO
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  OOo00oOoOo : List [ int ] = np . shape ( data )
  Ooo0OOooO : np . ndarray = data [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( self . crops [ ooOoooO0OOo ] ) if ooOoooO0OOo in self . crops else slice ( None , None ) ) for ooOoooO0OOo , v in enumerate ( OOo00oOoOo [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( self . sourceCol ) ) ]
  if 12 - 12: Oo - Ooo0Ooo + IIiIIiIi11I1 . i1 % I1Ii1I1
  if 63 - 63: oOO * i1 % i1iiIII111
  if step == self . StepEnum . Input :
   return Ooo0OOooO
   if 93 - 93: Oo + i1I - ooo000 * I1Ii1I1
   if 38 - 38: IiI11Ii111 . oOo0O00 - ooo000 % oOO - ooOOO / IiI11Ii111
  OO0o = None
  if 55 - 55: ooOOO
  if 58 - 58: OooOoo + iI1iII1I1I1i . OooOoo . i1iiIII111 % Oo
  for O0oOOOoo in self . transformations :
   if 50 - 50: IiIIii11Ii / i1I
   if O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch :
    if 98 - 98: Ooo0Ooo * ooOOO
    if OO0o is None :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 70 - 70: Iii1i / i1I % ooOOO / ooo000 % oOO
     if 90 - 90: IiI11Ii111 / Ooo0Ooo . ooOOO / IIiIIiIi11I1 - OooOoo
    O0oOOOoo . preExtract ( OO0o )
    if 97 - 97: IiI11Ii111 - i1i1i1111I % Iii1i - i1i1i1111I % i1i1i1111I
    if 39 - 39: I1I
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 15 - 15: i1 * IiI11Ii111 + I1Ii1I1 * Ooo0Ooo / Oo
  if step == self . StepEnum . Transformed :
   return Ooo0OOooO
   if 30 - 30: Ooo0Ooo - Iii1i
   if 44 - 44: Ii / ooOOO
  for iI1Ii1IiI in self . circular :
   O0Ooo , iIi1iII11I , Ii11IiIIiiI = iI1Ii1IiI . min , iI1Ii1IiI . max , iI1Ii1IiI . range
   O0oiIiiI11iI = OoOo0000o . toIndexer ( iI1Ii1IiI . colSel )
   Ooo0OOooO [ ... , O0oiIiiI11iI ] = np . mod ( ( Ooo0OOooO [ ... , O0oiIiiI11iI ] . astype ( float ) - O0Ooo ) , Ii11IiIIiiI )
   if 42 - 42: Oo % i1iiIII111 - Iii1i * IiIIii11Ii / ooOOO
  if step == self . StepEnum . CircularDataDefined :
   return Ooo0OOooO
   if 97 - 97: OooOoo - Oo + IiI11Ii111
   if 13 - 13: Ii + oOo0O00 / Iii1i + i1I
  if len ( self . oneHotColumns ) > 0 :
   if 54 - 54: IIiIIiIi11I1 . IIiIIiIi11I1 * i1i1i1111I * I11iiIi11i1I
   o0i1I1Ii = [ ]
   if 17 - 17: IiI11Ii111 + i1I % Ii % oOO % Iii1i * ooo000
   for ooOoooO0OOo in range ( 0 , len ( Ooo0OOooO [ 0 ] ) ) :
    if ooOoooO0OOo in self . oneHotColumns :
     oOo = Ooo0OOooO [ : , [ ooOoooO0OOo ] ]
     oOo = o0ooo0oOoO . convertCatToNumbers ( oOo , True , { v : ooOoooO0OOo for ooOoooO0OOo , v in enumerate ( self . oneHotColumns [ ooOoooO0OOo ] ) } ) [ "data" ]
     o0i1I1Ii . extend ( oOo )
    else :
     o0i1I1Ii . append ( Ooo0OOooO [ : , [ ooOoooO0OOo ] ] )
     if 57 - 57: I11iiIi11i1I - i1 . i1iiIII111
     if 80 - 80: ooo000 - ooOOO
   Ooo0OOooO = np . column_stack ( o0i1I1Ii )
   if 70 - 70: oOO % i1 % i1I * ooo000
   if 90 - 90: iI1iII1I1I1i % I11iiIi11i1I + i1I - i1i1i1111I + i1iiIII111
  if self . dtype is not None :
   Ooo0OOooO = Ooo0OOooO . astype ( self . dtype . as_numpy_dtype )
  else :
   Ooo0OOooO = Ooo0OOooO . astype ( float )
   if 44 - 44: i1iiIII111 + Ii * Oo . OooOoo % IiI11Ii111
   if 87 - 87: IIiIIiIi11I1 . IiIIii11Ii
  return Ooo0OOooO
  if 32 - 32: Ii - Oo + IIiIIiIi11I1 . Ooo0Ooo . Ii * i1
 def _processDataToShow ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 77 - 77: ooo000 % Ooo0Ooo / i1 + OooOoo - Oo
  if 66 - 66: i1iiIII111 + IiI11Ii111 + ooo000 . Iii1i - Ii
  if 4 - 4: i1I * OooOoo + I11iiIi11i1I + ooOOO % I1Ii1I1
  if 7 - 7: ooo000 - ooOOO * oOO
  if 79 - 79: IIiIIiIi11I1 - Ii - Ooo0Ooo + ooOOO
  if 21 - 21: oOo0O00
  if 41 - 41: IIiIIiIi11I1 + i1iiIII111 - Iii1i % i1I
  if 58 - 58: i1 + I11iiIi11i1I / IiI11Ii111
  if 4 - 4: i1 / ooOOO + ooo000 - OooOoo
  if 82 - 82: i1iiIII111 - oOo0O00
  if 7 - 7: ooo000
  if 81 - 81: IiI11Ii111 % i1 + Ii
  if 2 - 2: Ooo0Ooo * I1Ii1I1 / I1Ii1I1 . oOo0O00 / iI1iII1I1I1i / Ooo0Ooo
  if 62 - 62: IIiIIiIi11I1 * ooo000 + i1iiIII111 / i1i1i1111I % Iii1i - Oo
  return self . _processData ( data , step )
  if 11 - 11: Oo + i1i1i1111I
 def recoverToRawData ( self , items : 'np.ndarray|list[*+]' , revealedIdxs : List [ int ] = None ) -> 'np.ndarray' :
  if 48 - 48: oOO + ooo000 % Iii1i . Iii1i % Oo
  if 61 - 61: ooo000 % IIiIIiIi11I1 - OooOoo % i1i1i1111I / I1Ii1I1
  if 74 - 74: iI1iII1I1I1i + ooOOO . OooOoo - Ooo0Ooo * ooOOO
  if 22 - 22: i1i1i1111I - Oo / Ii / I11iiIi11i1I / i1 + IIiIIiIi11I1
  if 44 - 44: IiIIii11Ii - i1I
  if 94 - 94: Ii % oOO - I1Ii1I1 + IiIIii11Ii
  if 34 - 34: oOo0O00 / Oo / oOO * i1 * I11iiIi11i1I
  if 42 - 42: ooOOO + Ii . Ooo0Ooo
  if 33 - 33: IiIIii11Ii * iI1iII1I1I1i + i1iiIII111
  if 95 - 95: i1i1i1111I / Oo
  if 18 - 18: iI1iII1I1I1i / oOo0O00
  if 99 - 99: IIiIIiIi11I1 % IiI11Ii111 * i1i1i1111I * iI1iII1I1I1i - ooo000
  if 98 - 98: oOo0O00 / I1Ii1I1
  if 63 - 63: I1I . oOO
  if 69 - 69: I1Ii1I1 * IIiIIiIi11I1 . Iii1i + oOO
  items = np . array ( items )
  if 8 - 8: IiI11Ii111
  if 50 - 50: ooOOO . i1iiIII111
  if revealedIdxs is None :
   revealedIdxs = [ * range ( 0 , items . shape [ - 1 ] ) ]
   if 92 - 92: Ii / IiI11Ii111 - i1iiIII111 / oOO * OooOoo % ooOOO
   if 80 - 80: i1 + oOo0O00
  iiIII1 = [ ]
  if 2 - 2: Oo
  if 66 - 66: ooo000
  if len ( self . oneHotColumns ) > 0 :
   if 57 - 57: oOo0O00 % i1i1i1111I % IiIIii11Ii - I1Ii1I1
   iiiii1iI1 = [ * self . oneHotColumns . keys ( ) ]
   iiiii1iI1 . sort ( )
   if 36 - 36: IiIIii11Ii + ooOOO + Ooo0Ooo
   if 7 - 7: oOO / i1i1i1111I + IiI11Ii111 - I1I % iI1iII1I1I1i
   o0i1I1Ii = [ ]
   oOoo0Oo0o0O0 = 0
   o0oOOo0OOO0oO = 0
   if 91 - 91: Iii1i . i1iiIII111 * IiI11Ii111 / OooOoo . oOO
   for ooOoooO0OOo in range ( 0 , self . getShape ( ) [ - 1 ] ) :
    if ooOoooO0OOo == oOoo0Oo0o0O0 :
     if ooOoooO0OOo in iiiii1iI1 :
      if 59 - 59: ooOOO % ooo000 % i1I % Ooo0Ooo % i1I
      Oo0OoOO0 = self . oneHotColumns [ ooOoooO0OOo ]
      O0ooO00o0O = len ( Oo0OoOO0 )
      oOoo0Oo0o0O0 += O0ooO00o0O
      o0oOOo0OOO0oO += 1
      if 68 - 68: IiI11Ii111 / oOo0O00 . IIiIIiIi11I1 + OooOoo % IIiIIiIi11I1
      if all ( [ ooOoooO0OOo in revealedIdxs for i in range ( ooOoooO0OOo , ooOoooO0OOo + O0ooO00o0O ) ] ) :
       if 14 - 14: OooOoo - ooo000 + i1
       o0O0O00 = items [ ... , ooOoooO0OOo : ooOoooO0OOo + O0ooO00o0O ]
       oO0O0oo00Oo = np . argmax ( o0O0O00 , axis = - 1 )
       iiIii1IiII = { i : v for i , v in enumerate ( Oo0OoOO0 ) }
       o0i1I1Ii . append ( np . reshape ( np . frompyfunc ( lambda IiIIiiII : iiIii1IiII [ IiIIiiII ] , 1 , 1 ) ( oO0O0oo00Oo ) , [ * o0O0O00 . shape [ : - 1 ] , 1 ] ) )
       iiIII1 . append ( o0oOOo0OOO0oO - 1 )
      else :
       raise ValueError ( "Column selection not covered all one-hot indices cannot perform recovering data." )
     else :
      oOoo0Oo0o0O0 += 1
      o0oOOo0OOO0oO += 1
      if ooOoooO0OOo in revealedIdxs :
       o0i1I1Ii . append ( items [ : , [ ooOoooO0OOo ] ] )
       iiIII1 . append ( o0oOOo0OOO0oO - 1 )
       if 5 - 5: IiI11Ii111
       if 70 - 70: ooOOO - ooOOO / I1I / i1 % iI1iII1I1I1i % I1Ii1I1
   items = np . column_stack ( o0i1I1Ii )
   if 67 - 67: i1I / Oo
  else :
   if 20 - 20: oOO
   iiIII1 = [ * range ( 0 , self . getShape ( ) [ - 1 ] ) ]
   if 64 - 64: ooo000
   if 21 - 21: I1Ii1I1 / I11iiIi11i1I % i1I . I1I % I1Ii1I1
  oo00 = self . getInputShape ( )
  O0oO000O = OoOo0000o . parse ( oo00 [ - 1 ] , self . sourceCol )
  if 19 - 19: Ii
  if 15 - 15: I1Ii1I1
  for iI1Ii1IiI in self . circular :
   O0Ooo , iIi1iII11I , Ii11IiIIiiI = iI1Ii1IiI . min , iI1Ii1IiI . max , iI1Ii1IiI . range
   O0oiIiiI11iI = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , iI1Ii1IiI . colSel ) if i in iiIII1 ]
   items [ ... , O0oiIiiI11iI ] = np . mod ( ( items [ ... , O0oiIiiI11iI ] . astype ( float ) - O0Ooo ) , Ii11IiIIiiI )
   if 30 - 30: Iii1i . i1i1i1111I
   if 89 - 89: iI1iII1I1I1i - ooo000 - Ii . I11iiIi11i1I . IiI11Ii111
  if len ( self . transformations ) :
   if 86 - 86: IIiIIiIi11I1 * ooo000 * Iii1i . i1i1i1111I % oOo0O00
   for O0oOOOoo in reversed ( self . transformations ) :
    if 25 - 25: i1i1i1111I - Ii + i1
    i1III1 = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , O0oOOOoo . colSel ) if i in iiIII1 ]
    Oo0o00oOOO00 = np . vectorize ( O0oOOOoo . transformFrom ) ( items [ ... , i1III1 ] )
    if 18 - 18: oOo0O00 + Ooo0Ooo
    if 76 - 76: Oo * Iii1i . I1I
    if items . dtype != Oo0o00oOOO00 . dtype :
     if len ( i1III1 ) != items . shape [ - 1 ] :
      items = items . astype ( np . dtype ( "O" ) )
     else :
      items = items . astype ( Oo0o00oOOO00 . dtype )
      if 94 - 94: iI1iII1I1I1i
      if 97 - 97: Iii1i / ooOOO + i1I + ooo000
    items [ ... , i1III1 ] = Oo0o00oOOO00
    if 57 - 57: i1iiIII111
    if 3 - 3: Ooo0Ooo . ooo000 - ooOOO - i1i1i1111I . ooo000 . IiIIii11Ii
  return items if isinstance ( self . fromNode , O0 ) else self . fromNode . recoverToRawData ( items , O0oO000O )
  if 39 - 39: i1i1i1111I
 def getPrintableItems ( self , items , recovered = True ) :
  if 91 - 91: Iii1i + iI1iII1I1I1i
  if 70 - 70: ooo000 . i1I % ooOOO
  if 99 - 99: Ii - IiI11Ii111 % IiIIii11Ii . I1I % Ooo0Ooo
  if 54 - 54: oOo0O00 / OooOoo % oOO - i1I * i1I
  if 80 - 80: ooo000 / iI1iII1I1I1i % I11iiIi11i1I . i1
  if 70 - 70: oOO % i1I % IIiIIiIi11I1 . I11iiIi11i1I
  if 88 - 88: IIiIIiIi11I1 * i1i1i1111I % Iii1i + i1I + I1Ii1I1 - IiIIii11Ii
  if 59 - 59: i1I
  if 59 - 59: IiI11Ii111 . OooOoo / i1i1i1111I . OooOoo
  if 56 - 56: iI1iII1I1I1i + I11iiIi11i1I * oOO % ooo000 / oOo0O00 . i1i1i1111I
  if 71 - 71: i1I
  if 48 - 48: iI1iII1I1I1i . IiIIii11Ii
  if 43 - 43: Oo + IIiIIiIi11I1 - oOo0O00 - i1i1i1111I * OooOoo
  if 63 - 63: IiI11Ii111 - i1i1i1111I / Oo
  if 70 - 70: oOO * ooOOO / IiI11Ii111 . i1I * OooOoo - Ooo0Ooo
  O0000000 = ( Ii1II11 ( items ) . tolist ( ) if isinstance ( items , np . ndarray ) else items ) if recovered else self . recoverToRawData ( items ) . tolist ( )
  if 35 - 35: OooOoo / IiI11Ii111
  if 62 - 62: i1I % iI1iII1I1I1i . Ii
  O0o0o0Oo00O0 = isinstance ( O0000000 [ 0 ] , list )
  if 91 - 91: IiIIii11Ii * OooOoo + Oo
  if not O0o0o0Oo00O0 :
   if 71 - 71: oOo0O00 * IIiIIiIi11I1 + Ii
   OO0oo0OoooOO = "Value"
  elif len ( O0000000 [ 0 ] ) == 1 :
   if 41 - 41: OooOoo % i1I . OooOoo / IiIIii11Ii
   OO0oo0OoooOO = "Value"
   O0000000 = [ c [ 0 ] for c in O0000000 ]
  else :
   if 64 - 64: i1I
   OO0oo0OoooOO = "Table"
   if 3 - 3: i1i1i1111I . ooo000 * i1iiIII111 / ooOOO - iI1iII1I1I1i . I1Ii1I1
   if 28 - 28: IIiIIiIi11I1 + I1Ii1I1
  return [ [ OO0oo0OoooOO , json . dumps ( i ) ] for i in O0000000 ]
  if 65 - 65: IiI11Ii111 % i1iiIII111
class II1IiI1I ( II1i1I ) :
 if 93 - 93: Ii . IIiIIiIi11I1 . I11iiIi11i1I
 if 84 - 84: I1Ii1I1 / ooOOO * iI1iII1I1I1i * i1i1i1111I / OooOoo
 if 54 - 54: ooo000
 if 70 - 70: IIiIIiIi11I1 . Ii . IiIIii11Ii
 if 72 - 72: Ii * Oo . IiIIii11Ii % IiI11Ii111 . iI1iII1I1I1i / Oo
 if 85 - 85: i1iiIII111
 if 24 - 24: Ii . IiIIii11Ii * iI1iII1I1I1i / Ii
 if 73 - 73: Ii / Ii
 Propagate = 0
 if 60 - 60: Ooo0Ooo
 if 76 - 76: Iii1i * IIiIIiIi11I1 . ooOOO
 Current = 1
 if 90 - 90: I11iiIi11i1I . oOo0O00 % i1iiIII111 % oOo0O00 * OooOoo / i1I
 if 67 - 67: i1I - i1I % Ooo0Ooo / IiIIii11Ii
 Cache = 2
 if 17 - 17: ooOOO + Oo - i1i1i1111I - I11iiIi11i1I % OooOoo
class o0oo0o ( Oo0ooo0OO0 ) :
 if 5 - 5: Ii + IiIIii11Ii / oOO
 if 85 - 85: i1 - I1Ii1I1 * iI1iII1I1I1i . I1I + IiIIii11Ii
 if 57 - 57: i1 % OooOoo + Ooo0Ooo
 if 68 - 68: ooo000
 if 35 - 35: Ii - Ooo0Ooo * I1I - oOO % i1
 if 92 - 92: oOO + I1I % oOO
 if 39 - 39: i1 + ooo000
 class StepEnum ( I1i1i ) :
  if 81 - 81: OooOoo - Ii % i1iiIII111
  if 43 - 43: iI1iII1I1I1i
  if 57 - 57: Ii * IiIIii11Ii - iI1iII1I1I1i
  if 80 - 80: i1i1i1111I + ooo000 + I1Ii1I1
  if 27 - 27: Iii1i / Ii % i1iiIII111 % Oo + Ii
  if 64 - 64: oOo0O00 * Iii1i * IiI11Ii111 * i1 . i1i1i1111I . Oo
  if 60 - 60: Oo - Iii1i % i1iiIII111 / iI1iII1I1I1i + ooo000
  pass
  if 7 - 7: I1Ii1I1 * Iii1i / IiI11Ii111 - i1 + ooOOO + i1i1i1111I
 def __init__ ( self , dtype : 'tf.DType' = None , sourceCol : str = "None:None" ) :
  if 88 - 88: i1i1i1111I . OooOoo
  if 24 - 24: i1I + Ii + I1Ii1I1 . Ooo0Ooo
  if 98 - 98: i1i1i1111I . Oo + I1I + I1Ii1I1 * i1I + ooOOO
  if 57 - 57: i1iiIII111 % iI1iII1I1I1i . Ii + Oo - I1I - OooOoo
  if 60 - 60: Ii % i1I + IiIIii11Ii * Iii1i * i1
  if 86 - 86: Ii
  if 2 - 2: IiI11Ii111 + oOo0O00 / Iii1i * I1I
  if 89 - 89: Iii1i . IiIIii11Ii + Ii / Ooo0Ooo / Ii
  if 65 - 65: oOo0O00 * i1i1i1111I . oOo0O00 % IiI11Ii111 * Oo
  if 29 - 29: IiI11Ii111 + I1Ii1I1 % IiIIii11Ii % i1 + i1I + i1iiIII111
  if 19 - 19: IiIIii11Ii
  super ( ) . __init__ ( instanceClass = OoiI1iiI11IIi1 . Image , dtype = dtype , sourceCol = sourceCol )
  if 50 - 50: Ii
  if 8 - 8: i1I - Iii1i % Iii1i * ooo000
  self . preprocessInBatch = False
  if 74 - 74: Ii % oOO . iI1iII1I1I1i - IIiIIiIi11I1
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 34 - 34: i1
  if 62 - 62: OooOoo + I1I * I1I * oOo0O00 % oOo0O00
  if 75 - 75: i1 + Iii1i . IIiIIiIi11I1 - ooo000 - i1iiIII111 / i1iiIII111
  if 2 - 2: IiIIii11Ii / Iii1i
  if 10 - 10: ooo000 / ooOOO + ooo000 / I1Ii1I1
  if 37 - 37: iI1iII1I1I1i
  if 69 - 69: i1I / I1Ii1I1 . i1I
  if 90 - 90: i1 / oOo0O00
  if 43 - 43: i1i1i1111I
  if 2 - 2: i1I . Ooo0Ooo . Ii * i1 + oOO . oOO
  if 53 - 53: i1 + OooOoo . i1i1i1111I . ooo000 - iI1iII1I1I1i
  if 29 - 29: Iii1i % oOo0O00
  if 87 - 87: i1iiIII111 - oOO % oOO
  if 58 - 58: I1Ii1I1 % I1Ii1I1 . i1I
  if 95 - 95: oOo0O00 - ooo000 / i1 . Ooo0Ooo / I1Ii1I1
  if 2 - 2: iI1iII1I1I1i / IiIIii11Ii + I1Ii1I1 % ooOOO . iI1iII1I1I1i - Iii1i
  if 89 - 89: Iii1i / Oo - IiIIii11Ii . i1 / oOO
  o0o0oooO0 = o0o ( self . train , self . getRootSources ( False ) , sourceDataset = sourceDataset )
  if 1 - 1: Ooo0Ooo / I1Ii1I1
  if 13 - 13: I1Ii1I1 % IiIIii11Ii . Oo % i1I % Iii1i - IiIIii11Ii
  iiI1iIi = o0o0oooO0 . getData ( start = start , end = end )
  if 73 - 73: Ooo0Ooo
  if 14 - 14: I11iiIi11i1I
  return self . getProcessedData ( iiI1iIi , step = step )
  if 56 - 56: IiIIii11Ii % i1iiIII111
 def refreshItemShape ( self ) :
  if 71 - 71: i1I . i1I + iI1iII1I1I1i * IIiIIiIi11I1 * I1Ii1I1
  if 91 - 91: ooo000 . I11iiIi11i1I % Ii . i1 + oOO - IiI11Ii111
  if 28 - 28: oOO
  if 49 - 49: I11iiIi11i1I / IIiIIiIi11I1 % I11iiIi11i1I / i1iiIII111 + oOo0O00
  if 7 - 7: I11iiIi11i1I . I1Ii1I1 / IIiIIiIi11I1 * Iii1i / I1Ii1I1 . oOO
  if 28 - 28: oOO + i1 / OooOoo / ooOOO . i1i1i1111I
  if 36 - 36: ooOOO - I1I * OooOoo
  if 96 - 96: Oo * Ooo0Ooo . i1I + I1I % Iii1i
  ooO0OOo = self . getInputShape ( ) [ 1 : ]
  if 87 - 87: Iii1i * OooOoo
  if 5 - 5: Ii / OooOoo + OooOoo / iI1iII1I1I1i / IiIIii11Ii - OooOoo
  if 90 - 90: i1
  ooIiIIIii = [ tx for tx in self . transformations if isinstance ( tx , Ooo000oO ) ]
  if len ( ooIiIIIii ) :
   ooO0OOo [ - 3 ] = ooIiIIIii [ - 1 ] . height
   ooO0OOo [ - 2 ] = ooIiIIIii [ - 1 ] . width
   if 88 - 88: IiIIii11Ii
   if 92 - 92: iI1iII1I1I1i / iI1iII1I1I1i - ooo000 + Oo % IiI11Ii111
  self . setItemShape ( [ * ooO0OOo ] )
  if 69 - 69: i1i1i1111I / Iii1i
 def _processData ( self , data : 'tf.Tensor' , step : 'DataPreprocessing.Node.Image.StepEnum' = StepEnum . Output ) -> 'tf.Tensor' :
  if 84 - 84: i1i1i1111I % Ooo0Ooo
  if 88 - 88: i1i1i1111I * oOo0O00 - IiI11Ii111 - I1Ii1I1 . I11iiIi11i1I % I1I
  if 16 - 16: ooOOO
  if 32 - 32: ooOOO % IiI11Ii111 . ooo000 - OooOoo / i1i1i1111I % I1I
  if 16 - 16: Iii1i - Ii % ooo000 + oOO
  if 48 - 48: iI1iII1I1I1i - ooo000 . ooo000 / OooOoo
  if 11 - 11: ooo000 % IiIIii11Ii + oOo0O00 . oOo0O00 % ooOOO
  if 39 - 39: iI1iII1I1I1i . ooo000 - oOo0O00 / I1I % i1 * i1I
  if 54 - 54: oOo0O00 . IiI11Ii111 * ooo000
  if 22 - 22: OooOoo / ooo000 / Ooo0Ooo / Oo
  if 12 - 12: ooOOO / Ooo0Ooo / OooOoo
  if 95 - 95: oOO * i1iiIII111 * ooOOO
  if 87 - 87: I11iiIi11i1I . I11iiIi11i1I
  if 82 - 82: oOO
  if 95 - 95: IiI11Ii111 % IiI11Ii111 . OooOoo - i1
  iiIII1I1ii = o0ooo0oOoO . tensorSlice ( data , self . sourceCol )
  if 93 - 93: i1i1i1111I * IiI11Ii111 * i1I
  if 88 - 88: i1 + oOO / i1 + OooOoo
  if step == self . StepEnum . Input :
   return iiIII1I1ii
   if 93 - 93: I1Ii1I1 - Ii + IiIIii11Ii
   if 69 - 69: i1 / ooOOO
  for O0oOOOoo in self . transformations :
   if isinstance ( O0oOOOoo , iiii1I11IIiI1 ) and ( self . train . currentSourceDataset in [ I111II1II111I . Dataset . Types . Train , I111II1II111I . Dataset . Types . ValidationTrain ] ) :
    iiIII1I1ii = O0oOOOoo . augmentTo ( iiIII1I1ii )
   elif hasattr ( O0oOOOoo , "transformTo" ) :
    if 35 - 35: ooo000 - i1I * ooOOO
    iiIII1I1ii = O0oOOOoo . transformTo ( iiIII1I1ii )
    if 64 - 64: ooo000 - ooOOO % i1iiIII111
  return iiIII1I1ii
  if 26 - 26: Ooo0Ooo / i1I + IIiIIiIi11I1
 def _processDataToShow ( self , data : 'tf.Tensor' , step : 'DataPreprocessing.Node.Image.StepEnum' = StepEnum . Output ) -> 'tf.Tensor' :
  if 35 - 35: IiI11Ii111 - ooo000 % Ooo0Ooo . I1I
  if 36 - 36: I1Ii1I1 . i1iiIII111
  if 37 - 37: oOO . Iii1i * i1I
  if 43 - 43: I11iiIi11i1I + i1iiIII111 . ooo000 / OooOoo % i1iiIII111
  if 48 - 48: ooo000 - iI1iII1I1I1i + Oo / Iii1i / iI1iII1I1I1i
  if 36 - 36: IiIIii11Ii / i1I
  if 16 - 16: ooo000 / oOo0O00 . Ii
  if 86 - 86: oOO * I1I % i1
  if 21 - 21: oOo0O00 . oOo0O00 + Ii / iI1iII1I1I1i
  if 73 - 73: iI1iII1I1I1i / Oo / Iii1i * Iii1i
  if 69 - 69: Oo * I11iiIi11i1I - I1Ii1I1 + Oo / IiIIii11Ii . oOO
  if 58 - 58: oOO
  if 36 - 36: I1I / ooOOO + I1Ii1I1
  if 56 - 56: ooOOO - IIiIIiIi11I1 + Oo . I1I - I1Ii1I1
  if 83 - 83: I11iiIi11i1I . i1iiIII111 - OooOoo * iI1iII1I1I1i / iI1iII1I1I1i - OooOoo
  iiIII1I1ii = o0ooo0oOoO . tensorSlice ( data , self . sourceCol )
  if 74 - 74: i1iiIII111 - I1I - iI1iII1I1I1i / Iii1i
  if 15 - 15: Ii . IiIIii11Ii * OooOoo
  if step == self . StepEnum . Input :
   return iiIII1I1ii
   if 57 - 57: Iii1i . i1iiIII111 + I11iiIi11i1I * Ii * Ii
   if 4 - 4: I1Ii1I1 - OooOoo
  for O0oOOOoo in self . transformations :
   if isinstance ( O0oOOOoo , iiii1I11IIiI1 ) and ( self . train . currentSourceDataset in [ I111II1II111I . Dataset . Types . Train , I111II1II111I . Dataset . Types . ValidationTrain ] ) :
    iiIII1I1ii = O0oOOOoo . augmentTo ( iiIII1I1ii )
   elif hasattr ( O0oOOOoo , "transformTo" ) :
    if 9 - 9: i1iiIII111 / I1I - Oo
    iiIII1I1ii = O0oOOOoo . transformTo ( iiIII1I1ii )
    if 55 - 55: IiI11Ii111
  return iiIII1I1ii
  if 39 - 39: Oo % I1I
 def processData ( self , data : Union [ 'np.ndarray' , 'tf.Tensor' ] , step : 'DataPreprocessing.Node.Image.StepEnum' = StepEnum . Output ) -> Union [ 'np.ndarray' , 'tf.Tensor' ] :
  if 98 - 98: i1i1i1111I % I1Ii1I1 - I1I . Oo
  if 26 - 26: IiIIii11Ii % OooOoo + ooo000 % I1Ii1I1
  if 93 - 93: IiI11Ii111
  if 83 - 83: IIiIIiIi11I1 % i1
  if 45 - 45: IiIIii11Ii * IiI11Ii111
  if 46 - 46: I1I * OooOoo / OooOoo / iI1iII1I1I1i * IiI11Ii111 / I1I
  if 67 - 67: I1Ii1I1 % oOo0O00 . IIiIIiIi11I1 + i1 * IiIIii11Ii
  if 29 - 29: Ooo0Ooo / Ooo0Ooo
  if 12 - 12: Ii + ooo000 - Ii . iI1iII1I1I1i % Ii
  if 66 - 66: IiI11Ii111 - IIiIIiIi11I1
  if 16 - 16: I1I / Ii - Iii1i . Oo - OooOoo
  if 51 - 51: IiIIii11Ii
  if 83 - 83: oOO / oOO * I1Ii1I1 * i1i1i1111I * IIiIIiIi11I1
  if 86 - 86: ooOOO - ooOOO % IIiIIiIi11I1 - i1iiIII111 / ooOOO - OooOoo
  if isinstance ( data , np . ndarray ) :
   return self . processDataNPArray ( data , step )
  elif isinstance ( data , tf . Tensor ) :
   return self . _processData ( data , step )
  else :
   raise ValueError ( "Data type not supported." )
   if 19 - 19: OooOoo / OooOoo
 def processDataNPArray ( self , data : 'np.ndarray' , step : 'DataPreprocessing.Node.Image.StepEnum' = StepEnum . Output ) -> 'np.ndarray' :
  if 21 - 21: Iii1i % Oo * oOo0O00 % OooOoo + oOO + i1I
  if 20 - 20: I1Ii1I1 * IiIIii11Ii / Ii - I1Ii1I1 - i1iiIII111 % I1I
  if 48 - 48: ooo000 . IIiIIiIi11I1 / i1i1i1111I / Oo * Ii % ooOOO
  if 51 - 51: ooOOO - i1 . IIiIIiIi11I1 . i1iiIII111 * oOO / oOo0O00
  if 99 - 99: oOO
  if 42 - 42: i1i1i1111I . i1
  if 100 - 100: ooo000 / Ii * oOo0O00 % ooo000
  if 30 - 30: IIiIIiIi11I1 * IiIIii11Ii * i1i1i1111I - ooOOO + IIiIIiIi11I1
  if 6 - 6: ooOOO + i1i1i1111I % I1Ii1I1
  if 81 - 81: IiIIii11Ii . Ooo0Ooo . ooOOO * i1i1i1111I . i1iiIII111 % i1iiIII111
  if 55 - 55: i1I . i1i1i1111I * i1I
  if 93 - 93: I1I % i1iiIII111 % oOO - IIiIIiIi11I1
  if 46 - 46: IIiIIiIi11I1 . Iii1i
  if 18 - 18: ooOOO
  return np . array ( self . _processData ( tf . convert_to_tensor ( data ) , step ) )
  if 22 - 22: Iii1i / IiI11Ii111 . IIiIIiIi11I1 * Oo
 def processDataTensor ( self , data : 'tf.Tensor' , step : 'DataPreprocessing.Node.Image.StepEnum' = StepEnum . Output ) -> 'tf.Tensor' :
  if 18 - 18: i1i1i1111I * oOo0O00 / I1I . i1 % Ooo0Ooo * IiI11Ii111
  if 52 - 52: i1I % iI1iII1I1I1i * Ii - i1I
  if 67 - 67: i1i1i1111I / Ooo0Ooo / IIiIIiIi11I1 - i1
  if 11 - 11: OooOoo / ooo000 - Iii1i * i1iiIII111 - i1I
  if 68 - 68: IIiIIiIi11I1 % oOO * IiIIii11Ii - I1I / i1I
  if 90 - 90: I1I + IiI11Ii111 . ooo000 . oOo0O00 + Iii1i / I11iiIi11i1I
  if 87 - 87: i1iiIII111 % i1 / OooOoo . I1Ii1I1 . i1I . i1i1i1111I
  if 46 - 46: IiIIii11Ii
  if 63 - 63: oOo0O00 + iI1iII1I1I1i % IIiIIiIi11I1 + Iii1i
  if 92 - 92: Iii1i
  if 18 - 18: iI1iII1I1I1i % oOo0O00 - oOO + Ooo0Ooo
  if 64 - 64: i1I + i1I - oOo0O00 - i1i1i1111I
  if 54 - 54: IiIIii11Ii - Ooo0Ooo
  if 89 - 89: ooOOO
  return self . _processData ( data )
  if 43 - 43: Iii1i
 def recoverToRawData ( self , items ) :
  if 53 - 53: i1iiIII111 + i1
  if 61 - 61: i1I . ooo000
  if 35 - 35: IiI11Ii111 - iI1iII1I1I1i / i1i1i1111I - i1I . IiIIii11Ii
  if 18 - 18: ooo000 * i1iiIII111 / Ii / IiIIii11Ii * i1I
  if 60 - 60: I1Ii1I1 . IiIIii11Ii + I1Ii1I1 . I1Ii1I1 % Ooo0Ooo - I1I
  if 55 - 55: i1i1i1111I / IiI11Ii111 + oOo0O00
  if 68 - 68: i1I % IiI11Ii111 + IiIIii11Ii - Ooo0Ooo + Ooo0Ooo
  if 32 - 32: ooOOO + i1 + oOo0O00
  if 91 - 91: oOo0O00 . Oo % ooo000
  if 73 - 73: i1 % i1 % ooOOO * i1I + iI1iII1I1I1i
  if 37 - 37: ooOOO % Ooo0Ooo
  if 34 - 34: I11iiIi11i1I
  if 98 - 98: oOO * OooOoo / Ii / i1iiIII111 % Ooo0Ooo % OooOoo
  if 78 - 78: I1I - oOO % I11iiIi11i1I * ooOOO % i1 . I1Ii1I1
  items = np . array ( items )
  if 14 - 14: i1I
  if 58 - 58: I1Ii1I1 . Oo
  if len ( self . transformations ) :
   if 62 - 62: IIiIIiIi11I1
   for O0oOOOoo in reversed ( self . transformations ) :
    if hasattr ( O0oOOOoo , "transformFrom" ) :
     items = O0oOOOoo . transformFrom ( items )
     if 42 - 42: IiIIii11Ii % oOo0O00 / Ooo0Ooo
     if 48 - 48: i1I - OooOoo / Ii
  return items if isinstance ( self . fromNode , O0 ) else self . fromNode . recoverToRawData ( items )
  if 32 - 32: Ii
 def getPrintableItems ( self , items , recovered = True ) :
  if 39 - 39: Ooo0Ooo % ooo000 + i1i1i1111I
  if 19 - 19: i1 % Ii % OooOoo . IiIIii11Ii * OooOoo . Oo
  if 27 - 27: i1iiIII111 - IiIIii11Ii - IiI11Ii111 % I1I - i1I + i1iiIII111
  if 81 - 81: Iii1i - Ooo0Ooo % i1I . I1I % ooOOO . IiIIii11Ii
  if 71 - 71: ooOOO / i1iiIII111 * ooo000
  if 50 - 50: i1i1i1111I . i1
  if 70 - 70: Ii + oOo0O00 / I1I / I1Ii1I1 - OooOoo
  if 5 - 5: oOo0O00 / iI1iII1I1I1i
  if 38 - 38: Ooo0Ooo + I1I
  if 84 - 84: Iii1i
  if 39 - 39: iI1iII1I1I1i * i1I
  if 54 - 54: ooo000 * Iii1i % oOO . i1iiIII111 * OooOoo
  if 73 - 73: i1I - OooOoo . i1i1i1111I
  if 83 - 83: iI1iII1I1I1i - i1i1i1111I + ooOOO - Ii / I1I + i1iiIII111
  if 8 - 8: oOO / IiIIii11Ii
  return [ [ "Image" , json . dumps ( ( i if isinstance ( self . fromNode , iiI1i11iii ) else i * 255 ) . tolist ( ) ) ] for i in ( items if recovered else self . recoverToRawData ( items ) ) ]
  if 7 - 7: oOO / IiI11Ii111
  if 36 - 36: i1iiIII111 - iI1iII1I1I1i / I1Ii1I1 + I1I
class ii1iiiiiII ( O0o000oO000 ) :
 if 74 - 74: I1I
 if 27 - 27: i1
 if 3 - 3: ooOOO / Ooo0Ooo
 if 60 - 60: Oo . Ooo0Ooo * IiIIii11Ii - Iii1i
 if 57 - 57: IIiIIiIi11I1 / IiI11Ii111 % i1iiIII111 + i1
 if 96 - 96: I1Ii1I1
 if 36 - 36: I1I + i1i1i1111I . i1 / i1I * ooOOO % IIiIIiIi11I1
 class StepEnum ( O0o000oO000 . StepEnum ) :
  if 22 - 22: I1I . ooOOO
  if 92 - 92: OooOoo . oOO
  if 38 - 38: i1I . Iii1i * iI1iII1I1I1i . I1Ii1I1
  if 21 - 21: oOo0O00 / IiIIii11Ii . iI1iII1I1I1i . Ooo0Ooo * oOO + iI1iII1I1I1i
  if 94 - 94: IIiIIiIi11I1
  if 83 - 83: IIiIIiIi11I1 * ooOOO + Oo - IiI11Ii111 % ooOOO / Ii
  if 50 - 50: oOO * oOO / iI1iII1I1I1i
  if 20 - 20: OooOoo - I11iiIi11i1I + I1Ii1I1 . i1iiIII111 / Ii % i1I
  SeriesConverted = 3
  if 89 - 89: ooo000 - oOo0O00 % ooOOO
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 65 - 65: OooOoo * IIiIIiIi11I1 / I1I / i1I - I1Ii1I1 . Oo
  if 17 - 17: i1i1i1111I
  if 7 - 7: I11iiIi11i1I
  if 59 - 59: i1 . IiIIii11Ii * oOO * IiI11Ii111 - Ii
  if 86 - 86: iI1iII1I1I1i
  if 7 - 7: Ii + i1 * OooOoo % IiIIii11Ii
  if 14 - 14: IiI11Ii111 % IiIIii11Ii + IiI11Ii111 / Oo + IIiIIiIi11I1
  def __init__ ( self , controller : 'Source.Noise.GeneratorController' ) :
   if 14 - 14: OooOoo / IIiIIiIi11I1
   if 50 - 50: i1 + oOO / I1Ii1I1 - Iii1i / oOo0O00 + OooOoo
   if 19 - 19: ooo000
   if 23 - 23: i1iiIII111 * ooOOO * ooo000 % I1I
   if 25 - 25: Iii1i * oOO * I1I / oOo0O00 + iI1iII1I1I1i + Iii1i
   if 40 - 40: IIiIIiIi11I1 % IiI11Ii111 % i1iiIII111 % ooOOO . iI1iII1I1I1i
   if 3 - 3: IiIIii11Ii . IiI11Ii111
   if 88 - 88: IiIIii11Ii % IiI11Ii111 . I1I + iI1iII1I1I1i
   if 64 - 64: I1Ii1I1 % Ooo0Ooo - I1I
   if 21 - 21: i1iiIII111 * i1 - I1Ii1I1 + IIiIIiIi11I1 - IIiIIiIi11I1
   super ( ) . __init__ ( controller )
   if 41 - 41: IiIIii11Ii / i1I
   if 20 - 20: Ooo0Ooo
   self . _noiseShape = [ ]
   if 11 - 11: oOO + OooOoo . OooOoo % Iii1i
   if 84 - 84: I1Ii1I1 % i1I / oOo0O00
   self . outputsetInfo = { }
   if 15 - 15: i1iiIII111
  def copy ( self ) -> 'Source.Noise.GeneratorDetail' :
   if 99 - 99: Ii / i1I / i1iiIII111 + i1I
   if 52 - 52: i1 - iI1iII1I1I1i
   if 86 - 86: Ooo0Ooo / IiI11Ii111 / oOo0O00 * I1Ii1I1 * Ooo0Ooo . ooo000
   if 10 - 10: ooOOO * I11iiIi11i1I % Iii1i
   if 83 - 83: i1iiIII111 % I1I . Oo / oOO / Ii . ooOOO
   if 74 - 74: I1Ii1I1 / i1i1i1111I . OooOoo / I1Ii1I1 . i1i1i1111I
   if 48 - 48: I11iiIi11i1I + Oo * IiIIii11Ii * OooOoo % oOO - Ooo0Ooo
   if 69 - 69: oOo0O00 - Oo . Oo % I11iiIi11i1I
   if 42 - 42: oOO % ooo000 . oOo0O00
   if 40 - 40: Iii1i * Ii
   if 50 - 50: I11iiIi11i1I % IIiIIiIi11I1
   ii1IIiIIi : OO0O0 . GeneratorDetail = OO0O0 . GeneratorDetail ( self . controller )
   if 50 - 50: oOo0O00 - oOo0O00 - Oo * Ooo0Ooo % OooOoo * I1I
   if 38 - 38: Oo / OooOoo % Ooo0Ooo * I1Ii1I1 / I1I . I1Ii1I1
   for Ii1I in [ "_noiseShape" , "outputsetInfo" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 3 - 3: i1i1i1111I * oOo0O00 . I1Ii1I1
   return ii1IIiIIi
   if 79 - 79: I1I % oOo0O00 . IIiIIiIi11I1
  def getData ( self , batchSize : int = 1 ) -> 'np.ndarray' :
   if 66 - 66: Oo * IIiIIiIi11I1 . iI1iII1I1I1i % Ooo0Ooo / i1I
   if 79 - 79: ooOOO % I11iiIi11i1I % I1Ii1I1 . I1I % Oo
   if 95 - 95: Ii . Ooo0Ooo / Ooo0Ooo - I1Ii1I1 . Iii1i
   if 8 - 8: IiIIii11Ii
   if 26 - 26: oOO / I1I + ooo000 % Oo / i1iiIII111 . Ii
   if 42 - 42: i1 + I11iiIi11i1I
   if 31 - 31: Iii1i * oOO + I1Ii1I1 * IiI11Ii111 - I1Ii1I1
   if 85 - 85: Ii % iI1iII1I1I1i . oOO - Ooo0Ooo * I1Ii1I1
   if 59 - 59: i1 / oOO / I11iiIi11i1I / IiI11Ii111
   if 50 - 50: I1I / Ooo0Ooo - i1i1i1111I * i1iiIII111 % Oo * oOO
   if 97 - 97: ooo000 / Oo - Ooo0Ooo / oOO
   if 40 - 40: Iii1i
   if 10 - 10: I11iiIi11i1I / I1Ii1I1
   OOo00oOoOo = self . _noiseShape
   OOo00oOoOo [ 0 ] = batchSize
   return tf . convert_to_tensor ( np . random . random ( size = OOo00oOoOo ) , dtype = tf . float32 )
   if 26 - 26: IiI11Ii111 * OooOoo
  def getNextBatch ( self ) -> 'np.ndarray' :
   if 13 - 13: I11iiIi11i1I % i1 * I1Ii1I1 + IiI11Ii111 - i1i1i1111I * I11iiIi11i1I
   if 62 - 62: Iii1i * IIiIIiIi11I1 - IIiIIiIi11I1
   if 50 - 50: Ii
   if 55 - 55: IiIIii11Ii * I1Ii1I1 % oOO . Oo % ooOOO * i1
   if 99 - 99: IiI11Ii111
   if 17 - 17: iI1iII1I1I1i % Oo - I11iiIi11i1I - Oo
   if 46 - 46: i1I - i1 % oOo0O00 % IIiIIiIi11I1 + I1Ii1I1
   if 95 - 95: OooOoo . ooo000 * IiIIii11Ii - ooo000 * ooo000 % I1Ii1I1
   if 79 - 79: Oo % i1iiIII111 / iI1iII1I1I1i
   if 27 - 27: I11iiIi11i1I % i1I % I1Ii1I1
   if 44 - 44: IiI11Ii111 / Ooo0Ooo + Iii1i
   o0OOOO0Oo0O = self . batchSize
   if 98 - 98: oOo0O00 * i1I / Iii1i % iI1iII1I1I1i
   if 35 - 35: OooOoo - Ooo0Ooo % i1I - i1i1i1111I + i1I - IiI11Ii111
   O00o000Oo = self . getData ( batchSize = o0OOOO0Oo0O )
   if 51 - 51: oOO . oOO . iI1iII1I1I1i % oOo0O00
   return O00o000Oo
   if 88 - 88: ooOOO - IiIIii11Ii % IiI11Ii111 * oOo0O00 % ooOOO - i1i1i1111I
  class GeneratorController ( I111II1II111I . Controller ) :
   if 66 - 66: I11iiIi11i1I % oOo0O00
   if 15 - 15: i1 - iI1iII1I1I1i + i1iiIII111 % I1I
   if 52 - 52: oOO % Oo % oOo0O00 - oOO % ooOOO . oOo0O00
   if 41 - 41: IiI11Ii111
   if 22 - 22: I11iiIi11i1I * Iii1i - I1Ii1I1 + Ii . ooo000 / OooOoo
   if 59 - 59: ooo000
   if 52 - 52: IiI11Ii111 % Iii1i . oOO
   def __init__ ( self , attachObject : Union [ 'Source.Noise' , 'DataPreprocessing.Node.SourceLike' ] ) :
    if 23 - 23: ooOOO % I11iiIi11i1I + Oo
    if 99 - 99: oOO . oOO
    if 74 - 74: Ii / IIiIIiIi11I1 + oOO + i1 % IiI11Ii111
    if 77 - 77: ooOOO - Oo * IiIIii11Ii % i1 - OooOoo . iI1iII1I1I1i
    if 48 - 48: Ii
    if 1 - 1: IiIIii11Ii . ooo000
    if 98 - 98: Oo - IiI11Ii111 % I1I + IiIIii11Ii . oOo0O00 - Oo
    if 72 - 72: I1I % oOO - oOo0O00
    if 56 - 56: Ii % IIiIIiIi11I1 % Iii1i * Oo
    if 68 - 68: Ooo0Ooo / Ii * Oo . I1I
    super ( ) . __init__ ( attachObject = attachObject )
    if 55 - 55: Oo * i1 . ooOOO
   @ property
   def detailType ( self ) -> Callable [ ... , 'Source.Noise.GeneratorDetail' ] :
    if 38 - 38: OooOoo + IiI11Ii111 % Ii
    if 51 - 51: i1iiIII111 + oOO - IiIIii11Ii - I1Ii1I1
    if 39 - 39: ooo000
    if 19 - 19: i1iiIII111 . IiIIii11Ii
    if 79 - 79: IIiIIiIi11I1 - i1iiIII111 / I1Ii1I1 - I1Ii1I1 / Oo
    if 78 - 78: i1iiIII111
    if 31 - 31: oOo0O00 * iI1iII1I1I1i
    if 4 - 4: oOo0O00 - ooo000 - oOo0O00
    if 70 - 70: i1iiIII111 * IiI11Ii111 + i1
    if 77 - 77: I1Ii1I1 + i1 . i1 % i1iiIII111
    return OO0O0 . GeneratorDetail
    if 1 - 1: OooOoo . i1iiIII111 + IiIIii11Ii * I1I
   def __init__ ( self , sourceType = "noise" , noiseShape = [ None , 1 ] , name : str = "" ) :
    if 14 - 14: IiI11Ii111 * Ii
    if 1 - 1: ooo000 / I1Ii1I1 / i1i1i1111I . IIiIIiIi11I1 * OooOoo / iI1iII1I1I1i
    if 64 - 64: ooOOO - oOO
    if 83 - 83: i1 * IiIIii11Ii % i1iiIII111 % i1iiIII111 * oOO
    if 42 - 42: i1I / oOo0O00
    if 22 - 22: OooOoo + i1iiIII111 * ooo000 . I11iiIi11i1I . IIiIIiIi11I1 + IiIIii11Ii
    if 79 - 79: iI1iII1I1I1i
    if 9 - 9: i1iiIII111
    if 7 - 7: Ii * oOo0O00 + i1i1i1111I % iI1iII1I1I1i + iI1iII1I1I1i
    if 40 - 40: i1 - I1I + IiIIii11Ii
    if 99 - 99: iI1iII1I1I1i + I11iiIi11i1I
    if 94 - 94: oOo0O00 * iI1iII1I1I1i . IiIIii11Ii . oOo0O00 % i1I * iI1iII1I1I1i
    if 26 - 26: IiI11Ii111 + Ii / i1iiIII111
    super ( ) . __init__ ( instanceClass = OoiI1iiI11IIi1 . TimeSeries , dtype = tf . float32 )
    if 30 - 30: oOO % i1 . Oo / I11iiIi11i1I
    if 28 - 28: i1i1i1111I . I1I * I11iiIi11i1I / IiI11Ii111
    self . _instanceClass = I1ooOoO0OooO . Noise
    if 72 - 72: i1iiIII111 / i1i1i1111I * I1Ii1I1 + Oo
    if 57 - 57: Ooo0Ooo + I1I + i1 + I11iiIi11i1I - Oo . I11iiIi11i1I
    self . generatorController = OO0O0 . GeneratorController ( self )
    if 73 - 73: IiIIii11Ii
    if 55 - 55: I1I - ooOOO + IIiIIiIi11I1 - IIiIIiIi11I1 . ooo000 - I1Ii1I1
    self . _noiseShape = noiseShape
    if 76 - 76: i1i1i1111I % i1 + ooo000 / OooOoo
    if 76 - 76: ooOOO % Ooo0Ooo - i1iiIII111 + IiI11Ii111 . i1I
    self . generatorController [ I111II1II111I . Dataset . Types . Train ] . _noiseShape = self . _noiseShape
    self . generatorController [ I111II1II111I . Dataset . Types . Test ] . _noiseShape = self . _noiseShape
    if 74 - 74: Ii . Ii . IiI11Ii111 % i1iiIII111 % IIiIIiIi11I1
   def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
    if 30 - 30: oOO . i1iiIII111 / Oo / i1i1i1111I * oOO
    if 77 - 77: I11iiIi11i1I * oOo0O00 + oOo0O00 / ooo000
    if 36 - 36: I11iiIi11i1I % IiI11Ii111 + IiI11Ii111 * iI1iII1I1I1i * IiIIii11Ii % iI1iII1I1I1i
    if 22 - 22: IIiIIiIi11I1 + i1I + I11iiIi11i1I + I11iiIi11i1I / Oo
    if 76 - 76: I1Ii1I1
    if 19 - 19: iI1iII1I1I1i
    if 96 - 96: oOO - i1i1i1111I % oOo0O00 / oOO % I1I
    if 82 - 82: i1i1i1111I - Iii1i - i1I + oOo0O00 % ooOOO
    if 43 - 43: ooOOO
    if 27 - 27: I1Ii1I1 - ooo000 % Oo % i1i1i1111I
    if 24 - 24: Iii1i / I11iiIi11i1I / i1iiIII111 % oOO - i1i1i1111I . i1I
    super ( ) . parseJSON ( obj , train )
    if 32 - 32: oOO - ooOOO . i1I + Iii1i . IiI11Ii111
   def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> 'np.ndarray' :
    if 85 - 85: I1Ii1I1 % iI1iII1I1I1i . i1I - IiIIii11Ii . OooOoo + oOO
    if 55 - 55: I1I % IiIIii11Ii / i1iiIII111 . I11iiIi11i1I
    if 69 - 69: iI1iII1I1I1i
    if 96 - 96: i1iiIII111
    if 25 - 25: ooo000 * Iii1i
    if 96 - 96: Oo . i1 % i1i1i1111I % i1 . OooOoo % i1I
    if 61 - 61: i1iiIII111 / Oo + i1
    if 93 - 93: i1I . I11iiIi11i1I . oOO + Oo
    if 65 - 65: Ii . i1iiIII111 + OooOoo . I1I + iI1iII1I1I1i * I1I
    if 52 - 52: i1iiIII111
    return self . generatorController . getNextBatch ( datasetType = ( sourceDataset or self . train . currentSourceDataset ) )
    if 90 - 90: I1I - ooo000 - iI1iII1I1I1i / I1I . IiIIii11Ii
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> 'np.ndarray' :
   if 66 - 66: ooo000 % i1 % IiIIii11Ii / IiI11Ii111 / Iii1i . i1iiIII111
   if 70 - 70: i1i1i1111I - oOo0O00 + iI1iII1I1I1i
   if 86 - 86: i1iiIII111 . ooo000
   if 49 - 49: IIiIIiIi11I1 % i1I
   if 24 - 24: Oo + ooo000 . oOo0O00
   if 32 - 32: IiI11Ii111 * OooOoo . i1 % IIiIIiIi11I1
   if 63 - 63: Iii1i - I1Ii1I1
   if 70 - 70: ooo000 - Iii1i - i1 + I1Ii1I1 + I11iiIi11i1I
   if 11 - 11: ooOOO + Ooo0Ooo . Ii . Oo
   if 80 - 80: i1iiIII111 - I1I * oOO + oOo0O00 * ooOOO - Ii
   if 48 - 48: Ii
   if 25 - 25: oOO % OooOoo . I1I - ooOOO . IIiIIiIi11I1 / Ooo0Ooo
   if 27 - 27: I11iiIi11i1I / ooOOO . ooOOO * ooOOO
   if 59 - 59: I11iiIi11i1I
   if 97 - 97: i1I / I1I + i1I . i1I - Ii
   o0OOOO0Oo0O = self . batchSize
   if 54 - 54: ooOOO - IiI11Ii111 * Iii1i * i1I
   if 23 - 23: oOO % ooOOO
   O00o000Oo : np . ndarray = self . getData ( batchSize = o0OOOO0Oo0O )
   if 79 - 79: ooOOO - IiIIii11Ii + i1 . oOO + iI1iII1I1I1i
   if 18 - 18: iI1iII1I1I1i . I1I + Ooo0Ooo . oOO
   return O00o000Oo
   if 72 - 72: Oo
 def __init__ ( self , instanceClass : 'DataPreprocessing.Node.Types' = None , sourceCol : str = "None:None" , dtype : 'tf.DType' = None ) :
  if 97 - 97: Ii + oOo0O00 / i1I / I11iiIi11i1I
  if 98 - 98: I11iiIi11i1I . I1I - IIiIIiIi11I1 % IiIIii11Ii - I11iiIi11i1I
  if 29 - 29: I1I / oOo0O00 - iI1iII1I1I1i - ooOOO . i1 . Iii1i
  if 78 - 78: IiI11Ii111
  if 15 - 15: I11iiIi11i1I / Ooo0Ooo * Iii1i
  if 24 - 24: ooo000 / IiIIii11Ii / I1Ii1I1 + ooOOO . i1i1i1111I
  if 84 - 84: i1i1i1111I / IiI11Ii111
  if 5 - 5: IiIIii11Ii * iI1iII1I1I1i - Iii1i / ooOOO + Iii1i . Ii
  if 91 - 91: i1I - ooOOO * i1I . I1Ii1I1 / IiIIii11Ii + i1
  if 71 - 71: Ii . IIiIIiIi11I1 % IiI11Ii111 * Oo + OooOoo * OooOoo
  if 97 - 97: iI1iII1I1I1i % i1I . oOO
  if 61 - 61: ooo000 * ooOOO
  super ( ) . __init__ ( instanceClass = ( instanceClass or OoiI1iiI11IIi1 . SourceLike ) , dtype = dtype , sourceCol = sourceCol )
  if 74 - 74: I1Ii1I1 / IiIIii11Ii / IIiIIiIi11I1 . oOo0O00
  if 19 - 19: Iii1i + ooOOO
  self . splittable : bool = False
  if 89 - 89: I1I * Ooo0Ooo / Oo . IiI11Ii111 % Ii . I1I
  if 40 - 40: Ooo0Ooo % ooo000 . Ii / IIiIIiIi11I1
  self . _getDataMode : iII11iiiii . Node . GetDataMode = II1IiI1I . Current
  if 77 - 77: ooo000 / OooOoo - i1i1i1111I
  if 74 - 74: Ooo0Ooo / i1I % Iii1i
  self . generatorController : I111II1II111I . Controller = None
  if 2 - 2: IIiIIiIi11I1 - i1iiIII111 % Iii1i
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 8 - 8: IIiIIiIi11I1
  if 32 - 32: i1I + Iii1i
  if 4 - 4: IiI11Ii111 / i1i1i1111I - Ii / iI1iII1I1I1i
  if 22 - 22: Oo . I1I
  if 70 - 70: Ii % I11iiIi11i1I * i1i1i1111I - ooo000
  if 64 - 64: Oo / Iii1i
  if 33 - 33: ooOOO * Ooo0Ooo * Oo
  if 64 - 64: i1I
  if 22 - 22: IIiIIiIi11I1 . iI1iII1I1I1i . oOo0O00 + Ooo0Ooo / Ii
  if 19 - 19: oOo0O00 + OooOoo
  if 24 - 24: i1i1i1111I / ooo000 * Iii1i
  if 19 - 19: I1I / ooOOO % i1i1i1111I
  if 19 - 19: Iii1i * ooOOO % iI1iII1I1I1i + I1Ii1I1 - IiI11Ii111 - Iii1i
  if 27 - 27: Ooo0Ooo / IiIIii11Ii * Oo + OooOoo / Ooo0Ooo - i1i1i1111I
  if 84 - 84: oOo0O00 % oOO * OooOoo . ooOOO
  if 45 - 45: i1I + IiIIii11Ii % ooo000 . OooOoo . Oo . i1I
  if 86 - 86: i1iiIII111
  o0o0oooO0 = o0o ( self . train , self . getRootSources ( False ) , sourceDataset = sourceDataset )
  if 69 - 69: I1Ii1I1 . oOO - oOo0O00 - IiI11Ii111 * oOO
  if 53 - 53: oOO - I11iiIi11i1I - Ooo0Ooo
  iiI1iIi = o0o0oooO0 . getData ( start = start , end = end )
  if 17 - 17: ooo000 - Ii
  if 2 - 2: ooOOO % iI1iII1I1I1i + Iii1i + i1 % iI1iII1I1I1i
  return self . getProcessedData ( iiI1iIi , step = step )
  if 85 - 85: i1I . i1I . IIiIIiIi11I1 . IiI11Ii111 + i1I
 def getProcessedData ( self , rootData : 'Train.RootData|list<*>' , step : 'DataPreprocessing.Node.SourceLike.StepEnum' = StepEnum . Output ) -> 'list<*>' :
  if 17 - 17: Ooo0Ooo
  if 39 - 39: Ii
  if 52 - 52: I11iiIi11i1I * ooo000 / OooOoo % i1iiIII111 / i1
  if 36 - 36: I11iiIi11i1I + ooOOO - Ii - I1Ii1I1 % Oo
  if 29 - 29: Ooo0Ooo % ooOOO + I1Ii1I1 - Iii1i / I1Ii1I1
  if 9 - 9: IIiIIiIi11I1 / OooOoo
  if 2 - 2: Iii1i + I1I / Iii1i
  if 8 - 8: Iii1i
  if 71 - 71: i1 - ooo000 + i1 - Oo % IiI11Ii111
  if 1 - 1: I11iiIi11i1I
  if 67 - 67: i1i1i1111I % ooOOO . ooo000 . Iii1i . i1I
  if 12 - 12: OooOoo % OooOoo / IIiIIiIi11I1 * I1I
  if 59 - 59: oOO % iI1iII1I1I1i % IiI11Ii111 * ooo000 . oOO . i1iiIII111
  if 39 - 39: oOO . IIiIIiIi11I1 - ooo000 + Ii / Ii
  if 3 - 3: I11iiIi11i1I % i1 + Ooo0Ooo / Oo . i1
  if step == O0o000oO000 . StepEnum . RawInput :
   return rootData
   if 58 - 58: Oo
  if isinstance ( rootData , I1i11iii1iI1 ) :
   if 67 - 67: i1iiIII111
   if self . key in [ * rootData . dppNodes . keys ( ) ] :
    if step == O0o000oO000 . StepEnum . RawInput :
     return rootData . dppNodes [ self . key ]
    elif step != O0o000oO000 . StepEnum . Output :
     raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
    else :
     rootData = rootData . dppNodes [ self . key ]
   else :
    raise ValueError ( "Root Data cannot be found for data preprocessing" )
    if 12 - 12: oOO % IiIIii11Ii * ooOOO * I11iiIi11i1I + i1I / oOo0O00
    if 20 - 20: I1I
    if 82 - 82: Iii1i * IiIIii11Ii . I1I
  return rootData
  if 42 - 42: Ooo0Ooo + Ooo0Ooo
 def getProcessedDataToShow ( self , rootData : 'Train.RootData|list<*>' , step : 'DataPreprocessing.Node.SourceLike.StepEnum' = StepEnum . Output ) -> 'list<*>' :
  if 4 - 4: ooo000 + IiI11Ii111 % ooOOO % oOo0O00
  if 75 - 75: ooo000 + iI1iII1I1I1i - Ii / Ii . OooOoo % ooOOO
  if 83 - 83: OooOoo . oOO * I11iiIi11i1I . OooOoo / i1 * I11iiIi11i1I
  if 58 - 58: Iii1i + ooo000 / Ii / IiIIii11Ii % I11iiIi11i1I
  if 9 - 9: i1iiIII111 + iI1iII1I1I1i / IiIIii11Ii / I1I
  if 53 - 53: i1 / iI1iII1I1I1i + Iii1i
  if 2 - 2: I1Ii1I1 . Oo % oOO
  if 18 - 18: i1iiIII111 * oOO . Ooo0Ooo . I1Ii1I1 . i1iiIII111
  if 45 - 45: oOo0O00 . ooo000 * Ii . iI1iII1I1I1i . IiI11Ii111
  if 23 - 23: ooOOO . Ooo0Ooo
  if 53 - 53: Ii
  if 11 - 11: i1 % I11iiIi11i1I
  if 19 - 19: Iii1i . I1Ii1I1 . OooOoo / i1I
  if 95 - 95: i1i1i1111I - i1i1i1111I + Iii1i / ooOOO * IiIIii11Ii % Iii1i
  return self . getProcessedData ( rootData , step )
  if 64 - 64: Ooo0Ooo - i1 + ooOOO * ooo000 + Ii * oOo0O00
  if 84 - 84: iI1iII1I1I1i / Ooo0Ooo
 def getPrintableItems ( self , items , recovered = True ) :
  if 29 - 29: ooo000 + Oo . i1i1i1111I % i1 + IiIIii11Ii . IIiIIiIi11I1
  if 93 - 93: I1I * oOo0O00 * OooOoo - i1 + oOO + Ooo0Ooo
  if 11 - 11: oOO - I1Ii1I1 / Oo + OooOoo
  if 59 - 59: ooo000 / Iii1i - ooo000 % ooo000 - ooo000 + OooOoo
  if 17 - 17: IiI11Ii111 . Ooo0Ooo - oOO
  if 57 - 57: IiI11Ii111 + IIiIIiIi11I1 + i1i1i1111I - I1Ii1I1 * i1I
  if 8 - 8: IiIIii11Ii / Ii . Oo - oOo0O00 % i1I % IIiIIiIi11I1
  if 39 - 39: i1 / i1iiIII111
  if 35 - 35: Ii + oOo0O00
  if 93 - 93: ooo000 * OooOoo % OooOoo . i1i1i1111I
  if 44 - 44: ooOOO - IiIIii11Ii % IiIIii11Ii / i1I + Iii1i / ooo000
  if 85 - 85: oOo0O00 + i1i1i1111I * Oo . IiI11Ii111 * I1I - oOO
  if 71 - 71: I11iiIi11i1I
  if 19 - 19: Iii1i / Ooo0Ooo * oOo0O00 / i1
  return [ [ "Image" , json . dumps ( i . tolist ( ) ) ] for i in items ]
  if 44 - 44: oOo0O00 % I11iiIi11i1I % i1i1i1111I / I11iiIi11i1I % i1I + Ooo0Ooo
class IIiIiiii ( O0o000oO000 ) :
 if 12 - 12: oOo0O00 + I1I
 if 85 - 85: i1i1i1111I + I1Ii1I1 * Iii1i / ooo000 . oOo0O00 . IiI11Ii111
 if 96 - 96: Iii1i - IIiIIiIi11I1 / Oo / I11iiIi11i1I * ooo000
 if 7 - 7: I1I
 if 21 - 21: I1I
 if 14 - 14: oOO - IiI11Ii111 % Ii % i1i1i1111I . ooOOO
 if 5 - 5: I1I
 class StepEnum ( I1i1i ) :
  if 39 - 39: i1 . IIiIIiIi11I1 . Oo * i1I
  if 60 - 60: Ooo0Ooo % Oo . ooo000 * IiIIii11Ii / IiI11Ii111 * Ii
  if 93 - 93: Oo + oOo0O00 % iI1iII1I1I1i * i1iiIII111 % IiIIii11Ii
  if 2 - 2: i1i1i1111I . iI1iII1I1I1i / i1 + I11iiIi11i1I + Oo / Iii1i
  if 61 - 61: I11iiIi11i1I % iI1iII1I1I1i
  if 67 - 67: IIiIIiIi11I1 . iI1iII1I1I1i / Ii % i1 * Oo - Ooo0Ooo
  if 14 - 14: oOO . I11iiIi11i1I * IiI11Ii111 . IIiIIiIi11I1
  if 20 - 20: IiI11Ii111 / i1I
  SeriesConverted = 3
  if 82 - 82: IIiIIiIi11I1 + Oo - I1I % IIiIIiIi11I1
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 44 - 44: iI1iII1I1I1i . Ooo0Ooo
  if 72 - 72: Iii1i
  if 24 - 24: Iii1i % oOO * IiIIii11Ii
  if 46 - 46: Ii % I1Ii1I1 . ooOOO * oOo0O00
  if 25 - 25: ooo000 / I1Ii1I1
  if 21 - 21: ooo000
  if 75 - 75: ooo000
  def __init__ ( self , controller : 'DataPreprocessing.Node.TimeSeries.GeneratorController' ) :
   if 78 - 78: oOO - iI1iII1I1I1i + ooo000 + IIiIIiIi11I1 * ooo000 . iI1iII1I1I1i
   if 88 - 88: i1i1i1111I + IiI11Ii111 - Oo * i1I / OooOoo + i1i1i1111I
   if 42 - 42: Oo
   if 53 - 53: ooo000 / Iii1i . IIiIIiIi11I1
   if 2 - 2: IiIIii11Ii / Ii
   if 84 - 84: I1Ii1I1 + I1I + Oo * oOO % i1
   if 74 - 74: oOO + oOo0O00
   if 65 - 65: i1
   if 4 - 4: oOo0O00
   if 14 - 14: IiI11Ii111 - Iii1i . i1 + OooOoo . IiIIii11Ii . i1i1i1111I
   super ( ) . __init__ ( controller )
   if 49 - 49: IiIIii11Ii * oOO * oOo0O00 - ooo000
   if 92 - 92: IiI11Ii111 / i1iiIII111
   self . _referenceIndexes : List [ int ] = [ ]
   if 30 - 30: i1i1i1111I % Iii1i . i1iiIII111
   if 3 - 3: ooOOO
   self . _cacheInput : List [ Any ] = [ ]
   if 64 - 64: OooOoo + I11iiIi11i1I - Ooo0Ooo % Oo
  @ property
  def epochSize ( self ) -> int :
   if 41 - 41: oOO / i1iiIII111 + Oo * OooOoo
   if 70 - 70: iI1iII1I1I1i
   if 64 - 64: OooOoo . i1I / IiIIii11Ii
   if 98 - 98: I11iiIi11i1I - i1iiIII111 . ooOOO + ooo000 / Ii
   if 98 - 98: iI1iII1I1I1i % i1 / ooo000 * OooOoo . oOo0O00 + Ooo0Ooo
   if 98 - 98: ooOOO + iI1iII1I1I1i - OooOoo - IiIIii11Ii . iI1iII1I1I1i . Oo
   if 4 - 4: Ii / iI1iII1I1I1i % IiIIii11Ii . ooo000
   if 34 - 34: oOO - i1 * Ii - Oo / i1iiIII111 - oOo0O00
   if 30 - 30: I1Ii1I1 . oOo0O00 - oOo0O00 . i1iiIII111 % iI1iII1I1I1i
   if 86 - 86: Ii - I1Ii1I1
   return ( len ( self . _referenceIndexes ) if len ( self . _referenceIndexes ) else None ) if self . _epochSize is None else self . _epochSize
   if 73 - 73: ooOOO + ooo000
  def getEpochSize ( self , refresh : bool = False ) -> int :
   if 88 - 88: OooOoo - I1Ii1I1 - I11iiIi11i1I % Ii + iI1iII1I1I1i
   if 54 - 54: OooOoo + iI1iII1I1I1i . ooo000 * I1I
   if 19 - 19: I1I . I1I + oOO * ooo000
   if 61 - 61: OooOoo * IiI11Ii111 + I1I / I11iiIi11i1I
   if 56 - 56: IIiIIiIi11I1 % Ii % Iii1i - I11iiIi11i1I + ooo000 % i1I
   if 87 - 87: Ii / i1iiIII111
   if 100 - 100: ooOOO / IiIIii11Ii . Iii1i
   if 88 - 88: OooOoo % I1I - Ooo0Ooo % i1i1i1111I * i1iiIII111
   if 77 - 77: ooOOO - i1iiIII111 . i1iiIII111 / Ooo0Ooo
   if 58 - 58: IIiIIiIi11I1
   if 65 - 65: IIiIIiIi11I1 - i1iiIII111 * ooOOO + Ooo0Ooo / i1i1i1111I
   if 76 - 76: i1 . ooOOO % I1Ii1I1 / I1I - OooOoo - iI1iII1I1I1i
   if 94 - 94: Ii / I1Ii1I1
   return self . epochSize
   if 23 - 23: IIiIIiIi11I1 / Oo . iI1iII1I1I1i . IIiIIiIi11I1 + IiI11Ii111 - Oo
  def copy ( self ) -> 'DataPreprocessing.Node.TimeSeries.GeneratorDetail' :
   if 63 - 63: Ooo0Ooo
   if 22 - 22: oOo0O00
   if 21 - 21: IiIIii11Ii % oOo0O00 . oOO + i1I - oOO
   if 30 - 30: IiIIii11Ii
   if 23 - 23: Ooo0Ooo
   if 75 - 75: I1I
   if 75 - 75: Iii1i / I1Ii1I1
   if 96 - 96: oOO % Oo . I1Ii1I1 + ooo000
   if 35 - 35: Ii . oOO - i1i1i1111I . iI1iII1I1I1i
   if 60 - 60: I1I
   if 11 - 11: iI1iII1I1I1i / i1iiIII111 . Iii1i * Ii
   ii1IIiIIi : IIiIiiii . GeneratorDetail = IIiIiiii . GeneratorDetail ( self . controller )
   if 38 - 38: I1I / Ooo0Ooo / I1Ii1I1 - ooOOO + ooo000
   if 74 - 74: iI1iII1I1I1i . I1Ii1I1
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_referenceIndexes" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 73 - 73: Ooo0Ooo - oOO / Iii1i
   return ii1IIiIIi
   if 70 - 70: Ii % ooo000
  def initialize ( self ) :
   if 97 - 97: Ii + IiIIii11Ii / IiI11Ii111
   if 94 - 94: i1iiIII111 % IiI11Ii111 . IiI11Ii111 / OooOoo / iI1iII1I1I1i
   if 90 - 90: I1Ii1I1 - oOO
   if 12 - 12: Oo % ooo000
   if 29 - 29: Ii * i1I + Ooo0Ooo
   if 8 - 8: Ooo0Ooo - iI1iII1I1I1i
   if 51 - 51: I1Ii1I1 + I1Ii1I1 - oOo0O00 % I1I + IIiIIiIi11I1 % ooOOO
   super ( ) . initialize ( )
   if 80 - 80: i1I * Iii1i + Iii1i - oOO % oOo0O00 - Iii1i
   if 54 - 54: IiIIii11Ii - Iii1i - Ii / Iii1i % Oo * i1I
   if len ( self . _referenceIndexes ) == 0 :
    if 22 - 22: I1Ii1I1 . i1i1i1111I / oOo0O00 + IiI11Ii111 / Ii
    I1 : IIiIiiii = self . controller . attachObject
    if 36 - 36: i1I % i1I . i1
    if 23 - 23: I1I + i1
    O0oo0O00O0OO0 : int = I1 . getRootSources ( ) [ 0 ] . epochSize
    if O0oo0O00O0OO0 is None :
     return
     if 27 - 27: I1Ii1I1 . i1
     if 46 - 46: Ii
    self . _referenceIndexes = [ i for i in range ( 0 , O0oo0O00O0OO0 - ( I1 . seriesLen - 1 ) ) ]
    if 20 - 20: i1iiIII111 * Ii + Oo
    if 80 - 80: i1iiIII111 / i1iiIII111 + Ii * ooo000 / I11iiIi11i1I % oOO
    if I1 . seriesLabel is not None :
     if 72 - 72: I1I * I1I % i1
     oo0oO00O : int = I1 . seriesLabel
     o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
     if 25 - 25: i1 + ooo000
     if 21 - 21: OooOoo - oOO . IiIIii11Ii . oOO % i1
     if o0o0oooO0 [ 0 ] . splittable :
      if 16 - 16: ooOOO + i1i1i1111I
      IIi11ii1IIi : List [ Any ] = o0o0oooO0 [ 0 ] . getData ( )
      if 21 - 21: iI1iII1I1I1i . IiI11Ii111 + i1iiIII111 - IiI11Ii111 % IiI11Ii111
      if 18 - 18: Oo
      if I1 . seriesLabelParser == "n" :
       self . _referenceIndexes . sort ( key = lambda ooooO0O0Oo : float ( IIi11ii1IIi [ ooooO0O0Oo ] [ oo0oO00O ] ) )
      else :
       self . _referenceIndexes . sort ( key = lambda ooooO0O0Oo : IIi11ii1IIi [ ooooO0O0Oo ] [ oo0oO00O ] )
       if 19 - 19: ooo000 - I1I
       if 10 - 10: oOo0O00 - IiIIii11Ii % I1Ii1I1 + i1i1i1111I
    if isinstance ( I1 . fromNode , Oo0ooo0OO0 ) :
     if 2 - 2: IiI11Ii111 / i1i1i1111I + I1I % iI1iII1I1I1i
     o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
     if 44 - 44: i1I . I1Ii1I1 / iI1iII1I1I1i - i1 . Oo
     if 62 - 62: ooo000 / Ooo0Ooo / ooOOO
     if o0o0oooO0 [ 0 ] . splittable :
      if 61 - 61: I11iiIi11i1I / ooo000 * ooOOO
      IIi11ii1IIi : np . ndarray = o0o0oooO0 [ 0 ] . getData ( )
      if 50 - 50: OooOoo
      if 90 - 90: IiI11Ii111
      self . _cacheInput = I1 . fromNode . processData ( IIi11ii1IIi )
      if 55 - 55: iI1iII1I1I1i
      if 99 - 99: Iii1i . i1I
    if I1 . reversed :
     self . _referenceIndexes = [ index + I1 . seriesLen - 1 for index in self . _referenceIndexes ]
     if 76 - 76: oOO * ooOOO
  def getCacheInput ( self , start : int = None , end : int = None , indexes : List [ int ] = None ) -> 'np.ndarray<*>' :
   if 41 - 41: Ii + I1I
   if 22 - 22: i1i1i1111I . i1 + IiIIii11Ii + i1iiIII111 . ooOOO . I1I
   if 93 - 93: i1I . Oo
   if 39 - 39: Ii * I11iiIi11i1I
   if 57 - 57: iI1iII1I1I1i % OooOoo * iI1iII1I1I1i + IiI11Ii111
   if 17 - 17: ooOOO * OooOoo / i1i1i1111I
   if 65 - 65: ooOOO / i1iiIII111 * oOO * i1I . I1Ii1I1
   if 95 - 95: oOo0O00
   if 99 - 99: IIiIIiIi11I1 - Ooo0Ooo . ooo000 - I1I % I1I
   if 31 - 31: i1I % oOO
   if 56 - 56: IiIIii11Ii . Ii % I1Ii1I1
   if 44 - 44: oOO * oOo0O00 * ooOOO - Ii
   if 67 - 67: I11iiIi11i1I * I11iiIi11i1I + I11iiIi11i1I
   if 25 - 25: I1Ii1I1 % Ooo0Ooo + IIiIIiIi11I1 * ooo000 / Iii1i / I11iiIi11i1I
   if 35 - 35: OooOoo - i1I * IiIIii11Ii / oOo0O00
   if 28 - 28: IiIIii11Ii + i1I . I1Ii1I1 - I1Ii1I1 % I1Ii1I1 / IiIIii11Ii
   if start == "None" :
    start = None
   if end == "None" :
    end = None
    if 2 - 2: oOO
    if 24 - 24: ooo000 * oOo0O00 / iI1iII1I1I1i
   if start is not None or end is not None :
    return self . _cacheInput [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= len ( self . _cacheInput ) or idx < - len ( self . _cacheInput ) ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    return self . _cacheInput [ indexes ]
   else :
    return self . _cacheInput [ : ]
    if 23 - 23: I1I - ooOOO % Iii1i / I1Ii1I1 . I1Ii1I1
  def prepareIteration ( self ) :
   if 32 - 32: oOo0O00 . i1I % I1Ii1I1
   if 77 - 77: Iii1i
   if 78 - 78: Ooo0Ooo * I1Ii1I1 - iI1iII1I1I1i * OooOoo . ooo000 - Iii1i
   if 34 - 34: i1I . Ooo0Ooo + I1I
   if 24 - 24: IIiIIiIi11I1
   if 37 - 37: Iii1i . i1 * i1i1i1111I % i1i1i1111I . i1 % i1
   if 48 - 48: IiI11Ii111 % I1Ii1I1
   if 18 - 18: iI1iII1I1I1i + i1i1i1111I
   if not self . initialized :
    self . initialize ( )
    if 12 - 12: ooo000 / Ii . Iii1i - OooOoo % iI1iII1I1I1i
    if 63 - 63: i1iiIII111 . ooOOO - Oo - Ooo0Ooo * IIiIIiIi11I1 . Ooo0Ooo
   self . batchIdxReset ( )
   if 17 - 17: I1I + I11iiIi11i1I * IiIIii11Ii * Iii1i
   if 2 - 2: i1 + I1Ii1I1 - ooOOO / i1i1i1111I - iI1iII1I1I1i
   if self . shuffle :
    self . _shuffleData ( )
    if 55 - 55: i1 / Oo * I1I / Oo - IiI11Ii111 . ooOOO
  def _shuffleData ( self ) :
   if 37 - 37: Ooo0Ooo . OooOoo + Oo / IiIIii11Ii - oOo0O00 + Oo
   if 96 - 96: I1Ii1I1 - iI1iII1I1I1i
   if 61 - 61: I11iiIi11i1I - IIiIIiIi11I1 + Ii - I1I - IiI11Ii111 + oOo0O00
   if 24 - 24: ooOOO . i1i1i1111I - i1iiIII111 - Oo + I11iiIi11i1I
   if 71 - 71: i1i1i1111I . IiI11Ii111 - i1I % I1I
   if 23 - 23: I1Ii1I1 * I1Ii1I1 . oOo0O00
   if 72 - 72: oOo0O00 - ooOOO
   if 99 - 99: IIiIIiIi11I1 . i1 / ooOOO
   np . random . shuffle ( self . _referenceIndexes )
   if 45 - 45: I1I + ooo000 % ooOOO % iI1iII1I1I1i
  def setData ( self , inputArray : Union [ list ] = [ ] , outputArray : None = None , hasHeader : None = None ) :
   if 73 - 73: I1Ii1I1
   if 46 - 46: IiIIii11Ii % i1 * ooo000
   if 98 - 98: oOO - i1I
   if 6 - 6: iI1iII1I1I1i * I1I / I11iiIi11i1I
   if 56 - 56: ooOOO * Iii1i . IiI11Ii111 . i1 + i1iiIII111 % i1iiIII111
   if 62 - 62: I1Ii1I1 + ooo000 . ooOOO * i1iiIII111 / IiI11Ii111 % Iii1i
   if 5 - 5: IIiIIiIi11I1 / i1i1i1111I % Ooo0Ooo + oOo0O00 . IIiIIiIi11I1
   if 83 - 83: Oo - i1 + I11iiIi11i1I - ooOOO % I1I + iI1iII1I1I1i
   if 7 - 7: ooo000 * oOO . IiIIii11Ii - Ooo0Ooo
   if 33 - 33: OooOoo - ooo000 * ooo000 / oOO
   if 9 - 9: oOo0O00 * i1i1i1111I * I11iiIi11i1I
   if 48 - 48: IiI11Ii111 * Ii % OooOoo . IIiIIiIi11I1 - I1Ii1I1
   if 74 - 74: Iii1i
   iI1I = list ( inputArray )
   if 100 - 100: i1iiIII111 + iI1iII1I1I1i . oOO * Iii1i - oOo0O00
   if 31 - 31: Ooo0Ooo - i1iiIII111 . Ii
   if len ( np . shape ( iI1I ) ) != 1 :
    raise ValueError ( "Input Shape must be a 1-dimensional list." )
    if 30 - 30: iI1iII1I1I1i / Ooo0Ooo + I11iiIi11i1I % I1I / ooo000 . IIiIIiIi11I1
    if 83 - 83: I1I * ooo000 . Oo - oOO
   if len ( iI1I ) == 0 :
    raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
    if 18 - 18: I1Ii1I1 * Ooo0Ooo
    if 53 - 53: ooOOO % IiI11Ii111 . I11iiIi11i1I . iI1iII1I1I1i
   self . _referenceIndexes = iI1I
   if 66 - 66: Ooo0Ooo % I1I + i1iiIII111 % IiI11Ii111 * ooo000 . IIiIIiIi11I1
  def getData ( self , start : int = None , end : int = None , indexes : int = None ) -> 'np.ndarray<*>' :
   if 97 - 97: Ooo0Ooo % I1I
   if 39 - 39: I11iiIi11i1I / IiI11Ii111 * IIiIIiIi11I1 % Iii1i - i1iiIII111 * i1iiIII111
   if 3 - 3: oOo0O00 * OooOoo % Oo / iI1iII1I1I1i * ooOOO . oOO
   if 55 - 55: oOO . iI1iII1I1I1i - Ooo0Ooo . I1I - Ii / i1i1i1111I
   if 52 - 52: Iii1i % IIiIIiIi11I1
   if 25 - 25: I1Ii1I1 % IiI11Ii111 % i1I . I1Ii1I1 % IIiIIiIi11I1
   if 16 - 16: Ooo0Ooo / i1iiIII111 * i1 / i1i1i1111I - iI1iII1I1I1i
   if 95 - 95: oOO
   if 55 - 55: ooOOO % ooo000 / i1I
   if 38 - 38: I1I . i1I
   if 69 - 69: i1 * i1 . oOo0O00 + IiI11Ii111 * Iii1i * Oo
   if 37 - 37: IiI11Ii111 % iI1iII1I1I1i - Iii1i
   if 49 - 49: i1i1i1111I / i1iiIII111 % iI1iII1I1I1i % Iii1i / IiIIii11Ii
   if 34 - 34: I1Ii1I1 % i1 + I11iiIi11i1I % ooOOO * i1
   if 7 - 7: i1i1i1111I / oOO - Ooo0Ooo . I11iiIi11i1I - ooo000 . ooo000
   if 83 - 83: i1 * Oo * i1iiIII111
   if not self . initialized :
    self . initialize ( )
    if 83 - 83: Ii % ooo000 . ooOOO * OooOoo % I11iiIi11i1I
    if 12 - 12: I1I . Ii - Oo
   I1 : IIiIiiii = self . controller . attachObject
   if 61 - 61: IiI11Ii111
   if 20 - 20: oOo0O00 * iI1iII1I1I1i . I1I . Iii1i
   if I1 . getEpochSize ( True ) is None :
    return [ ]
    if 66 - 66: Ii % i1i1i1111I % I1Ii1I1 - OooOoo - I1Ii1I1 % IiI11Ii111
    if 54 - 54: oOo0O00 / I11iiIi11i1I + Iii1i + Iii1i * iI1iII1I1I1i
   o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
   if 19 - 19: i1I % i1I + iI1iII1I1I1i / ooOOO * i1i1i1111I
   if 10 - 10: Iii1i % i1I - Oo * IiI11Ii111
   if start == "None" or start is None :
    start = 0
   if end == "None" or end is None :
    end = len ( self . _referenceIndexes )
    if 50 - 50: I1Ii1I1
    if 61 - 61: OooOoo - oOO . I11iiIi11i1I . OooOoo
   o00oO0O0o00O : List [ int ]
   if start is not None or end is not None :
    o00oO0O0o00O = self . _referenceIndexes [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= end or idx < - end ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    indexes = [ ( idx if idx >= 0 else ( len ( self . _referenceIndexes ) + idx ) ) for idx in indexes ]
    if 3 - 3: Oo % iI1iII1I1I1i
    oo0 : List [ Any ] = [ ]
    for IiI in indexes :
     oo0 . append ( self . _referenceIndexes [ IiI ] )
    o00oO0O0o00O = oo0
   else :
    o00oO0O0o00O = self . _referenceIndexes [ : ]
    if 8 - 8: Ooo0Ooo / ooOOO / ooOOO + i1iiIII111 / ooo000 % I1Ii1I1
    if 83 - 83: I11iiIi11i1I + IIiIIiIi11I1 * Iii1i
   if not o0o0oooO0 [ 0 ] . splittable :
    raise ValueError ( "Time Series data preprocessing node currenly only supports for splittable data sources." )
    if 11 - 11: oOo0O00 . OooOoo
    if 39 - 39: IiIIii11Ii * I1I
   if isinstance ( I1 . fromNode , list ) :
    raise ValueError ( "Multiple from node is detected from a time series data source" )
    if 53 - 53: i1I . OooOoo . iI1iII1I1I1i / i1 + Iii1i
    if 24 - 24: i1I + ooo000 - Ii * IiI11Ii111 / ooo000
   I1IIiI : List [ np . ndarray ] = [ ]
   O00O00o : List [ int ] = None
   I11i : int = - 1 if I1 . reversed else 1
   if 84 - 84: OooOoo . i1 + i1iiIII111 - OooOoo
   for ooOoOOoo00 in range ( 0 , I1 . seriesLen ) :
    II1I : np . ndarray
    if 98 - 98: Ii + IiIIii11Ii + Ooo0Ooo / I11iiIi11i1I + oOO . iI1iII1I1I1i
    if self . _cacheInput and len ( self . _cacheInput ) :
     II1I = self . getCacheInput ( indexes = o00oO0O0o00O )
     if 48 - 48: Iii1i * ooo000 / ooOOO
    else :
     II1I = I1 . fromNode . getData ( indexes = o00oO0O0o00O )
     if 66 - 66: Oo / i1I + IIiIIiIi11I1 - I11iiIi11i1I / IiIIii11Ii
     if 36 - 36: Ooo0Ooo - I1I / i1 / Ii - ooo000 - iI1iII1I1I1i
    O00O00o = np . shape ( II1I ) if O00O00o is None else O00O00o
    iiIII1I1ii : np . ndarray = II1I [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( I1 . crops [ idx ] ) if idx in I1 . crops else slice ( None , None ) ) for idx , v in enumerate ( O00O00o [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( I1 . sourceCol ) ) ]
    I1IIiI . append ( iiIII1I1ii [ : , np . newaxis ] )
    o00oO0O0o00O = [ ( batchIndex + I11i ) for batchIndex in o00oO0O0o00O ]
    if 78 - 78: Ooo0Ooo % i1I + OooOoo . i1I + oOo0O00
    if 73 - 73: I1Ii1I1 * Ii / I1Ii1I1 + IiI11Ii111
   return np . concatenate ( I1IIiI , axis = 1 )
   if 68 - 68: I1Ii1I1 / i1I - OooOoo % Iii1i
  def getNextBatch ( self ) -> 'np.ndarray' :
   if 50 - 50: i1i1i1111I - i1I - Ooo0Ooo % I1Ii1I1
   if 25 - 25: IiI11Ii111 - IiI11Ii111 % OooOoo
   if 76 - 76: oOO % I1I / oOO + IIiIIiIi11I1 * oOO - I11iiIi11i1I
   if 60 - 60: iI1iII1I1I1i - I1Ii1I1 % Ooo0Ooo + oOo0O00 . i1 . ooOOO
   if 68 - 68: I11iiIi11i1I . ooOOO
   if 78 - 78: i1iiIII111 . I1I
   if 78 - 78: I1I * i1i1i1111I % OooOoo / Iii1i - Iii1i
   if 1 - 1: oOo0O00
   if 39 - 39: iI1iII1I1I1i
   if 52 - 52: i1i1i1111I % oOo0O00
   if 95 - 95: i1 * oOo0O00 . i1I * I1I . Oo + Iii1i
   if not self . initialized :
    self . initialize ( )
    if 27 - 27: IIiIIiIi11I1 % OooOoo + oOO * OooOoo - Ii
    if 76 - 76: Ooo0Ooo % i1iiIII111 * ooo000 * I1Ii1I1 + OooOoo
   if self . batchIdx is None :
    self . prepareIteration ( )
    if 38 - 38: i1iiIII111
    if 80 - 80: OooOoo * I11iiIi11i1I . i1 / i1 + i1I . IIiIIiIi11I1
   IiIIiiII : int = self . batchIdx
   o0OOOO0Oo0O : int = self . batchSize
   if 55 - 55: Oo % ooOOO % IiI11Ii111 % ooo000
   if 17 - 17: Ii % IiIIii11Ii * oOO - Iii1i / i1i1i1111I
   if ( self . dropRemainder and ( IiIIiiII + 1 ) * o0OOOO0Oo0O > self . epochSize ) or ( ( not self . dropRemainder ) and IiIIiiII * o0OOOO0Oo0O >= self . epochSize ) :
    self . prepareIteration ( )
    IiIIiiII = self . batchIdx
    if 61 - 61: i1 + Iii1i * IiI11Ii111 - Ooo0Ooo - I11iiIi11i1I . Ooo0Ooo
    if 74 - 74: OooOoo - oOo0O00 * Iii1i
   O00o000Oo : np . ndarray = self . getData ( start = IiIIiiII * o0OOOO0Oo0O , end = ( IiIIiiII + 1 ) * o0OOOO0Oo0O )
   if 40 - 40: IIiIIiIi11I1 + ooOOO
   if 16 - 16: i1iiIII111 / i1i1i1111I / I1I * IiI11Ii111 - ooo000 + Oo
   self . batchIdxIncrement ( )
   if 2 - 2: IIiIIiIi11I1
   return O00o000Oo
   if 63 - 63: I1Ii1I1 / IIiIIiIi11I1 . Ii + i1
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> 'np.ndarray' :
   if 54 - 54: i1I
   if 98 - 98: Ii / i1iiIII111 / i1I % i1i1i1111I % I1I % I11iiIi11i1I
   if 62 - 62: iI1iII1I1I1i / Ii
   if 25 - 25: I1Ii1I1 * oOo0O00 + ooOOO
   if 58 - 58: IiI11Ii111 % ooOOO . IIiIIiIi11I1
   if 56 - 56: iI1iII1I1I1i
   if 96 - 96: OooOoo - i1iiIII111 / Iii1i . IIiIIiIi11I1 * Ooo0Ooo
   if 42 - 42: IiI11Ii111
   if 10 - 10: Ii * oOO * i1i1i1111I + IIiIIiIi11I1
   if 89 - 89: I1Ii1I1 * oOO
   if 76 - 76: ooOOO . ooo000 + I1I
   if 33 - 33: IiI11Ii111
   if 10 - 10: I11iiIi11i1I + IiIIii11Ii . oOO + i1i1i1111I * Oo
   if 42 - 42: ooOOO + IiI11Ii111 * IiIIii11Ii - i1
   if 78 - 78: ooo000 . IIiIIiIi11I1 . Iii1i - oOo0O00 . i1I . i1
   if len ( self . _referenceIndexes ) == 0 :
    return np . array ( [ ] )
    if 2 - 2: i1iiIII111 + Oo + ooOOO % i1 . oOO % OooOoo
    if 23 - 23: oOO
   Oo0o0oo0 : np . ndarray = np . arange ( len ( self . _referenceIndexes ) )
   np . random . seed ( randomSeed )
   np . random . shuffle ( Oo0o0oo0 )
   np . random . seed ( )
   if 4 - 4: i1I / ooo000 - Ii / I11iiIi11i1I / oOO + oOO
   if 52 - 52: Iii1i + iI1iII1I1I1i * oOO % OooOoo . i1iiIII111 - I1Ii1I1
   O00o000Oo : np . ndarray = self . getData ( indexes = Oo0o0oo0 )
   if 78 - 78: i1i1i1111I + oOo0O00 - Ooo0Ooo * IiI11Ii111 * I1I / i1
   if 44 - 44: OooOoo - Ii / IiI11Ii111 / oOo0O00 - Iii1i + I11iiIi11i1I
   return O00o000Oo . copy ( )
   if 65 - 65: Ooo0Ooo
  def partition ( self , prop : float = 0.2 , shuffle : float = False ) -> Tuple [ 'np.ndarray' , 'np.ndarray' ] :
   if 63 - 63: I11iiIi11i1I
   if 93 - 93: IIiIIiIi11I1 % IiI11Ii111 . Ii / Oo * IiI11Ii111
   if 90 - 90: oOO . oOo0O00 * i1i1i1111I / I1I . OooOoo
   if 50 - 50: Oo . oOO + oOO + i1iiIII111
   if 72 - 72: i1iiIII111
   if 21 - 21: I1Ii1I1 / Oo * IiI11Ii111 . ooo000
   if 5 - 5: I1Ii1I1 - Iii1i / i1iiIII111
   if 29 - 29: Iii1i - IIiIIiIi11I1 - IiIIii11Ii + ooOOO * oOo0O00
   if 62 - 62: Ii * OooOoo % I1I * iI1iII1I1I1i . oOo0O00 . ooo000
   if 96 - 96: IiI11Ii111
   if 74 - 74: i1 * ooOOO % Ooo0Ooo
   if 63 - 63: OooOoo - I1Ii1I1 - i1iiIII111 / i1I
   if 49 - 49: IiIIii11Ii
   if 30 - 30: OooOoo
   if 96 - 96: oOO . Iii1i + IiIIii11Ii / IIiIIiIi11I1
   if not self . initialized :
    self . initialize ( )
    if 72 - 72: I1I . I11iiIi11i1I - Ii - i1iiIII111
    if 7 - 7: Ii / ooo000 - Ooo0Ooo / Iii1i
   IiiI1 = len ( self . _referenceIndexes )
   iII11i1 = math . floor ( IiiI1 * prop )
   i1iI1iI = self . _referenceIndexes [ : ]
   if 48 - 48: OooOoo
   if 94 - 94: i1i1i1111I * Ooo0Ooo * Iii1i + oOO % i1I
   if shuffle :
    np . random . shuffle ( i1iI1iI )
    if 16 - 16: I1I
    if 76 - 76: i1I
   ooo00 = i1iI1iI [ iII11i1 : ]
   O0o = i1iI1iI [ : iII11i1 ]
   if 16 - 16: i1 . Iii1i
   if 19 - 19: Iii1i / ooOOO % i1iiIII111
   return ooo00 , O0o
   if 21 - 21: iI1iII1I1I1i / i1I + IiI11Ii111 - i1 + i1I . I1Ii1I1
 class GeneratorController ( I111II1II111I . Controller ) :
  if 51 - 51: Ii
  if 80 - 80: Ooo0Ooo % OooOoo . IiIIii11Ii - oOo0O00 - i1iiIII111 * ooOOO
  if 35 - 35: OooOoo % i1iiIII111 . oOO + oOo0O00 % oOo0O00 * i1iiIII111
  if 29 - 29: Oo . Iii1i % oOO * oOO . IiI11Ii111
  if 50 - 50: IiIIii11Ii * I1I % oOo0O00
  if 37 - 37: ooo000 - I1Ii1I1 / IiI11Ii111
  if 88 - 88: Oo / IiI11Ii111 - IIiIIiIi11I1
  def __init__ ( self , attachObject : 'DataPreprocessing.Node.TimeSeries' ) :
   if 7 - 7: Ooo0Ooo * Iii1i - i1
   if 53 - 53: Ooo0Ooo
   if 18 - 18: Ooo0Ooo % iI1iII1I1I1i . Iii1i
   if 38 - 38: OooOoo * ooo000 - OooOoo . I1I
   if 46 - 46: IiIIii11Ii
   if 65 - 65: i1i1i1111I . I1I + Iii1i
   if 9 - 9: i1i1i1111I / IIiIIiIi11I1 - i1iiIII111 . Ooo0Ooo
   if 7 - 7: iI1iII1I1I1i % Ii % IiIIii11Ii
   if 17 - 17: oOo0O00 + i1i1i1111I
   if 27 - 27: i1iiIII111 % oOo0O00
   super ( ) . __init__ ( attachObject = attachObject )
   if 57 - 57: Ii + ooo000 * IiIIii11Ii + Oo / i1iiIII111
  @ property
  def detailType ( self ) -> Callable [ ... , 'DataPreprocessing.Node.TimeSeries.GeneratorDetail' ] :
   if 89 - 89: Ii % iI1iII1I1I1i + i1I . i1i1i1111I
   if 98 - 98: i1I % ooo000 % oOo0O00 - ooo000 * I1I % Ooo0Ooo
   if 43 - 43: oOO . I1I / IiI11Ii111 + IIiIIiIi11I1
   if 34 - 34: oOO * ooo000 - Iii1i % iI1iII1I1I1i + I1Ii1I1 . i1
   if 96 - 96: IIiIIiIi11I1 - i1i1i1111I * ooOOO % Iii1i / Oo * i1I
   if 24 - 24: IiI11Ii111 . IiIIii11Ii
   if 56 - 56: I1I / OooOoo / IiI11Ii111 * IIiIIiIi11I1
   if 28 - 28: I1I / ooo000 % ooOOO + I1Ii1I1 . OooOoo % i1iiIII111
   if 31 - 31: iI1iII1I1I1i - ooo000
   if 80 - 80: I1Ii1I1 * I1Ii1I1 + IIiIIiIi11I1 - IiI11Ii111 / I1Ii1I1
   return IIiIiiii . GeneratorDetail
   if 29 - 29: i1iiIII111 % OooOoo * OooOoo . I1Ii1I1 / i1I . Oo
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 33 - 33: i1i1i1111I . IiI11Ii111 - i1 / I11iiIi11i1I / oOo0O00 + OooOoo
   if 28 - 28: i1i1i1111I - i1I % I11iiIi11i1I
   if 20 - 20: IIiIIiIi11I1 . i1iiIII111 + i1iiIII111 . i1iiIII111 + OooOoo
   if 50 - 50: iI1iII1I1I1i
   if 42 - 42: IiI11Ii111 % i1i1i1111I % oOO / i1
   if 16 - 16: Iii1i
   if 92 - 92: i1 + OooOoo / Ooo0Ooo / OooOoo
   if 17 - 17: iI1iII1I1I1i - I1I - i1i1i1111I / Ooo0Ooo
   if 93 - 93: Ii * ooo000 - IIiIIiIi11I1 + iI1iII1I1I1i . Iii1i
   if 27 - 27: Ii + ooo000 / i1iiIII111 . i1iiIII111 % I1Ii1I1
   if 80 - 80: OooOoo + oOo0O00 * Ii . IIiIIiIi11I1 * oOo0O00
   if 94 - 94: OooOoo
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   IiOoOOOoO0 = Oooo0OOO . epochSize
   if 64 - 64: Ooo0Ooo . IiIIii11Ii - I11iiIi11i1I
   if 22 - 22: Ooo0Ooo - IiIIii11Ii / Iii1i % Ooo0Ooo
   if 21 - 21: Ii
   if randomFold :
    ( o0 , I1IiIii ) = Oooo0OOO . partition ( prop = validation , shuffle = True )
    if 32 - 32: I1I - IiIIii11Ii % ooo000 * Ooo0Ooo + i1i1i1111I * oOo0O00
    if 74 - 74: i1iiIII111 + IIiIIiIi11I1 % i1I * I1I
   else :
    if 14 - 14: i1I / i1I * IIiIIiIi11I1 * i1I * oOO
    oo0oOo0O0 = math . floor ( 1 / validation )
    IiIIiiII = self . validationTime % oo0oOo0O0
    IIi11ii1IIi = Oooo0OOO . oriData . copy ( ) [ 1 : ] if Oooo0OOO . hasHeader else Oooo0OOO . oriData . copy ( )
    if 91 - 91: i1i1i1111I % IiI11Ii111 + I11iiIi11i1I
    if 55 - 55: i1I
    if IiIIiiII == 0 and Oooo0OOO . shuffle :
     np . random . shuffle ( IIi11ii1IIi )
     if 95 - 95: i1iiIII111 + oOo0O00 . I1I % Ooo0Ooo / Ooo0Ooo
     if 38 - 38: OooOoo / i1
    ii1i1II1iiiI = math . ceil ( IiOoOOOoO0 / oo0oOo0O0 )
    I1I1111 = IiIIiiII * ii1i1II1iiiI
    oOO0o00 = ( IiIIiiII + 1 ) * ii1i1II1iiiI
    o0 = np . vstack ( ( IIi11ii1IIi [ : I1I1111 ] , IIi11ii1IIi [ oOO0o00 : ] ) )
    I1IiIii = IIi11ii1IIi [ I1I1111 : oOO0o00 ]
    if 76 - 76: Oo - Oo / I1Ii1I1
    if 92 - 92: oOO % i1i1i1111I * Oo * IiI11Ii111 + oOo0O00
   self [ I111II1II111I . Dataset . Types . ValidationTrain ] . setData ( inputArray = o0 )
   self [ I111II1II111I . Dataset . Types . Validation ] . setData ( inputArray = I1IiIii )
   if 72 - 72: ooOOO / Iii1i . i1i1i1111I
   if 24 - 24: Ooo0Ooo - I1Ii1I1 * I1I / I11iiIi11i1I % oOo0O00 * IIiIIiIi11I1
   o0o0oooO0 = self . attachObject . getRootSources ( )
   for oOO0O0 in o0o0oooO0 :
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Validation ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . ValidationTrain ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    if 39 - 39: I1Ii1I1 * i1iiIII111
    if 51 - 51: I11iiIi11i1I - IIiIIiIi11I1 * I11iiIi11i1I . I11iiIi11i1I % OooOoo / I1I
   self . validationTime += 1
   if 58 - 58: oOO * IIiIIiIi11I1 * i1iiIII111 . oOO * oOo0O00
  def splitTestDataset ( self , test : float = 0.2 , shuffle : float = False ) :
   if 9 - 9: Ii % i1i1i1111I - I1I * ooOOO
   if 74 - 74: ooo000 + iI1iII1I1I1i + i1I * oOO % ooo000 + Iii1i
   if 97 - 97: I11iiIi11i1I + iI1iII1I1I1i - ooOOO % ooo000 % oOO / i1
   if 1 - 1: OooOoo - ooo000 / Ii . Ii % i1I
   if 19 - 19: ooo000 . OooOoo - Oo . Ooo0Ooo
   if 42 - 42: iI1iII1I1I1i + I11iiIi11i1I * Ooo0Ooo
   if 36 - 36: I11iiIi11i1I - i1iiIII111 - i1iiIII111
   if 97 - 97: IiIIii11Ii - I1Ii1I1 . ooOOO
   if 61 - 61: Iii1i + Ii . I11iiIi11i1I - iI1iII1I1I1i
   if 44 - 44: I11iiIi11i1I - oOo0O00 / Ii * i1i1i1111I + Ooo0Ooo
   if 49 - 49: i1iiIII111 + OooOoo . I1Ii1I1
   if 33 - 33: i1i1i1111I + i1I % IiI11Ii111
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   ( o0 , Oo00OOo0oo0 ) = Oooo0OOO . partition ( prop = test , shuffle = shuffle )
   if 61 - 61: OooOoo . I1I / I11iiIi11i1I
   if 53 - 53: Iii1i - i1 % IIiIIiIi11I1 + i1i1i1111I . iI1iII1I1I1i
   self [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = o0 )
   self [ I111II1II111I . Dataset . Types . Test ] . setData ( inputArray = Oo00OOo0oo0 )
   if 3 - 3: I1I - Ii
   if 80 - 80: OooOoo + I11iiIi11i1I / Ooo0Ooo
   o0o0oooO0 = self . attachObject . getRootSources ( )
   for oOO0O0 in o0o0oooO0 :
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Test ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    if 8 - 8: i1iiIII111 . Ii
    if 70 - 70: oOO * Iii1i / ooOOO % i1i1i1111I * I1I
 def __init__ ( self , seriesLen : int = 2 , sourceCol : str = "None:None" , dtype : 'tf.DType' = None ) :
  if 35 - 35: Iii1i % Ooo0Ooo % i1i1i1111I * IIiIIiIi11I1 % IIiIIiIi11I1 % i1I
  if 63 - 63: i1iiIII111 + OooOoo
  if 72 - 72: I1I . ooo000 + IiI11Ii111
  if 35 - 35: oOo0O00 . Ii + I1I - ooo000 + IIiIIiIi11I1
  if 39 - 39: i1I . IIiIIiIi11I1 + i1 * ooOOO % Iii1i
  if 44 - 44: oOO * OooOoo . Ooo0Ooo * I1Ii1I1 . IiI11Ii111
  if 33 - 33: Ii / i1i1i1111I / IiIIii11Ii
  if 68 - 68: i1iiIII111 / ooOOO % Iii1i % I1I - oOo0O00
  if 20 - 20: i1
  if 13 - 13: iI1iII1I1I1i * iI1iII1I1I1i * oOo0O00 - Ooo0Ooo % iI1iII1I1I1i
  if 47 - 47: Oo + oOo0O00 * I11iiIi11i1I . ooOOO - I11iiIi11i1I
  if 93 - 93: Iii1i / I11iiIi11i1I
  super ( ) . __init__ ( instanceClass = OoiI1iiI11IIi1 . TimeSeries , sourceCol = sourceCol , dtype = dtype )
  if 67 - 67: IiI11Ii111 / I11iiIi11i1I + I11iiIi11i1I - Oo + Ooo0Ooo % I1Ii1I1
  if 32 - 32: I1Ii1I1 / Iii1i - IiIIii11Ii * oOO * IiI11Ii111 - ooOOO
  self . seriesSort : int = - 1
  if 22 - 22: IIiIIiIi11I1 - I11iiIi11i1I + Oo / iI1iII1I1I1i
  if 25 - 25: ooo000 . I1Ii1I1 - I1I % i1i1i1111I * i1i1i1111I + I11iiIi11i1I
  self . seriesLen : int = seriesLen
  if 98 - 98: iI1iII1I1I1i
  if 70 - 70: oOo0O00 / ooo000 / i1iiIII111 + oOo0O00 % Ooo0Ooo
  self . oneHotColumns : Dict [ int , Set [ str ] ] = { }
  if 80 - 80: Iii1i % OooOoo - OooOoo / OooOoo - i1
  if 84 - 84: iI1iII1I1I1i . I11iiIi11i1I % Iii1i % OooOoo
  self . transformations : List [ oo0OOOOOO0o00 ] = [ ]
  if 22 - 22: i1I - Ii
  if 5 - 5: i1iiIII111 - oOO + iI1iII1I1I1i * oOO . iI1iII1I1I1i + iI1iII1I1I1i
  self . circular : List [ O000oOo0 ] = [ ]
  if 75 - 75: ooOOO * iI1iII1I1I1i . Ooo0Ooo
  if 64 - 64: I1I + I11iiIi11i1I % i1i1i1111I
  self . _colToCircular : Dict [ int , int ] = { }
  if 70 - 70: Ii % I1I - I11iiIi11i1I - IiIIii11Ii . i1I
  if 9 - 9: IiI11Ii111 - oOO . i1I
  self . preprocessInBatch : bool = True
  if 39 - 39: IiI11Ii111 % ooo000 * I1Ii1I1
  if 52 - 52: I11iiIi11i1I / oOO + iI1iII1I1I1i % I1I - I11iiIi11i1I
  self . _classCount : int = None
  if 3 - 3: IIiIIiIi11I1 . ooo000
  if 11 - 11: i1I / ooo000
  self . generatorController : IIiIiiii . GeneratorController = IIiIiiii . GeneratorController ( self )
  if 88 - 88: I1Ii1I1
 def appendOn ( self , source : Union [ 'Source.Config' , 'DataPreprocessing.Node.Config' , List [ 'DataPreprocessing.Node.Config' ] ] , key : str , outputset : str = None ) -> 'DataPreprocessing.Node.TimeSeries' :
  if 15 - 15: IiI11Ii111 * i1iiIII111 . i1i1i1111I * oOO % OooOoo . i1I
  if 83 - 83: ooo000 % Oo * OooOoo % IIiIIiIi11I1 . Iii1i
  if 52 - 52: IiI11Ii111 * Oo . iI1iII1I1I1i . i1I
  if 17 - 17: OooOoo - i1I
  if 72 - 72: oOO - IiI11Ii111
  if 30 - 30: I11iiIi11i1I + Ooo0Ooo
  if 85 - 85: iI1iII1I1I1i % i1 . i1iiIII111
  if 6 - 6: i1iiIII111 - I11iiIi11i1I - Ooo0Ooo % I11iiIi11i1I
  if 94 - 94: i1iiIII111 / IiIIii11Ii
  if 89 - 89: IIiIIiIi11I1 . i1 - Oo * I1Ii1I1
  if 85 - 85: i1iiIII111 . i1iiIII111
  if 44 - 44: i1iiIII111 . Ii - OooOoo + i1i1i1111I * IIiIIiIi11I1 % IiI11Ii111
  if 78 - 78: i1 * ooOOO % ooOOO * Ii + IiIIii11Ii + I11iiIi11i1I
  if 69 - 69: i1i1i1111I . oOo0O00
  if 9 - 9: Ii - Oo * OooOoo
  if 30 - 30: Ii + ooo000 / iI1iII1I1I1i % i1iiIII111 . ooo000 * oOO
  if isinstance ( source , list ) :
   raise ValueError ( "Time Series Data Preprocessing Node can only append on a single Source.Config or DataPreprocessing.Node.Config object." )
  elif isinstance ( source , Oo0ooo0OO0 ) :
   if 78 - 78: Ii
   oOO0O0 = source . getRootSources ( )
   if len ( oOO0O0 ) > 0 :
    raise ValueError ( "Time Series Data Preprocessing Node can only make reference to one root source." )
    if 75 - 75: iI1iII1I1I1i - iI1iII1I1I1i % Ii % i1 / oOo0O00 * ooOOO
    if 46 - 46: oOo0O00 % Ooo0Ooo + i1I - oOo0O00
   i1IIiiIi = [ source ]
   if 18 - 18: IIiIIiIi11I1 + IIiIIiIi11I1 / I1I % IiIIii11Ii . i1I
   if 64 - 64: I1Ii1I1 - OooOoo % iI1iII1I1I1i
   if isinstance ( source , IIiIiiii ) :
    raise ValueError ( "There should be no series data preprocessing node before any series data preprocessing node." )
    if 30 - 30: I11iiIi11i1I
    if 51 - 51: I1I * Ii * i1I / i1iiIII111 . oOO
   while len ( i1IIiiIi ) :
    OooooOoO0Oo0 = set ( )
    for O0oo0 in i1IIiiIi :
     if isinstance ( O0oo0 . fromNode , list ) :
      for i11II in O0oo0 . fromNode :
       if isinstance ( i11II , IIiIiiii ) :
        raise ValueError ( "There should be no series data preprocessing node before any series data preprocessing node." )
       elif isinstance ( i11II , Oo0ooo0OO0 ) :
        OooooOoO0Oo0 . add ( i11II )
     if isinstance ( O0oo0 . fromNode , IIiIiiii ) :
      raise ValueError ( "There should be no series data preprocessing node before any series data preprocessing node." )
     elif isinstance ( O0oo0 . fromNode , Oo0ooo0OO0 ) :
      OooooOoO0Oo0 . add ( O0oo0 . fromNode )
    i1IIiiIi = OooooOoO0Oo0
    if 45 - 45: ooOOO * i1 % Ooo0Ooo % Iii1i - I1I - oOo0O00
    if 38 - 38: ooOOO - I1Ii1I1 - Oo * IiIIii11Ii
  return super ( ) . appendOn ( source , key , outputset = outputset )
  if 96 - 96: IiIIii11Ii % oOo0O00 % i1i1i1111I * IIiIIiIi11I1 * IiI11Ii111 + Oo
  if 55 - 55: iI1iII1I1I1i
  if 1 - 1: I1Ii1I1 . i1i1i1111I / I11iiIi11i1I
  if 86 - 86: ooo000
 def getEpochSize ( self , refresh : bool = False ) -> int :
  if 73 - 73: oOo0O00 . i1 . ooOOO + IIiIIiIi11I1 * ooo000
  if 90 - 90: i1I
  if 33 - 33: IIiIIiIi11I1 / oOo0O00 - OooOoo . OooOoo % oOO
  if 52 - 52: i1 * Iii1i / OooOoo
  if 55 - 55: Iii1i + i1I % I1Ii1I1 - oOO . Ooo0Ooo / ooo000
  if 58 - 58: IiI11Ii111 . ooo000 * Ooo0Ooo - Ooo0Ooo
  if 10 - 10: OooOoo
  if 41 - 41: i1 - I1Ii1I1 + OooOoo . OooOoo / i1 * ooOOO
  if 79 - 79: Ii % I1I . iI1iII1I1I1i * oOO - i1
  if 54 - 54: IiI11Ii111 + Iii1i * IIiIIiIi11I1 . iI1iII1I1I1i
  if 79 - 79: i1iiIII111
  if 20 - 20: ooOOO + Oo - oOo0O00 + IiI11Ii111 . I1I / i1
  if 100 - 100: iI1iII1I1I1i . ooo000 + IiIIii11Ii
  return self . generatorController [ self . train . currentSourceDataset ] . getEpochSize ( refresh = refresh )
  if 56 - 56: ooo000 / Oo . oOO
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 50 - 50: OooOoo - ooo000
  if 28 - 28: i1I
  if 75 - 75: ooo000 * i1iiIII111 % IiIIii11Ii
  if 75 - 75: I1Ii1I1 * IIiIIiIi11I1
  if 88 - 88: ooOOO - oOo0O00 . Ii % Iii1i
  if 28 - 28: Iii1i + i1iiIII111 / i1i1i1111I + I1I * ooOOO
  if 100 - 100: ooOOO * ooo000 % IIiIIiIi11I1
  if 19 - 19: oOO % i1
  if 74 - 74: oOo0O00
  if 61 - 61: i1i1i1111I / ooOOO
  if 47 - 47: i1i1i1111I - IIiIIiIi11I1 + oOo0O00
  if 75 - 75: IiIIii11Ii / i1i1i1111I
  if 15 - 15: i1I * I11iiIi11i1I - I11iiIi11i1I
  if 60 - 60: I1I + OooOoo . Iii1i * Iii1i + i1I
  if 42 - 42: iI1iII1I1I1i / Ooo0Ooo - Ooo0Ooo
  if 13 - 13: Ii / I11iiIi11i1I * I11iiIi11i1I + Ii . Oo
  if 93 - 93: IIiIIiIi11I1 % i1i1i1111I / I1I + i1i1i1111I % i1i1i1111I + i1i1i1111I
  o0o0oooO0 = o0o ( self . train , self . getRootSources ( False ) , sourceDataset = sourceDataset )
  if 33 - 33: IIiIIiIi11I1 - oOO
  if 53 - 53: Oo * Iii1i
  iiI1iIi = o0o0oooO0 . getData ( start = start , end = end )
  if 63 - 63: oOO . Oo - IiI11Ii111 . ooo000 * I11iiIi11i1I
  if 41 - 41: OooOoo + iI1iII1I1I1i + Ooo0Ooo . oOO
  return self . getProcessedData ( iiI1iIi , step = step )
  if 84 - 84: OooOoo
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> 'np.ndarray' :
  if 55 - 55: I1I * i1i1i1111I / ooOOO + I1I / Iii1i
  if 52 - 52: Ii
  if 24 - 24: I1Ii1I1 . I11iiIi11i1I
  if 56 - 56: i1iiIII111 * Iii1i * i1iiIII111
  if 18 - 18: Oo + Oo
  if 38 - 38: ooo000 . Ooo0Ooo
  if 62 - 62: Oo
  if 41 - 41: ooOOO
  if 41 - 41: i1I % Iii1i / ooo000 . i1 - I11iiIi11i1I / OooOoo
  if 17 - 17: ooOOO / Ii
  return self . generatorController . getNextBatch ( datasetType = ( sourceDataset or self . train . currentSourceDataset ) )
  if 5 - 5: i1I / I1Ii1I1 / I1Ii1I1
 def copy ( self , node : 'DataPreprocessing.Node.TimeSeries' ) -> 'DataPreprocessing.Node.TimeSeries' :
  if 7 - 7: OooOoo - Iii1i * Oo
  if 85 - 85: Ii % Oo . ooOOO / oOo0O00 % i1 / i1I
  if 13 - 13: I1Ii1I1 / IiIIii11Ii
  if 24 - 24: Oo - I1Ii1I1 / IiI11Ii111 / i1iiIII111 + Ooo0Ooo
  if 87 - 87: OooOoo + oOo0O00 / I1Ii1I1
  if 65 - 65: oOo0O00 + iI1iII1I1I1i % Iii1i - I1Ii1I1
  if 34 - 34: Ooo0Ooo % I1I - I1Ii1I1 + Ii * i1I
  if 46 - 46: iI1iII1I1I1i - IIiIIiIi11I1
  if 81 - 81: i1I + oOO
  if 82 - 82: I1Ii1I1 + IIiIIiIi11I1 % IiIIii11Ii / i1i1i1111I - I1Ii1I1 + ooo000
  super ( ) . copy ( node )
  node . seriesSort = self . seriesSort
  node . seriesLen = self . seriesLen
  if 52 - 52: i1I + ooOOO . IIiIIiIi11I1
 def refreshItemShape ( self ) :
  if 98 - 98: IiIIii11Ii / I11iiIi11i1I / IiI11Ii111 . Ooo0Ooo
  if 54 - 54: ooOOO . IiIIii11Ii - i1
  if 32 - 32: IiIIii11Ii % oOo0O00 / ooOOO - ooo000
  if 56 - 56: i1 + I1I + i1I % Ooo0Ooo * i1I / oOO
  if 44 - 44: OooOoo / I1I + ooo000 * i1I - oOo0O00 / Oo
  if 44 - 44: I1Ii1I1 . iI1iII1I1I1i * Ooo0Ooo * I1I
  if 96 - 96: i1 % ooOOO + oOo0O00 / oOO - I11iiIi11i1I + Ooo0Ooo
  if 32 - 32: Iii1i % Oo - oOO - oOo0O00 / IIiIIiIi11I1 % i1I
  oo00 = self . getInputShape ( ) [ 1 : ]
  ooO0OOo = [ self . seriesLen , * oo00 [ 1 : - 1 ] , len ( o0ooo0oOoO . getColList ( oo00 [ - 1 ] , self . sourceCol ) ) ]
  if 82 - 82: IiI11Ii111 % oOO
  if 85 - 85: Ooo0Ooo
  self . setItemShape ( [ * ooO0OOo ] )
  if 13 - 13: I11iiIi11i1I / Oo . ooo000
 def _processData ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 66 - 66: iI1iII1I1I1i / Iii1i . Iii1i / I1I - OooOoo - ooo000
  if 8 - 8: I1Ii1I1 * Oo . oOO + IiI11Ii111
  if 55 - 55: Iii1i % OooOoo % ooOOO - i1I
  if 27 - 27: OooOoo
  if 16 - 16: I1I - oOo0O00 % iI1iII1I1I1i
  if 51 - 51: ooOOO + OooOoo
  if 96 - 96: I1Ii1I1 * oOo0O00 - ooo000 + I1I / IiI11Ii111
  if 14 - 14: i1I / oOo0O00 % I1I . ooo000
  if 74 - 74: i1i1i1111I % Oo * I1Ii1I1
  if 83 - 83: ooo000 * oOo0O00 * iI1iII1I1I1i % i1i1i1111I
  if 80 - 80: Iii1i - oOO - I1I / i1iiIII111
  if 29 - 29: Ii . ooo000 . I1Ii1I1 . i1I + Iii1i
  if 15 - 15: i1 * IiI11Ii111 % i1I + Ii
  if 98 - 98: I1I
  if 29 - 29: ooOOO + I1I
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 61 - 61: IIiIIiIi11I1 - I1I * ooOOO * Oo % Ii + i1I
  if 70 - 70: i1i1i1111I + Ii * Ooo0Ooo . IiI11Ii111 - Ii / i1i1i1111I
  if step == Ii1Ii1iii . StepEnum . Input :
   return Ooo0OOooO
   if 33 - 33: Oo . Iii1i - i1I + i1I * i1i1i1111I
   if 99 - 99: Ii
  OO0o = None
  if 40 - 40: Ii / I11iiIi11i1I / Ooo0Ooo % Oo - oOO - Ii
  if 96 - 96: IiI11Ii111
  for O0oOOOoo in self . transformations :
   if 78 - 78: i1
   if O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch :
    if 38 - 38: I1I . ooOOO
    if OO0o is None :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = Ii1Ii1iii . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 65 - 65: oOo0O00 + ooOOO % Ii / i1iiIII111 / i1i1i1111I / Ooo0Ooo
     if 8 - 8: i1I - Oo * i1I - I1I . ooo000 % Ii
    O0oOOOoo . preExtract ( OO0o )
    if 11 - 11: Oo - i1i1i1111I * IIiIIiIi11I1
    if 15 - 15: Oo / i1I
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 88 - 88: OooOoo . iI1iII1I1I1i + Iii1i
  if step == Ii1Ii1iii . StepEnum . Transformed :
   return Ooo0OOooO
   if 21 - 21: i1i1i1111I % i1i1i1111I + OooOoo . iI1iII1I1I1i % oOo0O00
   if 41 - 41: i1i1i1111I - IiI11Ii111
  for iI1Ii1IiI in self . circular :
   O0Ooo , iIi1iII11I , Ii11IiIIiiI = iI1Ii1IiI . min , iI1Ii1IiI . max , iI1Ii1IiI . range
   O0oiIiiI11iI = OoOo0000o . toIndexer ( iI1Ii1IiI . colSel )
   Ooo0OOooO [ ... , O0oiIiiI11iI ] = np . mod ( ( Ooo0OOooO [ ... , O0oiIiiI11iI ] . astype ( float ) - O0Ooo ) , Ii11IiIIiiI )
   if 28 - 28: I11iiIi11i1I - IIiIIiIi11I1 + oOo0O00 - Ooo0Ooo
  if step == Ii1Ii1iii . StepEnum . CircularDataDefined :
   return Ooo0OOooO
   if 25 - 25: i1 . i1i1i1111I % IIiIIiIi11I1 . IiI11Ii111 + Oo
   if 85 - 85: i1I . I1Ii1I1 + OooOoo / Oo
  if len ( self . oneHotColumns ) > 0 :
   if 45 - 45: i1i1i1111I . i1 * i1i1i1111I
   o0i1I1Ii = [ ]
   if 43 - 43: Ii + Ooo0Ooo
   for ooOoooO0OOo in range ( 0 , len ( Ooo0OOooO [ 0 ] ) ) :
    if ooOoooO0OOo in self . oneHotColumns :
     oOo = Ooo0OOooO [ : , [ ooOoooO0OOo ] ]
     oOo = o0ooo0oOoO . convertCatToNumbers ( oOo , True , { v : ooOoooO0OOo for ooOoooO0OOo , v in enumerate ( self . oneHotColumns [ ooOoooO0OOo ] ) } ) [ "data" ]
     o0i1I1Ii . extend ( oOo )
    else :
     o0i1I1Ii . append ( Ooo0OOooO [ : , [ ooOoooO0OOo ] ] )
     if 77 - 77: I1Ii1I1 - i1i1i1111I - oOO - IiIIii11Ii + I1Ii1I1 + i1iiIII111
     if 23 - 23: oOo0O00 - Iii1i . IiIIii11Ii / IIiIIiIi11I1 + i1i1i1111I * iI1iII1I1I1i
   Ooo0OOooO = np . column_stack ( o0i1I1Ii )
   if 75 - 75: IiI11Ii111 % I11iiIi11i1I + IiIIii11Ii % ooo000 - IiI11Ii111
   if 37 - 37: IiI11Ii111 % Ii / IiIIii11Ii . i1I . i1iiIII111
  if self . dtype is not None :
   Ooo0OOooO = Ooo0OOooO . astype ( self . dtype . as_numpy_dtype )
  else :
   Ooo0OOooO = Ooo0OOooO . astype ( float )
   if 56 - 56: ooo000 + IiIIii11Ii / I11iiIi11i1I + oOo0O00
   if 19 - 19: i1i1i1111I - iI1iII1I1I1i
  return Ooo0OOooO
  if 20 - 20: OooOoo - IiIIii11Ii * IiIIii11Ii - Iii1i
 def recoverToRawData ( self , items : 'np.ndarray|list[*+]' , revealedIdxs : List [ int ] = None ) -> 'np.ndarray' :
  if 34 - 34: IIiIIiIi11I1 . Ii . oOo0O00 . ooOOO
  if 15 - 15: ooo000 . I11iiIi11i1I
  if 83 - 83: ooOOO / I11iiIi11i1I . Oo - Iii1i
  if 1 - 1: Ooo0Ooo - IiI11Ii111 % ooOOO . IIiIIiIi11I1 . oOO / OooOoo
  if 1 - 1: I1Ii1I1 - I11iiIi11i1I / Oo * Oo
  if 45 - 45: OooOoo / OooOoo / OooOoo % I1Ii1I1 / OooOoo % oOo0O00
  if 2 - 2: IIiIIiIi11I1 + OooOoo + I1I % IiI11Ii111 + i1I
  if 77 - 77: Iii1i . i1i1i1111I + Ii
  if 93 - 93: iI1iII1I1I1i + Oo % IiIIii11Ii / Oo . i1
  if 45 - 45: i1iiIII111 . i1iiIII111 / OooOoo - I11iiIi11i1I / OooOoo % Iii1i
  if 56 - 56: IiIIii11Ii . oOO - Ii
  if 77 - 77: i1 % OooOoo . Iii1i % i1i1i1111I
  if 4 - 4: IiI11Ii111 . i1iiIII111 + i1
  if 39 - 39: IiI11Ii111
  if 43 - 43: Oo % ooOOO
  items = np . array ( items )
  if 37 - 37: Ooo0Ooo % oOo0O00 - OooOoo * oOO
  if 5 - 5: I11iiIi11i1I . oOO
  if revealedIdxs is None :
   revealedIdxs = [ * range ( 0 , items . shape [ - 1 ] ) ]
   if 79 - 79: ooo000 . i1
   if 97 - 97: oOO - Iii1i * i1
  iiIII1 = [ ]
  if 60 - 60: Oo % OooOoo * i1 . IiI11Ii111 * iI1iII1I1I1i
  if 33 - 33: ooo000 * IiI11Ii111
  if len ( self . oneHotColumns ) > 0 :
   if 74 - 74: i1iiIII111
   iiiii1iI1 = [ * self . oneHotColumns . keys ( ) ]
   iiiii1iI1 . sort ( )
   if 43 - 43: IiIIii11Ii + IiIIii11Ii - i1I % Iii1i + oOO
   if 98 - 98: i1I / Iii1i * Ooo0Ooo
   o0i1I1Ii = [ ]
   oOoo0Oo0o0O0 = 0
   o0oOOo0OOO0oO = 0
   if 78 - 78: Ii % oOo0O00 * OooOoo + I11iiIi11i1I
   for ooOoooO0OOo in range ( 0 , len ( self . getShape ( ) ) ) :
    if ooOoooO0OOo == oOoo0Oo0o0O0 :
     if ooOoooO0OOo in iiiii1iI1 :
      if 78 - 78: Iii1i - i1i1i1111I - Ii * i1iiIII111 - Ooo0Ooo
      Oo0OoOO0 = self . oneHotColumns [ ooOoooO0OOo ]
      O0ooO00o0O = len ( Oo0OoOO0 )
      oOoo0Oo0o0O0 += O0ooO00o0O
      o0oOOo0OOO0oO += 1
      if 59 - 59: iI1iII1I1I1i / ooOOO
      if all ( [ ooOoooO0OOo in revealedIdxs for i in range ( ooOoooO0OOo , ooOoooO0OOo + O0ooO00o0O ) ] ) :
       if 48 - 48: i1i1i1111I . i1iiIII111 - iI1iII1I1I1i / Ooo0Ooo
       o0O0O00 = items [ ... , ooOoooO0OOo : ooOoooO0OOo + O0ooO00o0O ]
       oO0O0oo00Oo = np . argmax ( o0O0O00 , axis = - 1 )
       iiIii1IiII = { i : v for i , v in enumerate ( Oo0OoOO0 ) }
       o0i1I1Ii . append ( np . reshape ( np . frompyfunc ( lambda IiIIiiII : iiIii1IiII [ IiIIiiII ] , 1 , 1 ) ( oO0O0oo00Oo ) , [ * o0O0O00 . shape [ : - 1 ] , 1 ] ) )
       iiIII1 . append ( o0oOOo0OOO0oO - 1 )
      else :
       raise ValueError ( "Column selection not covered all one-hot indices cannot perform recovering data." )
     else :
      oOoo0Oo0o0O0 += 1
      o0oOOo0OOO0oO += 1
      if ooOoooO0OOo in revealedIdxs :
       o0i1I1Ii . append ( items [ : , [ ooOoooO0OOo ] ] )
       iiIII1 . append ( o0oOOo0OOO0oO - 1 )
       if 12 - 12: oOO - i1i1i1111I
       if 39 - 39: Ii % IiIIii11Ii / Iii1i / ooOOO % I1I
   items = np . column_stack ( o0i1I1Ii )
   if 62 - 62: IiI11Ii111 - I1Ii1I1 % IiI11Ii111 * oOo0O00 - oOo0O00 + iI1iII1I1I1i
   if 100 - 100: i1iiIII111 / oOO . I1Ii1I1 + i1
  oo00 = self . getInputShape ( )
  O0oO000O = OoOo0000o . parse ( oo00 [ - 1 ] , self . sourceCol )
  if 96 - 96: I1Ii1I1 + I1I
  if 39 - 39: Ii . i1i1i1111I + OooOoo - Oo + i1iiIII111
  for iI1Ii1IiI in self . circular :
   O0Ooo , iIi1iII11I , Ii11IiIIiiI = iI1Ii1IiI . min , iI1Ii1IiI . max , iI1Ii1IiI . range
   O0oiIiiI11iI = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , iI1Ii1IiI . colSel ) if i in iiIII1 ]
   items [ ... , O0oiIiiI11iI ] = np . mod ( ( items [ ... , O0oiIiiI11iI ] . astype ( float ) - O0Ooo ) , Ii11IiIIiiI )
   if 44 - 44: IiI11Ii111 - Oo
   if 42 - 42: i1iiIII111 + oOo0O00 - Iii1i % I1Ii1I1 - IIiIIiIi11I1
  if len ( self . transformations ) :
   if 73 - 73: I1Ii1I1 . I1Ii1I1 + iI1iII1I1I1i + Ii
   for O0oOOOoo in reversed ( self . transformations ) :
    if 31 - 31: OooOoo / IiI11Ii111
    i1III1 = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , O0oOOOoo . colSel ) if i in iiIII1 ]
    items [ ... , i1III1 ] = np . vectorize ( O0oOOOoo . transformFrom ) ( items [ ... , i1III1 ] )
    if 44 - 44: oOo0O00 % I1Ii1I1 + i1i1i1111I / oOO + I11iiIi11i1I / ooo000
    if 29 - 29: ooOOO
  return items if isinstance ( self . fromNode , O0 ) else self . fromNode . recoverToRawData ( items , O0oO000O )
  if 3 - 3: Ooo0Ooo % ooo000
 def getPrintableItems ( self , items , recovered = True ) :
  if 24 - 24: IiI11Ii111 % iI1iII1I1I1i . Oo / oOo0O00 - IiI11Ii111 / OooOoo
  if 17 - 17: oOo0O00
  if 12 - 12: oOO - Oo / i1 + i1I
  if 23 - 23: IiI11Ii111 - IIiIIiIi11I1 / ooo000 . i1
  if 17 - 17: I1I . i1 . i1I
  if 21 - 21: oOo0O00 . IiIIii11Ii % I1Ii1I1 . Ii / Ooo0Ooo
  if 13 - 13: Ii % i1I . i1 / IiIIii11Ii / i1 % IIiIIiIi11I1
  if 78 - 78: IiI11Ii111 . Iii1i . Iii1i . I1Ii1I1
  if 91 - 91: i1iiIII111 * Oo - OooOoo - i1iiIII111 / ooo000
  if 92 - 92: ooOOO * IIiIIiIi11I1 * I11iiIi11i1I . IiIIii11Ii * IiI11Ii111 + oOo0O00
  if 1 - 1: i1I - OooOoo % Iii1i / IiIIii11Ii + I1I * OooOoo
  if 96 - 96: ooo000 . iI1iII1I1I1i
  if 60 - 60: oOo0O00 . ooo000 + iI1iII1I1I1i + oOo0O00 * i1
  if 57 - 57: Oo
  if 79 - 79: I1I + IiI11Ii111 * Oo
  O0000000 = ( Ii1II11 ( items ) . tolist ( ) if isinstance ( items , np . ndarray ) else items ) if recovered else self . recoverToRawData ( items ) . tolist ( )
  if 11 - 11: IIiIIiIi11I1 - Ooo0Ooo - Ooo0Ooo * Ii + I1Ii1I1 + IIiIIiIi11I1
  if 83 - 83: OooOoo . i1I . oOO / i1i1i1111I
  O0o0o0Oo00O0 = isinstance ( O0000000 [ 0 ] , list )
  if 90 - 90: IIiIIiIi11I1 + Ii % i1i1i1111I - IiI11Ii111 * OooOoo . OooOoo
  if not O0o0o0Oo00O0 :
   if 32 - 32: Oo
   OO0oo0OoooOO = "Value"
  elif len ( O0000000 [ 0 ] ) == 1 :
   if 51 - 51: oOO * iI1iII1I1I1i * ooo000 . IIiIIiIi11I1
   OO0oo0OoooOO = "Value"
   O0000000 = [ c [ 0 ] for c in O0000000 ]
  else :
   if 81 - 81: i1iiIII111 / OooOoo / I1I / IIiIIiIi11I1
   OO0oo0OoooOO = "Table"
   if 16 - 16: i1I + i1i1i1111I / ooo000 / I11iiIi11i1I * oOo0O00
   if 83 - 83: Ooo0Ooo + IIiIIiIi11I1 / i1i1i1111I . OooOoo + IiI11Ii111
  return [ [ OO0oo0OoooOO , json . dumps ( i ) ] for i in O0000000 ]
  if 40 - 40: Ii . Iii1i
class Ii1111i ( Oo0ooo0OO0 ) :
 if 32 - 32: i1i1i1111I * OooOoo / Ooo0Ooo + IiI11Ii111 + I11iiIi11i1I * ooo000
 if 49 - 49: OooOoo / oOO - ooOOO * IIiIIiIi11I1 . oOO
 if 26 - 26: Ooo0Ooo - i1I + i1iiIII111 . I11iiIi11i1I / Ii / Oo
 if 13 - 13: Iii1i * IiIIii11Ii - I1Ii1I1
 if 90 - 90: oOo0O00 - Ooo0Ooo / i1 - IiIIii11Ii
 if 9 - 9: I1Ii1I1 - ooOOO
 if 41 - 41: i1 / IiIIii11Ii - ooo000
 class StepEnum ( I1i1i ) :
  if 41 - 41: IIiIIiIi11I1 % ooOOO - iI1iII1I1I1i % I11iiIi11i1I
  if 38 - 38: I1Ii1I1 - ooOOO / oOo0O00 % IiIIii11Ii * Oo
  if 3 - 3: OooOoo - Iii1i + Ooo0Ooo
  if 75 - 75: Ooo0Ooo % i1iiIII111
  if 50 - 50: Oo + Ii / OooOoo - Ooo0Ooo - IIiIIiIi11I1
  if 23 - 23: i1iiIII111 / Iii1i * iI1iII1I1I1i % I1I % ooOOO
  if 88 - 88: i1i1i1111I / i1I / Oo
  pass
  if 39 - 39: IiIIii11Ii * I1Ii1I1 . I1I / oOo0O00
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 64 - 64: Iii1i % IiIIii11Ii + i1I - iI1iII1I1I1i
  if 18 - 18: I11iiIi11i1I . Ii + iI1iII1I1I1i
  if 4 - 4: IiI11Ii111 / I11iiIi11i1I
  if 18 - 18: oOo0O00
  if 58 - 58: OooOoo * I1I / OooOoo - Ii * i1I
  if 90 - 90: i1iiIII111 + ooo000 . ooo000 - iI1iII1I1I1i * ooo000 . I1I
  if 53 - 53: OooOoo / Ooo0Ooo % Iii1i / i1i1i1111I . OooOoo / Iii1i
  def __init__ ( self , controller : 'DataPreprocessing.Node.TXT.GeneratorController' ) :
   if 7 - 7: I11iiIi11i1I * I11iiIi11i1I + OooOoo + ooOOO - I1I % I1I
   if 97 - 97: iI1iII1I1I1i - i1I
   if 49 - 49: I11iiIi11i1I
   if 22 - 22: IiI11Ii111 % IIiIIiIi11I1 - i1i1i1111I * I1I * Iii1i - i1iiIII111
   if 82 - 82: IiI11Ii111 + Ooo0Ooo + OooOoo % oOO . Ooo0Ooo + ooOOO
   if 73 - 73: Oo . OooOoo / IiI11Ii111 + i1i1i1111I + I1I % IiIIii11Ii
   if 7 - 7: i1i1i1111I . i1iiIII111 . ooo000 + IIiIIiIi11I1 . I11iiIi11i1I + Ii
   if 70 - 70: I1I
   if 68 - 68: i1I % Ii * ooOOO + i1i1i1111I * oOo0O00 . Ii
   if 35 - 35: IiIIii11Ii . ooo000
   super ( ) . __init__ ( controller )
   if 50 - 50: i1i1i1111I + I1I * I1I + Oo % ooOOO
   if 66 - 66: IIiIIiIi11I1 / iI1iII1I1I1i + IiIIii11Ii + Ii % Ii / IiI11Ii111
   self . _referenceIndexes : List [ int ] = [ ]
   if 82 - 82: Oo
   if 52 - 52: ooo000 + iI1iII1I1I1i + IIiIIiIi11I1 . oOO - ooOOO
   self . _cacheInput : List [ Any ] = [ ]
   if 5 - 5: IiI11Ii111
  @ property
  def epochSize ( self ) -> int :
   if 5 - 5: Oo - ooo000
   if 78 - 78: oOO * I1I * Oo - i1i1i1111I - Oo
   if 47 - 47: Ooo0Ooo - Ooo0Ooo % i1i1i1111I . i1I % IIiIIiIi11I1
   if 50 - 50: i1I + I11iiIi11i1I * I1I / I1Ii1I1
   if 53 - 53: IIiIIiIi11I1
   if 6 - 6: Iii1i + oOO + IiIIii11Ii / ooOOO / oOO + i1i1i1111I
   if 76 - 76: i1iiIII111 - OooOoo - oOO
   if 48 - 48: i1 + i1
   if 75 - 75: I11iiIi11i1I % oOo0O00 / ooo000 / OooOoo - iI1iII1I1I1i . IIiIIiIi11I1
   if 43 - 43: i1i1i1111I . i1iiIII111 * ooOOO % Ooo0Ooo - oOO
   return ( len ( self . _referenceIndexes ) if len ( self . _referenceIndexes ) else None ) if self . _epochSize is None else self . _epochSize
   if 63 - 63: Iii1i / Iii1i / I11iiIi11i1I / I1I + I1Ii1I1
  def getEpochSize ( self , refresh : bool = False ) -> int :
   if 60 - 60: ooo000 - Ooo0Ooo
   if 76 - 76: i1 * i1iiIII111 + IiIIii11Ii . Ii * I1Ii1I1
   if 41 - 41: IiIIii11Ii % oOo0O00
   if 55 - 55: i1
   if 1 - 1: I1I - oOO . IIiIIiIi11I1 % Iii1i / iI1iII1I1I1i
   if 98 - 98: I1Ii1I1 % IIiIIiIi11I1
   if 61 - 61: Oo - I11iiIi11i1I . OooOoo + i1iiIII111
   if 17 - 17: IIiIIiIi11I1 * I11iiIi11i1I * I1I - IiI11Ii111 . Iii1i . iI1iII1I1I1i
   if 11 - 11: Ii . OooOoo
   if 92 - 92: I1I / oOo0O00 + IIiIIiIi11I1
   if 28 - 28: IiIIii11Ii . IIiIIiIi11I1 * iI1iII1I1I1i * Oo - Ooo0Ooo % Oo
   if 87 - 87: IIiIIiIi11I1 % ooo000 . IiI11Ii111 + IiIIii11Ii - ooo000
   if 52 - 52: oOo0O00 - IiI11Ii111 . ooo000 % I11iiIi11i1I
   return self . epochSize
   if 31 - 31: ooOOO + Iii1i
  def copy ( self ) -> 'DataPreprocessing.Node.TXT.GeneratorDetail' :
   if 3 - 3: IiIIii11Ii * I1Ii1I1 / OooOoo + ooo000 * IiIIii11Ii
   if 26 - 26: I1I % I1Ii1I1 * i1i1i1111I / i1I
   if 10 - 10: IiI11Ii111 / Iii1i * iI1iII1I1I1i
   if 3 - 3: oOo0O00 * i1 - Ooo0Ooo
   if 7 - 7: i1iiIII111
   if 64 - 64: Oo % i1iiIII111 . Oo . i1i1i1111I . OooOoo - Ooo0Ooo
   if 2 - 2: I11iiIi11i1I
   if 5 - 5: IiIIii11Ii - oOO
   if 74 - 74: ooOOO / i1iiIII111 - iI1iII1I1I1i % I1I % i1iiIII111 / oOo0O00
   if 65 - 65: I1I * IIiIIiIi11I1 + IiI11Ii111 . Oo / oOo0O00
   if 74 - 74: i1I - ooOOO . i1 - I11iiIi11i1I
   ii1IIiIIi : Ii1111i . GeneratorDetail = Ii1111i . GeneratorDetail ( self . controller )
   if 53 - 53: oOo0O00 - i1 * Iii1i / i1i1i1111I / OooOoo - Ooo0Ooo
   if 55 - 55: I11iiIi11i1I / oOo0O00 / ooo000
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_referenceIndexes" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 69 - 69: i1I + IIiIIiIi11I1 / OooOoo
   return ii1IIiIIi
   if 38 - 38: Ii
  def initialize ( self ) :
   if 5 - 5: OooOoo * oOO . Ii - oOo0O00 . ooo000 * Iii1i
   if 41 - 41: i1I
   if 4 - 4: ooOOO + OooOoo / Oo - I1I - Ii
   if 83 - 83: I1I * i1iiIII111 / I1I - IiI11Ii111 - I1I * Iii1i
   if 12 - 12: Ii
   if 93 - 93: i1I
   if 7 - 7: i1I % i1i1i1111I / iI1iII1I1I1i % Oo % Iii1i
   super ( ) . initialize ( )
   if 40 - 40: I1Ii1I1 . i1 % ooOOO + i1iiIII111 . oOO
   if 77 - 77: Ii % IiI11Ii111
   if len ( self . _referenceIndexes ) == 0 :
    if 95 - 95: ooOOO . i1
    I1 : Ii1111i = self . controller . attachObject
    if 82 - 82: Ooo0Ooo - i1 . ooo000 - I1Ii1I1
    if 69 - 69: I11iiIi11i1I . OooOoo . Ooo0Ooo / i1i1i1111I % i1I + oOo0O00
    O0oo0O00O0OO0 : int = I1 . getRootSources ( ) [ 0 ] . epochSize
    if O0oo0O00O0OO0 is None :
     return
     if 100 - 100: ooOOO * Iii1i - i1 + i1i1i1111I
     if 12 - 12: IiIIii11Ii
    self . _referenceIndexes = [ i for i in range ( 0 , O0oo0O00O0OO0 - ( I1 . seriesLen - 1 ) ) ]
    if 88 - 88: i1 / IiI11Ii111 . IIiIIiIi11I1 - IiI11Ii111 / iI1iII1I1I1i
    if 80 - 80: OooOoo + oOO . Oo % oOo0O00 * OooOoo
    if I1 . seriesLabel is not None :
     if 86 - 86: i1 % Ooo0Ooo - IiIIii11Ii * Iii1i
     oo0oO00O : int = I1 . seriesLabel
     o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
     if 97 - 97: ooo000 . Ooo0Ooo - Oo - IIiIIiIi11I1 % ooo000 - OooOoo
     if 85 - 85: I1I % i1 - oOO - IiIIii11Ii % Iii1i
     if o0o0oooO0 [ 0 ] . splittable :
      if 12 - 12: ooo000 * I1Ii1I1 * ooo000 - i1I / I1Ii1I1 / Ooo0Ooo
      IIi11ii1IIi : List [ Any ] = o0o0oooO0 [ 0 ] . getData ( )
      if 56 - 56: I11iiIi11i1I - I11iiIi11i1I * i1I . I1I
      if 58 - 58: i1i1i1111I - i1iiIII111 - I1Ii1I1 / IiI11Ii111 % oOO * IiI11Ii111
      if I1 . seriesLabelParser == "n" :
       self . _referenceIndexes . sort ( key = lambda ooooO0O0Oo : float ( IIi11ii1IIi [ ooooO0O0Oo ] [ oo0oO00O ] ) )
      else :
       self . _referenceIndexes . sort ( key = lambda ooooO0O0Oo : IIi11ii1IIi [ ooooO0O0Oo ] [ oo0oO00O ] )
       if 1 - 1: i1I + i1 % i1I + oOO
       if 14 - 14: i1iiIII111 + IiI11Ii111
    if isinstance ( I1 . fromNode , Oo0ooo0OO0 ) :
     if 62 - 62: OooOoo - i1iiIII111 - IIiIIiIi11I1 % ooo000
     o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
     if 38 - 38: oOO
     if 25 - 25: oOO + i1iiIII111 . i1i1i1111I . oOo0O00 * Oo
     if o0o0oooO0 [ 0 ] . splittable :
      if 99 - 99: ooo000 . IIiIIiIi11I1 + i1I % I1I
      IIi11ii1IIi : np . ndarray = o0o0oooO0 [ 0 ] . getData ( )
      if 74 - 74: OooOoo
      if 76 - 76: IiIIii11Ii - oOO . oOO
      self . _cacheInput = I1 . fromNode . processData ( IIi11ii1IIi )
      if 57 - 57: Oo
      if 40 - 40: Ii - IiIIii11Ii . Iii1i . IiI11Ii111 * I1Ii1I1
    if I1 . reversed :
     self . _referenceIndexes = [ index + I1 . seriesLen - 1 for index in self . _referenceIndexes ]
     if 34 - 34: I1Ii1I1 % iI1iII1I1I1i % oOO
  def getCacheInput ( self , start : int = None , end : int = None , indexes : List [ int ] = None ) -> 'np.ndarray<*>' :
   if 63 - 63: iI1iII1I1I1i * i1 . Iii1i
   if 100 - 100: I1I % Iii1i
   if 16 - 16: OooOoo
   if 44 - 44: i1i1i1111I . I11iiIi11i1I * Ii - ooOOO - i1I / Iii1i
   if 52 - 52: IiI11Ii111 * OooOoo + I1Ii1I1 / I1I / IiI11Ii111 - I1I
   if 16 - 16: Iii1i % I1Ii1I1 - Iii1i . I1I - OooOoo . ooOOO
   if 23 - 23: Ooo0Ooo * ooOOO / i1I * iI1iII1I1I1i
   if 47 - 47: oOo0O00 - Iii1i
   if 90 - 90: i1i1i1111I - ooOOO * oOo0O00
   if 51 - 51: IiIIii11Ii % IIiIIiIi11I1 - Ii + ooo000 * IIiIIiIi11I1 % I1I
   if 47 - 47: ooOOO + i1 + i1iiIII111 + i1i1i1111I * ooo000 + Ooo0Ooo
   if 71 - 71: Ooo0Ooo * I11iiIi11i1I + ooOOO / I1I % oOo0O00
   if 72 - 72: IiIIii11Ii / oOO * I1Ii1I1 - IIiIIiIi11I1 - Ooo0Ooo / ooo000
   if 39 - 39: i1 + Iii1i / iI1iII1I1I1i * IiIIii11Ii - I11iiIi11i1I
   if 61 - 61: I11iiIi11i1I
   if 78 - 78: I1Ii1I1 / Ooo0Ooo * IiI11Ii111
   if start == "None" :
    start = None
   if end == "None" :
    end = None
    if 72 - 72: ooOOO * oOo0O00
    if 32 - 32: IiI11Ii111 - i1iiIII111 * Ii % Iii1i + oOo0O00 * i1iiIII111
   if start is not None or end is not None :
    return self . _cacheInput [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= len ( self . _cacheInput ) or idx < - len ( self . _cacheInput ) ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    return self . _cacheInput [ indexes ]
   else :
    return self . _cacheInput [ : ]
    if 8 - 8: Ii * I1Ii1I1 % oOO
  def prepareIteration ( self ) :
   if 35 - 35: I1Ii1I1 - Iii1i * iI1iII1I1I1i . I1I
   if 36 - 36: I1I % i1I
   if 6 - 6: iI1iII1I1I1i - IIiIIiIi11I1 / i1I / ooOOO + IiIIii11Ii * Iii1i
   if 31 - 31: i1i1i1111I . OooOoo - oOO + Oo + IiIIii11Ii
   if 5 - 5: Iii1i / i1iiIII111 + I1Ii1I1 . Oo % I1I + i1iiIII111
   if 30 - 30: OooOoo
   if 60 - 60: i1 + IIiIIiIi11I1 / i1iiIII111 % i1i1i1111I / Oo
   if 15 - 15: IiIIii11Ii / i1I
   if not self . initialized :
    self . initialize ( )
    if 4 - 4: ooo000 / I1Ii1I1 + iI1iII1I1I1i
    if 34 - 34: Ooo0Ooo % ooo000
   self . batchIdxReset ( )
   if 24 - 24: Oo + Ii * IiIIii11Ii % i1 - I1I % oOO
   if 92 - 92: IiIIii11Ii + i1iiIII111 + ooOOO . Ooo0Ooo * IiI11Ii111 . i1i1i1111I
   if self . shuffle :
    self . _shuffleData ( )
    if 75 - 75: Oo + i1i1i1111I
  def _shuffleData ( self ) :
   if 62 - 62: IiIIii11Ii + i1iiIII111 + i1 * iI1iII1I1I1i * Ii * Ooo0Ooo
   if 18 - 18: oOO / Ooo0Ooo . I1I - i1
   if 57 - 57: Oo - i1i1i1111I / i1iiIII111
   if 61 - 61: I1Ii1I1 - ooOOO - Oo
   if 23 - 23: I11iiIi11i1I . I11iiIi11i1I + I11iiIi11i1I . iI1iII1I1I1i
   if 51 - 51: i1I . IiI11Ii111
   if 8 - 8: i1 % IiI11Ii111 . i1 - Iii1i
   if 31 - 31: i1iiIII111 % Ooo0Ooo . IIiIIiIi11I1 * oOo0O00 . i1iiIII111
   np . random . shuffle ( self . _referenceIndexes )
   if 5 - 5: IiI11Ii111 + oOO % OooOoo / Ooo0Ooo * i1 - Oo
  def setData ( self , inputArray : Union [ list ] = [ ] , outputArray : None = None , hasHeader : None = None ) :
   if 23 - 23: i1 + I11iiIi11i1I
   if 72 - 72: oOo0O00 . IiIIii11Ii % oOo0O00 . OooOoo * Ii
   if 19 - 19: i1 % oOo0O00 - IiIIii11Ii
   if 6 - 6: oOO / i1 / i1 . OooOoo + IiIIii11Ii - IiIIii11Ii
   if 57 - 57: I1Ii1I1 - IiI11Ii111 % Oo . i1iiIII111
   if 38 - 38: oOo0O00 . ooOOO * i1i1i1111I / I1I % oOo0O00
   if 32 - 32: IiIIii11Ii % i1i1i1111I / I1Ii1I1 . i1I
   if 62 - 62: Oo . Iii1i + OooOoo - i1I
   if 15 - 15: IiI11Ii111 - ooo000 / i1i1i1111I + I1I - I11iiIi11i1I / Oo
   if 55 - 55: IiI11Ii111 * i1i1i1111I
   if 96 - 96: I11iiIi11i1I
   if 63 - 63: OooOoo % I1Ii1I1
   if 13 - 13: i1 % i1I - i1iiIII111 . I1I - iI1iII1I1I1i
   iI1I = list ( inputArray )
   if 56 - 56: Iii1i . OooOoo + I11iiIi11i1I % iI1iII1I1I1i
   if 63 - 63: iI1iII1I1I1i
   if len ( np . shape ( iI1I ) ) != 1 :
    raise ValueError ( "Input Shape must be a 1-dimensional list." )
    if 83 - 83: IiI11Ii111 + IiI11Ii111 * i1i1i1111I
    if 48 - 48: ooOOO . ooOOO
   if len ( iI1I ) == 0 :
    raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
    if 41 - 41: Iii1i
    if 23 - 23: OooOoo
   self . _referenceIndexes = iI1I
   if 100 - 100: I11iiIi11i1I - oOO / oOO - Ii % oOo0O00 / IiIIii11Ii
  def getData ( self , start : int = None , end : int = None , indexes : int = None ) -> 'np.ndarray<*>' :
   if 8 - 8: i1iiIII111 % I11iiIi11i1I
   if 52 - 52: Ii - Ii / Iii1i + IiI11Ii111
   if 100 - 100: ooOOO / iI1iII1I1I1i - IiIIii11Ii * i1i1i1111I + OooOoo % i1
   if 55 - 55: Oo % i1i1i1111I . oOO / OooOoo * iI1iII1I1I1i
   if 23 - 23: Ii
   if 97 - 97: i1 . ooOOO / ooo000
   if 8 - 8: oOO
   if 40 - 40: Iii1i / Oo
   if 31 - 31: oOO * IiIIii11Ii / I1Ii1I1 / oOO . I1I
   if 88 - 88: ooo000 . Oo % Ooo0Ooo * Ooo0Ooo / i1 . oOO
   if 73 - 73: i1i1i1111I * IIiIIiIi11I1 * ooo000 / Iii1i % I11iiIi11i1I - i1I
   if 91 - 91: IIiIIiIi11I1 * IIiIIiIi11I1 - I1Ii1I1
   if 6 - 6: Iii1i
   if 46 - 46: ooOOO . Oo
   if 100 - 100: IIiIIiIi11I1
   if 2 - 2: Ooo0Ooo . ooOOO / IiIIii11Ii % Iii1i
   if not self . initialized :
    self . initialize ( )
    if 84 - 84: IiI11Ii111 % Oo + I1I / Iii1i - IiIIii11Ii % i1i1i1111I
    if 98 - 98: i1I
   I1 : Ii1111i = self . controller . attachObject
   if 97 - 97: IiI11Ii111
   if 34 - 34: IiIIii11Ii + IiIIii11Ii + IiI11Ii111 - OooOoo - ooo000 % IiIIii11Ii
   if I1 . getEpochSize ( True ) is None :
    return [ ]
    if 44 - 44: IiI11Ii111 . iI1iII1I1I1i / IIiIIiIi11I1 - i1i1i1111I
    if 31 - 31: Oo - I11iiIi11i1I * Ooo0Ooo % OooOoo
   o0o0oooO0 : List [ Oo0ooo0OO0 , O0 ] = I1 . getRootSources ( )
   if 55 - 55: IiIIii11Ii % ooo000
   if 14 - 14: ooo000 * ooo000
   if start == "None" or start is None :
    start = 0
   if end == "None" or end is None :
    end = len ( self . _referenceIndexes )
    if 100 - 100: i1 % IiIIii11Ii . IIiIIiIi11I1 + I1I
    if 59 - 59: I1I
   o00oO0O0o00O : List [ int ]
   if start is not None or end is not None :
    o00oO0O0o00O = self . _referenceIndexes [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= end or idx < - end ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    indexes = [ ( idx if idx >= 0 else ( len ( self . _referenceIndexes ) + idx ) ) for idx in indexes ]
    if 70 - 70: oOo0O00 - I1Ii1I1 . OooOoo * oOo0O00 / ooo000
    oo0 : List [ Any ] = [ ]
    for IiI in indexes :
     oo0 . append ( self . _referenceIndexes [ IiI ] )
    o00oO0O0o00O = oo0
   else :
    o00oO0O0o00O = self . _referenceIndexes [ : ]
    if 9 - 9: ooo000 + I1Ii1I1 - IIiIIiIi11I1
    if 55 - 55: I1I * Iii1i
   if not o0o0oooO0 [ 0 ] . splittable :
    raise ValueError ( "Time Series data preprocessing node currenly only supports for splittable data sources." )
    if 38 - 38: i1i1i1111I . Ooo0Ooo - oOo0O00 . Oo / I1Ii1I1 + oOo0O00
    if 66 - 66: IiI11Ii111 . ooo000
   if isinstance ( I1 . fromNode , list ) :
    raise ValueError ( "Multiple from node is detected from a time series data source" )
    if 69 - 69: I1I - ooOOO - Iii1i - ooo000 + ooo000 + oOO
    if 73 - 73: I11iiIi11i1I % Iii1i - ooo000 / oOO
   I1IIiI : List [ np . ndarray ] = [ ]
   O00O00o : List [ int ] = None
   I11i : int = - 1 if I1 . reversed else 1
   if 72 - 72: Iii1i . ooOOO
   for ooOoOOoo00 in range ( 0 , I1 . seriesLen ) :
    II1I : np . ndarray
    if 70 - 70: IiI11Ii111 - i1
    if self . _cacheInput and len ( self . _cacheInput ) :
     II1I = self . getCacheInput ( indexes = o00oO0O0o00O )
     if 52 - 52: i1i1i1111I / i1I + OooOoo / IiI11Ii111 * I1Ii1I1 . IIiIIiIi11I1
    else :
     II1I = I1 . fromNode . getData ( indexes = o00oO0O0o00O )
     if 8 - 8: IiI11Ii111 + ooOOO / Ii . ooOOO
     if 7 - 7: OooOoo * Oo % oOO . iI1iII1I1I1i
    O00O00o = np . shape ( II1I ) if O00O00o is None else O00O00o
    iiIII1I1ii : np . ndarray = II1I [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( I1 . crops [ idx ] ) if idx in I1 . crops else slice ( None , None ) ) for idx , v in enumerate ( O00O00o [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( I1 . sourceCol ) ) ]
    I1IIiI . append ( iiIII1I1ii [ : , np . newaxis ] )
    o00oO0O0o00O = [ ( batchIndex + I11i ) for batchIndex in o00oO0O0o00O ]
    if 22 - 22: I1Ii1I1 % ooOOO
    if 62 - 62: I11iiIi11i1I
   return np . concatenate ( I1IIiI , axis = 1 )
   if 25 - 25: i1i1i1111I
  def getNextBatch ( self ) -> 'np.ndarray' :
   if 69 - 69: iI1iII1I1I1i
   if 90 - 90: Ii - i1iiIII111 - iI1iII1I1I1i * IiI11Ii111 % I11iiIi11i1I
   if 84 - 84: IIiIIiIi11I1 % i1I + IiI11Ii111
   if 58 - 58: Ii % I1Ii1I1 + Oo / Oo - Oo
   if 36 - 36: i1iiIII111 - IiIIii11Ii - Oo % IiI11Ii111 % oOO
   if 85 - 85: Iii1i
   if 56 - 56: IIiIIiIi11I1
   if 28 - 28: i1iiIII111 * i1 - Ooo0Ooo . Oo / IiI11Ii111 / iI1iII1I1I1i
   if 47 - 47: I1Ii1I1 - Ooo0Ooo * Oo
   if 54 - 54: IiI11Ii111 + I1I - oOO - i1i1i1111I % i1i1i1111I
   if 74 - 74: i1I % i1I
   if not self . initialized :
    self . initialize ( )
    if 75 - 75: ooo000
    if 68 - 68: Ii * Oo
   if self . batchIdx is None :
    self . prepareIteration ( )
    if 98 - 98: Iii1i * IIiIIiIi11I1
    if 10 - 10: IiIIii11Ii - I1Ii1I1 / ooo000 . i1
   IiIIiiII : int = self . batchIdx
   o0OOOO0Oo0O : int = self . batchSize
   if 89 - 89: Oo - i1
   if 10 - 10: I11iiIi11i1I % ooOOO + Ii % Ii
   if ( self . dropRemainder and ( IiIIiiII + 1 ) * o0OOOO0Oo0O > self . epochSize ) or ( ( not self . dropRemainder ) and IiIIiiII * o0OOOO0Oo0O >= self . epochSize ) :
    self . prepareIteration ( )
    IiIIiiII = self . batchIdx
    if 40 - 40: Ii % IIiIIiIi11I1 / I1Ii1I1 * IiIIii11Ii % oOo0O00 * IiIIii11Ii
    if 67 - 67: i1 % Ooo0Ooo + i1
   O00o000Oo : np . ndarray = self . getData ( start = IiIIiiII * o0OOOO0Oo0O , end = ( IiIIiiII + 1 ) * o0OOOO0Oo0O )
   if 88 - 88: oOO % OooOoo . ooOOO - I1I * IiI11Ii111
   if 81 - 81: i1iiIII111 / i1iiIII111
   self . batchIdxIncrement ( )
   if 14 - 14: i1i1i1111I + I1Ii1I1 % oOO + i1i1i1111I
   return O00o000Oo
   if 81 - 81: IIiIIiIi11I1 + I1Ii1I1 - I1Ii1I1 . I1I * Ii - Oo
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> 'np.ndarray' :
   if 90 - 90: i1 - IiI11Ii111 % IiIIii11Ii + Oo + I1I
   if 93 - 93: i1iiIII111 + Oo / ooo000 + Ii / IiI11Ii111
   if 32 - 32: IIiIIiIi11I1
   if 77 - 77: i1iiIII111 % Ii % i1I * Ooo0Ooo
   if 90 - 90: IiIIii11Ii + oOO % OooOoo - ooOOO * Ii * oOO
   if 96 - 96: I1Ii1I1 % Oo * IIiIIiIi11I1 - I1I * i1iiIII111
   if 84 - 84: Ooo0Ooo
   if 52 - 52: i1i1i1111I . I1I / IIiIIiIi11I1 % Ooo0Ooo / iI1iII1I1I1i
   if 4 - 4: OooOoo * IIiIIiIi11I1 . i1 * oOo0O00
   if 2 - 2: oOo0O00 / I1Ii1I1 / I1Ii1I1 * ooOOO * IiI11Ii111 . I11iiIi11i1I
   if 93 - 93: Ooo0Ooo . i1
   if 24 - 24: Ooo0Ooo / oOo0O00 + Oo . Oo % oOo0O00 * oOo0O00
   if 35 - 35: oOO + ooOOO
   if 20 - 20: Iii1i * ooOOO / IiIIii11Ii / IiI11Ii111 . iI1iII1I1I1i + Ooo0Ooo
   if 45 - 45: Oo . I11iiIi11i1I * i1i1i1111I - Ooo0Ooo + Iii1i + IiI11Ii111
   if len ( self . _referenceIndexes ) == 0 :
    return np . array ( [ ] )
    if 74 - 74: oOo0O00 . IiIIii11Ii - I1I
    if 80 - 80: i1i1i1111I % iI1iII1I1I1i / i1iiIII111 . OooOoo + oOo0O00
   Oo0o0oo0 : np . ndarray = np . arange ( len ( self . _referenceIndexes ) )
   np . random . seed ( randomSeed )
   np . random . shuffle ( Oo0o0oo0 )
   np . random . seed ( )
   if 42 - 42: IiI11Ii111
   if 8 - 8: ooo000 / i1i1i1111I . I1I . ooo000 + i1iiIII111
   O00o000Oo : np . ndarray = self . getData ( indexes = Oo0o0oo0 )
   if 79 - 79: i1I / I1Ii1I1 % Ii
   if 82 - 82: IIiIIiIi11I1 / ooo000
   return O00o000Oo . copy ( )
   if 92 - 92: i1I - Ooo0Ooo * I1Ii1I1 % I1Ii1I1
  def partition ( self , prop : float = 0.2 , shuffle : float = False ) -> Tuple [ 'np.ndarray' , 'np.ndarray' ] :
   if 73 - 73: i1 / ooo000 % i1i1i1111I
   if 73 - 73: i1i1i1111I . oOO * I1I
   if 78 - 78: IiI11Ii111 . oOo0O00 / ooOOO / OooOoo * Iii1i + ooo000
   if 55 - 55: I11iiIi11i1I / I1I * Ooo0Ooo + I1I / I11iiIi11i1I + oOO
   if 78 - 78: ooOOO / I1I
   if 61 - 61: I11iiIi11i1I . Ooo0Ooo - IiI11Ii111
   if 33 - 33: I11iiIi11i1I . IiIIii11Ii - I1Ii1I1 + i1 + oOO * I1Ii1I1
   if 50 - 50: oOO / i1iiIII111 + iI1iII1I1I1i . I1I + i1iiIII111
   if 3 - 3: I1Ii1I1 + I11iiIi11i1I % IiIIii11Ii % ooOOO % IIiIIiIi11I1
   if 81 - 81: i1
   if 73 - 73: Ooo0Ooo % i1iiIII111 + i1iiIII111 / IiI11Ii111
   if 13 - 13: i1iiIII111 - ooOOO . Oo - oOO
   if 67 - 67: Ii . i1I
   if 76 - 76: OooOoo + I11iiIi11i1I % iI1iII1I1I1i
   if 28 - 28: IiI11Ii111 + ooo000 * ooo000
   if not self . initialized :
    self . initialize ( )
    if 67 - 67: iI1iII1I1I1i - oOO % i1I % ooOOO
    if 59 - 59: Ooo0Ooo
   IiiI1 = len ( self . _referenceIndexes )
   iII11i1 = math . floor ( IiiI1 * prop )
   i1iI1iI = self . _referenceIndexes [ : ]
   if 90 - 90: iI1iII1I1I1i
   if 90 - 90: Ooo0Ooo . Ii % ooOOO . iI1iII1I1I1i % i1i1i1111I . Iii1i
   if shuffle :
    np . random . shuffle ( i1iI1iI )
    if 98 - 98: ooOOO % iI1iII1I1I1i
    if 14 - 14: IIiIIiIi11I1 - Ooo0Ooo + Ooo0Ooo
   ooo00 = i1iI1iI [ iII11i1 : ]
   O0o = i1iI1iI [ : iII11i1 ]
   if 94 - 94: i1iiIII111 . oOO . I11iiIi11i1I
   if 55 - 55: Oo
   return ooo00 , O0o
   if 50 - 50: oOo0O00 * i1I + I1Ii1I1 * I1I
 class GeneratorController ( I111II1II111I . Controller ) :
  if 37 - 37: IiIIii11Ii / Ooo0Ooo % I11iiIi11i1I % Iii1i + i1iiIII111 + Iii1i
  if 83 - 83: Ooo0Ooo - i1I * i1
  if 63 - 63: Ii + ooOOO / I1Ii1I1
  if 72 - 72: IIiIIiIi11I1 . oOO * I1Ii1I1 % i1iiIII111
  if 58 - 58: oOo0O00
  if 5 - 5: Ii + i1
  if 69 - 69: IIiIIiIi11I1 * I1Ii1I1 - ooo000
  def __init__ ( self , attachObject : 'DataPreprocessing.Node.TXT' ) :
   if 39 - 39: Ooo0Ooo . I11iiIi11i1I / oOo0O00 * i1 % Ooo0Ooo
   if 72 - 72: ooo000
   if 26 - 26: IiIIii11Ii % Iii1i / i1i1i1111I
   if 3 - 3: OooOoo
   if 57 - 57: ooo000 % i1iiIII111 % IiI11Ii111 . I1I * Iii1i
   if 98 - 98: I11iiIi11i1I * OooOoo + IIiIIiIi11I1
   if 59 - 59: ooo000 % Ii - I1I
   if 50 - 50: OooOoo - I1I . Ooo0Ooo
   if 28 - 28: oOo0O00 + IiI11Ii111 / ooOOO
   if 52 - 52: ooo000 % i1 * Oo / i1i1i1111I % OooOoo
   super ( ) . __init__ ( attachObject = attachObject )
   if 26 - 26: iI1iII1I1I1i + Ooo0Ooo
  @ property
  def detailType ( self ) -> Callable [ ... , 'DataPreprocessing.Node.TXT.GeneratorDetail' ] :
   if 12 - 12: Ii * i1 - iI1iII1I1I1i . oOo0O00
   if 36 - 36: iI1iII1I1I1i - I1Ii1I1 - Ooo0Ooo
   if 18 - 18: ooo000 / oOO - Ii + I11iiIi11i1I
   if 79 - 79: IIiIIiIi11I1 % ooOOO - IiIIii11Ii - ooOOO % oOo0O00
   if 84 - 84: I11iiIi11i1I + i1iiIII111
   if 18 - 18: I1I + iI1iII1I1I1i - Iii1i + IIiIIiIi11I1 / ooo000
   if 60 - 60: IIiIIiIi11I1 % Iii1i + OooOoo + Iii1i
   if 62 - 62: IiIIii11Ii - oOo0O00 . iI1iII1I1I1i % IiIIii11Ii
   if 26 - 26: i1i1i1111I . IIiIIiIi11I1 + I1I
   if 84 - 84: IiI11Ii111 . i1I
   return Ii1111i . GeneratorDetail
   if 8 - 8: Ii
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 74 - 74: Ii * IiIIii11Ii - ooo000
   if 46 - 46: OooOoo % oOo0O00 / ooOOO * i1 + i1iiIII111 % Ooo0Ooo
   if 47 - 47: I1Ii1I1 + I1I
   if 87 - 87: Ooo0Ooo - Ii
   if 81 - 81: Iii1i * ooOOO . Iii1i - i1i1i1111I % Ii . i1
   if 40 - 40: IiIIii11Ii * i1i1i1111I - IiI11Ii111 . IiI11Ii111 * I11iiIi11i1I
   if 73 - 73: ooo000 * i1i1i1111I + oOO . i1iiIII111 . I11iiIi11i1I
   if 28 - 28: ooOOO - Ooo0Ooo - oOo0O00 . oOo0O00 * iI1iII1I1I1i - Ooo0Ooo
   if 12 - 12: Ooo0Ooo * IIiIIiIi11I1 % Iii1i * iI1iII1I1I1i + i1I
   if 53 - 53: ooo000 * OooOoo % IiI11Ii111 * Iii1i
   if 95 - 95: OooOoo * ooo000 + i1iiIII111
   if 77 - 77: Iii1i + IiI11Ii111 % ooOOO . I1Ii1I1 * i1
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   IiOoOOOoO0 = Oooo0OOO . epochSize
   if 89 - 89: I1Ii1I1 . i1I
   if 91 - 91: Ooo0Ooo - oOo0O00
   if 3 - 3: IIiIIiIi11I1 + i1 * IiI11Ii111
   if randomFold :
    ( o0 , I1IiIii ) = Oooo0OOO . partition ( prop = validation , shuffle = True )
    if 69 - 69: OooOoo / ooOOO . IiIIii11Ii . i1i1i1111I
    if 28 - 28: oOO
   else :
    if 50 - 50: oOo0O00 . oOo0O00 - i1 - I1I
    oo0oOo0O0 = math . floor ( 1 / validation )
    IiIIiiII = self . validationTime % oo0oOo0O0
    IIi11ii1IIi = Oooo0OOO . oriData . copy ( ) [ 1 : ] if Oooo0OOO . hasHeader else Oooo0OOO . oriData . copy ( )
    if 71 - 71: ooOOO . I11iiIi11i1I - I1Ii1I1 + iI1iII1I1I1i + oOo0O00
    if 39 - 39: I1I . i1iiIII111
    if IiIIiiII == 0 and Oooo0OOO . shuffle :
     np . random . shuffle ( IIi11ii1IIi )
     if 78 - 78: Oo + I1Ii1I1 . i1
     if 65 - 65: i1 * i1i1i1111I + Ooo0Ooo % Ooo0Ooo
    ii1i1II1iiiI = math . ceil ( IiOoOOOoO0 / oo0oOo0O0 )
    I1I1111 = IiIIiiII * ii1i1II1iiiI
    oOO0o00 = ( IiIIiiII + 1 ) * ii1i1II1iiiI
    o0 = np . vstack ( ( IIi11ii1IIi [ : I1I1111 ] , IIi11ii1IIi [ oOO0o00 : ] ) )
    I1IiIii = IIi11ii1IIi [ I1I1111 : oOO0o00 ]
    if 40 - 40: oOo0O00 - I1I . I1I . IiIIii11Ii
    if 10 - 10: I1I * OooOoo . I11iiIi11i1I + I1I + ooOOO
   self [ I111II1II111I . Dataset . Types . ValidationTrain ] . setData ( inputArray = o0 )
   self [ I111II1II111I . Dataset . Types . Validation ] . setData ( inputArray = I1IiIii )
   if 54 - 54: i1i1i1111I % I1I + IiI11Ii111
   if 68 - 68: I1Ii1I1 + Oo * oOO - i1iiIII111 % i1iiIII111
   o0o0oooO0 = self . attachObject . getRootSources ( )
   for oOO0O0 in o0o0oooO0 :
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Validation ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . ValidationTrain ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    if 80 - 80: i1I . oOo0O00 % i1i1i1111I * oOO / ooo000
    if 43 - 43: Oo % iI1iII1I1I1i - IiIIii11Ii
   self . validationTime += 1
   if 98 - 98: I1I / I1I % i1I . oOo0O00 / oOO
  def splitTestDataset ( self , test : float = 0.2 , shuffle : float = False ) :
   if 98 - 98: oOO . Ii * Ii * oOO / i1i1i1111I
   if 34 - 34: ooOOO / IiI11Ii111 / oOo0O00 / I1Ii1I1
   if 14 - 14: IiIIii11Ii % iI1iII1I1I1i % i1 * i1I . Oo * I1Ii1I1
   if 9 - 9: OooOoo + I1I - i1i1i1111I + oOo0O00 . ooo000
   if 12 - 12: i1i1i1111I / i1iiIII111
   if 83 - 83: I1I + i1i1i1111I . i1iiIII111
   if 29 - 29: I1I
   if 8 - 8: Iii1i + iI1iII1I1I1i - oOO
   if 12 - 12: Oo * IiI11Ii111 . Ooo0Ooo * IiI11Ii111 + oOo0O00 % i1iiIII111
   if 41 - 41: Ooo0Ooo - oOo0O00 / oOo0O00 + Oo
   if 72 - 72: IiI11Ii111 / Oo % Ooo0Ooo / IiI11Ii111 % i1iiIII111 + OooOoo
   if 8 - 8: i1i1i1111I + Oo % Ooo0Ooo . Oo
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   ( o0 , Oo00OOo0oo0 ) = Oooo0OOO . partition ( prop = test , shuffle = shuffle )
   if 89 - 89: ooo000 - IiI11Ii111 * Iii1i . I11iiIi11i1I . OooOoo * I1Ii1I1
   if 86 - 86: Oo / oOO - OooOoo
   self [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = o0 )
   self [ I111II1II111I . Dataset . Types . Test ] . setData ( inputArray = Oo00OOo0oo0 )
   if 54 - 54: OooOoo / i1i1i1111I * IIiIIiIi11I1 * ooo000 + I1Ii1I1
   if 84 - 84: i1I % OooOoo - I11iiIi11i1I . I1I
   o0o0oooO0 = self . attachObject . getRootSources ( )
   for oOO0O0 in o0o0oooO0 :
    oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Test ] = oOO0O0 . generatorController [ I111II1II111I . Dataset . Types . Train ]
    if 81 - 81: i1I - i1i1i1111I * Iii1i
 def __init__ ( self , sourceCol : str = "None:None" , dtype : 'tf.DType' = None , source : str = None , order : int = 0 ) :
  if 2 - 2: i1 % IiIIii11Ii / IIiIIiIi11I1
  if 17 - 17: iI1iII1I1I1i % Ii
  if 91 - 91: OooOoo / Iii1i
  if 6 - 6: iI1iII1I1I1i * oOO + IiI11Ii111 + OooOoo - I1I + oOO
  if 60 - 60: OooOoo
  if 79 - 79: oOo0O00 . I1Ii1I1 + Ii
  if 43 - 43: Iii1i % OooOoo * I11iiIi11i1I * Iii1i - Ii - oOo0O00
  if 71 - 71: I1Ii1I1
  if 24 - 24: Ooo0Ooo . oOo0O00 + IIiIIiIi11I1
  if 34 - 34: IiI11Ii111 - Ii + i1I * Iii1i
  if 33 - 33: I11iiIi11i1I
  if 94 - 94: i1iiIII111 % ooo000 - ooOOO * Ii / Oo
  if 50 - 50: IiIIii11Ii * OooOoo - i1
  super ( ) . __init__ ( instanceClass = OoiI1iiI11IIi1 . TXT , sourceCol = sourceCol , dtype = dtype )
  if 66 - 66: I11iiIi11i1I - I11iiIi11i1I % ooo000 - Ooo0Ooo + IiI11Ii111
  if 80 - 80: I1I . ooo000
  if 85 - 85: Ooo0Ooo
  self . transformations : List [ oo0OOOOOO0o00 ] = [ ]
  if 83 - 83: i1I / Iii1i
  if 12 - 12: I1I
  self . preprocessInBatch : bool = True
  if 72 - 72: ooOOO . i1I - iI1iII1I1I1i + i1i1i1111I
  if 97 - 97: Iii1i % I11iiIi11i1I / I1I . Oo + ooOOO
  self . _classCount : int = None
  if 67 - 67: i1 + I1Ii1I1 % i1I * oOo0O00 + i1i1i1111I
  if 76 - 76: ooOOO . i1I - Ii * i1 + iI1iII1I1I1i + OooOoo
  self . separator : str = None
  if 72 - 72: IiIIii11Ii % i1i1i1111I
  if 95 - 95: I1I - Ii * i1iiIII111 % i1
  self . tokenSource : str = None
  if 17 - 17: ooo000 * Iii1i - ooOOO % I11iiIi11i1I % I11iiIi11i1I - Ooo0Ooo
  if 43 - 43: OooOoo * I1Ii1I1 % oOO + I1Ii1I1
  self . preprocessSource : str = None
  if 21 - 21: oOO / Oo . I1I % i1 / IiIIii11Ii
  self . sequenceLen : str = None
  self . highWords : str = None
  if 27 - 27: Ooo0Ooo
  if 66 - 66: Ooo0Ooo + oOo0O00 % Ooo0Ooo * Ooo0Ooo - IIiIIiIi11I1
  if 65 - 65: IiI11Ii111
  self . generatorController : Ii1111i . GeneratorController = Ii1111i . GeneratorController ( self )
  if 52 - 52: oOO + IIiIIiIi11I1 / ooOOO
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 94 - 94: i1iiIII111 % IIiIIiIi11I1 % i1iiIII111
  if 19 - 19: i1
  if 46 - 46: i1i1i1111I / i1iiIII111 - i1iiIII111 + I1Ii1I1 % IiI11Ii111 % IIiIIiIi11I1
  if 36 - 36: iI1iII1I1I1i * i1i1i1111I + i1i1i1111I * oOo0O00 * I11iiIi11i1I
  if 50 - 50: Ooo0Ooo / i1iiIII111 - Oo . IiI11Ii111 % Ooo0Ooo - ooOOO
  if 43 - 43: IiI11Ii111 + Ooo0Ooo
  if 46 - 46: IiIIii11Ii . Ooo0Ooo * oOo0O00
  if 15 - 15: iI1iII1I1I1i - IiI11Ii111 % i1 - Iii1i * Ii
  if 73 - 73: I11iiIi11i1I + I1Ii1I1
  if 8 - 8: ooo000
  if 25 - 25: i1i1i1111I
  if 98 - 98: i1I + OooOoo - ooOOO / OooOoo / ooOOO % oOO
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "transformations" :
    if 96 - 96: IiI11Ii111 + I1Ii1I1
    setattr ( self , Ii1I , [ Oo000oO00O . createFromJSON ( tx ) for tx in iiiiIi1IiiIi ] )
   elif Ii1I == "dtype" :
    if iiiiIi1IiiIi is not None :
     self . dtype = O0 . getDataType ( iiiiIi1IiiIi )
    else :
     self . dtype = None
   elif Ii1I == "source" :
    if type ( iiiiIi1IiiIi ) == str :
     iiiiIi1IiiIi = int ( iiiiIi1IiiIi . replace ( "Image " , "" ) . replace ( "Table " , "" ) . replace ( "TXT " , "" ) )
    self . source = iiiiIi1IiiIi
    self . _train = train
    if 62 - 62: oOO - i1I . I11iiIi11i1I * ooOOO
    self . _fromNode = train . sources [ iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , int ) else [ train . dppNodes [ dppKey ] for dppKey in iiiiIi1IiiIi ] if isinstance ( iiiiIi1IiiIi , list ) else train . dppNodes [ iiiiIi1IiiIi ]
   elif Ii1I == "_getDataMode" :
    setattr ( self , Ii1I , II1IiI1I [ iiiiIi1IiiIi ] )
   elif Ii1I == "crops" :
    self . crops = { idx : crop for idx , crop in enumerate ( iiiiIi1IiiIi ) if crop is not None }
   elif Ii1I in [ "sourceCol" , "_epochSize" , "outputset" , "_order" , "_shape" , "preprocessInBatch" , "_dataShape" , "_key" , "sequenceLen" , "highWords" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
   elif ( Ii1I not in [ "train" , "fromNode" , "_instanceClass" , "order" ] ) :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 56 - 56: Ii * I11iiIi11i1I . ooOOO . I1I . oOo0O00 / oOO
 def getEpochSize ( self , refresh : bool = False ) -> int :
  if 1 - 1: i1iiIII111
  if 29 - 29: i1 * I11iiIi11i1I + ooo000 - IIiIIiIi11I1
  if 14 - 14: ooOOO + Ooo0Ooo + Iii1i
  if 45 - 45: OooOoo % ooo000
  if 6 - 6: IIiIIiIi11I1 - ooo000 + OooOoo * OooOoo - Ii
  if 81 - 81: I1I * oOo0O00 - IiI11Ii111
  if 74 - 74: Oo
  if 77 - 77: I11iiIi11i1I / Ooo0Ooo + OooOoo - IiIIii11Ii % Ii * I1Ii1I1
  if 11 - 11: I1I + i1 % Iii1i
  if 87 - 87: i1iiIII111 - oOO + i1i1i1111I / I1Ii1I1
  if 50 - 50: ooOOO - I1I
  if 78 - 78: IIiIIiIi11I1 - I11iiIi11i1I * ooOOO
  if 37 - 37: Iii1i - oOO - Iii1i % i1iiIII111 - i1I . i1I
  return self . generatorController [ self . train . currentSourceDataset ] . getEpochSize ( refresh = refresh )
  if 13 - 13: i1i1i1111I % IIiIIiIi11I1 - IiIIii11Ii + OooOoo . i1I
 def getData ( self , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) :
  if 87 - 87: oOo0O00 + oOo0O00 . I1Ii1I1 % I1I + Oo * Ooo0Ooo
  if 36 - 36: I1Ii1I1 % i1 % i1iiIII111 % i1I * IIiIIiIi11I1
  if 35 - 35: Ooo0Ooo - ooo000 + i1I + Ii
  if 62 - 62: IiIIii11Ii
  if 42 - 42: IiI11Ii111 * I1I + oOo0O00
  if 29 - 29: IIiIIiIi11I1 % IIiIIiIi11I1 * i1iiIII111 . Ooo0Ooo
  if 73 - 73: Iii1i / i1I
  if 35 - 35: IIiIIiIi11I1 . i1 - Oo + I1I + IiIIii11Ii
  if 76 - 76: Oo - Ii . Oo . i1iiIII111
  if 83 - 83: iI1iII1I1I1i - oOo0O00 / IiI11Ii111
  if 34 - 34: i1i1i1111I * ooOOO
  if 89 - 89: OooOoo - IiIIii11Ii / iI1iII1I1I1i + i1iiIII111 % ooo000
  if 33 - 33: i1
  if 44 - 44: IIiIIiIi11I1 * Oo + ooo000
  if 69 - 69: IiIIii11Ii * I1I - IiI11Ii111
  if 86 - 86: i1 / oOO / IiIIii11Ii
  if 48 - 48: Iii1i % i1I * IiIIii11Ii
  o0o0oooO0 = o0o ( self . train , self . getRootSources ( False ) , sourceDataset = sourceDataset )
  if 63 - 63: oOo0O00 % IiIIii11Ii - Oo % Ooo0Ooo * Ii - OooOoo
  if 68 - 68: Oo * Ooo0Ooo / I1Ii1I1
  iiI1iIi = o0o0oooO0 . getData ( start = start , end = end )
  if 31 - 31: oOo0O00 * iI1iII1I1I1i
  if 1 - 1: iI1iII1I1I1i . ooOOO . ooo000
  return self . getProcessedData ( iiI1iIi , step = step )
  if 76 - 76: Oo * IIiIIiIi11I1 + i1I * IIiIIiIi11I1
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> 'np.ndarray' :
  if 93 - 93: oOo0O00 / oOO . i1iiIII111 + i1iiIII111 % I11iiIi11i1I . I1I
  if 64 - 64: ooo000 + Oo . iI1iII1I1I1i
  if 4 - 4: ooo000 % Oo
  if 3 - 3: iI1iII1I1I1i
  if 45 - 45: Iii1i * Ii * iI1iII1I1I1i . Ii * ooo000
  if 59 - 59: ooOOO * Ii % oOO - IiI11Ii111 - I1Ii1I1
  if 68 - 68: Oo + OooOoo - Oo
  if 96 - 96: i1 % oOO * i1I
  if 55 - 55: i1 - I1I + IIiIIiIi11I1 - i1
  if 48 - 48: I11iiIi11i1I + Ooo0Ooo % IIiIIiIi11I1 . iI1iII1I1I1i . OooOoo / oOO
  return self . generatorController . getNextBatch ( datasetType = ( sourceDataset or self . train . currentSourceDataset ) )
  if 69 - 69: i1i1i1111I + I1I
 def refreshItemShape ( self ) :
  if 30 - 30: I1I . Iii1i % i1i1i1111I
  if 35 - 35: IiI11Ii111 . iI1iII1I1I1i
  if 40 - 40: oOo0O00 - IiI11Ii111
  if 30 - 30: i1 - IIiIIiIi11I1 + i1I * Ooo0Ooo
  if 57 - 57: ooOOO
  if 67 - 67: I1I
  if 91 - 91: Ii . i1 - Ooo0Ooo + oOO + ooo000 / Iii1i
  if 66 - 66: I1Ii1I1 + Ooo0Ooo
  oo00 = self . getInputShape ( ) [ 1 : ]
  ooO0OOo = [ * oo00 [ : - 1 ] , len ( o0ooo0oOoO . getColList ( oo00 [ - 1 ] , self . sourceCol ) ) ]
  if 31 - 31: i1I - i1i1i1111I + I11iiIi11i1I / ooo000 % i1I - Oo
  if 12 - 12: OooOoo * I1I
  self . setItemShape ( [ * ooO0OOo ] )
  if 22 - 22: ooOOO
 def _processData ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 81 - 81: i1iiIII111 / ooo000 / Oo . IIiIIiIi11I1 % oOO * i1I
  if 19 - 19: oOo0O00 % i1iiIII111 - iI1iII1I1I1i
  if 34 - 34: ooOOO * IiIIii11Ii - I1I * IiIIii11Ii / i1iiIII111 * ooOOO
  if 37 - 37: Oo
  if 67 - 67: oOO
  if 86 - 86: i1i1i1111I + ooo000 / I1I - Iii1i % i1iiIII111 * OooOoo
  if 8 - 8: oOO % Oo
  if 89 - 89: iI1iII1I1I1i / Ooo0Ooo * oOo0O00 % oOO . ooOOO
  if 64 - 64: ooOOO
  if 49 - 49: I1Ii1I1 / i1i1i1111I . I11iiIi11i1I + I1I / i1iiIII111 / ooOOO
  if 8 - 8: Oo
  if 24 - 24: oOO / ooo000 / I1I . Iii1i
  if 66 - 66: oOo0O00 - IIiIIiIi11I1 - i1I . Iii1i
  if 54 - 54: IIiIIiIi11I1 * Oo - i1 % ooo000 - IiI11Ii111 / IiIIii11Ii
  if 1 - 1: IIiIIiIi11I1 - i1i1i1111I * Ooo0Ooo * I1Ii1I1
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 13 - 13: Ii / oOO + I11iiIi11i1I % ooo000
  if 72 - 72: oOo0O00
  if step == self . StepEnum . Input :
   return Ooo0OOooO
   if 14 - 14: i1I - Ii / I1Ii1I1 / oOo0O00 - i1iiIII111
   if 52 - 52: Ooo0Ooo % oOo0O00 - Oo
  OO0o = None
  if 76 - 76: ooo000 . i1iiIII111 . i1 * Iii1i % ooo000
  if 33 - 33: i1I . IIiIIiIi11I1 * Iii1i * oOo0O00 / OooOoo
  for O0oOOOoo in self . transformations :
   if 44 - 44: IiI11Ii111 . Ii - oOO . IiIIii11Ii . i1I % Oo
   if O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch :
    if 25 - 25: OooOoo % ooo000 % Iii1i - iI1iII1I1I1i
    if OO0o is None :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 36 - 36: i1iiIII111 . i1
     if 9 - 9: ooo000 / OooOoo * I1Ii1I1 + Iii1i - OooOoo
    O0oOOOoo . preExtract ( OO0o )
    if 23 - 23: Ooo0Ooo
    if 74 - 74: oOO . I11iiIi11i1I * IiIIii11Ii - I11iiIi11i1I + OooOoo . IiI11Ii111
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 30 - 30: oOO + i1
  if step == self . StepEnum . Transformed :
   return Ooo0OOooO
   if 97 - 97: I1I + IiI11Ii111 * i1i1i1111I * Ooo0Ooo . IiIIii11Ii
   if 58 - 58: i1i1i1111I + IIiIIiIi11I1
  if self . dtype is not None :
   Ooo0OOooO = Ooo0OOooO . astype ( self . dtype . as_numpy_dtype )
  else :
   Ooo0OOooO = Ooo0OOooO . astype ( float )
   if 40 - 40: ooo000 + I1I % IiIIii11Ii
   if 16 - 16: I1Ii1I1
  return Ooo0OOooO
  if 95 - 95: oOo0O00
 def recoverToRawData ( self , items : 'np.ndarray|list[*+]' , revealedIdxs : List [ int ] = None ) -> 'np.ndarray' :
  if 7 - 7: OooOoo
  if 70 - 70: i1i1i1111I / i1I
  if 43 - 43: i1I % IIiIIiIi11I1 * i1I
  if 75 - 75: i1
  if 44 - 44: Oo - IIiIIiIi11I1 - IIiIIiIi11I1 . Iii1i * I1I
  if 5 - 5: I11iiIi11i1I - Ii - i1I
  if 39 - 39: OooOoo
  if 33 - 33: Iii1i - i1i1i1111I + ooOOO - i1 % oOO * i1I
  if 42 - 42: iI1iII1I1I1i / ooo000
  if 72 - 72: oOO . ooo000 - iI1iII1I1I1i
  if 60 - 60: Ii - ooo000 . i1 + i1iiIII111 + i1I * iI1iII1I1I1i
  if 87 - 87: i1 * IIiIIiIi11I1 . Ii / i1 / ooOOO / i1I
  if 54 - 54: iI1iII1I1I1i * IIiIIiIi11I1 + i1iiIII111 + Iii1i . oOO + ooOOO
  if 69 - 69: i1I
  if 39 - 39: I1I - oOO . IiIIii11Ii . Iii1i - oOo0O00 + I1Ii1I1
  items = np . array ( items )
  if 62 - 62: iI1iII1I1I1i
  if 77 - 77: i1I + oOo0O00 * Ooo0Ooo - Oo . Oo
  if revealedIdxs is None :
   revealedIdxs = [ * range ( 0 , items . shape [ - 1 ] ) ]
   if 7 - 7: IIiIIiIi11I1 % oOo0O00 - IiIIii11Ii - oOo0O00
   if 87 - 87: Ooo0Ooo + iI1iII1I1I1i + I11iiIi11i1I / iI1iII1I1I1i % I1Ii1I1 / ooo000
  iiIII1 = [ ]
  if 88 - 88: oOo0O00 / i1iiIII111 % Iii1i + i1I / Iii1i
  if 78 - 78: ooo000 + IiIIii11Ii % Ooo0Ooo * Ooo0Ooo . ooo000
  oo00 = self . getInputShape ( )
  O0oO000O = OoOo0000o . parse ( oo00 [ - 1 ] , self . sourceCol )
  if 93 - 93: IiI11Ii111 * Ooo0Ooo / I1I . OooOoo % Ooo0Ooo
  if 71 - 71: IiI11Ii111 . iI1iII1I1I1i - iI1iII1I1I1i - IiI11Ii111
  if len ( self . transformations ) :
   if 48 - 48: I1I . i1I % OooOoo - ooo000
   for O0oOOOoo in reversed ( self . transformations ) :
    if 29 - 29: i1I - iI1iII1I1I1i / i1i1i1111I . Ii
    i1III1 = [ iiIII1 . index ( i ) for i in OoOo0000o . parse ( len ( O0oO000O ) , O0oOOOoo . colSel ) if i in iiIII1 ]
    items [ ... , i1III1 ] = np . vectorize ( O0oOOOoo . transformFrom ) ( items [ ... , i1III1 ] )
    if 57 - 57: Oo + OooOoo
    if 71 - 71: I1Ii1I1 - Ii / oOO - I1Ii1I1 * oOo0O00
  return items if isinstance ( self . fromNode , O0 ) else self . fromNode . recoverToRawData ( items , O0oO000O )
  if 26 - 26: I1I / i1
 def getPrintableItems ( self , items , recovered = True ) :
  if 7 - 7: IiI11Ii111 / i1I
  if 30 - 30: ooo000 + ooo000 . Iii1i
  if 49 - 49: i1 + Iii1i * IiI11Ii111 - OooOoo + I1I
  if 44 - 44: ooo000 % OooOoo + oOo0O00 % i1i1i1111I
  if 18 - 18: i1 + Ii - ooo000 . ooOOO + I11iiIi11i1I
  if 72 - 72: oOO + i1iiIII111 - i1
  if 14 - 14: i1I
  if 81 - 81: ooOOO . IiIIii11Ii / oOo0O00 + I11iiIi11i1I / Iii1i
  if 42 - 42: Ooo0Ooo - oOo0O00
  if 17 - 17: Iii1i + oOO - Ooo0Ooo
  if 71 - 71: iI1iII1I1I1i * ooo000 % I1Ii1I1 . i1 . i1I
  if 17 - 17: i1 . i1i1i1111I
  if 62 - 62: i1i1i1111I
  if 80 - 80: oOO + Ooo0Ooo - i1I / OooOoo % IIiIIiIi11I1 % i1I
  if 68 - 68: I11iiIi11i1I / I1I - i1i1i1111I * ooOOO
  O0000000 = ( Ii1II11 ( items ) . tolist ( ) if isinstance ( items , np . ndarray ) else items ) if recovered else self . recoverToRawData ( items ) . tolist ( )
  if 21 - 21: IiIIii11Ii % I1Ii1I1 - i1I
  if 15 - 15: i1I * oOo0O00 - Oo + Ooo0Ooo
  O0o0o0Oo00O0 = isinstance ( O0000000 [ 0 ] , list )
  if 2 - 2: I1Ii1I1 / oOO
  if not O0o0o0Oo00O0 :
   if 72 - 72: IIiIIiIi11I1 . Iii1i . i1i1i1111I + Ii * I1Ii1I1
   OO0oo0OoooOO = "TXT"
  elif len ( O0000000 [ 0 ] ) == 1 :
   if 68 - 68: i1iiIII111 + i1i1i1111I * Iii1i / OooOoo
   OO0oo0OoooOO = "TXT"
   O0000000 = [ c [ 0 ] for c in O0000000 ]
  else :
   if 88 - 88: Iii1i * i1i1i1111I
   OO0oo0OoooOO = "TXT"
   if 93 - 93: oOo0O00 + ooOOO + ooo000 . ooOOO
   if 68 - 68: OooOoo % i1i1i1111I * ooOOO . ooo000
  return [ [ OO0oo0OoooOO , json . dumps ( i ) ] for i in O0000000 ]
  if 54 - 54: i1iiIII111 - Iii1i
 def getProcessedData ( self , rootData : 'Train.RootData' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 100 - 100: IiIIii11Ii
  if 22 - 22: i1I * ooOOO - I1Ii1I1 + Ii
  if 30 - 30: Ii - oOO - oOo0O00 + oOO * I1I / Iii1i
  if 74 - 74: IIiIIiIi11I1 % i1 / oOO
  if 28 - 28: Iii1i % Ii - ooOOO . i1iiIII111
  if 58 - 58: i1 / ooo000 / i1i1i1111I - oOO + i1iiIII111
  if 65 - 65: IiI11Ii111 . iI1iII1I1I1i * Oo . Ii + Oo * i1I
  if 56 - 56: IIiIIiIi11I1 % OooOoo * IiI11Ii111 . OooOoo
  if 45 - 45: i1I
  if 17 - 17: Oo
  if 72 - 72: IiIIii11Ii % OooOoo
  if self . key in rootData . dppNodes :
   if step != I1i1i . Output :
    raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
   return rootData . dppNodes [ self . key ]
   if 31 - 31: OooOoo * i1I
   if 58 - 58: ooOOO
  I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProcessedData ( rootData )
  if 74 - 74: IIiIIiIi11I1 / i1iiIII111 % I1Ii1I1 % Oo % oOO + IiIIii11Ii
  if 42 - 42: i1i1i1111I
  return self . processData ( I1i , step = step )
  if 55 - 55: iI1iII1I1I1i % i1i1i1111I
 def getProcessedDataToShow ( self , rootData : 'Train.RootData' , step : 'DataPreprocessing.Node.StepEnum' = I1i1i . Output ) -> 'np.ndarray' :
  if 37 - 37: Iii1i / i1iiIII111 - oOo0O00 - Oo * oOo0O00
  if 24 - 24: iI1iII1I1I1i % i1I / Ooo0Ooo
  if 21 - 21: IiIIii11Ii / i1i1i1111I % oOO % i1
  if 89 - 89: I1Ii1I1
  if 39 - 39: IIiIIiIi11I1 % iI1iII1I1I1i * Ooo0Ooo / iI1iII1I1I1i * I1Ii1I1 - ooOOO
  if 39 - 39: oOo0O00 * I1I
  if 81 - 81: IiI11Ii111 + I11iiIi11i1I - IIiIIiIi11I1
  if 22 - 22: IiIIii11Ii - Oo - ooo000 + oOo0O00 * i1
  if 67 - 67: Ii * IiI11Ii111 / Ii % ooOOO / Iii1i % oOo0O00
  if 17 - 17: i1I - Ii - Iii1i
  if 93 - 93: i1I
  if self . key in rootData . dppNodes :
   if step != I1i1i . Output :
    raise ValueError ( "When data is preprocessed elementally, it cannot be received using intercepted steps." )
   return rootData . dppNodes [ self . key ]
   if 37 - 37: IiI11Ii111
   if 9 - 9: IiIIii11Ii * i1 - Ooo0Ooo - OooOoo
  I1i = ( rootData . sources [ self . source ] if self . outputset is None else rootData . sources [ self . source ] [ self . outputset ] ) if isinstance ( self . source , int ) else self . train . dppNodes [ self . source ] . getProcessedData ( rootData )
  if 37 - 37: ooo000 - OooOoo
  if 17 - 17: IiI11Ii111 + Ii / i1
  return self . processDataToShow ( I1i , step = step )
  if 53 - 53: Ii / i1i1i1111I % ooOOO * Ii * Oo
 def _processData ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 87 - 87: iI1iII1I1I1i / Oo / Oo
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 97 - 97: I1Ii1I1 / oOo0O00 - ooOOO . IIiIIiIi11I1
  if 43 - 43: Iii1i % i1i1i1111I . ooOOO % OooOoo
  if 79 - 79: i1iiIII111 / IiI11Ii111
  if 68 - 68: iI1iII1I1I1i + I1Ii1I1 + i1I / i1 % i1iiIII111 * IiI11Ii111
  if 54 - 54: IIiIIiIi11I1 - i1i1i1111I - i1 + Iii1i % I1Ii1I1 / Ooo0Ooo
  if 99 - 99: oOo0O00 * iI1iII1I1I1i
  if 94 - 94: i1iiIII111 - Iii1i
  if 6 - 6: OooOoo / i1I % i1I . Ii . oOo0O00 - iI1iII1I1I1i
  if 53 - 53: oOo0O00
  if 39 - 39: I11iiIi11i1I - IIiIIiIi11I1
  if 32 - 32: i1iiIII111 * ooOOO + Ii * oOo0O00 * i1 / Oo
  if 52 - 52: IiI11Ii111 - Ii / Ooo0Ooo * IiIIii11Ii - ooOOO
  if 74 - 74: I1I % oOo0O00
  if 30 - 30: ooo000 % Iii1i % i1iiIII111 + i1I / IiIIii11Ii / I1Ii1I1
  if 66 - 66: i1 % iI1iII1I1I1i + i1 / I11iiIi11i1I
  OOo00oOoOo : List [ int ] = np . shape ( data )
  Ooo0OOooO : np . ndarray = data [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( self . crops [ ooOoooO0OOo ] ) if ooOoooO0OOo in self . crops else slice ( None , None ) ) for ooOoooO0OOo , v in enumerate ( OOo00oOoOo [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( self . sourceCol ) ) ]
  if 13 - 13: Iii1i / IIiIIiIi11I1
  if 30 - 30: i1 + I1I * Ii
  if ( step == self . StepEnum . Input ) :
   return Ooo0OOooO
   if 24 - 24: oOo0O00 - Oo
   if 23 - 23: IIiIIiIi11I1 + ooOOO
  OO0o = None
  if 3 - 3: oOO % I1I + iI1iII1I1I1i * Ii / i1 / IiIIii11Ii
  if 6 - 6: ooo000 . OooOoo . i1
  for O0oOOOoo in self . transformations :
   if 17 - 17: Iii1i . i1i1i1111I - IiIIii11Ii
   if ( O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch ) :
    if 46 - 46: IIiIIiIi11I1 % i1I . ooOOO
    if ( OO0o is None ) :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 82 - 82: ooOOO . OooOoo / oOo0O00 * ooo000 + i1i1i1111I + i1i1i1111I
     if 76 - 76: IiIIii11Ii / i1i1i1111I + i1iiIII111 / I11iiIi11i1I / Ii
    O0oOOOoo . preExtract ( OO0o )
    if 63 - 63: i1I . i1 . IiIIii11Ii * IiIIii11Ii . i1
    if 94 - 94: IiI11Ii111 + i1i1i1111I + IIiIIiIi11I1 % i1iiIII111 . IIiIIiIi11I1 * i1iiIII111
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 46 - 46: ooo000 . i1 - I11iiIi11i1I / OooOoo
  if ( step == self . StepEnum . Transformed ) :
   return Ooo0OOooO
   if 36 - 36: Iii1i / Oo - Ooo0Ooo * OooOoo
   if 10 - 10: oOO * IiIIii11Ii * Ooo0Ooo * i1iiIII111 / Iii1i / Iii1i
  IiIiIIIiIIiI : str = self . separator
  IiIi1iIi = [ ]
  if IiIiIIIiIIiI is not None :
   for ooOoooO0OOo in range ( len ( Ooo0OOooO ) ) :
    if 59 - 59: i1iiIII111 . oOo0O00 . Ii / i1iiIII111
    IiIi1iIi . append ( ( IiIiIIIiIIiI . join ( Ooo0OOooO [ ooOoooO0OOo ] ) ) . split ( IiIiIIIiIIiI ) )
  else :
   IiIi1iIi = list ( Ooo0OOooO )
   if 78 - 78: ooo000 * IiIIii11Ii % Ooo0Ooo * iI1iII1I1I1i % iI1iII1I1I1i
   if 10 - 10: I1I / Ooo0Ooo * Iii1i
   if 65 - 65: i1I
   if 5 - 5: Ii
   if 11 - 11: Oo - I1I . IiI11Ii111
  I111i11iiI = [ tf . keras . preprocessing . text . one_hot ( d [ 0 ] , self . sequenceLen ) for d in IiIi1iIi ]
  if 51 - 51: ooo000 . oOO / Oo % I11iiIi11i1I - oOO - IiIIii11Ii
  if 12 - 12: IiIIii11Ii * IiI11Ii111 - IiIIii11Ii . Ii * i1I
  O00oOOo0 = tf . keras . preprocessing . sequence . pad_sequences ( I111i11iiI , maxlen = self . highWords , padding = 'post' )
  return O00oOOo0
  if 5 - 5: IIiIIiIi11I1
 def _processDataToShow ( self , data : 'np.ndarray<int|float|str>' , step : 'DataPreprocessing.Node.Columns.StepEnum' = StepEnum . Output ) -> 'np.ndarray<int|float|str>' :
  if 20 - 20: I1Ii1I1 - oOO . oOo0O00 . OooOoo - I1I * iI1iII1I1I1i
  Ooo0OOooO = o0ooo0oOoO . arraySlice ( data , self . sourceCol )
  if 27 - 27: oOo0O00 - iI1iII1I1I1i . I11iiIi11i1I
  if 29 - 29: Iii1i * i1 % ooo000 . iI1iII1I1I1i % IiI11Ii111 % i1I
  if 81 - 81: Oo + ooOOO * oOo0O00 + oOO % I1I
  if 53 - 53: ooOOO . IIiIIiIi11I1 - i1I + Ii
  if 56 - 56: I11iiIi11i1I % Ooo0Ooo * IiIIii11Ii - i1i1i1111I
  if 72 - 72: Oo - Ooo0Ooo . oOo0O00
  if 46 - 46: IiIIii11Ii . IiI11Ii111 * ooo000 + I1I
  if 39 - 39: I11iiIi11i1I . Ii
  if 81 - 81: I1I - OooOoo % Ii . IiIIii11Ii / IiIIii11Ii % Ooo0Ooo
  if 43 - 43: IIiIIiIi11I1 / IIiIIiIi11I1
  if 62 - 62: I1I . Oo
  if 49 - 49: oOO * Oo - I1Ii1I1 % Ooo0Ooo
  if 14 - 14: oOO + OooOoo - Iii1i
  if 14 - 14: Ii + OooOoo
  if 48 - 48: i1iiIII111 + Ii . i1iiIII111
  OOo00oOoOo : List [ int ] = np . shape ( data )
  Ooo0OOooO : np . ndarray = data [ ( slice ( None , None ) ,
 * ( ( OoOo0000o . toIndexer ( self . crops [ ooOoooO0OOo ] ) if ooOoooO0OOo in self . crops else slice ( None , None ) ) for ooOoooO0OOo , v in enumerate ( OOo00oOoOo [ 1 : - 1 ] ) ) ,
 OoOo0000o . toIndexer ( self . sourceCol ) ) ]
  if 38 - 38: I11iiIi11i1I . Ii * i1I * oOO % I1I
  if 73 - 73: iI1iII1I1I1i - I11iiIi11i1I / IIiIIiIi11I1 % OooOoo
  if ( step == self . StepEnum . Input ) :
   return Ooo0OOooO
   if 40 - 40: ooo000 . Iii1i / oOo0O00 / i1
   if 68 - 68: Ii * Iii1i
  OO0o = None
  if 4 - 4: oOo0O00 . i1iiIII111 / IiI11Ii111 / IiI11Ii111 + i1
  if 3 - 3: ooOOO * iI1iII1I1I1i . i1I % Ooo0Ooo
  for O0oOOOoo in self . transformations :
   if 41 - 41: ooo000 - I11iiIi11i1I / IiI11Ii111
   if ( O0oOOOoo . requirePreExtraction and not O0oOOOoo . cachedPrefetch ) :
    if 64 - 64: IiIIii11Ii / I11iiIi11i1I . ooo000 % OooOoo / OooOoo + iI1iII1I1I1i
    if ( OO0o is None ) :
     OO0o = self . train . dppNodes [ self . key ] . getData ( step = self . StepEnum . Input , sourceDataset = I111II1II111I . Dataset . Types . Train )
     if 100 - 100: ooo000 * Iii1i . I1Ii1I1
     if 17 - 17: OooOoo . i1
    O0oOOOoo . preExtract ( OO0o )
    if 37 - 37: IiIIii11Ii
    if 49 - 49: iI1iII1I1I1i - I1Ii1I1 . i1i1i1111I + IiIIii11Ii * i1I % Ii
   Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] = np . vectorize ( O0oOOOoo . transformTo ) ( Ooo0OOooO [ ... , OoOo0000o . toIndexer ( O0oOOOoo . colSel ) ] )
   if 34 - 34: I11iiIi11i1I
  if ( step == self . StepEnum . Transformed ) :
   return Ooo0OOooO
   if 81 - 81: Iii1i % i1iiIII111
   if 9 - 9: Ooo0Ooo - oOO . I1Ii1I1 . I1I
  IiIiIIIiIIiI : str = self . separator
  IiIi1iIi = [ ]
  if IiIiIIIiIIiI is not None :
   for ooOoooO0OOo in range ( len ( Ooo0OOooO ) ) :
    if 75 - 75: I11iiIi11i1I - oOO
    IiIi1iIi . append ( ( IiIiIIIiIIiI . join ( Ooo0OOooO [ ooOoooO0OOo ] ) ) . split ( IiIiIIIiIIiI ) )
  else :
   IiIi1iIi = list ( Ooo0OOooO )
   if 38 - 38: IiI11Ii111 - i1I . oOO
  return IiIi1iIi
  if 49 - 49: i1i1i1111I - i1iiIII111
  if 18 - 18: IiI11Ii111 - oOO + oOo0O00 + oOo0O00
class OO0O0 ( ) :
 if 20 - 20: OooOoo
 if 21 - 21: oOO * ooOOO / oOO
 if 70 - 70: i1i1i1111I / iI1iII1I1I1i / iI1iII1I1I1i / i1i1i1111I
 if 39 - 39: i1 . Oo . oOO
 if 5 - 5: ooo000 / ooo000 * i1I * ooOOO . IiI11Ii111 . i1
 if 86 - 86: Iii1i - i1i1i1111I - ooOOO . i1i1i1111I - I11iiIi11i1I
 if 73 - 73: Oo . IiI11Ii111 % i1iiIII111 / IiI11Ii111 - oOo0O00 / IIiIIiIi11I1
 Type = OoiI1iiI11IIi1
 StepEnum = I1i1i
 Config = Oo0ooo0OO0
 Columns = Ii1Ii1iii
 Image = o0oo0o
 SourceLike = O0o000oO000
 TimeSeriese = IIiIiiii
 Noise = ii1iiiiiII
 BERT = I11ii
 TXT = Ii1111i
 if 53 - 53: I1I % i1i1i1111I + i1 . i1i1i1111I + ooOOO
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] , train : 'Train' ) -> 'Node' :
  if 12 - 12: I11iiIi11i1I . Oo
  if 15 - 15: Oo * Iii1i + i1i1i1111I + i1 * I1Ii1I1
  if 41 - 41: iI1iII1I1I1i . Iii1i % oOo0O00 + Ii - IiIIii11Ii % Ooo0Ooo
  if 1 - 1: ooOOO * ooo000 . Oo - I11iiIi11i1I + iI1iII1I1I1i
  if 68 - 68: Iii1i . I1I
  if 14 - 14: ooo000 + i1iiIII111 + IIiIIiIi11I1
  if 17 - 17: i1iiIII111 - IIiIIiIi11I1
  if 77 - 77: iI1iII1I1I1i . ooOOO * Iii1i
  if 29 - 29: ooOOO - ooOOO
  if 80 - 80: IiI11Ii111 % iI1iII1I1I1i % IiI11Ii111 . i1 / Oo % i1
  if 51 - 51: oOo0O00 % I1Ii1I1 . ooo000 * i1i1i1111I + ooo000 . Iii1i
  if 29 - 29: iI1iII1I1I1i - IiIIii11Ii
  if 30 - 30: oOO
  if 6 - 6: ooo000 - i1i1i1111I / Ii
  if 11 - 11: oOO
  OOooOo = getattr ( OO0O0 , OoiI1iiI11IIi1 . getName ( obj [ "_instanceClass" ] ) ) ( )
  OOooOo . parseJSON ( obj , train )
  return OOooOo
  if 51 - 51: ooo000
  if 37 - 37: Ii
class ooo0 :
 if 36 - 36: I11iiIi11i1I + iI1iII1I1I1i - oOo0O00 % oOO
 if 49 - 49: i1I * i1I % I11iiIi11i1I + I11iiIi11i1I + iI1iII1I1I1i . Iii1i
 if 84 - 84: Oo - Iii1i
 if 7 - 7: Iii1i - iI1iII1I1I1i . i1 - IIiIIiIi11I1
 if 41 - 41: IiI11Ii111 + I1I / iI1iII1I1I1i . Oo % Oo
 if 10 - 10: i1I . Ooo0Ooo * Ii . ooOOO
 if 79 - 79: I1Ii1I1
 def __init__ ( self , instanceClass : 'DataPreprocessing.Transformation.Types' , method : 'Enumeration' ) :
  if 12 - 12: oOo0O00 + IiIIii11Ii . i1iiIII111
  if 76 - 76: ooOOO - i1 / I11iiIi11i1I / oOo0O00
  if 85 - 85: Ooo0Ooo * i1iiIII111 * I1Ii1I1 + i1I / Oo
  if 62 - 62: I1I . i1 * i1 + Ii . IiI11Ii111 + i1I
  if 75 - 75: ooo000 - IiIIii11Ii
  if 28 - 28: Oo - IiI11Ii111 * iI1iII1I1I1i - Oo / I1I - i1I
  if 39 - 39: OooOoo * I11iiIi11i1I + OooOoo - I1I
  if 96 - 96: I11iiIi11i1I + i1iiIII111 - i1 * OooOoo % IIiIIiIi11I1
  if 85 - 85: iI1iII1I1I1i % i1i1i1111I * i1i1i1111I + i1
  if 36 - 36: Oo / IiI11Ii111 - iI1iII1I1I1i - Ooo0Ooo . Iii1i
  if 47 - 47: Oo % i1 - i1iiIII111
  if 60 - 60: Oo / Oo * OooOoo - Iii1i + ooo000
  self . _instanceClass = instanceClass
  if 90 - 90: IiI11Ii111 % IiIIii11Ii / ooo000 + ooo000 + I1I
  self . _method = method
  if 76 - 76: IiI11Ii111 * Iii1i - oOo0O00 . i1iiIII111 * IiIIii11Ii
 @ property
 def instanceClass ( self ) -> 'DataPreprocessing.Transformation.Types' :
  if 63 - 63: i1
  if 77 - 77: ooOOO / OooOoo * Oo - oOO * ooo000 - i1I
  if 20 - 20: OooOoo + Ii % i1iiIII111
  if 4 - 4: ooo000 / Iii1i . i1i1i1111I . Ii . i1i1i1111I
  if 42 - 42: Ooo0Ooo . i1I . I1I - oOO
  if 34 - 34: IiI11Ii111 * I11iiIi11i1I * i1i1i1111I
  if 18 - 18: i1
  if 1 - 1: oOO
  if 66 - 66: I1I * I11iiIi11i1I
  if 39 - 39: i1I - Ii % oOO * IIiIIiIi11I1 - I1I / I1I
  return self . _instanceClass
  if 10 - 10: ooOOO
 @ property
 def method ( self ) -> 'Enumeration' :
  if 86 - 86: Oo % iI1iII1I1I1i - i1
  if 81 - 81: i1iiIII111 + Ooo0Ooo * IiI11Ii111 . OooOoo
  if 17 - 17: I11iiIi11i1I
  if 71 - 71: Iii1i / Ooo0Ooo
  if 28 - 28: I11iiIi11i1I
  if 94 - 94: Oo + ooo000 - i1 . Iii1i
  if 20 - 20: ooOOO - Oo
  if 89 - 89: IiI11Ii111 - Ooo0Ooo / I1I % IiI11Ii111 + i1i1i1111I % Ooo0Ooo
  if 60 - 60: Iii1i + OooOoo / i1I / i1i1i1111I
  if 92 - 92: i1 * I1Ii1I1 * OooOoo + OooOoo % ooo000
  return self . _method
  if 59 - 59: I1Ii1I1
 def copy ( self ) -> 'DataPreprocessing.Transformation.Config' :
  if 49 - 49: iI1iII1I1I1i / ooOOO % IiI11Ii111 % i1iiIII111 % I1Ii1I1
  if 24 - 24: IiI11Ii111 / ooOOO - ooOOO
  if 39 - 39: ooOOO % Ooo0Ooo / oOO * I11iiIi11i1I - Oo . i1i1i1111I
  if 40 - 40: Ii / Ooo0Ooo
  if 33 - 33: IiI11Ii111
  if 91 - 91: i1iiIII111 . IIiIIiIi11I1 % i1i1i1111I - i1iiIII111 + IiIIii11Ii
  if 77 - 77: Ii * ooo000 * I1Ii1I1 * I11iiIi11i1I - IiI11Ii111 - Ii
  if 22 - 22: Oo % OooOoo * Iii1i
  if 92 - 92: ooo000 + iI1iII1I1I1i / Oo / I1Ii1I1 - ooo000 * ooo000
  if 93 - 93: I1I
  pass
  if 19 - 19: I11iiIi11i1I + oOo0O00
 def _copyAttributesTo ( self , newTransformation , * attrs ) :
  if 10 - 10: I1Ii1I1 . i1iiIII111 % IiI11Ii111 + i1I % IIiIIiIi11I1
  if 60 - 60: iI1iII1I1I1i * i1I
  if 26 - 26: IIiIIiIi11I1 + i1iiIII111 % i1i1i1111I + OooOoo % ooOOO
  if 93 - 93: i1i1i1111I + i1i1i1111I . I1I - ooo000
  if 59 - 59: I1I
  if 91 - 91: OooOoo - ooo000 + iI1iII1I1I1i * Oo - Oo
  if 21 - 21: oOo0O00 % I1Ii1I1 * I1I
  if 27 - 27: Iii1i
  if 70 - 70: IiIIii11Ii
  if 51 - 51: I11iiIi11i1I . OooOoo
  if 74 - 74: ooOOO * oOO
  for IiiiI in attrs :
   setattr ( newTransformation , IiiiI , getattr ( self , IiiiI ) )
   if 88 - 88: I11iiIi11i1I % i1i1i1111I / iI1iII1I1I1i / Ooo0Ooo / oOo0O00 + oOO
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 45 - 45: Iii1i / IIiIIiIi11I1
  if 18 - 18: i1i1i1111I
  if 79 - 79: oOO . OooOoo + IIiIIiIi11I1 % ooOOO
  if 87 - 87: Ooo0Ooo
  if 88 - 88: IIiIIiIi11I1 / Ooo0Ooo % ooo000 / i1i1i1111I + IiI11Ii111 / i1iiIII111
  if 46 - 46: Iii1i . IiIIii11Ii . i1i1i1111I
  if 5 - 5: IiI11Ii111 . oOO + OooOoo + Ooo0Ooo / I1Ii1I1
  if 27 - 27: Iii1i . Ooo0Ooo / iI1iII1I1I1i . OooOoo / i1iiIII111 / Ii
  if 20 - 20: I11iiIi11i1I * Iii1i / I1I * ooOOO * OooOoo * ooOOO
  if 26 - 26: I1I + Oo % i1I - OooOoo
  if 72 - 72: IiI11Ii111
class oo0OOOOOO0o00 ( ooo0 ) :
 if 15 - 15: ooo000 * Oo / Ooo0Ooo - IiI11Ii111
 if 50 - 50: oOo0O00 - i1 . Iii1i / IiIIii11Ii + ooOOO
 if 33 - 33: Iii1i
 if 50 - 50: Ooo0Ooo
 if 51 - 51: iI1iII1I1I1i % Iii1i . oOO
 if 37 - 37: i1iiIII111 * Iii1i % Oo
 if 43 - 43: Oo * Ooo0Ooo - OooOoo + Ooo0Ooo % I1Ii1I1 * I11iiIi11i1I
 def __init__ ( self , method : 'DataPreprocessing.Transformation.Columns.Types' , colSel : str = "None:None" ) :
  if 1 - 1: oOo0O00 / Oo . Iii1i + Iii1i + IiI11Ii111
  if 53 - 53: Ooo0Ooo % I1I . i1iiIII111 . i1iiIII111 / IiIIii11Ii
  if 21 - 21: I1Ii1I1 / oOO / i1iiIII111 . oOO % iI1iII1I1I1i / iI1iII1I1I1i
  if 82 - 82: IiIIii11Ii / Ii + oOo0O00
  if 64 - 64: i1iiIII111 / I1I * IiIIii11Ii % Ii
  if 99 - 99: i1i1i1111I
  if 15 - 15: i1iiIII111 / I11iiIi11i1I + Ooo0Ooo
  if 24 - 24: oOO - oOO % ooo000 / Ii
  if 29 - 29: iI1iII1I1I1i
  if 36 - 36: Iii1i % Iii1i / IiIIii11Ii + I11iiIi11i1I % Iii1i
  super ( ) . __init__ ( oOoOoo0oO0 . Columns , method )
  if 43 - 43: IiIIii11Ii + I1Ii1I1 % i1iiIII111 . IiIIii11Ii * Ooo0Ooo % iI1iII1I1I1i
  if 42 - 42: IiI11Ii111 - i1i1i1111I % I1I . iI1iII1I1I1i
  self . _requirePreExtraction = False
  if 76 - 76: Iii1i / oOo0O00 * iI1iII1I1I1i + OooOoo - iI1iII1I1I1i
  if 33 - 33: Oo * ooo000 . Iii1i
  self . colSel = colSel
  if 71 - 71: I11iiIi11i1I + iI1iII1I1I1i % Oo . I1Ii1I1 + I1Ii1I1
  if 15 - 15: ooo000 / I11iiIi11i1I
  self . _cachedPrefetch = False
  if 77 - 77: Iii1i . I1I % iI1iII1I1I1i + Ooo0Ooo
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 88 - 88: OooOoo . I11iiIi11i1I * i1I * i1I % i1 % Iii1i
  if 88 - 88: ooo000 + Oo . i1 * i1I
  if 78 - 78: i1I - OooOoo % Oo - i1iiIII111 * ooo000 * Ii
  if 29 - 29: IIiIIiIi11I1 % oOO
  if 67 - 67: OooOoo + IiIIii11Ii % oOO * I11iiIi11i1I % I11iiIi11i1I - Oo
  if 70 - 70: i1I / ooo000 - i1
  if 7 - 7: Iii1i % Iii1i * i1 - i1I - IiI11Ii111 + i1I
  if 79 - 79: oOo0O00 * i1iiIII111 + ooOOO - ooOOO + Ii . iI1iII1I1I1i
  if 52 - 52: Ooo0Ooo / ooo000 / i1iiIII111 * i1 + oOo0O00
  if 99 - 99: i1I + ooo000 . ooOOO . i1
  if 44 - 44: I11iiIi11i1I * IiI11Ii111 / i1iiIII111 % i1I * Ii
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I not in [ "_instanceClass" , "_method" , "dppNodes" , "colConfigs" , "_cachedPrefetch" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 60 - 60: i1I * IiIIii11Ii - i1iiIII111 % I11iiIi11i1I - i1
 @ property
 def requirePreExtraction ( self ) -> bool :
  if 87 - 87: Ooo0Ooo + oOO * ooo000 . IIiIIiIi11I1
  if 68 - 68: oOo0O00 / Ii * IIiIIiIi11I1
  if 89 - 89: iI1iII1I1I1i . Oo
  if 88 - 88: ooo000 - I1I . Iii1i + Iii1i
  if 63 - 63: I1I % i1I - OooOoo / I1I / I11iiIi11i1I
  if 42 - 42: i1 . Ooo0Ooo / i1I
  if 76 - 76: OooOoo + i1iiIII111 % Ii * I1Ii1I1 * i1
  if 12 - 12: ooo000 * i1iiIII111
  if 26 - 26: i1 - i1iiIII111
  if 89 - 89: i1iiIII111 * oOo0O00 . iI1iII1I1I1i % ooOOO / Ii % I1I
  return self . _requirePreExtraction
  if 18 - 18: ooOOO / IIiIIiIi11I1
 @ property
 def cachedPrefetch ( self ) -> bool :
  if 63 - 63: oOo0O00
  if 55 - 55: Ii + i1 % IiIIii11Ii * IiIIii11Ii + IiIIii11Ii
  if 89 - 89: OooOoo . Ii . Oo - IIiIIiIi11I1
  if 33 - 33: I1I
  if 54 - 54: IiIIii11Ii + ooOOO % IIiIIiIi11I1
  if 51 - 51: I1Ii1I1
  if 14 - 14: i1 % IiI11Ii111 * OooOoo . Iii1i - Ooo0Ooo
  if 42 - 42: iI1iII1I1I1i
  if 95 - 95: OooOoo . OooOoo / i1 % Iii1i
  if 47 - 47: oOo0O00 + oOO - IiIIii11Ii * i1
  return self . _cachedPrefetch
  if 86 - 86: ooOOO
 def preExtract ( self , preFetchedColumns : 'np.ndarray' ) :
  if 48 - 48: i1iiIII111 + i1iiIII111 % Ii
  if 17 - 17: i1iiIII111 / Iii1i - IIiIIiIi11I1 - IIiIIiIi11I1
  if 99 - 99: oOo0O00 % i1 / OooOoo * Ooo0Ooo - I1I
  if 74 - 74: Ii % Ooo0Ooo + Iii1i . I1Ii1I1 % i1 * ooo000
  if 73 - 73: OooOoo * i1I - I1Ii1I1 . I1Ii1I1
  if 20 - 20: i1I
  if 57 - 57: Iii1i + Oo - iI1iII1I1I1i
  if 99 - 99: Ooo0Ooo . iI1iII1I1I1i * i1i1i1111I . Oo + I1Ii1I1
  if 5 - 5: I1I
  if 75 - 75: oOo0O00 + IiI11Ii111
  pass
  if 5 - 5: IiI11Ii111 - I1Ii1I1 - ooo000 . I1Ii1I1
 def transformTo ( self , val : Union [ int , float , str ] ) -> float :
  if 94 - 94: oOO
  if 84 - 84: i1 * i1
  if 76 - 76: i1i1i1111I * IiI11Ii111 * i1I / IiI11Ii111 - Oo / Iii1i
  if 44 - 44: IIiIIiIi11I1 . i1i1i1111I
  if 21 - 21: Ii - Ii
  if 72 - 72: I11iiIi11i1I / i1
  if 84 - 84: ooOOO - iI1iII1I1I1i / i1iiIII111 . oOo0O00
  if 80 - 80: IIiIIiIi11I1 + oOO * iI1iII1I1I1i % oOO / OooOoo
  if 8 - 8: OooOoo / I11iiIi11i1I / Iii1i * i1i1i1111I
  if 22 - 22: oOO % oOo0O00 . Ooo0Ooo + Ooo0Ooo
  if 47 - 47: i1iiIII111 % ooOOO / Ooo0Ooo - i1I . Ooo0Ooo
  if 89 - 89: Ooo0Ooo
  if 34 - 34: ooOOO / I1Ii1I1 + iI1iII1I1I1i + I1I
  pass
  if 58 - 58: ooOOO - IIiIIiIi11I1 - oOO % Iii1i + iI1iII1I1I1i
 def transformFrom ( self , val : float ) -> Union [ int , float , str ] :
  if 1 - 1: IiI11Ii111 * Ooo0Ooo + IIiIIiIi11I1 + iI1iII1I1I1i - Ooo0Ooo . i1i1i1111I
  if 19 - 19: I11iiIi11i1I % iI1iII1I1I1i % oOO / OooOoo + ooo000
  if 67 - 67: IiI11Ii111
  if 18 - 18: ooo000 / i1i1i1111I * ooo000 * Oo + iI1iII1I1I1i
  if 4 - 4: i1iiIII111
  if 26 - 26: I11iiIi11i1I . Ii - ooo000 + ooo000
  if 70 - 70: I1I . ooo000 . oOo0O00 - i1I - IiIIii11Ii
  if 82 - 82: OooOoo
  if 60 - 60: I1I % I1Ii1I1 . OooOoo + IiIIii11Ii % i1
  if 48 - 48: ooOOO * ooo000 . i1i1i1111I . IiI11Ii111 % IiI11Ii111 . oOO
  if 88 - 88: Iii1i % iI1iII1I1I1i % Iii1i
  if 90 - 90: IIiIIiIi11I1
  if 1 - 1: ooo000 % Oo - I1Ii1I1 + IIiIIiIi11I1 . Oo - Ii
  pass
  if 61 - 61: oOo0O00 . i1 / Ooo0Ooo
class OOO0o0OOo0o ( oo0OOOOOO0o00 ) :
 if 42 - 42: i1i1i1111I
 if 5 - 5: Ii . IIiIIiIi11I1 * Oo . oOO - IiIIii11Ii
 if 4 - 4: Iii1i / Ii + IiIIii11Ii / oOo0O00 * IIiIIiIi11I1 % I1Ii1I1
 if 88 - 88: IiI11Ii111 / Ii / Iii1i . I1Ii1I1 * IIiIIiIi11I1 % IiIIii11Ii
 if 80 - 80: ooOOO - iI1iII1I1I1i * i1iiIII111 * i1 * IiI11Ii111
 if 55 - 55: iI1iII1I1I1i % oOo0O00 * ooOOO
 if 98 - 98: OooOoo + ooo000
 class Methods ( II1i1I ) :
  if 85 - 85: IiI11Ii111 * ooOOO * I1Ii1I1 * oOo0O00 . ooo000 . oOo0O00
  if 15 - 15: I1I * oOo0O00 - Ii
  if 88 - 88: I1I . iI1iII1I1I1i / IiI11Ii111
  if 99 - 99: Ooo0Ooo - ooo000
  if 95 - 95: IiI11Ii111 * ooo000 - Oo % ooo000 * Iii1i
  if 68 - 68: IIiIIiIi11I1 + iI1iII1I1I1i . oOo0O00
  if 77 - 77: IiIIii11Ii . oOo0O00 % ooo000 % I11iiIi11i1I % ooOOO . ooOOO
  if 76 - 76: I11iiIi11i1I . I1I . I11iiIi11i1I + I1Ii1I1 - oOo0O00
  MinMax = 0
  if 95 - 95: IiIIii11Ii
  if 57 - 57: i1iiIII111 + i1I . IiI11Ii111
  RelativeToZero = 1
  if 74 - 74: I1I - ooOOO / i1 + OooOoo + iI1iII1I1I1i
  if 95 - 95: Oo . i1i1i1111I . Ii * I11iiIi11i1I * IiIIii11Ii
  RelativeToMean = 2
  if 89 - 89: oOO
  if 33 - 33: Ooo0Ooo * IiI11Ii111 % i1iiIII111 % IiI11Ii111
  RelativeToRange = 3
  if 29 - 29: i1 . IiIIii11Ii
 def __init__ ( self , colSel : str = "None:None" , scaleType : 'DataPreprocessing.Transformation.Columns.Normalize.Methods' = Methods . MinMax , rangeMin : float = None , rangeMax : float = None , relValue : float = None ) :
  if 74 - 74: I11iiIi11i1I . I1I * iI1iII1I1I1i . I1I
  if 84 - 84: oOO * Ii . OooOoo
  if 19 - 19: ooOOO - IiIIii11Ii / IIiIIiIi11I1 % OooOoo * i1iiIII111 . i1iiIII111
  if 38 - 38: i1I / IIiIIiIi11I1 % Oo % IiI11Ii111 * OooOoo
  if 9 - 9: ooOOO - oOO % ooOOO
  if 58 - 58: Iii1i - I1Ii1I1 + i1I
  if 32 - 32: IIiIIiIi11I1 . oOO * IIiIIiIi11I1 + I1Ii1I1
  if 11 - 11: i1i1i1111I - I1Ii1I1 - IIiIIiIi11I1
  if 44 - 44: ooOOO . OooOoo + I1Ii1I1 % iI1iII1I1I1i - Ooo0Ooo
  if 80 - 80: IiI11Ii111 % i1I - I11iiIi11i1I % IIiIIiIi11I1 - i1iiIII111
  if 38 - 38: I11iiIi11i1I + iI1iII1I1I1i + oOo0O00
  if 9 - 9: Iii1i + Oo
  if 79 - 79: i1I * I1I
  if 54 - 54: i1iiIII111
  super ( ) . __init__ ( oOO0o00oOOo00 . Types . Normalize , colSel )
  if 4 - 4: OooOoo
  if 36 - 36: oOo0O00 + IiI11Ii111 - Ooo0Ooo / IiIIii11Ii * Ooo0Ooo
  self . _requirePreExtraction = True
  if 16 - 16: IiIIii11Ii
  if 53 - 53: OooOoo - OooOoo * i1 * iI1iII1I1I1i . Iii1i
  self . scaleType = scaleType
  if 85 - 85: IiI11Ii111 + I11iiIi11i1I + i1iiIII111 . i1
  if 14 - 14: OooOoo . OooOoo * oOo0O00 - i1
  self . range = ( rangeMax - rangeMin ) if ( rangeMin is not None and rangeMax is not None ) else None
  if 32 - 32: I1I
  if 57 - 57: IIiIIiIi11I1 / oOO . I1Ii1I1 - oOo0O00 + IiIIii11Ii - Ooo0Ooo
  self . relValue = relValue
  if 25 - 25: Oo
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 17 - 17: I1I . Iii1i % oOO - oOO / oOO - Ii
  if 51 - 51: i1iiIII111 . oOo0O00 * IiI11Ii111 + I11iiIi11i1I
  if 43 - 43: ooo000 - IiIIii11Ii / i1iiIII111 - oOo0O00 * i1i1i1111I
  if 67 - 67: I1Ii1I1
  if 81 - 81: I11iiIi11i1I * i1iiIII111 / i1i1i1111I / I11iiIi11i1I / oOO
  if 49 - 49: Ii % IiI11Ii111 + ooo000 + i1I
  if 92 - 92: oOo0O00 % oOO / I1Ii1I1 % oOO * oOo0O00
  if 58 - 58: i1iiIII111
  if 20 - 20: i1
  if 11 - 11: I1Ii1I1 / oOO % iI1iII1I1I1i % I1Ii1I1 . I1Ii1I1 / Iii1i
  if 27 - 27: I11iiIi11i1I - oOo0O00 - iI1iII1I1I1i / IIiIIiIi11I1
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "scaleType" :
    setattr ( self , Ii1I , OOO0o0OOo0o . Methods . parse ( iiiiIi1IiiIi ) )
   elif Ii1I not in [ "_instanceClass" , "_method" , "dppNodes" , "colConfigs" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 70 - 70: Ooo0Ooo / i1iiIII111 % IIiIIiIi11I1 / OooOoo
 @ property
 def requirePreExtraction ( self ) -> bool :
  if 68 - 68: ooo000 * i1 . Iii1i / I11iiIi11i1I
  if 62 - 62: i1 % iI1iII1I1I1i + Iii1i . Ooo0Ooo
  if 24 - 24: i1 % ooOOO / IiIIii11Ii * IiIIii11Ii * i1 - i1iiIII111
  if 55 - 55: OooOoo / iI1iII1I1I1i
  if 64 - 64: Ii * ooOOO . I1I + I11iiIi11i1I + i1I + IIiIIiIi11I1
  if 28 - 28: OooOoo
  if 100 - 100: OooOoo / oOO / iI1iII1I1I1i + Iii1i
  if 40 - 40: ooOOO / OooOoo . i1iiIII111 + oOo0O00 + I11iiIi11i1I - IiI11Ii111
  if 93 - 93: i1 * iI1iII1I1I1i % Ii - Oo + Ooo0Ooo . IIiIIiIi11I1
  if 72 - 72: IiIIii11Ii . Ooo0Ooo % oOo0O00 * iI1iII1I1I1i - i1
  return False if self . scaleType == self . Methods . RelativeToRange else True
  if 68 - 68: ooo000 + Iii1i % ooOOO + I11iiIi11i1I
 def preExtract ( self , preFetchedColumns : 'np.ndarray' ) :
  if 86 - 86: Ooo0Ooo * i1 - I1I
  if 24 - 24: IiI11Ii111 / I1Ii1I1 . oOO + i1iiIII111 % oOO + iI1iII1I1I1i
  if 89 - 89: Iii1i . Ooo0Ooo * i1 / IiI11Ii111
  if 34 - 34: i1I % ooOOO * I1Ii1I1
  if 54 - 54: IIiIIiIi11I1 . Iii1i - oOO
  if 77 - 77: Ii / OooOoo . Ii
  if 29 - 29: I11iiIi11i1I % Iii1i
  if 89 - 89: i1
  if 93 - 93: i1i1i1111I - OooOoo - i1 % IiIIii11Ii / Ooo0Ooo
  if 71 - 71: i1iiIII111 . i1i1i1111I % oOO . Iii1i * Oo
  if 47 - 47: iI1iII1I1I1i / ooOOO
  IIii11II = preFetchedColumns [ ... , OoOo0000o . toIndexer ( self . colSel ) ]
  if 22 - 22: i1i1i1111I - ooo000 + IiI11Ii111 + IiI11Ii111 - IiIIii11Ii
  if 60 - 60: oOo0O00 % IIiIIiIi11I1 + i1I + IiI11Ii111 + IiIIii11Ii % IiIIii11Ii
  iIi1iII11I = np . max ( IIii11II )
  O0Ooo = np . min ( IIii11II )
  if 4 - 4: i1 + ooo000 * OooOoo
  if 73 - 73: i1i1i1111I * Oo - I11iiIi11i1I + oOo0O00 + oOO . i1
  if self . scaleType == self . Methods . MinMax :
   if 80 - 80: i1iiIII111 / IiIIii11Ii / OooOoo
   self . range = iIi1iII11I - O0Ooo
   self . relValue = O0Ooo
  elif self . scaleType == self . Methods . RelativeToZero :
   if 8 - 8: I11iiIi11i1I * I11iiIi11i1I * i1i1i1111I / ooo000
   self . range = max ( [ 0 , iIi1iII11I ] ) - min ( [ 0 , O0Ooo ] )
   self . relValue = 0
  elif self . scaleType == self . Methods . RelativeToMean :
   if 84 - 84: i1i1i1111I . I1Ii1I1 % i1i1i1111I
   self . range = iIi1iII11I - O0Ooo
   self . relValue = np . sum ( IIii11II ) / len ( IIii11II )
   if 39 - 39: oOo0O00 - oOo0O00 * i1iiIII111
   if 20 - 20: I1I
  self . _cachedPrefetch = True
  if 6 - 6: IIiIIiIi11I1 / ooo000 * ooOOO % I1I - I11iiIi11i1I . oOO
 def transformTo ( self , val : float ) -> float :
  if 19 - 19: I1I . IiIIii11Ii * i1
  if 23 - 23: I1Ii1I1 . oOo0O00 * Iii1i + I1Ii1I1 * I1I % Ooo0Ooo
  if 30 - 30: Iii1i * ooOOO % i1i1i1111I
  if 23 - 23: oOO . IiIIii11Ii . I1Ii1I1 * IIiIIiIi11I1 + i1iiIII111 % i1I
  if 73 - 73: Iii1i
  if 37 - 37: ooOOO % OooOoo . i1 * OooOoo
  if 42 - 42: Iii1i - oOO . IiI11Ii111
  if 12 - 12: I1I
  if 39 - 39: i1 * I11iiIi11i1I + IiIIii11Ii * i1i1i1111I - I1I / IiI11Ii111
  if 99 - 99: Ooo0Ooo % I1Ii1I1 * Ooo0Ooo - Ooo0Ooo % I1Ii1I1 . IIiIIiIi11I1
  if 31 - 31: Oo / OooOoo . Iii1i
  if 99 - 99: i1i1i1111I % I1I
  if 65 - 65: i1
  return ( float ( val ) - self . relValue ) / self . range
  if 6 - 6: oOo0O00
 def transformFrom ( self , val : float ) -> float :
  if 76 - 76: Ii % IiI11Ii111 / I11iiIi11i1I
  if 78 - 78: oOO
  if 70 - 70: i1i1i1111I % ooo000 % Ooo0Ooo * IiIIii11Ii + I1I / Oo
  if 74 - 74: i1I
  if 76 - 76: I11iiIi11i1I
  if 20 - 20: I1I
  if 25 - 25: oOO - I1I * Oo
  if 57 - 57: Ooo0Ooo / ooo000
  if 63 - 63: oOo0O00
  if 92 - 92: IIiIIiIi11I1 . Iii1i . I1I * oOO * i1i1i1111I % IiI11Ii111
  if 15 - 15: oOo0O00 - i1iiIII111 . Oo . I1I / I1Ii1I1
  if 3 - 3: ooOOO + i1I
  if 48 - 48: IIiIIiIi11I1 . ooOOO . IIiIIiIi11I1 % ooo000
  if 45 - 45: IIiIIiIi11I1
  return val * self . range + self . relValue
  if 59 - 59: OooOoo * iI1iII1I1I1i + OooOoo
class i1iiIii1 ( oo0OOOOOO0o00 ) :
 if 64 - 64: i1i1i1111I % Ii . iI1iII1I1I1i + I1I . IiI11Ii111 % ooo000
 if 99 - 99: Ooo0Ooo . ooo000
 if 60 - 60: Iii1i
 if 45 - 45: ooOOO % IiI11Ii111 - ooo000 - IiI11Ii111 * i1
 if 92 - 92: I1I / iI1iII1I1I1i
 if 8 - 8: IIiIIiIi11I1
 if 14 - 14: i1iiIII111 * Iii1i % i1I . i1i1i1111I - Ii + oOO
 def __init__ ( self , colSel : str = "None:None" , base : float = math . e ) :
  if 54 - 54: I1Ii1I1 / I1I
  if 39 - 39: ooo000 . i1iiIII111
  if 69 - 69: oOo0O00 + oOO * I11iiIi11i1I * oOO
  if 25 - 25: I1Ii1I1 * iI1iII1I1I1i / IiI11Ii111 + Iii1i * i1I
  if 64 - 64: I11iiIi11i1I / i1iiIII111
  if 70 - 70: IiIIii11Ii / i1iiIII111 % ooOOO * i1iiIII111 + I1I . IiI11Ii111
  if 99 - 99: i1I
  if 54 - 54: I1I
  if 40 - 40: i1 / IIiIIiIi11I1 - oOO % oOO / IIiIIiIi11I1
  if 26 - 26: I1I % i1 / Iii1i % Ii
  super ( ) . __init__ ( oOO0o00oOOo00 . Types . Log , colSel )
  if 34 - 34: Ooo0Ooo / iI1iII1I1I1i + I11iiIi11i1I + Ooo0Ooo + ooOOO - I11iiIi11i1I
  if 56 - 56: ooOOO - ooo000 . IIiIIiIi11I1 / OooOoo . ooo000 . i1
  self . base = base
  if 14 - 14: IiIIii11Ii + i1I / IIiIIiIi11I1 - ooo000
 def transformTo ( self , val : float ) -> float :
  if 5 - 5: ooOOO
  if 46 - 46: Iii1i + Oo % ooOOO . i1i1i1111I + IiIIii11Ii
  if 57 - 57: Oo % oOo0O00
  if 92 - 92: ooo000 * i1i1i1111I
  if 10 - 10: ooo000 % Oo . ooo000 + Iii1i
  if 26 - 26: i1i1i1111I . IiI11Ii111 % ooo000 / Iii1i
  if 43 - 43: ooOOO + IiIIii11Ii - ooOOO
  if 23 - 23: I11iiIi11i1I - ooo000 / ooOOO % IIiIIiIi11I1 / i1i1i1111I - ooOOO
  if 4 - 4: ooOOO + i1iiIII111
  if 36 - 36: IiIIii11Ii % Ooo0Ooo * Ooo0Ooo
  if 4 - 4: i1
  if 1 - 1: i1i1i1111I
  if 77 - 77: OooOoo * IIiIIiIi11I1 / i1 / I11iiIi11i1I
  return math . log ( max ( [ float ( val ) , 0 ] ) , self . base )
  if 49 - 49: ooOOO - OooOoo * Oo * iI1iII1I1I1i * I1I
 def transformFrom ( self , val : float ) -> float :
  if 50 - 50: oOO / Ii + i1iiIII111 % iI1iII1I1I1i * Iii1i
  if 75 - 75: Iii1i + IiI11Ii111
  if 74 - 74: Ooo0Ooo
  if 88 - 88: oOO . i1i1i1111I . I1I
  if 53 - 53: Iii1i + ooOOO / ooOOO % ooOOO % IIiIIiIi11I1 / iI1iII1I1I1i
  if 5 - 5: Ooo0Ooo
  if 23 - 23: i1iiIII111 % i1I * Oo + oOo0O00
  if 24 - 24: ooOOO + IiI11Ii111 + ooo000 * i1I - i1iiIII111
  if 38 - 38: IIiIIiIi11I1 . IiIIii11Ii
  if 56 - 56: i1iiIII111 - I1Ii1I1
  if 65 - 65: Iii1i
  if 15 - 15: i1i1i1111I * iI1iII1I1I1i * ooOOO / oOo0O00
  if 60 - 60: oOo0O00 * i1iiIII111 * I1Ii1I1 % i1iiIII111 / Oo
  return self . base ** val
  if 53 - 53: oOO / I1Ii1I1 / ooOOO - I11iiIi11i1I * IIiIIiIi11I1 % i1i1i1111I
class iIi ( oo0OOOOOO0o00 ) :
 if 60 - 60: OooOoo . IiI11Ii111 * i1iiIII111 + ooo000 - i1i1i1111I
 if 95 - 95: Ii / i1I + oOO + i1i1i1111I + oOo0O00 * I1Ii1I1
 if 81 - 81: i1 * IiIIii11Ii + oOO / I1I / I1Ii1I1 - oOO
 if 61 - 61: ooo000 + IIiIIiIi11I1 * oOO % I1I . OooOoo . Ooo0Ooo
 if 42 - 42: iI1iII1I1I1i + IIiIIiIi11I1 * i1i1i1111I . i1iiIII111
 if 67 - 67: i1i1i1111I / iI1iII1I1I1i % I11iiIi11i1I . ooOOO % i1i1i1111I
 if 93 - 93: IIiIIiIi11I1
 def __init__ ( self , colSel : str = "None:None" ) :
  if 94 - 94: Oo . Oo - oOo0O00 . ooOOO - ooOOO
  if 49 - 49: i1i1i1111I * i1I . i1 % i1I . IiIIii11Ii - oOo0O00
  if 23 - 23: IIiIIiIi11I1 + I11iiIi11i1I / i1iiIII111 % I1Ii1I1 * IIiIIiIi11I1 / IIiIIiIi11I1
  if 38 - 38: IIiIIiIi11I1 * Iii1i - IIiIIiIi11I1 . oOO % Oo
  if 81 - 81: i1 + I1Ii1I1
  if 43 - 43: I1Ii1I1
  if 12 - 12: oOO * oOO . I1Ii1I1 / IIiIIiIi11I1 - i1I % Ii
  super ( ) . __init__ ( oOO0o00oOOo00 . Types . Exponential , colSel )
  if 79 - 79: ooo000 * Iii1i - oOO / Ooo0Ooo
 def transformTo ( self , val : float ) -> float :
  if 47 - 47: oOO / i1I / IiIIii11Ii * i1i1i1111I - oOo0O00 - ooo000
  if 98 - 98: OooOoo % Iii1i . I1I . IIiIIiIi11I1 * i1I . Iii1i
  if 58 - 58: i1
  if 63 - 63: I11iiIi11i1I . I11iiIi11i1I * Ooo0Ooo * Ooo0Ooo * i1I
  if 29 - 29: IIiIIiIi11I1 . Ii
  if 74 - 74: ooOOO / ooOOO % OooOoo % Ooo0Ooo * IIiIIiIi11I1
  if 93 - 93: iI1iII1I1I1i % I1Ii1I1 - IiI11Ii111
  if 53 - 53: IIiIIiIi11I1 . ooOOO + i1iiIII111
  if 51 - 51: OooOoo - IIiIIiIi11I1 - ooo000
  if 47 - 47: i1i1i1111I + I11iiIi11i1I % I11iiIi11i1I / iI1iII1I1I1i . ooOOO % IIiIIiIi11I1
  if 62 - 62: Iii1i + I1I . i1iiIII111 + OooOoo / Ii
  if 24 - 24: ooo000 / i1 % I1I . OooOoo
  if 96 - 96: ooOOO * I1Ii1I1 + iI1iII1I1I1i + i1
  return math . e ** float ( val )
  if 31 - 31: IiI11Ii111
 def transformFrom ( self , val : float ) -> float :
  if 92 - 92: iI1iII1I1I1i
  if 97 - 97: ooo000 . i1iiIII111 / i1i1i1111I
  if 56 - 56: OooOoo + OooOoo * iI1iII1I1I1i + IIiIIiIi11I1 - IiIIii11Ii
  if 16 - 16: oOO + I1I
  if 62 - 62: i1I % Ii . IiIIii11Ii * ooo000 / Ooo0Ooo * IiI11Ii111
  if 27 - 27: IIiIIiIi11I1 / Ooo0Ooo
  if 30 - 30: OooOoo + OooOoo
  if 69 - 69: ooo000 * I11iiIi11i1I / i1
  if 60 - 60: IIiIIiIi11I1 / I1Ii1I1
  if 24 - 24: I1I % Ii . i1
  if 30 - 30: Ii - oOO . i1I * OooOoo + I1I * ooOOO
  if 5 - 5: iI1iII1I1I1i * Iii1i
  if 35 - 35: i1 / I1I
  return math . log ( max ( [ val , 0 ] ) )
  if 88 - 88: oOO
class II1iiI1 ( oo0OOOOOO0o00 ) :
 if 63 - 63: Iii1i * iI1iII1I1I1i + iI1iII1I1I1i / i1I . I11iiIi11i1I
 if 91 - 91: IiIIii11Ii * Oo * Ooo0Ooo - ooo000 % Iii1i % ooo000
 if 38 - 38: IiIIii11Ii * oOo0O00 + OooOoo
 if 13 - 13: oOO - iI1iII1I1I1i / IiI11Ii111
 if 86 - 86: oOo0O00 - Iii1i
 if 42 - 42: OooOoo * iI1iII1I1I1i
 if 26 - 26: Ooo0Ooo % I11iiIi11i1I % IiI11Ii111 + ooOOO / OooOoo * I11iiIi11i1I
 def __init__ ( self , colSel : str = "None:None" , exponent : float = 1 ) :
  if 72 - 72: i1I * Ii
  if 29 - 29: IiI11Ii111 - iI1iII1I1I1i % I11iiIi11i1I * I1I / i1i1i1111I
  if 89 - 89: i1 . Oo / IiI11Ii111
  if 66 - 66: Ooo0Ooo % IiIIii11Ii + i1i1i1111I
  if 88 - 88: Iii1i * i1iiIII111 / ooo000 . Ooo0Ooo - I11iiIi11i1I * ooo000
  if 82 - 82: ooo000 . iI1iII1I1I1i * oOo0O00 / Ooo0Ooo - i1i1i1111I - oOo0O00
  if 73 - 73: oOO * i1 - oOO / IiIIii11Ii % IiI11Ii111
  if 12 - 12: i1 . i1iiIII111 % oOo0O00 / IIiIIiIi11I1 / I1Ii1I1 - OooOoo
  if 14 - 14: i1I + i1 - iI1iII1I1I1i
  if 38 - 38: Ooo0Ooo % i1
  super ( ) . __init__ ( oOO0o00oOOo00 . Types . Power , colSel )
  if 77 - 77: IiI11Ii111 + IiI11Ii111 + Iii1i + oOO / i1I
  if 45 - 45: oOo0O00 * IiIIii11Ii - Ooo0Ooo
  self . exponent = exponent
  if 100 - 100: IiIIii11Ii * i1i1i1111I / Ii - IIiIIiIi11I1 % Ii / Ii
 def transformTo ( self , val : float ) -> float :
  if 20 - 20: Iii1i . OooOoo * iI1iII1I1I1i * ooo000 / ooo000 * i1
  if 88 - 88: IiIIii11Ii / ooo000 * iI1iII1I1I1i * I1Ii1I1 / I1I / oOo0O00
  if 65 - 65: i1I + IiI11Ii111 / Ooo0Ooo . ooo000
  if 1 - 1: i1I
  if 16 - 16: IiI11Ii111
  if 2 - 2: I11iiIi11i1I % ooo000 - Iii1i
  if 96 - 96: OooOoo / oOo0O00 - iI1iII1I1I1i + oOO
  if 74 - 74: I1I * IIiIIiIi11I1 * IiIIii11Ii % IiIIii11Ii % ooOOO * i1i1i1111I
  if 62 - 62: IiI11Ii111 . Iii1i * I1I % IIiIIiIi11I1
  if 13 - 13: IiIIii11Ii + oOO * Iii1i . oOo0O00
  if 45 - 45: ooOOO / Ooo0Ooo - oOo0O00 % ooOOO
  if 64 - 64: i1 * oOO
  if 57 - 57: i1iiIII111 . I11iiIi11i1I / Iii1i % i1iiIII111 * ooo000
  return ( float ( val ) ** self . exponent ) if self . exponent % 1 == 0 else ( max ( [ val , 0 ] ) ** self . exponent )
  if 56 - 56: oOO . iI1iII1I1I1i / oOO
 def transformFrom ( self , val : float ) -> float :
  if 39 - 39: iI1iII1I1I1i - i1I . oOO % i1 % ooOOO - i1
  if 34 - 34: IiI11Ii111 . I11iiIi11i1I - i1iiIII111
  if 80 - 80: Ii % ooo000
  if 21 - 21: Ii + i1 / I11iiIi11i1I . i1I % ooo000 * ooOOO
  if 51 - 51: I1Ii1I1 * i1 + i1 + ooOOO + I11iiIi11i1I
  if 52 - 52: I1Ii1I1 + I1Ii1I1 . IiIIii11Ii . Ii - i1
  if 65 - 65: Iii1i . oOO % I1I . i1iiIII111
  if 40 - 40: oOo0O00 % Ooo0Ooo - oOo0O00 . i1I
  if 8 - 8: ooo000 - ooOOO
  if 57 - 57: Ooo0Ooo - i1I * Oo
  if 85 - 85: Ooo0Ooo . I1Ii1I1 . Oo / Ii + i1I / ooo000
  if 90 - 90: oOO + I11iiIi11i1I - i1i1i1111I
  if 82 - 82: Ii * oOo0O00 . i1iiIII111 . IiI11Ii111 % i1
  return max ( [ val , 0 ] ) ** ( 1 / self . exponent )
  if 28 - 28: OooOoo + oOO
class OoI1iii1I ( oo0OOOOOO0o00 ) :
 if 62 - 62: Iii1i % Oo
 if 4 - 4: I1Ii1I1
 if 38 - 38: Oo - i1i1i1111I % IiIIii11Ii
 if 72 - 72: ooo000
 if 96 - 96: IiI11Ii111 . IiI11Ii111 + i1I % I1I . IiIIii11Ii - Ii
 if 46 - 46: i1I . i1I . i1
 if 74 - 74: iI1iII1I1I1i % I11iiIi11i1I . IIiIIiIi11I1 - i1i1i1111I
 def __init__ ( self , colSel : str = "None:None" ) :
  if 62 - 62: oOO
  if 2 - 2: IiI11Ii111 + IiI11Ii111 / I1Ii1I1 / IiIIii11Ii % IIiIIiIi11I1 . Oo
  if 77 - 77: OooOoo . i1 % OooOoo / i1i1i1111I
  if 98 - 98: i1I + IiIIii11Ii
  if 21 - 21: i1I . ooOOO
  if 6 - 6: I1I . i1i1i1111I - IIiIIiIi11I1 - I11iiIi11i1I + IiIIii11Ii % ooo000
  if 20 - 20: ooOOO - Iii1i % ooo000 - i1i1i1111I . I1Ii1I1 * Ooo0Ooo
  super ( ) . __init__ ( oOO0o00oOOo00 . Types . Classify , colSel )
  if 95 - 95: Ii * i1
  if 8 - 8: IiIIii11Ii % Ooo0Ooo . IIiIIiIi11I1 + i1i1i1111I
  self . _requirePreExtraction = True
  if 22 - 22: Oo
  if 71 - 71: i1i1i1111I . i1i1i1111I % OooOoo . i1
  self . valueList = { }
  if 87 - 87: i1 % Ii / i1iiIII111 / i1I + I11iiIi11i1I
  if 99 - 99: OooOoo % Ooo0Ooo . i1 / Oo
  self . _valueListReversed = { }
  if 37 - 37: IiI11Ii111 + oOO - I11iiIi11i1I * IiI11Ii111 * Iii1i . i1I
 @ property
 def valueListReversed ( self ) :
  if 91 - 91: Oo * ooo000 % Ii % oOo0O00
  if 46 - 46: IiIIii11Ii
  if 21 - 21: i1i1i1111I
  if 19 - 19: I1I
  if 55 - 55: I11iiIi11i1I
  if 16 - 16: Oo + oOO * ooOOO . ooOOO
  if 96 - 96: oOO . i1i1i1111I * IiI11Ii111 * IIiIIiIi11I1
  return self . _valueListReversed
  if 14 - 14: oOO . ooOOO / Ooo0Ooo
 def preExtract ( self , preFetchedColumns : 'np.ndarray' ) :
  if 73 - 73: ooOOO + IiIIii11Ii % Iii1i
  if 52 - 52: i1I
  if 88 - 88: I11iiIi11i1I + Ooo0Ooo . iI1iII1I1I1i / i1iiIII111 + Ooo0Ooo - IiI11Ii111
  if 72 - 72: IiI11Ii111 * oOO
  if 45 - 45: Ii * ooOOO - IiI11Ii111 / i1i1i1111I + oOo0O00
  if 19 - 19: Iii1i % IiI11Ii111 + iI1iII1I1I1i + iI1iII1I1I1i * I1Ii1I1 - i1iiIII111
  if 25 - 25: oOO * iI1iII1I1I1i + ooo000 - i1i1i1111I % IiIIii11Ii % I1I
  if 6 - 6: ooo000
  if 37 - 37: I11iiIi11i1I / ooo000 * IIiIIiIi11I1 . oOo0O00
  if 87 - 87: I11iiIi11i1I - i1I + OooOoo . ooo000 * IiI11Ii111 / iI1iII1I1I1i
  if 50 - 50: Oo
  if 98 - 98: OooOoo - oOO * Ooo0Ooo - Iii1i
  if 99 - 99: IiI11Ii111 + I11iiIi11i1I
  IIii11II = np . reshape ( preFetchedColumns [ ... , OoOo0000o . toIndexer ( self . colSel ) ] , [ - 1 ] )
  if 17 - 17: oOO - Ooo0Ooo % IIiIIiIi11I1
  if 84 - 84: Oo
  self . valueList = o0ooo0oOoO . convertCatToNumbers ( IIii11II ) [ "dict" ]
  if 51 - 51: I1Ii1I1 - IIiIIiIi11I1 - oOo0O00
  if 6 - 6: IiIIii11Ii . IIiIIiIi11I1
  self . _valueListReversed = { v : k for ( k , v ) in self . valueList . items ( ) }
  if 17 - 17: OooOoo . i1iiIII111
  if 19 - 19: I1I / OooOoo + i1iiIII111
  self . _cachedPrefetch = True
  if 96 - 96: Iii1i . i1iiIII111 % I11iiIi11i1I * IiI11Ii111
 def transformTo ( self , val : float ) -> float :
  if 40 - 40: i1i1i1111I - I1Ii1I1 - IiIIii11Ii . i1iiIII111 . OooOoo
  if 2 - 2: i1 + I1I + I1I . Oo * ooOOO % IiIIii11Ii
  if 53 - 53: i1iiIII111
  if 79 - 79: oOo0O00 / OooOoo * OooOoo / Oo / Iii1i
  if 78 - 78: OooOoo
  if 75 - 75: i1 + Oo * ooOOO
  if 90 - 90: ooOOO . oOO . I11iiIi11i1I - ooOOO / I1I * iI1iII1I1I1i
  if 62 - 62: OooOoo % oOo0O00 * OooOoo . Oo . Ooo0Ooo
  if 68 - 68: i1i1i1111I / I1I
  if 63 - 63: I11iiIi11i1I % I11iiIi11i1I . Iii1i . i1I . ooo000
  if 20 - 20: Ooo0Ooo / iI1iII1I1I1i + I11iiIi11i1I
  if 99 - 99: I1I - i1iiIII111 * I11iiIi11i1I + iI1iII1I1I1i - oOo0O00
  if 100 - 100: Ooo0Ooo / oOo0O00 / I11iiIi11i1I
  return self . valueList [ val ]
  if 67 - 67: I1I / IIiIIiIi11I1 * OooOoo * oOo0O00 + oOo0O00
 def transformFrom ( self , val : float ) -> str :
  if 96 - 96: i1iiIII111 / I1I
  if 42 - 42: i1i1i1111I
  if 60 - 60: oOO * oOO / i1iiIII111 . i1 . ooOOO
  if 44 - 44: oOO / I11iiIi11i1I * I1Ii1I1
  if 66 - 66: Iii1i / iI1iII1I1I1i + IIiIIiIi11I1 - Ooo0Ooo
  if 49 - 49: Ii * OooOoo % oOO % IIiIIiIi11I1
  if 39 - 39: I11iiIi11i1I * i1i1i1111I - OooOoo
  if 8 - 8: i1iiIII111 - i1i1i1111I / I1I * ooo000 * IiIIii11Ii % IiI11Ii111
  if 25 - 25: IiIIii11Ii
  if 100 - 100: ooo000 / Oo / Ii * oOo0O00 - i1i1i1111I * ooOOO
  if 34 - 34: Oo . Iii1i
  if 50 - 50: ooOOO
  if 37 - 37: i1I / ooo000 % oOo0O00
  return self . valueListReversed [ val ]
  if 46 - 46: oOo0O00 - I1I + i1i1i1111I / IiI11Ii111 % Oo - Oo
class ooO0O ( oo0OOOOOO0o00 ) :
 if 22 - 22: IiI11Ii111 - Iii1i - Iii1i . I1I . oOo0O00
 if 29 - 29: IiI11Ii111 + IIiIIiIi11I1 % IiIIii11Ii
 if 95 - 95: IiIIii11Ii % Ooo0Ooo % i1i1i1111I * I11iiIi11i1I * I11iiIi11i1I % i1i1i1111I
 if 61 - 61: Ii - OooOoo * IiIIii11Ii . i1I % OooOoo
 if 64 - 64: I1I + Ooo0Ooo - I11iiIi11i1I / IIiIIiIi11I1 / oOo0O00
 if 75 - 75: I1I
 if 28 - 28: I1Ii1I1
 class Methods ( II1i1I ) :
  if 22 - 22: IiI11Ii111 / i1iiIII111
  if 34 - 34: iI1iII1I1I1i . oOo0O00 . I1I - Oo * oOo0O00
  if 94 - 94: I1I % oOO - oOo0O00 - IIiIIiIi11I1 - IIiIIiIi11I1 * ooOOO
  if 1 - 1: i1 . ooo000 - IiIIii11Ii - ooo000
  if 2 - 2: iI1iII1I1I1i
  if 49 - 49: I1Ii1I1 / OooOoo % I1Ii1I1 . oOO * Oo / i1I
  if 28 - 28: oOO - IIiIIiIi11I1 / ooOOO % OooOoo - Ooo0Ooo
  if 34 - 34: IiI11Ii111 / I1I / oOo0O00 . IiIIii11Ii * i1I * Ooo0Ooo
  Auto = 0
  if 73 - 73: Ii * ooo000
  if 52 - 52: Ii - oOO + i1 + I1Ii1I1 . ooOOO / ooOOO
  Mode = 1
  if 27 - 27: ooOOO % oOO % i1i1i1111I
  if 15 - 15: oOo0O00 * IiIIii11Ii - OooOoo . I1Ii1I1 + Oo
  Delete = 2
  if 4 - 4: i1 * oOO - i1i1i1111I * IIiIIiIi11I1
 def __init__ ( self , handleType : 'DataPreprocessing.Transformation.Columns.MissingData.Methods' ) :
  if 97 - 97: oOo0O00 . i1 % ooOOO - I11iiIi11i1I * i1i1i1111I . Ooo0Ooo
  if 94 - 94: IiIIii11Ii % oOO + IiIIii11Ii
  if 74 - 74: i1i1i1111I / i1 % IIiIIiIi11I1
  if 74 - 74: I1I . Ooo0Ooo
  if 25 - 25: i1iiIII111 - IIiIIiIi11I1 % IIiIIiIi11I1 / iI1iII1I1I1i - I11iiIi11i1I - IIiIIiIi11I1
  if 61 - 61: i1I + IiIIii11Ii / Ooo0Ooo % i1i1i1111I
  if 27 - 27: IIiIIiIi11I1 . IiI11Ii111 + i1i1i1111I
  if 75 - 75: oOO / oOO . oOO
  if 39 - 39: IIiIIiIi11I1 - OooOoo
  if 25 - 25: IiI11Ii111 % Iii1i
  super ( ) . __init__ ( oOO0o00oOOo00 . Types . MissingData , True )
  if 87 - 87: Oo - Iii1i + Oo . i1i1i1111I
  if 11 - 11: Oo % i1iiIII111
  self . _requirePreExtraction = True
  if 40 - 40: oOo0O00 . I1Ii1I1 + I1I * ooOOO - IIiIIiIi11I1
  if 80 - 80: ooOOO . i1I
  self . _handleType = handleType
  if 78 - 78: i1i1i1111I
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 1 - 1: ooo000 % ooo000 . iI1iII1I1I1i + IiI11Ii111 * oOo0O00 . IiI11Ii111
  if 74 - 74: i1iiIII111
  if 62 - 62: Iii1i % ooo000
  if 59 - 59: ooo000 % i1 - iI1iII1I1I1i - Ii / i1I
  if 87 - 87: Ii . I1I / I1Ii1I1 - Ooo0Ooo
  if 40 - 40: I1Ii1I1 * Ii
  if 47 - 47: i1I - iI1iII1I1I1i % ooOOO / IiI11Ii111 + IIiIIiIi11I1
  if 14 - 14: IiIIii11Ii * iI1iII1I1I1i + I1I % IIiIIiIi11I1 / Iii1i - Oo
  if 15 - 15: oOo0O00 + IiI11Ii111 * iI1iII1I1I1i . IIiIIiIi11I1 * I1Ii1I1 / Ooo0Ooo
  if 1 - 1: I11iiIi11i1I - Ooo0Ooo + oOO % oOO * oOO
  if 54 - 54: Ii
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "_handleType" :
    setattr ( self , Ii1I , ooO0O . Methods . parse ( iiiiIi1IiiIi ) )
   elif Ii1I not in [ "_instanceClass" , "_method" , "dppNodes" , "colConfigs" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 97 - 97: IiI11Ii111 + I1I - I11iiIi11i1I + IIiIIiIi11I1 - i1I
 @ property
 def handleType ( self ) -> 'DataPreprocessing.Transformation.Columns.MissingData.Methods' :
  if 38 - 38: I1I * Ooo0Ooo
  if 36 - 36: Ii - ooo000 / I1I
  if 20 - 20: IIiIIiIi11I1 - Ooo0Ooo * IiI11Ii111 + ooo000
  if 34 - 34: I11iiIi11i1I + ooo000 - IiI11Ii111 - i1I + ooOOO * iI1iII1I1I1i
  if 96 - 96: IiIIii11Ii
  if 46 - 46: i1 * iI1iII1I1I1i + i1iiIII111 + Ii * OooOoo * ooOOO
  if 4 - 4: iI1iII1I1I1i / I1Ii1I1 - IiI11Ii111
  if 83 - 83: oOO
  if 93 - 93: I11iiIi11i1I * ooo000 % i1iiIII111
  if 30 - 30: ooOOO % Iii1i + iI1iII1I1I1i / ooOOO + Ii % IIiIIiIi11I1
  return self . _handleType
  if 68 - 68: IiIIii11Ii
 @ handleType . setter
 def handleType ( self , value : 'DataPreprocessing.Transformation.Columns.MissingData.Methods' ) :
  if 30 - 30: I1I / oOO * ooo000 + I1I % I1Ii1I1
  if 93 - 93: i1 . IiI11Ii111 - oOo0O00 - I11iiIi11i1I * Ii
  if 90 - 90: IIiIIiIi11I1 . iI1iII1I1I1i / I1I
  if 8 - 8: IiIIii11Ii . ooo000 . I1I
  if 23 - 23: Iii1i + Oo + OooOoo . IiIIii11Ii - i1 % oOO
  if 58 - 58: Ooo0Ooo % I1I / ooo000 + ooOOO - Ooo0Ooo * ooOOO
  if 89 - 89: Ii - I1I / IIiIIiIi11I1 / I1I
  if 74 - 74: ooOOO - i1iiIII111 . OooOoo % i1I . oOo0O00
  if 9 - 9: i1i1i1111I
  if 3 - 3: IIiIIiIi11I1 * Ooo0Ooo
  self . _requirePreExtraction = False if ( value == self . Methods . Delete ) else True
  self . _handleType = value
  if 6 - 6: Oo % IiI11Ii111 * Oo + ooo000
 def preExtract ( self , preFetchedColumns : 'np.ndarray' ) :
  if 39 - 39: i1I + IIiIIiIi11I1 - IIiIIiIi11I1 % I11iiIi11i1I / I1I
  if 31 - 31: Ooo0Ooo
  if 12 - 12: I1I + iI1iII1I1I1i + IiIIii11Ii
  if 35 - 35: I11iiIi11i1I - I1I % Iii1i + I1Ii1I1 + Ii - I1Ii1I1
  if 98 - 98: ooo000 . IIiIIiIi11I1 % Ooo0Ooo + IIiIIiIi11I1
  if 8 - 8: oOO . Oo * IiI11Ii111 / I1Ii1I1
  if 31 - 31: Oo - i1I / OooOoo . IIiIIiIi11I1 / ooOOO - IiIIii11Ii
  if 77 - 77: I11iiIi11i1I % Oo + I1I * IIiIIiIi11I1 / I11iiIi11i1I - iI1iII1I1I1i
  if 2 - 2: I11iiIi11i1I * IIiIIiIi11I1 . i1I
  if 9 - 9: ooo000
  if 83 - 83: Iii1i . ooOOO - Ii
  IIii11II = np . reshape ( preFetchedColumns [ ... , OoOo0000o . toIndexer ( self . colSel ) ] , [ - 1 ] )
  if 64 - 64: iI1iII1I1I1i
  if 68 - 68: oOo0O00 % iI1iII1I1I1i
  if self . handleType == self . Methods . Auto :
   if np . issubdtype ( IIii11II . dtype , np . integer ) or np . issubdtype ( IIii11II . dtype , np . float64 ) :
    self . missingValue = IIii11II . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o + OoOo0o0oooO ) / len ( IIii11II )
   else :
    self . missingValue = stats . mode ( IIii11II , axis = None ) [ 0 ] [ 0 ]
  elif self . handleType == self . Methods . Mode :
   self . missingValue = stats . mode ( IIii11II , axis = None ) [ 0 ] [ 0 ]
   if 71 - 71: ooo000 / i1 + i1i1i1111I * IIiIIiIi11I1 - I11iiIi11i1I
   if 42 - 42: I11iiIi11i1I % ooOOO + Ii + oOO % i1I * i1iiIII111
  self . _cachedPrefetch = True
  if 96 - 96: Iii1i / I1Ii1I1 / Ii * IiIIii11Ii - Ooo0Ooo
 def transformTo ( self , val : float ) -> float :
  if 1 - 1: OooOoo + IiI11Ii111 - Ii % IiIIii11Ii . I1I / Ii
  if 17 - 17: IiI11Ii111 % ooo000 - i1 / IiI11Ii111 . I1Ii1I1
  if 32 - 32: IiIIii11Ii - Iii1i + i1
  if 4 - 4: i1I % IiIIii11Ii . Ii + I1Ii1I1
  if 88 - 88: I1Ii1I1 / Oo . IiI11Ii111 / IiIIii11Ii
  if 28 - 28: oOO
  if 42 - 42: Iii1i
  if 38 - 38: i1i1i1111I / oOO
  if 18 - 18: ooo000 . OooOoo % oOo0O00 . Oo % Ii * i1I
  if 31 - 31: IiIIii11Ii
  if 39 - 39: iI1iII1I1I1i + I11iiIi11i1I / iI1iII1I1I1i + IiI11Ii111 - iI1iII1I1I1i
  if 27 - 27: OooOoo % i1iiIII111 + i1iiIII111 * I11iiIi11i1I / Oo
  if 48 - 48: oOO
  return self . missingValue if ( val is None or str ( val ) . strip ( ) == "" ) else val
  if 21 - 21: I1I / OooOoo % ooOOO - OooOoo
class oOO0o00oOOo00 :
 if 76 - 76: I11iiIi11i1I . I1Ii1I1 + IiIIii11Ii
 if 47 - 47: Ooo0Ooo - I11iiIi11i1I % i1i1i1111I * i1iiIII111 + Ii % i1
 if 7 - 7: i1I . IiI11Ii111 - oOo0O00 + I11iiIi11i1I + iI1iII1I1I1i
 if 50 - 50: i1iiIII111
 if 2 - 2: I11iiIi11i1I + oOo0O00 % Oo % i1iiIII111 * Iii1i * I11iiIi11i1I
 if 74 - 74: ooOOO * oOo0O00
 if 53 - 53: Ii + i1iiIII111 / iI1iII1I1I1i . IiI11Ii111 - IiIIii11Ii + IiIIii11Ii
 class Types ( II1i1I ) :
  if 77 - 77: IiIIii11Ii / I11iiIi11i1I + i1i1i1111I % I11iiIi11i1I . OooOoo * OooOoo
  if 58 - 58: oOo0O00 + iI1iII1I1I1i - IIiIIiIi11I1 * IIiIIiIi11I1
  if 35 - 35: I1Ii1I1 % oOo0O00 + Oo
  if 17 - 17: iI1iII1I1I1i % OooOoo
  if 37 - 37: i1 % IiI11Ii111 - IiI11Ii111 - Iii1i . Ii - oOo0O00
  if 43 - 43: oOo0O00 % oOo0O00 % i1I
  if 89 - 89: iI1iII1I1I1i - Oo + Ooo0Ooo - I1I / i1I * i1iiIII111
  if 54 - 54: Oo - i1iiIII111 / i1I + i1iiIII111 / I1Ii1I1 . iI1iII1I1I1i
  Normalize = 1
  if 56 - 56: IiI11Ii111 + Iii1i * oOo0O00 - Oo
  Log = 2
  if 20 - 20: OooOoo - IIiIIiIi11I1
  Exponential = 3
  if 51 - 51: i1i1i1111I / IiIIii11Ii + Oo
  Classify = 4
  if 89 - 89: ooOOO / IIiIIiIi11I1 . Ii * i1iiIII111 . IiIIii11Ii + i1iiIII111
  Power = 5
  if 72 - 72: IiIIii11Ii + IiIIii11Ii
  MissingData = 6
  if 80 - 80: Ooo0Ooo + Oo / Ooo0Ooo
 Config = oo0OOOOOO0o00
 Normalize = OOO0o0OOo0o
 Log = i1iiIii1
 Exponential = iIi
 Classify = OoI1iii1I
 Power = II1iiI1
 MissingData = ooO0O
 if 72 - 72: I1I / IIiIIiIi11I1 + Ooo0Ooo * I11iiIi11i1I - oOO . IiI11Ii111
class o00oo0 ( ooo0 ) :
 if 54 - 54: oOo0O00 . i1i1i1111I / i1i1i1111I - i1iiIII111 + IIiIIiIi11I1 * oOO
 if 42 - 42: i1I . iI1iII1I1I1i
 if 75 - 75: ooo000 / oOO
 if 50 - 50: IiI11Ii111
 if 88 - 88: Ooo0Ooo . Ii
 if 68 - 68: I11iiIi11i1I % IiIIii11Ii % Iii1i * Ii . IiIIii11Ii
 if 48 - 48: IiI11Ii111 / i1i1i1111I . IiIIii11Ii . I1Ii1I1 / Ii
 def __init__ ( self , method : 'DataPreprocessing.Transformation.Image.Types' ) :
  if 21 - 21: Ii + IiI11Ii111 . I1I * i1
  if 91 - 91: Ooo0Ooo % i1
  if 64 - 64: I1Ii1I1 . i1 . oOO % iI1iII1I1I1i * I11iiIi11i1I
  if 22 - 22: oOO . IiI11Ii111 % I11iiIi11i1I / oOo0O00 + I11iiIi11i1I - Oo
  if 97 - 97: Ooo0Ooo - i1 - ooOOO * OooOoo
  if 95 - 95: oOO
  if 30 - 30: i1i1i1111I % oOo0O00 / I1Ii1I1
  if 96 - 96: oOo0O00 - ooOOO - Ooo0Ooo / oOo0O00
  if 36 - 36: ooOOO
  if 60 - 60: I1I % I1Ii1I1 * IiI11Ii111 - Ooo0Ooo - iI1iII1I1I1i / IiI11Ii111
  super ( ) . __init__ ( oOoOoo0oO0 . Image , method )
  if 84 - 84: i1i1i1111I % oOO * IIiIIiIi11I1
class O00oOO ( o00oo0 ) :
 if 68 - 68: i1i1i1111I * ooOOO + IiI11Ii111 - I1I
 if 73 - 73: i1iiIII111 * i1i1i1111I / i1iiIII111 + ooo000 - oOo0O00
 if 84 - 84: IiI11Ii111 / ooOOO
 if 2 - 2: ooo000 * i1I
 if 98 - 98: oOO
 if 73 - 73: i1I + ooo000 - I11iiIi11i1I - i1i1i1111I
 if 16 - 16: I1Ii1I1 % i1I / i1 / OooOoo * ooo000 + oOO
 def __init__ ( self ) :
  if 63 - 63: Ii / i1
  if 60 - 60: IIiIIiIi11I1 / oOO
  if 100 - 100: ooo000 . i1i1i1111I * I1I
  if 66 - 66: oOo0O00 - I11iiIi11i1I * IIiIIiIi11I1 + I11iiIi11i1I
  if 32 - 32: ooOOO
  if 43 - 43: ooo000 % i1iiIII111 * iI1iII1I1I1i
  if 85 - 85: IiIIii11Ii * I11iiIi11i1I - oOO - Iii1i
  super ( ) . __init__ ( Ii1iI11 . Types . Normalize )
  if 62 - 62: ooOOO - ooOOO * ooOOO % Ooo0Ooo / I1Ii1I1 / iI1iII1I1I1i
 def copy ( self ) -> 'DataPreprocessing.Transformation.Image.Normalize' :
  if 5 - 5: Oo - Ooo0Ooo + IiIIii11Ii
  if 25 - 25: I1Ii1I1 + Ii . oOo0O00
  if 20 - 20: I11iiIi11i1I
  if 56 - 56: iI1iII1I1I1i + Oo * OooOoo + Ii
  if 32 - 32: i1I . i1I . I11iiIi11i1I
  if 45 - 45: Iii1i * Ooo0Ooo + Oo + i1 / oOO + i1iiIII111
  if 7 - 7: ooOOO . I1Ii1I1 / i1I / IIiIIiIi11I1 % Ooo0Ooo
  if 53 - 53: I1Ii1I1 / i1I - Ii * OooOoo + I1I / oOO
  if 13 - 13: ooo000
  if 6 - 6: IiI11Ii111 % IIiIIiIi11I1 . Ii . OooOoo + IiI11Ii111 / i1i1i1111I
  O0O0OO00o = O00oOO ( )
  self . _copyAttributesTo ( O0O0OO00o )
  return O0O0OO00o
  if 43 - 43: Iii1i - I1Ii1I1
 def transformTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 45 - 45: Ooo0Ooo % Oo . I1I + I11iiIi11i1I + I1I
  if 6 - 6: IIiIIiIi11I1 . IiIIii11Ii - Oo
  if 29 - 29: Ooo0Ooo
  if 10 - 10: IiI11Ii111
  if 97 - 97: Oo / ooo000
  if 71 - 71: oOo0O00 - I1I + Oo - iI1iII1I1I1i + i1
  if 20 - 20: oOo0O00
  if 32 - 32: IiI11Ii111
  if 17 - 17: i1 + I1Ii1I1 . Ooo0Ooo - Ooo0Ooo
  if 45 - 45: I1Ii1I1 . I1I / i1i1i1111I - Ooo0Ooo
  if 46 - 46: Iii1i % OooOoo - ooOOO
  if 59 - 59: i1iiIII111 + Ooo0Ooo / iI1iII1I1I1i
  if 18 - 18: i1
  return val / 255
  if 52 - 52: Ii - iI1iII1I1I1i / i1iiIII111 * Iii1i . IiIIii11Ii . Ooo0Ooo
 def transformFrom ( self , val : 'np.ndarray' ) -> 'np.ndarray' :
  if 71 - 71: Ooo0Ooo . Iii1i % iI1iII1I1I1i + i1i1i1111I
  if 99 - 99: I1Ii1I1
  if 11 - 11: i1i1i1111I % iI1iII1I1I1i - IiI11Ii111 * I1Ii1I1 / IiIIii11Ii / I1I
  if 74 - 74: i1 * Iii1i
  if 81 - 81: I11iiIi11i1I + i1I + i1iiIII111
  if 11 - 11: IIiIIiIi11I1 + iI1iII1I1I1i . oOo0O00 % I1I
  if 19 - 19: I11iiIi11i1I
  if 30 - 30: OooOoo
  if 35 - 35: ooOOO - Ooo0Ooo
  if 96 - 96: i1iiIII111 + Oo * Iii1i % Ii / oOo0O00
  if 9 - 9: i1iiIII111 . oOo0O00 * I11iiIi11i1I % i1iiIII111 . Ii . IiI11Ii111
  if 29 - 29: ooo000 + IiIIii11Ii
  if 93 - 93: Ooo0Ooo / I1I
  return val * 255
  if 98 - 98: i1iiIII111 . IIiIIiIi11I1
class OO0oo ( o00oo0 ) :
 if 74 - 74: Oo + ooOOO - iI1iII1I1I1i / Ii - OooOoo
 if 13 - 13: ooOOO . Ii - I1Ii1I1 . i1iiIII111
 if 91 - 91: I1Ii1I1 % i1 % i1I / IIiIIiIi11I1 * iI1iII1I1I1i . oOO
 if 48 - 48: Oo % ooo000 - iI1iII1I1I1i % IiIIii11Ii
 if 5 - 5: Oo % i1 - i1I
 if 31 - 31: i1i1i1111I
 if 8 - 8: IiIIii11Ii + i1i1i1111I % IiI11Ii111 - I1I % i1i1i1111I / IIiIIiIi11I1
 class Methods ( II1i1I ) :
  if 76 - 76: oOo0O00 - IIiIIiIi11I1
  if 4 - 4: ooOOO % oOo0O00 * ooo000 . oOo0O00 + IiIIii11Ii
  if 20 - 20: i1I + IiIIii11Ii / Iii1i - IIiIIiIi11I1 * IiIIii11Ii - Iii1i
  if 74 - 74: I1Ii1I1 - IIiIIiIi11I1 . oOO
  if 83 - 83: OooOoo - I1Ii1I1 * iI1iII1I1I1i
  if 15 - 15: I1Ii1I1 * Iii1i - ooo000 / i1i1i1111I * Oo
  if 72 - 72: Iii1i % Oo * IiI11Ii111 . i1
  if 56 - 56: i1I
  Bilinear = "bilinear"
  if 84 - 84: i1I
  if 36 - 36: oOO . iI1iII1I1I1i . Ii . OooOoo / IIiIIiIi11I1
  NearestNeighbor = "nearest"
  if 89 - 89: I1Ii1I1 * Iii1i % I11iiIi11i1I + iI1iII1I1I1i
  if 60 - 60: Ii - ooOOO . i1I * iI1iII1I1I1i
  Bicubic = "bicubic"
  if 18 - 18: I11iiIi11i1I - Oo / i1I . Ooo0Ooo + IiI11Ii111 * ooo000
  if 40 - 40: IIiIIiIi11I1 . I1I - i1iiIII111 * IiI11Ii111
  Area = "area"
  if 47 - 47: i1I * Oo * I1Ii1I1 % OooOoo
 def __init__ ( self , width : int = 32 , height : int = 32 , resizeMethod : 'DataPreprocessing.Transformation.Image.Resize.Methods' = Methods . Bilinear , preserveAspectRatio : bool = False ) :
  if 5 - 5: I1I . ooo000 + i1
  if 94 - 94: iI1iII1I1I1i * I11iiIi11i1I + IiI11Ii111 * IiIIii11Ii / Ii
  if 7 - 7: Oo + iI1iII1I1I1i - ooOOO * I11iiIi11i1I
  if 54 - 54: I1I - oOO + oOO . Oo / IIiIIiIi11I1 - ooOOO
  if 66 - 66: IIiIIiIi11I1 + IiI11Ii111 - IiIIii11Ii / IiI11Ii111
  if 80 - 80: i1iiIII111 * oOO * I1I + i1 % ooo000 + IiI11Ii111
  if 75 - 75: Oo - IiIIii11Ii / Ii / IiI11Ii111 . I1I
  if 8 - 8: ooOOO - i1I - OooOoo . IIiIIiIi11I1 - i1I . i1i1i1111I
  if 73 - 73: i1I % I1I / i1 + Ii
  if 28 - 28: i1 . IIiIIiIi11I1 % I1I % i1iiIII111 . ooo000 * I11iiIi11i1I
  if 17 - 17: IIiIIiIi11I1 * i1 + i1iiIII111 / I1Ii1I1 + Ooo0Ooo
  if 89 - 89: OooOoo . IiI11Ii111
  if 87 - 87: IIiIIiIi11I1 % IIiIIiIi11I1 + I11iiIi11i1I
  super ( ) . __init__ ( Ii1iI11 . Types . Resize )
  if 16 - 16: I1Ii1I1
  if 72 - 72: i1I - i1I
  self . width = width
  if 26 - 26: IiIIii11Ii * iI1iII1I1I1i . i1
  if 74 - 74: OooOoo / i1I
  self . height = height
  if 29 - 29: iI1iII1I1I1i
  if 83 - 83: Ooo0Ooo % Iii1i + i1I / ooOOO
  self . resizeMethod = resizeMethod
  if 88 - 88: IiIIii11Ii - Ii * i1iiIII111 + IIiIIiIi11I1 - IIiIIiIi11I1 * i1I
  if 11 - 11: I1I + OooOoo . oOo0O00 * I1I
  self . preserveAspectRatio = preserveAspectRatio
  if 39 - 39: I1I + i1 + i1i1i1111I % i1iiIII111 . IiIIii11Ii - Ii
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 76 - 76: I1Ii1I1 - Ii
  if 80 - 80: Ii % I1I * ooo000
  if 76 - 76: iI1iII1I1I1i + IiIIii11Ii * I1Ii1I1 - ooOOO % I1I / i1I
  if 13 - 13: ooo000 % Iii1i - oOO % i1iiIII111
  if 42 - 42: ooo000
  if 74 - 74: i1I / ooOOO * ooOOO
  if 14 - 14: i1i1i1111I
  if 3 - 3: IIiIIiIi11I1 / i1I * IIiIIiIi11I1
  if 34 - 34: IiIIii11Ii / i1I + Oo / Oo . I11iiIi11i1I
  if 10 - 10: IiI11Ii111 % IiI11Ii111 - Oo % OooOoo / i1I
  if 32 - 32: i1iiIII111 - I11iiIi11i1I / oOo0O00
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "resizeMethod" :
    setattr ( self , Ii1I , OO0oo . Methods . parse ( iiiiIi1IiiIi ) )
   elif Ii1I not in [ "_instanceClass" , "_method" , "dppNodes" , "colConfigs" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 65 - 65: Oo . i1iiIII111 . IIiIIiIi11I1 * I1I . iI1iII1I1I1i + IiIIii11Ii
 def copy ( self ) -> 'DataPreprocessing.Transformation.Image.Resize' :
  if 51 - 51: i1i1i1111I
  if 53 - 53: I1Ii1I1 * I1Ii1I1 - oOo0O00
  if 43 - 43: Ooo0Ooo + Iii1i / I1Ii1I1
  if 16 - 16: ooOOO + ooo000
  if 80 - 80: I1Ii1I1 * i1 / oOo0O00 % IIiIIiIi11I1 . iI1iII1I1I1i . i1
  if 86 - 86: ooOOO / ooo000 - Ii
  if 80 - 80: IIiIIiIi11I1 + Ii * Ii
  if 54 - 54: i1
  if 74 - 74: Ii . i1I - Oo + I1I - i1iiIII111
  if 18 - 18: ooOOO
  O0O0OO00o = OO0oo ( )
  self . _copyAttributesTo ( O0O0OO00o , "width" , "height" , "resizeMethod" , "preserveAspectRatio" )
  return O0O0OO00o
  if 81 - 81: I1Ii1I1 . I1Ii1I1 . oOo0O00 / Oo * i1iiIII111 - ooo000
 def transformTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 9 - 9: Ii % i1iiIII111 % ooOOO - i1i1i1111I
  if 68 - 68: ooOOO + I1I . I1I / ooo000 - Iii1i + OooOoo
  if 67 - 67: i1i1i1111I % Ooo0Ooo + i1iiIII111
  if 71 - 71: iI1iII1I1I1i
  if 83 - 83: IiIIii11Ii . IIiIIiIi11I1 * I1Ii1I1 % Ii % i1iiIII111
  if 23 - 23: i1I + I1Ii1I1 / i1I . Oo . oOo0O00 * I1Ii1I1
  if 74 - 74: ooOOO % Oo % Oo + Iii1i + i1i1i1111I
  if 28 - 28: ooo000 + i1I % i1I / oOo0O00 . I1Ii1I1
  if 53 - 53: Iii1i / I1Ii1I1 . Iii1i
  if 14 - 14: Ii + Ii / I11iiIi11i1I % oOo0O00
  if 90 - 90: IiI11Ii111 - I11iiIi11i1I % I11iiIi11i1I
  if 51 - 51: IiI11Ii111 + oOO + oOO . OooOoo
  if 60 - 60: Oo % i1
  if len ( val . shape ) == 3 :
   if 85 - 85: i1iiIII111 - Oo % oOo0O00 - ooOOO
   val = tf . expand_dims ( val , 0 )
   return tf . image . resize ( val , ( self . height , self . width ) , method = self . resizeMethod . value , preserve_aspect_ratio = self . preserveAspectRatio ) [ 0 ]
  elif len ( val . shape ) == 4 :
   return tf . image . resize ( val , ( self . height , self . width ) , method = self . resizeMethod . value , preserve_aspect_ratio = self . preserveAspectRatio )
  else :
   raise ValueError ( "Incorrect image transformation parameter." )
   if 89 - 89: Oo % I1I + Oo / Iii1i % Oo . I1I
class IiiI ( o00oo0 ) :
 if 52 - 52: i1 / I1Ii1I1 + ooOOO % Iii1i * OooOoo
 if 19 - 19: ooOOO * I1Ii1I1 - IIiIIiIi11I1 - i1 . Iii1i / OooOoo
 if 41 - 41: I1Ii1I1 + i1
 if 69 - 69: Ii - IIiIIiIi11I1 - Iii1i - oOo0O00
 if 99 - 99: I1I % i1I
 if 97 - 97: Ooo0Ooo - ooo000 * oOo0O00 - oOO . IIiIIiIi11I1
 if 63 - 63: Ii . iI1iII1I1I1i
 def __init__ ( self , centralFraction : float = 0.9 ) :
  if 84 - 84: oOo0O00 / Ii * Iii1i
  if 31 - 31: Ii * IiIIii11Ii
  if 10 - 10: IiI11Ii111
  if 92 - 92: oOo0O00 / OooOoo - ooOOO + I1Ii1I1
  if 56 - 56: i1i1i1111I + oOO - i1I
  if 86 - 86: I1Ii1I1 % IIiIIiIi11I1
  if 56 - 56: i1 * oOO % I1Ii1I1 + oOO / Oo * oOO
  if 22 - 22: I1I % I1I - I1Ii1I1 * oOO - Ooo0Ooo
  if 67 - 67: IIiIIiIi11I1
  if 95 - 95: ooOOO
  super ( ) . __init__ ( Ii1iI11 . Types . CentralCrop )
  if 24 - 24: IiIIii11Ii / i1 - I11iiIi11i1I . IiI11Ii111 % i1I + i1
  if 10 - 10: Ooo0Ooo
  self . centralFraction = centralFraction
  if 88 - 88: I1Ii1I1 % i1i1i1111I * I1I * i1 + oOo0O00
 def copy ( self ) -> 'DataPreprocessing.Transformation.Image.CentralCrop' :
  if 91 - 91: Ii * Iii1i + Iii1i - IIiIIiIi11I1
  if 62 - 62: oOO . oOo0O00 % i1I
  if 37 - 37: IiI11Ii111 % ooo000 % IiIIii11Ii / ooo000 - Ooo0Ooo % Ooo0Ooo
  if 17 - 17: i1
  if 70 - 70: i1iiIII111
  if 75 - 75: IiI11Ii111 . oOO + ooOOO
  if 95 - 95: I1Ii1I1 + IiIIii11Ii / i1I
  if 43 - 43: I1I . Ii / i1iiIII111
  if 79 - 79: IiIIii11Ii
  if 38 - 38: i1I
  O0O0OO00o = IiiI ( )
  self . _copyAttributesTo ( O0O0OO00o , "centralFraction" )
  return O0O0OO00o
  if 53 - 53: IiIIii11Ii * Oo
 def transformTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 96 - 96: Iii1i . Ooo0Ooo % oOo0O00 - Oo + i1 * Ooo0Ooo
  if 30 - 30: IiI11Ii111 + i1iiIII111 . Iii1i * ooOOO
  if 9 - 9: IIiIIiIi11I1 / OooOoo / ooOOO / OooOoo
  if 54 - 54: I11iiIi11i1I - Ii - I1I * I1Ii1I1 * oOO / Oo
  if 18 - 18: iI1iII1I1I1i . I11iiIi11i1I . i1I % IiIIii11Ii / oOo0O00
  if 87 - 87: i1iiIII111 * Oo / I1Ii1I1 . iI1iII1I1I1i
  if 96 - 96: Ooo0Ooo % IIiIIiIi11I1 / I1I
  if 10 - 10: oOo0O00
  if 78 - 78: Oo / Iii1i
  if 69 - 69: I1Ii1I1 - Ii / i1iiIII111 - ooOOO % Iii1i
  if 4 - 4: Oo % I11iiIi11i1I
  if 3 - 3: Ooo0Ooo * oOo0O00
  if 71 - 71: i1i1i1111I * Ii * Ii
  if len ( val . shape ) == 3 :
   if 17 - 17: I11iiIi11i1I
   return tf . image . central_crop ( val , self . centralFraction )
  elif len ( val . shape ) == 4 :
   if 20 - 20: ooOOO . oOO . i1i1i1111I
   return tf . map_fn ( lambda o0OO : tf . image . central_crop ( o0OO , self . centralFraction ) , val )
  else :
   raise ValueError ( "Incorrect image transformation parameter." )
   if 9 - 9: oOO * oOO - I1I - I1Ii1I1
class I11Iii1iiIi ( o00oo0 ) :
 if 83 - 83: IIiIIiIi11I1 * I1I + I1I
 if 40 - 40: Oo / Ooo0Ooo . IiIIii11Ii
 if 9 - 9: Iii1i
 if 38 - 38: i1i1i1111I . oOo0O00 . I1I . Oo
 if 31 - 31: i1iiIII111 + iI1iII1I1I1i * i1I
 if 39 - 39: IIiIIiIi11I1 . OooOoo
 if 88 - 88: i1 / IiIIii11Ii % iI1iII1I1I1i - i1i1i1111I / ooo000 - i1i1i1111I
 def __init__ ( self , centralFraction : float = 0.9 ) :
  if 91 - 91: oOO % oOO % oOO - IIiIIiIi11I1 - Ooo0Ooo
  if 61 - 61: IiIIii11Ii - I1I . IIiIIiIi11I1 % i1i1i1111I - I1I / IiI11Ii111
  if 69 - 69: oOO
  if 74 - 74: iI1iII1I1I1i % I1Ii1I1
  if 6 - 6: IIiIIiIi11I1 % Ii / ooOOO
  if 47 - 47: i1I
  if 33 - 33: I11iiIi11i1I + I11iiIi11i1I - i1i1i1111I
  if 83 - 83: i1 - Oo + oOO % Iii1i * i1I - ooo000
  if 100 - 100: Ii * Oo / IiIIii11Ii
  if 63 - 63: i1iiIII111 % I1I % i1I
  super ( ) . __init__ ( Ii1iI11 . Types . ToGrayscale )
  if 14 - 14: i1iiIII111 * ooo000 / OooOoo * IiIIii11Ii . ooOOO
 def copy ( self ) -> 'DataPreprocessing.Transformation.Image.ToGrayscale' :
  if 40 - 40: i1 / I1Ii1I1 % i1i1i1111I - i1I * i1iiIII111
  if 33 - 33: Ooo0Ooo
  if 30 - 30: Ooo0Ooo + Iii1i - Ii / iI1iII1I1I1i * i1i1i1111I
  if 99 - 99: iI1iII1I1I1i / ooOOO % I1Ii1I1
  if 8 - 8: IiIIii11Ii + IiIIii11Ii * i1iiIII111 * i1iiIII111 / oOo0O00 + Ii
  if 58 - 58: i1I * Ooo0Ooo * iI1iII1I1I1i - I11iiIi11i1I * I11iiIi11i1I
  if 69 - 69: OooOoo / Ii . Ii * OooOoo - Iii1i
  if 36 - 36: IiI11Ii111
  if 40 - 40: Oo . oOo0O00 / Oo - iI1iII1I1I1i
  if 47 - 47: oOO - Iii1i * Oo + oOo0O00 . Ooo0Ooo % Ooo0Ooo
  O0O0OO00o = I11Iii1iiIi ( )
  self . _copyAttributesTo ( O0O0OO00o )
  return O0O0OO00o
  if 62 - 62: I11iiIi11i1I
 def transformTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 54 - 54: OooOoo + OooOoo - oOo0O00
  if 39 - 39: ooOOO . oOO % IIiIIiIi11I1 - i1i1i1111I
  if 15 - 15: Oo
  if 65 - 65: Iii1i - i1 / i1iiIII111 / iI1iII1I1I1i
  if 100 - 100: oOo0O00
  if 85 - 85: Iii1i / i1 - OooOoo
  if 40 - 40: Ooo0Ooo * i1I % IIiIIiIi11I1 % ooOOO
  if 77 - 77: I1I . Ii * i1 + Oo % iI1iII1I1I1i - IiI11Ii111
  if 77 - 77: i1I % OooOoo % ooo000 + I1Ii1I1 % iI1iII1I1I1i + Iii1i
  if 37 - 37: Oo . I1I * i1i1i1111I . Ooo0Ooo % oOo0O00
  if 32 - 32: i1i1i1111I / ooOOO
  if 46 - 46: IiIIii11Ii - I11iiIi11i1I . I1Ii1I1 . IiIIii11Ii - i1i1i1111I % IIiIIiIi11I1
  if 8 - 8: i1
  if len ( val . shape ) == 3 :
   if 35 - 35: ooOOO - I1I
   return tf . image . rgb_to_grayscale ( val )
  elif len ( val . shape ) == 4 :
   if 94 - 94: ooo000 + IIiIIiIi11I1
   return tf . map_fn ( lambda o0OO : tf . image . rgb_to_grayscale ( o0OO ) , val )
  else :
   raise ValueError ( "Incorrect image transformation parameter." )
   if 38 - 38: i1iiIII111
class IIi1 ( o00oo0 ) :
 if 86 - 86: Oo / i1i1i1111I
 if 44 - 44: i1i1i1111I . i1I . Iii1i
 if 82 - 82: ooo000 . Iii1i
 if 63 - 63: i1
 if 95 - 95: i1I * Ii / IiIIii11Ii . OooOoo
 if 23 - 23: oOo0O00
 if 34 - 34: Ooo0Ooo * iI1iII1I1I1i
 def __init__ ( self , centralFraction : float = 0.9 ) :
  if 84 - 84: IiIIii11Ii * I1I
  if 72 - 72: OooOoo * Ooo0Ooo + Oo
  if 16 - 16: i1iiIII111 . IiI11Ii111 * IiI11Ii111 % oOo0O00
  if 35 - 35: Ooo0Ooo / i1i1i1111I * ooOOO % i1iiIII111 + iI1iII1I1I1i / i1iiIII111
  if 69 - 69: I11iiIi11i1I - OooOoo
  if 93 - 93: IiIIii11Ii % oOO . ooOOO . i1I % oOo0O00 * Ii
  if 24 - 24: I1I / IiIIii11Ii
  if 72 - 72: i1 % I11iiIi11i1I + Ii
  if 89 - 89: i1iiIII111 * I1Ii1I1
  if 66 - 66: i1iiIII111 . IIiIIiIi11I1 . Ii + I11iiIi11i1I - i1i1i1111I
  super ( ) . __init__ ( Ii1iI11 . Types . ToRGB )
  if 75 - 75: iI1iII1I1I1i * IiIIii11Ii / oOo0O00 + IiIIii11Ii / ooOOO / IIiIIiIi11I1
 def copy ( self ) -> 'DataPreprocessing.Transformation.Image.ToRGB' :
  if 64 - 64: ooOOO - ooOOO + ooo000 % ooOOO
  if 76 - 76: oOo0O00 . Ooo0Ooo
  if 37 - 37: Ii
  if 56 - 56: ooo000
  if 73 - 73: OooOoo % oOo0O00 - Ooo0Ooo % iI1iII1I1I1i / IiIIii11Ii
  if 47 - 47: iI1iII1I1I1i - i1I
  if 30 - 30: oOo0O00 + ooo000 * i1I . OooOoo . Oo
  if 3 - 3: iI1iII1I1I1i . IiIIii11Ii / ooOOO
  if 46 - 46: IiI11Ii111 / Ii - Ooo0Ooo . i1I . i1 % OooOoo
  if 81 - 81: iI1iII1I1I1i + iI1iII1I1I1i . OooOoo % OooOoo - Oo + IIiIIiIi11I1
  O0O0OO00o = IIi1 ( )
  self . _copyAttributesTo ( O0O0OO00o )
  return O0O0OO00o
  if 38 - 38: ooo000 . Ii
 def transformTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 28 - 28: Ii + i1
  if 96 - 96: i1I * i1 + IiI11Ii111 * I11iiIi11i1I % ooOOO + OooOoo
  if 59 - 59: IiIIii11Ii % i1 / i1i1i1111I - i1I - ooOOO
  if 73 - 73: ooOOO * oOo0O00 + IiIIii11Ii % IiI11Ii111
  if 46 - 46: I11iiIi11i1I * I1Ii1I1 . I1I - Oo
  if 64 - 64: OooOoo + Oo - i1 % OooOoo / ooOOO * Iii1i
  if 21 - 21: I1I % ooo000
  if 86 - 86: ooo000 - Oo
  if 60 - 60: Iii1i + ooOOO * ooOOO . ooo000
  if 44 - 44: Oo + I1Ii1I1 . ooo000 % I11iiIi11i1I / Oo . Iii1i
  if 45 - 45: OooOoo
  if 91 - 91: IiI11Ii111 % I1Ii1I1
  if 5 - 5: oOo0O00 * i1iiIII111 * IiIIii11Ii % I1Ii1I1
  if len ( val . shape ) == 3 :
   if 68 - 68: iI1iII1I1I1i / IIiIIiIi11I1 - ooOOO - I1I / I1I % i1iiIII111
   return tf . image . grayscale_to_rgb ( val )
  elif len ( val . shape ) == 4 :
   if 90 - 90: i1 / iI1iII1I1I1i * I1I
   return tf . map_fn ( lambda o0OO : tf . image . grayscale_to_rgb ( o0OO ) , val )
  else :
   raise ValueError ( "Incorrect image transformation parameter." )
   if 94 - 94: iI1iII1I1I1i * I11iiIi11i1I
class Ii1iI11 :
 if 28 - 28: i1I - i1i1i1111I / Oo + Iii1i . OooOoo
 if 49 - 49: IIiIIiIi11I1
 if 57 - 57: ooOOO . I1I
 if 81 - 81: I11iiIi11i1I + i1I - ooo000 * I1I + i1i1i1111I - IiIIii11Ii
 if 46 - 46: Oo / IiIIii11Ii . Iii1i / oOO
 if 73 - 73: i1i1i1111I / iI1iII1I1I1i % Iii1i / i1I * IiIIii11Ii
 if 7 - 7: I1I % iI1iII1I1I1i / i1 - Oo
 class Types ( II1i1I ) :
  if 17 - 17: I1I - i1i1i1111I + oOo0O00 * i1iiIII111 % Ii
  if 99 - 99: iI1iII1I1I1i * IiIIii11Ii
  if 78 - 78: Iii1i * OooOoo % oOO - Iii1i * IiI11Ii111 . Ii
  if 61 - 61: Iii1i / oOO
  if 84 - 84: i1i1i1111I - Oo / i1I % IiIIii11Ii + i1 / IiI11Ii111
  if 83 - 83: i1I + Ii - i1 / i1i1i1111I / IiI11Ii111 + IiI11Ii111
  if 67 - 67: IiIIii11Ii - iI1iII1I1I1i . iI1iII1I1I1i + Iii1i % I1Ii1I1 / I1I
  if 2 - 2: oOO % Ooo0Ooo . IiI11Ii111 . i1i1i1111I + iI1iII1I1I1i
  Normalize = 1
  if 44 - 44: I1Ii1I1
  if 94 - 94: i1 . Ii . iI1iII1I1I1i
  Resize = 2
  if 66 - 66: Ooo0Ooo % IiIIii11Ii - IIiIIiIi11I1 % i1iiIII111 + oOO * i1iiIII111
  if 1 - 1: i1I + oOo0O00 . Ii + IiI11Ii111 + iI1iII1I1I1i
  CentralCrop = 3
  if 23 - 23: Ooo0Ooo - IiI11Ii111
  if 38 - 38: OooOoo - I1Ii1I1 - Ooo0Ooo % Oo + Oo % oOo0O00
  ToGrayscale = 4
  if 99 - 99: Ii / i1 + oOO * i1iiIII111 + ooOOO . ooo000
  if 19 - 19: IIiIIiIi11I1
  ToRGB = 5
  if 50 - 50: I1I * IiI11Ii111 + I1I
 Normalize = O00oOO
 Resize = OO0oo
 CentralCrop = IiiI
 ToGrayscale = I11Iii1iiIi
 ToRGB = IIi1
 if 74 - 74: Ooo0Ooo . ooo000 * iI1iII1I1I1i
class iiii1I11IIiI1 ( ooo0 ) :
 if 33 - 33: iI1iII1I1I1i
 if 72 - 72: Ooo0Ooo % I11iiIi11i1I % IiIIii11Ii * i1iiIII111 % ooOOO - IiI11Ii111
 if 10 - 10: Ii
 if 51 - 51: iI1iII1I1I1i - OooOoo * oOo0O00 - I11iiIi11i1I . IiI11Ii111 - i1
 if 84 - 84: oOO - i1iiIII111 % iI1iII1I1I1i / Ii - i1i1i1111I
 if 21 - 21: I1I % Ooo0Ooo . ooOOO
 if 46 - 46: IiI11Ii111 * OooOoo % i1 + oOO - ooOOO . iI1iII1I1I1i
 def __init__ ( self , method : 'DataPreprocessing.Transformation.ImageAugmentation.Types' ) :
  if 1 - 1: IIiIIiIi11I1 . i1I * I1I
  if 50 - 50: I11iiIi11i1I . IiIIii11Ii - ooo000
  if 75 - 75: i1I - OooOoo
  if 97 - 97: i1
  if 86 - 86: IIiIIiIi11I1 / i1iiIII111 / Oo - IiIIii11Ii / IIiIIiIi11I1 - I1Ii1I1
  if 10 - 10: Iii1i / Iii1i
  if 71 - 71: I11iiIi11i1I - IiIIii11Ii % i1I
  super ( ) . __init__ ( oOoOoo0oO0 . ImageAugmentation , method )
  if 15 - 15: OooOoo / oOo0O00 * I1Ii1I1
class Ooo000oO ( iiii1I11IIiI1 ) :
 if 63 - 63: Ooo0Ooo / IiI11Ii111 * I1I . I1I . ooOOO
 if 10 - 10: ooo000 * i1iiIII111
 if 84 - 84: i1I / I11iiIi11i1I
 if 42 - 42: oOO * IiI11Ii111 + IiI11Ii111 * iI1iII1I1I1i
 if 93 - 93: IIiIIiIi11I1 . Ooo0Ooo . Iii1i . IIiIIiIi11I1
 if 35 - 35: ooOOO . i1 / Ii - Ii
 if 36 - 36: i1i1i1111I % IIiIIiIi11I1 * oOo0O00 + ooo000 / iI1iII1I1I1i % i1i1i1111I
 class TestCropMethods ( II1i1I ) :
  if 85 - 85: ooo000 * I11iiIi11i1I / iI1iII1I1I1i * I1Ii1I1 - IiIIii11Ii . IIiIIiIi11I1
  if 91 - 91: Iii1i + i1iiIII111 * IiIIii11Ii + I11iiIi11i1I
  if 56 - 56: I11iiIi11i1I . oOo0O00 / IIiIIiIi11I1 % oOo0O00
  if 9 - 9: IIiIIiIi11I1 / IiIIii11Ii % i1
  if 81 - 81: ooOOO
  if 14 - 14: IiI11Ii111 * I11iiIi11i1I % I1Ii1I1 - I1I - ooOOO * i1I
  if 23 - 23: I1Ii1I1
  if 18 - 18: i1 * i1I
  ResizePadOrCrop = 1
  if 75 - 75: Oo / i1I + Iii1i . Oo - I1I
  ResizePad = 2
  if 18 - 18: Iii1i * ooOOO + ooOOO % Ooo0Ooo + IIiIIiIi11I1 - i1i1i1111I
  Resize = 3
  if 47 - 47: Oo + iI1iII1I1I1i * ooo000 * Iii1i - i1iiIII111 + Ooo0Ooo
 def __init__ ( self , width : int = None , height : int = None , testCrop : 'DataPreprocessing.Transformation.ImageAugmentation.Crop.TestCropMethods' = TestCropMethods . ResizePadOrCrop ) :
  if 71 - 71: i1I / Oo . oOo0O00 - iI1iII1I1I1i + ooo000
  if 63 - 63: ooo000 - IIiIIiIi11I1 + Ooo0Ooo * ooo000 - IIiIIiIi11I1 + ooo000
  if 6 - 6: OooOoo + I11iiIi11i1I . i1iiIII111 * OooOoo * i1I
  if 56 - 56: i1iiIII111 + i1i1i1111I / IIiIIiIi11I1
  if 47 - 47: oOo0O00
  if 74 - 74: I11iiIi11i1I % I11iiIi11i1I - i1I / I11iiIi11i1I % IIiIIiIi11I1
  if 19 - 19: oOo0O00 + ooOOO * I1Ii1I1 / Iii1i
  if 56 - 56: oOO
  if 47 - 47: Ooo0Ooo . I1Ii1I1 % oOO % i1 - I11iiIi11i1I * Ooo0Ooo
  if 88 - 88: Ii . IIiIIiIi11I1 - OooOoo
  if 40 - 40: I1I - Ii % I1Ii1I1 / i1i1i1111I
  if 33 - 33: I1I . i1i1i1111I
  if 70 - 70: i1I / i1 / i1i1i1111I . Oo . ooOOO % Iii1i
  super ( ) . __init__ ( O00OO0 . Types . Crop )
  if 64 - 64: OooOoo + oOo0O00 * IiIIii11Ii
  if 20 - 20: Oo - i1i1i1111I + I1I + IiI11Ii111 - iI1iII1I1I1i
  self . width = width
  if 33 - 33: I11iiIi11i1I - i1iiIII111 / i1i1i1111I
  if 58 - 58: I1I % I11iiIi11i1I * i1i1i1111I - i1 * i1iiIII111
  self . height = height
  if 45 - 45: IiI11Ii111 - i1 - I1I * oOO
  if 92 - 92: oOO + ooOOO - iI1iII1I1I1i . oOO * OooOoo
  self . testCrop = testCrop
  if 42 - 42: Ii - Oo * IiI11Ii111 % i1I * Ooo0Ooo . OooOoo
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 34 - 34: oOo0O00 % IIiIIiIi11I1 * I1Ii1I1 - i1I
  if 26 - 26: oOO * OooOoo + I11iiIi11i1I - IiIIii11Ii
  if 15 - 15: iI1iII1I1I1i % Ooo0Ooo / i1I - IiI11Ii111
  if 7 - 7: Iii1i
  if 17 - 17: i1i1i1111I - Ii % IiI11Ii111 * OooOoo + I1I . oOO
  if 85 - 85: Oo / Oo / i1i1i1111I + i1I
  if 6 - 6: IiIIii11Ii + ooo000 * oOo0O00 / ooOOO * I1Ii1I1 - OooOoo
  if 5 - 5: ooo000
  if 44 - 44: I1I - i1 * I1I % IiIIii11Ii
  if 5 - 5: oOo0O00 / OooOoo / OooOoo - i1 + oOO
  if 12 - 12: i1 . IIiIIiIi11I1 . i1iiIII111
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "testCrop" :
    setattr ( self , Ii1I , O00OO0 . Crop . TestCropMethods . parse ( iiiiIi1IiiIi ) )
   elif Ii1I not in [ "_instanceClass" , "_method" , "dppNodes" , "colConfigs" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 41 - 41: oOo0O00 % ooOOO . Ii / oOo0O00 / I11iiIi11i1I
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Crop' :
  if 39 - 39: Ii + IIiIIiIi11I1
  if 36 - 36: IiI11Ii111 . i1 / I1Ii1I1
  if 66 - 66: i1I
  if 82 - 82: iI1iII1I1I1i % OooOoo . ooOOO + oOo0O00 . I1I
  if 12 - 12: IiI11Ii111
  if 2 - 2: Oo - oOO * i1 / i1iiIII111
  if 90 - 90: OooOoo / IIiIIiIi11I1 - i1 * Ooo0Ooo - i1iiIII111 + ooOOO
  if 57 - 57: iI1iII1I1I1i . iI1iII1I1I1i / IIiIIiIi11I1 + i1
  if 44 - 44: oOO + oOo0O00 . iI1iII1I1I1i
  if 13 - 13: Ooo0Ooo - Ooo0Ooo
  O0O0OO00o = Ooo000oO ( )
  self . _copyAttributesTo ( O0O0OO00o , "width" , "height" , "testCrop" )
  return O0O0OO00o
  if 14 - 14: i1 * I1I % i1I
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 96 - 96: ooOOO % I1Ii1I1
  if 60 - 60: OooOoo . IiIIii11Ii . Oo . ooOOO / i1 / i1I
  if 7 - 7: IIiIIiIi11I1 / oOO % i1iiIII111 % I11iiIi11i1I
  if 24 - 24: IIiIIiIi11I1 - I1I / i1I
  if 9 - 9: IiI11Ii111 % Ii
  if 29 - 29: IiI11Ii111 . OooOoo . IiIIii11Ii - IiI11Ii111
  if 32 - 32: IiIIii11Ii * iI1iII1I1I1i + i1i1i1111I * I1Ii1I1 + i1i1i1111I
  if 95 - 95: Ooo0Ooo
  if 87 - 87: Ii / ooo000
  if 84 - 84: i1iiIII111 * i1i1i1111I % Iii1i . ooOOO * I1I + ooo000
  if 33 - 33: ooOOO - oOo0O00
  if 33 - 33: i1I / Ooo0Ooo
  if 76 - 76: ooOOO
  if len ( val . shape ) == 3 :
   if 19 - 19: Iii1i * Ii
   return tf . image . random_crop ( val , ( self . height , self . width , val . shape [ - 1 ] ) )
  elif len ( val . shape ) == 4 :
   if 60 - 60: I1Ii1I1 / ooo000 - I11iiIi11i1I * i1iiIII111 / iI1iII1I1I1i / I11iiIi11i1I
   return tf . map_fn ( lambda o0OO : tf . image . random_crop ( o0OO , ( self . height , self . width , val . shape [ - 1 ] ) ) , val )
  else :
   raise ValueError ( "Incorrect image transformation parameter." )
   if 7 - 7: iI1iII1I1I1i % i1iiIII111 % IIiIIiIi11I1 * Ii . I1I % I1I
 def transformTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 70 - 70: Ii / Ii . i1I
  if 6 - 6: Ooo0Ooo
  if 28 - 28: i1iiIII111 / Ooo0Ooo % IIiIIiIi11I1 * i1iiIII111 - ooo000 + IiIIii11Ii
  if 71 - 71: IIiIIiIi11I1 . oOO / oOo0O00 * iI1iII1I1I1i
  if 84 - 84: i1
  if 38 - 38: I1I - I1Ii1I1 / oOo0O00
  if 49 - 49: Ooo0Ooo * oOo0O00 % i1i1i1111I
  if 43 - 43: Ooo0Ooo * I1I * i1iiIII111
  if 16 - 16: IIiIIiIi11I1 + i1iiIII111 / I11iiIi11i1I . IiIIii11Ii
  if 14 - 14: ooo000 - ooo000 % i1I + i1I + i1iiIII111 - Ooo0Ooo
  if 2 - 2: i1
  if 91 - 91: i1iiIII111 - OooOoo
  if 24 - 24: ooOOO - ooOOO % OooOoo * Iii1i . i1I
  if len ( val . shape ) == 3 :
   if 21 - 21: i1iiIII111 / i1i1i1111I
   if self . testCrop == self . TestCropMethods . ResizePadOrCrop :
    return tf . image . resize_with_crop_or_pad ( val , self . height , self . width )
   elif self . testCrop == self . TestCropMethods . ResizePad :
    return tf . image . resize_with_pad ( val , self . height , self . width )
   elif self . testCrop == self . TestCropMethods . Resize :
    return tf . image . resize ( tf . expand_dims ( val , 0 ) , ( self . height , self . width ) ) [ 0 ]
   else :
    raise ValueError ( "Non-supported test crop method of this image transformation." )
  elif len ( val . shape ) == 4 :
   if 94 - 94: IiIIii11Ii + i1I - IiIIii11Ii
   if self . testCrop == self . TestCropMethods . ResizePadOrCrop :
    return tf . map_fn ( lambda o0OO : tf . image . resize_with_crop_or_pad ( o0OO , self . height , self . width ) , val )
   elif self . testCrop == self . TestCropMethods . ResizePad :
    return tf . map_fn ( lambda o0OO : tf . image . resize_with_pad ( o0OO , self . height , self . width ) , val )
   elif self . testCrop == self . TestCropMethods . Resize :
    return tf . image . resize ( val , ( self . height , self . width ) )
   else :
    raise ValueError ( "Non-supported test crop method of this image transformation." )
  else :
   raise ValueError ( "Incorrect image augmentation parameter." )
   if 93 - 93: OooOoo - i1
class OoOoOoOO ( iiii1I11IIiI1 ) :
 if 28 - 28: I1Ii1I1
 if 80 - 80: oOO . i1 . OooOoo - I1Ii1I1
 if 76 - 76: Oo / IiI11Ii111 . IiIIii11Ii / OooOoo * oOo0O00
 if 86 - 86: OooOoo % I1Ii1I1
 if 78 - 78: Ii + oOo0O00 . ooo000 % oOO / Iii1i + iI1iII1I1I1i
 if 56 - 56: i1I * I1I + Ii % iI1iII1I1I1i % I1I % oOo0O00
 if 97 - 97: iI1iII1I1I1i - IiI11Ii111 * Ii . iI1iII1I1I1i
 class FlipMethods ( II1i1I ) :
  if 65 - 65: oOo0O00 + ooo000
  if 56 - 56: IiI11Ii111 - oOO + Ooo0Ooo / Iii1i
  if 88 - 88: oOo0O00 * I11iiIi11i1I / I11iiIi11i1I - IiIIii11Ii / Iii1i
  if 68 - 68: i1I + i1iiIII111 / Ooo0Ooo
  if 22 - 22: I1Ii1I1 - ooo000 - OooOoo % OooOoo / i1iiIII111
  if 58 - 58: IIiIIiIi11I1 / oOo0O00 / Ooo0Ooo * IiI11Ii111 % I1Ii1I1 * IIiIIiIi11I1
  if 8 - 8: ooOOO * I1Ii1I1 - i1 / ooOOO + Ooo0Ooo - ooo000
  if 14 - 14: IiIIii11Ii
  LeftRight = 1
  if 13 - 13: ooo000 % oOO . Ii
  UpDown = 2
  if 49 - 49: I1Ii1I1 - oOO % I11iiIi11i1I - I11iiIi11i1I * IIiIIiIi11I1
  Any = 3
  if 79 - 79: ooOOO + IiI11Ii111
 def __init__ ( self , flipDirection : 'DataPreprocessing.Transformation.ImageAugmentation.Flip.FlipMethods' = FlipMethods . LeftRight ) :
  if 33 - 33: i1
  if 88 - 88: IiI11Ii111 * i1i1i1111I + Ooo0Ooo % i1iiIII111 % i1i1i1111I - i1
  if 86 - 86: Ii + oOO % i1
  if 90 - 90: Oo / i1 % Iii1i % ooo000 . I1I % ooOOO
  if 61 - 61: i1i1i1111I % I1I / IIiIIiIi11I1 - IiI11Ii111
  if 32 - 32: oOO % i1i1i1111I . I1Ii1I1 * Iii1i / ooo000 . I1I
  if 13 - 13: I1Ii1I1 + Iii1i . OooOoo * i1I / Oo
  if 47 - 47: i1i1i1111I / I1I
  if 32 - 32: I1I * i1i1i1111I * Iii1i + i1I
  if 71 - 71: I1Ii1I1 . IIiIIiIi11I1
  super ( ) . __init__ ( O00OO0 . Types . Flip )
  if 6 - 6: Oo / oOO
  if 77 - 77: I1Ii1I1 - Oo . IiI11Ii111 / IiIIii11Ii
  self . flipDirection = flipDirection
  if 78 - 78: i1
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 13 - 13: IIiIIiIi11I1 - i1iiIII111 * i1I - Iii1i * Iii1i . Oo
  if 84 - 84: i1i1i1111I * ooo000 - I1I + oOo0O00 / oOo0O00
  if 68 - 68: I1I + I11iiIi11i1I
  if 100 - 100: IiIIii11Ii . i1iiIII111 . IIiIIiIi11I1 + oOo0O00
  if 56 - 56: Oo . Ii - oOO * Iii1i - OooOoo
  if 62 - 62: I1Ii1I1 % Ii
  if 33 - 33: Ii
  if 80 - 80: I11iiIi11i1I * Iii1i
  if 70 - 70: oOo0O00 / i1I * Oo * I1I / Oo / ooo000
  if 86 - 86: Iii1i . IiI11Ii111 + I1I * ooOOO / i1i1i1111I * oOO
  if 30 - 30: IiIIii11Ii * I1Ii1I1
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "flipDirection" :
    setattr ( self , Ii1I , OoOoOoOO . FlipMethods . parse ( iiiiIi1IiiIi ) )
   elif Ii1I not in [ "_instanceClass" , "_method" , "dppNodes" , "colConfigs" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 92 - 92: I1Ii1I1 - OooOoo + Ii * I1Ii1I1
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Flip' :
  if 12 - 12: Oo . Ooo0Ooo
  if 60 - 60: oOo0O00 + I11iiIi11i1I / I1I * ooo000 / IIiIIiIi11I1
  if 87 - 87: Oo
  if 96 - 96: ooo000
  if 58 - 58: Oo . iI1iII1I1I1i - oOO * OooOoo - IiI11Ii111
  if 1 - 1: Oo + i1iiIII111
  if 25 - 25: ooOOO - Ooo0Ooo / i1 - I1Ii1I1 . I1Ii1I1
  if 6 - 6: oOo0O00 % IIiIIiIi11I1 . i1iiIII111 * Iii1i / oOo0O00
  if 87 - 87: IiIIii11Ii
  if 26 - 26: IiI11Ii111
  O0O0OO00o = OoOoOoOO ( )
  self . _copyAttributesTo ( O0O0OO00o , "flipDirection" )
  return O0O0OO00o
  if 67 - 67: Ii . i1iiIII111 * Iii1i
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 58 - 58: Iii1i + ooOOO % I11iiIi11i1I
  if 41 - 41: oOo0O00 % Ooo0Ooo
  if 63 - 63: i1 . I11iiIi11i1I - Ooo0Ooo + iI1iII1I1I1i
  if 79 - 79: Iii1i . i1 % iI1iII1I1I1i . ooo000
  if 35 - 35: Ii + I11iiIi11i1I + i1iiIII111 / Iii1i + IIiIIiIi11I1 . I1Ii1I1
  if 57 - 57: IiI11Ii111 - iI1iII1I1I1i
  if 32 - 32: oOO / i1I / Oo . oOO * OooOoo / Iii1i
  if 47 - 47: i1i1i1111I
  if 97 - 97: I1I . ooOOO
  if 4 - 4: ooo000 / Iii1i % IiI11Ii111 . IiI11Ii111
  if 6 - 6: I1Ii1I1 . Ii + ooo000
  if 41 - 41: i1i1i1111I
  if 87 - 87: ooOOO * i1i1i1111I - i1i1i1111I * iI1iII1I1I1i
  if 7 - 7: ooOOO - IiIIii11Ii % i1I - I11iiIi11i1I - ooo000 % I1I
  iiI111 : 'tf.Tensor' = tf . cast ( tf . random . uniform ( [ ] , minval = 0 , maxval = 2 , dtype = tf . int32 ) , tf . float32 )
  if len ( val . shape ) == 3 :
   if 4 - 4: oOo0O00 * i1i1i1111I % i1
   if self . flipDirection == self . FlipMethods . LeftRight :
    return iiI111 * tf . reverse ( val , [ 1 ] ) + ( 1. - iiI111 ) * val
   elif self . flipDirection == self . FlipMethods . UpDown :
    return iiI111 * tf . reverse ( val , [ 0 ] ) + ( 1. - iiI111 ) * val
   elif self . flipDirection == self . FlipMethods . Any :
    if 70 - 70: Oo % Ii % Oo . i1iiIII111 + Ooo0Ooo * IIiIIiIi11I1
    val = iiI111 * tf . reverse ( val , [ 1 ] ) + ( 1. - iiI111 ) * val
    iiI111 : 'tf.Tensor' = tf . cast ( tf . random . uniform ( [ ] , minval = 0 , maxval = 2 , dtype = tf . int32 ) , tf . float32 )
    return iiI111 * tf . reverse ( val , [ 0 ] ) + ( 1. - iiI111 ) * val
   else :
    raise ValueError ( "Non-supported flip direction of this image transformation." )
  elif len ( val . shape ) == 4 :
   if 89 - 89: iI1iII1I1I1i - i1i1i1111I - i1iiIII111 % OooOoo
   if self . flipDirection == self . FlipMethods . LeftRight :
    return iiI111 * tf . reverse ( val , [ 2 ] ) + ( 1. - iiI111 ) * val
   elif self . flipDirection == self . FlipMethods . UpDown :
    return iiI111 * tf . reverse ( val , [ 1 ] ) + ( 1. - iiI111 ) * val
   elif self . flipDirection == self . FlipMethods . Any :
    val = iiI111 * tf . reverse ( val , [ 2 ] ) + ( 1. - iiI111 ) * val
    iiI111 = tf . cast ( tf . random . uniform ( [ ] , minval = 0 , maxval = 2 , dtype = tf . int32 ) , tf . float32 )
    return iiI111 * tf . reverse ( val , [ 1 ] ) + ( 1. - iiI111 ) * val
   else :
    raise ValueError ( "Non-supported flip direction of this image transformation." )
  else :
   raise ValueError ( "Incorrect image augmentation parameter." )
   if 35 - 35: Iii1i - IIiIIiIi11I1 . i1I . Oo / iI1iII1I1I1i
class OoOOooo ( iiii1I11IIiI1 ) :
 if 86 - 86: Iii1i % ooOOO
 if 91 - 91: oOo0O00 / I11iiIi11i1I - I1Ii1I1
 if 57 - 57: OooOoo * I1I + OooOoo * Ii
 if 80 - 80: i1I * I1Ii1I1 * oOO
 if 35 - 35: oOO % i1 - I11iiIi11i1I + I1Ii1I1 - iI1iII1I1I1i
 if 22 - 22: I1I % i1iiIII111 / IIiIIiIi11I1 * Iii1i * I1Ii1I1
 if 90 - 90: IiI11Ii111 . i1I / I11iiIi11i1I
 def __init__ ( self , deviation : int = 10 ) :
  if 52 - 52: I1I - IiI11Ii111 * oOo0O00 % oOo0O00 - oOo0O00 % ooOOO
  if 18 - 18: i1 - oOO % i1iiIII111 / ooo000 * IiIIii11Ii * OooOoo
  if 91 - 91: i1i1i1111I % oOO
  if 94 - 94: iI1iII1I1I1i - I1Ii1I1 - IIiIIiIi11I1 / i1iiIII111 / i1
  if 31 - 31: ooo000 . I1Ii1I1 * Ii
  if 14 - 14: I1I - ooOOO / Oo . ooOOO
  if 89 - 89: IiIIii11Ii . ooo000
  if 89 - 89: i1iiIII111 + I1Ii1I1
  if 54 - 54: I1Ii1I1 - I11iiIi11i1I
  if 72 - 72: I1I / IiIIii11Ii / Ii - oOo0O00
  super ( ) . __init__ ( O00OO0 . Types . Rotate )
  if 36 - 36: IiIIii11Ii + Oo * oOo0O00
  if 27 - 27: OooOoo + i1i1i1111I . Oo
  self . deviation = deviation
  if 60 - 60: i1I + oOo0O00 + i1I
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Rotate' :
  if 43 - 43: oOo0O00 * i1i1i1111I / oOO * oOO
  if 92 - 92: oOo0O00 / i1 - I11iiIi11i1I
  if 15 - 15: I1Ii1I1 . Oo % Oo
  if 53 - 53: IiI11Ii111 - ooOOO / ooo000
  if 37 - 37: IiI11Ii111 % I11iiIi11i1I
  if 57 - 57: iI1iII1I1I1i + I1I
  if 42 - 42: IiI11Ii111 * IiI11Ii111
  if 68 - 68: i1I + IiIIii11Ii . Iii1i / Ii
  if 60 - 60: ooOOO . i1i1i1111I + I11iiIi11i1I
  if 29 - 29: i1I - i1 / Ii
  O0O0OO00o = OoOOooo ( )
  self . _copyAttributesTo ( O0O0OO00o , "deviation" )
  return O0O0OO00o
  if 44 - 44: I1Ii1I1 % i1iiIII111 + I1I * i1i1i1111I
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 4 - 4: i1i1i1111I % ooOOO / oOo0O00 - IIiIIiIi11I1 / ooo000 % I1Ii1I1
  if 40 - 40: Ii * i1i1i1111I
  if 35 - 35: Iii1i - Ooo0Ooo - i1I * Oo - Iii1i * ooo000
  if 77 - 77: i1 - iI1iII1I1I1i * IiI11Ii111 + OooOoo . I11iiIi11i1I . IIiIIiIi11I1
  if 77 - 77: Ii * i1iiIII111 - Ooo0Ooo . ooOOO . i1i1i1111I - IiIIii11Ii
  if 75 - 75: Oo
  if 14 - 14: Iii1i + OooOoo
  if 94 - 94: Ooo0Ooo . Ii
  if 1 - 1: I1Ii1I1 . I1Ii1I1 - oOO
  if 80 - 80: I11iiIi11i1I - OooOoo / I1Ii1I1 . oOO . ooo000
  if 11 - 11: IiI11Ii111 * oOo0O00 % OooOoo
  if 48 - 48: iI1iII1I1I1i
  if 80 - 80: IiI11Ii111 - iI1iII1I1I1i % ooOOO % I1Ii1I1
  raise ValueError ( "Random rotation augmentation is not supported yet." )
  if 5 - 5: i1i1i1111I
class oOoOOo ( iiii1I11IIiI1 ) :
 if 83 - 83: IIiIIiIi11I1 / i1 / oOO * Ooo0Ooo
 if 9 - 9: i1I + I1Ii1I1 + i1iiIII111 % IiI11Ii111 * IiI11Ii111 * ooOOO
 if 59 - 59: IIiIIiIi11I1 * Ooo0Ooo * I1I
 if 97 - 97: IiI11Ii111 * I1Ii1I1 % i1 % Iii1i
 if 44 - 44: IIiIIiIi11I1 - IIiIIiIi11I1 % IiI11Ii111
 if 83 - 83: ooo000 / Ooo0Ooo - IIiIIiIi11I1 . Oo + Ii
 if 48 - 48: IiI11Ii111 / oOO + i1iiIII111 . ooOOO . i1
 def __init__ ( self , maxDelta : int = 0.1 ) :
  if 73 - 73: i1
  if 44 - 44: Iii1i * I11iiIi11i1I / oOO + Ooo0Ooo
  if 80 - 80: Ooo0Ooo - Iii1i * Ooo0Ooo % IiIIii11Ii / iI1iII1I1I1i + ooo000
  if 3 - 3: i1i1i1111I + i1i1i1111I / i1i1i1111I . I11iiIi11i1I
  if 38 - 38: I1Ii1I1 - OooOoo
  if 49 - 49: oOo0O00 * I11iiIi11i1I . Iii1i
  if 17 - 17: i1I + Ii + I11iiIi11i1I
  if 45 - 45: i1 * ooo000 + i1 + I1Ii1I1 + ooOOO
  if 83 - 83: iI1iII1I1I1i - i1I
  if 43 - 43: iI1iII1I1I1i
  super ( ) . __init__ ( O00OO0 . Types . Hue )
  if 93 - 93: IiIIii11Ii * iI1iII1I1I1i + IIiIIiIi11I1 / ooOOO
  self . maxDelta = maxDelta
  if 72 - 72: IiIIii11Ii * OooOoo * i1i1i1111I + I1Ii1I1 / oOO + oOo0O00
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Hue' :
  if 54 - 54: Ii % IIiIIiIi11I1 . I1Ii1I1 + I1Ii1I1
  if 62 - 62: I1Ii1I1 * ooOOO % Ooo0Ooo % I1Ii1I1 + I1I
  if 80 - 80: ooOOO - i1I * IiI11Ii111 % Ii
  if 19 - 19: i1
  if 86 - 86: ooOOO + iI1iII1I1I1i . Ii . ooOOO % i1i1i1111I
  if 44 - 44: i1i1i1111I * oOo0O00 / Ooo0Ooo / i1iiIII111 % IIiIIiIi11I1
  if 41 - 41: oOO * i1iiIII111
  if 9 - 9: IiI11Ii111 / ooo000 - i1 * I1Ii1I1 + oOo0O00 % Ooo0Ooo
  if 10 - 10: Ooo0Ooo / I1Ii1I1 * Iii1i
  if 35 - 35: I11iiIi11i1I
  O0O0OO00o = oOoOOo ( )
  self . _copyAttributesTo ( O0O0OO00o , "maxDelta" )
  return O0O0OO00o
  if 46 - 46: ooo000 . i1
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 27 - 27: i1i1i1111I - I11iiIi11i1I . IiI11Ii111
  if 64 - 64: I1I - OooOoo - I1Ii1I1 % ooo000 * IiIIii11Ii
  if 78 - 78: I1I * I11iiIi11i1I
  if 6 - 6: IiI11Ii111 . IIiIIiIi11I1 . i1i1i1111I
  if 50 - 50: i1
  if 26 - 26: i1 * I11iiIi11i1I . oOo0O00 + i1i1i1111I + oOo0O00 % i1
  if 54 - 54: Ii - I1Ii1I1 * Iii1i * IiI11Ii111 * i1i1i1111I / i1
  if 61 - 61: Ii % I1Ii1I1 * i1i1i1111I * i1I . i1
  if 54 - 54: Ooo0Ooo * iI1iII1I1I1i - iI1iII1I1I1i - i1
  if 54 - 54: ooo000 - IiIIii11Ii + IiIIii11Ii
  if 39 - 39: Ii % ooOOO / I11iiIi11i1I
  if 15 - 15: ooOOO + IiIIii11Ii / Oo * Ii . OooOoo
  if 49 - 49: i1I / IiIIii11Ii + i1 / oOO . IiI11Ii111
  if len ( val . shape ) == 3 :
   if 94 - 94: i1 / I1I
   return tf . image . random_hue ( val , self . maxDelta )
  elif len ( val . shape ) == 4 :
   if 84 - 84: I1I
   return tf . map_fn ( lambda o0OO : tf . image . random_hue ( o0OO , self . maxDelta ) , val )
  else :
   raise ValueError ( "Incorrect image augmentation parameter." )
   if 47 - 47: i1i1i1111I * I11iiIi11i1I + i1iiIII111 + Iii1i * Iii1i - OooOoo
class OO ( iiii1I11IIiI1 ) :
 if 18 - 18: ooo000 . oOo0O00 - Oo * i1iiIII111
 if 81 - 81: oOo0O00
 if 40 - 40: Ooo0Ooo - Oo / oOo0O00 - i1 % ooOOO
 if 85 - 85: i1I - iI1iII1I1I1i
 if 32 - 32: I1Ii1I1
 if 75 - 75: Ooo0Ooo . i1iiIII111 % IIiIIiIi11I1
 if 22 - 22: Ii / i1 / IiIIii11Ii
 def __init__ ( self , lower : float = 0.9 , upper : float = 1.1 ) :
  if 65 - 65: iI1iII1I1I1i / Oo - IiIIii11Ii / I1Ii1I1 % oOO
  if 34 - 34: IiI11Ii111 % i1I . i1I * IiI11Ii111 + IiIIii11Ii
  if 11 - 11: i1iiIII111 * i1I % i1I . ooOOO
  if 41 - 41: oOo0O00 * Ooo0Ooo + i1iiIII111 + OooOoo
  if 31 - 31: Iii1i . i1i1i1111I + I1Ii1I1 + OooOoo + I11iiIi11i1I
  if 49 - 49: IiIIii11Ii % ooOOO + Iii1i - i1i1i1111I
  if 65 - 65: IIiIIiIi11I1 - IiIIii11Ii % Oo . oOo0O00 * ooo000
  if 58 - 58: IiI11Ii111
  if 87 - 87: IIiIIiIi11I1 - OooOoo
  if 98 - 98: Ii + OooOoo * Iii1i % oOo0O00 . i1i1i1111I * iI1iII1I1I1i
  if 62 - 62: IIiIIiIi11I1 . ooOOO / Ooo0Ooo * i1 . Ooo0Ooo . Oo
  super ( ) . __init__ ( O00OO0 . Types . Contrast )
  if 29 - 29: Iii1i + IIiIIiIi11I1 * IiI11Ii111 % i1i1i1111I / ooOOO - IiIIii11Ii
  if 62 - 62: IIiIIiIi11I1 / oOo0O00 + I1Ii1I1
  self . lower = lower
  if 92 - 92: I1I * oOO / IIiIIiIi11I1 - I11iiIi11i1I * i1iiIII111
  if 12 - 12: Ii * ooo000 - I11iiIi11i1I
  self . upper = upper
  if 66 - 66: IiIIii11Ii
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Contrast' :
  if 46 - 46: Oo - i1iiIII111 * Ooo0Ooo + Ooo0Ooo * Ooo0Ooo . Ooo0Ooo
  if 72 - 72: Ii + i1 % i1 - ooOOO - Ooo0Ooo
  if 82 - 82: i1iiIII111
  if 73 - 73: Oo + Ooo0Ooo * Oo
  if 10 - 10: i1I / i1iiIII111
  if 54 - 54: OooOoo / ooOOO
  if 48 - 48: I11iiIi11i1I
  if 20 - 20: IiI11Ii111 - i1i1i1111I - i1I
  if 17 - 17: OooOoo
  if 83 - 83: i1I - oOo0O00 - ooo000 % IIiIIiIi11I1 % oOo0O00 % I11iiIi11i1I
  O0O0OO00o = OO ( )
  self . _copyAttributesTo ( O0O0OO00o , "lower" , "upper" )
  return O0O0OO00o
  if 62 - 62: IiI11Ii111 % I1I - i1I . i1 - Ii
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 45 - 45: Ii - ooOOO
  if 91 - 91: i1I - I1Ii1I1
  if 24 - 24: i1i1i1111I % ooOOO - OooOoo
  if 31 - 31: Oo
  if 18 - 18: ooo000 + Iii1i % IIiIIiIi11I1 . ooo000
  if 27 - 27: IiI11Ii111
  if 12 - 12: Ooo0Ooo % iI1iII1I1I1i / Iii1i * IiIIii11Ii % IiIIii11Ii
  if 29 - 29: Ooo0Ooo . I1Ii1I1 / Iii1i / Ooo0Ooo
  if 25 - 25: IIiIIiIi11I1 - IiIIii11Ii / IIiIIiIi11I1
  if 59 - 59: IiI11Ii111 - oOo0O00 * I1Ii1I1
  if 99 - 99: oOo0O00 % Iii1i . Iii1i + Ii * I1I
  if 96 - 96: I1I - Iii1i
  if 28 - 28: I11iiIi11i1I + I1Ii1I1
  if len ( val . shape ) == 3 :
   if 91 - 91: ooo000 + i1iiIII111 / i1 / i1iiIII111
   return tf . image . random_contrast ( val , self . lower , self . upper )
  elif len ( val . shape ) == 4 :
   if 53 - 53: Oo
   return tf . map_fn ( lambda o0OO : tf . image . random_contrast ( o0OO , self . lower , self . upper ) , val )
  else :
   raise ValueError ( "Incorrect image augmentation parameter." )
   if 72 - 72: OooOoo * i1 . Iii1i % Ooo0Ooo * i1I
class O0o0 ( iiii1I11IIiI1 ) :
 if 43 - 43: i1i1i1111I * Oo
 if 13 - 13: I11iiIi11i1I / iI1iII1I1I1i . IiI11Ii111 - I1I . ooo000 * Ooo0Ooo
 if 50 - 50: ooo000 / IiI11Ii111 * IIiIIiIi11I1 + I1Ii1I1
 if 65 - 65: i1
 if 21 - 21: i1I + ooOOO % Iii1i + I1I
 if 26 - 26: IiI11Ii111 - I1Ii1I1 . IiI11Ii111 * Iii1i + IIiIIiIi11I1 / IiIIii11Ii
 if 28 - 28: I1I * Oo * I1I
 def __init__ ( self , lower : float = 0.9 , upper : float = 1.1 ) :
  if 20 - 20: i1iiIII111 + iI1iII1I1I1i / i1iiIII111 * iI1iII1I1I1i - i1I . i1iiIII111
  if 7 - 7: Ii / ooo000 + iI1iII1I1I1i % Ii % i1i1i1111I - OooOoo
  if 90 - 90: OooOoo + IiI11Ii111 + oOO + IiI11Ii111
  if 10 - 10: I1Ii1I1 + IiI11Ii111 * i1 % I11iiIi11i1I % I1Ii1I1
  if 1 - 1: i1iiIII111 . ooOOO . iI1iII1I1I1i % IIiIIiIi11I1 - ooOOO - i1I
  if 12 - 12: i1i1i1111I - Ooo0Ooo
  if 46 - 46: IiIIii11Ii - I11iiIi11i1I / OooOoo / ooo000
  if 14 - 14: i1iiIII111 * ooOOO * i1I * Iii1i * OooOoo
  if 73 - 73: ooOOO % oOo0O00 % I1I
  if 86 - 86: i1iiIII111 + IIiIIiIi11I1 - ooo000 - i1 . oOO % Ooo0Ooo
  if 44 - 44: Iii1i + Ii * i1I * IiIIii11Ii . IiIIii11Ii % ooo000
  super ( ) . __init__ ( O00OO0 . Types . Saturation )
  if 96 - 96: I1I % I1I / IiIIii11Ii % i1I
  if 97 - 97: Iii1i - Oo
  self . lower = lower
  if 75 - 75: OooOoo . iI1iII1I1I1i * Iii1i
  if 54 - 54: oOO . i1 + Ii - I11iiIi11i1I
  self . upper = upper
  if 64 - 64: iI1iII1I1I1i . Iii1i / OooOoo * i1 . I1I
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Saturation' :
  if 71 - 71: i1i1i1111I . Iii1i / IiI11Ii111 % ooo000 - IIiIIiIi11I1
  if 55 - 55: I1Ii1I1 - Iii1i
  if 26 - 26: i1 - ooOOO + i1 % IiIIii11Ii - IIiIIiIi11I1 - Iii1i
  if 59 - 59: i1I . Iii1i * ooo000 + i1iiIII111 * oOo0O00 - I1I
  if 76 - 76: IIiIIiIi11I1 - i1iiIII111 . ooo000 + iI1iII1I1I1i
  if 26 - 26: i1i1i1111I / ooOOO - IiI11Ii111 * i1I . i1iiIII111
  if 35 - 35: oOO % i1 - Ii * IiIIii11Ii
  if 67 - 67: oOO - Ii . i1iiIII111 / Oo / OooOoo
  if 76 - 76: Ooo0Ooo - OooOoo
  if 41 - 41: I11iiIi11i1I - Ii . i1I
  O0O0OO00o = O0o0 ( )
  self . _copyAttributesTo ( O0O0OO00o , "lower" , "upper" )
  return O0O0OO00o
  if 42 - 42: oOo0O00 . i1i1i1111I . ooo000 + i1iiIII111 . IiI11Ii111
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 60 - 60: Ii . i1i1i1111I . Ii % iI1iII1I1I1i . I11iiIi11i1I / I11iiIi11i1I
  if 41 - 41: iI1iII1I1I1i - i1 * oOo0O00
  if 94 - 94: i1 + i1I - i1I / Ii
  if 71 - 71: Oo + Oo / I11iiIi11i1I % i1I + ooo000
  if 64 - 64: I11iiIi11i1I
  if 29 - 29: I1I . Iii1i
  if 45 - 45: oOO / ooOOO * I1Ii1I1
  if 46 - 46: Oo . i1I . Ii * IiIIii11Ii / oOo0O00 % Iii1i
  if 74 - 74: i1I / i1i1i1111I + I1Ii1I1
  if 41 - 41: IiI11Ii111 - i1I % i1 . i1 / oOO
  if 70 - 70: Ooo0Ooo - ooo000 - Ii - ooo000 * I11iiIi11i1I / i1I
  if 41 - 41: I1I
  if 100 - 100: I1I . IiI11Ii111 % IIiIIiIi11I1
  if len ( val . shape ) == 3 :
   if 71 - 71: iI1iII1I1I1i % oOo0O00
   return tf . image . random_saturation ( val , self . lower , self . upper )
  elif len ( val . shape ) == 4 :
   if 38 - 38: I1I * I11iiIi11i1I . I11iiIi11i1I . Ooo0Ooo / I1Ii1I1 / i1I
   return tf . map_fn ( lambda o0OO : tf . image . random_saturation ( o0OO , self . lower , self . upper ) , val )
  else :
   raise ValueError ( "Incorrect image augmentation parameter." )
   if 86 - 86: IiI11Ii111 * iI1iII1I1I1i
class iIi1iiIi ( iiii1I11IIiI1 ) :
 if 45 - 45: i1i1i1111I % i1iiIII111 % Oo
 if 29 - 29: i1i1i1111I . IIiIIiIi11I1
 if 66 - 66: i1iiIII111 . iI1iII1I1I1i - iI1iII1I1I1i - IIiIIiIi11I1
 if 10 - 10: oOO / IiI11Ii111 % Ii / Ii / OooOoo
 if 68 - 68: iI1iII1I1I1i + Ii + I11iiIi11i1I + IiI11Ii111
 if 97 - 97: Iii1i / I1I
 if 54 - 54: ooo000
 def __init__ ( self , maxDelta : float = 0.1 ) :
  if 57 - 57: IIiIIiIi11I1 % IiI11Ii111 . I1Ii1I1 * ooOOO
  if 98 - 98: I1Ii1I1 - i1iiIII111 - iI1iII1I1I1i + I1I . ooo000
  if 37 - 37: IIiIIiIi11I1 - IiIIii11Ii + oOo0O00 . i1 + iI1iII1I1I1i
  if 46 - 46: iI1iII1I1I1i + oOo0O00
  if 39 - 39: oOO % i1iiIII111 / Ooo0Ooo / IiI11Ii111 * Ii % Oo
  if 67 - 67: Oo . i1iiIII111 . Ooo0Ooo
  if 61 - 61: oOO / IiIIii11Ii
  if 10 - 10: Ooo0Ooo - Ooo0Ooo + IIiIIiIi11I1
  if 5 - 5: Ii + Ooo0Ooo * Iii1i % oOO % I11iiIi11i1I / I1I
  if 9 - 9: ooOOO / i1iiIII111 - Ii * IIiIIiIi11I1 / i1iiIII111
  super ( ) . __init__ ( O00OO0 . Types . Brightness )
  if 66 - 66: i1 . oOo0O00 * IiIIii11Ii * ooo000
  if 26 - 26: I1I / i1I % i1 / IiI11Ii111 + OooOoo + ooOOO
  self . maxDelta = maxDelta
  if 99 - 99: Ii - i1i1i1111I + i1iiIII111
 def copy ( self ) -> 'DataPreprocessing.Transformation.ImageAugmentation.Brightness' :
  if 44 - 44: I11iiIi11i1I - OooOoo * I1I - oOO % I1I . I1Ii1I1
  if 35 - 35: OooOoo * i1i1i1111I - Oo - I11iiIi11i1I * ooo000 * I1Ii1I1
  if 92 - 92: ooo000 % iI1iII1I1I1i % ooOOO * Ooo0Ooo - I1Ii1I1 * I1I
  if 81 - 81: I1I . oOO * ooOOO + IIiIIiIi11I1
  if 72 - 72: I1Ii1I1 * I11iiIi11i1I - i1I . I1I
  if 16 - 16: I1Ii1I1 / i1I * i1i1i1111I + I1Ii1I1 * i1
  if 18 - 18: Iii1i * I1Ii1I1 - i1 + i1I * ooOOO
  if 94 - 94: I11iiIi11i1I
  if 47 - 47: IiIIii11Ii + i1i1i1111I + oOO
  if 79 - 79: oOO + I11iiIi11i1I
  O0O0OO00o = iIi1iiIi ( )
  self . _copyAttributesTo ( O0O0OO00o , "maxDelta" )
  return O0O0OO00o
  if 31 - 31: ooOOO
 def augmentTo ( self , val : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 99 - 99: Ii
  if 30 - 30: i1 - I1I . I1Ii1I1
  if 65 - 65: IIiIIiIi11I1 - I1I
  if 42 - 42: IiI11Ii111 + oOo0O00 . i1I - ooo000 % iI1iII1I1I1i + Oo
  if 55 - 55: Ooo0Ooo % OooOoo * I1I . IiIIii11Ii / Ii
  if 68 - 68: oOO / oOO - ooo000 + oOo0O00
  if 81 - 81: iI1iII1I1I1i + ooo000
  if 7 - 7: I11iiIi11i1I * I1Ii1I1 % Iii1i / I1Ii1I1 % oOO + iI1iII1I1I1i
  if 23 - 23: oOo0O00 % iI1iII1I1I1i - I1I * I1I - i1i1i1111I
  if 51 - 51: Iii1i / oOO
  if 38 - 38: Oo . I1Ii1I1 - ooo000 * OooOoo
  if 66 - 66: i1
  if 27 - 27: oOo0O00 - Ii % oOo0O00 % IIiIIiIi11I1 * i1I + i1i1i1111I
  if len ( val . shape ) == 3 :
   if 81 - 81: Ooo0Ooo
   return tf . image . random_brightness ( val , self . maxDelta )
  elif len ( val . shape ) == 4 :
   if 31 - 31: i1 * Ii * i1
   return tf . map_fn ( lambda o0OO : tf . image . random_brightness ( o0OO , self . maxDelta ) , val )
  else :
   raise ValueError ( "Incorrect image augmentation parameter." )
   if 13 - 13: Oo
class O00OO0 :
 if 50 - 50: ooo000 / I1Ii1I1 - I11iiIi11i1I / ooOOO
 if 47 - 47: i1i1i1111I + Iii1i + oOO
 if 82 - 82: IiI11Ii111 - OooOoo - I1Ii1I1
 if 74 - 74: Oo . Iii1i * I11iiIi11i1I
 if 40 - 40: i1i1i1111I - ooo000 . Ooo0Ooo * Ii * Ii
 if 24 - 24: oOo0O00 . i1I - Oo . iI1iII1I1I1i
 if 34 - 34: i1iiIII111 * I11iiIi11i1I / IiI11Ii111 * ooo000 . OooOoo
 class Types ( II1i1I ) :
  if 40 - 40: Iii1i . ooo000 - IIiIIiIi11I1
  if 70 - 70: i1iiIII111 + i1 - i1i1i1111I / IiIIii11Ii - Ii
  if 23 - 23: OooOoo + I11iiIi11i1I / I1I % ooOOO + ooOOO * Iii1i
  if 59 - 59: i1i1i1111I
  if 83 - 83: iI1iII1I1I1i
  if 97 - 97: I11iiIi11i1I % IiIIii11Ii
  if 4 - 4: Iii1i / IiIIii11Ii
  if 82 - 82: Ooo0Ooo . iI1iII1I1I1i - ooOOO . i1iiIII111 % i1 / I1I
  Crop = 1
  if 100 - 100: IIiIIiIi11I1
  if 98 - 98: ooOOO
  Flip = 2
  if 59 - 59: IiIIii11Ii + i1i1i1111I + i1I / I1Ii1I1 % oOo0O00
  if 97 - 97: I1Ii1I1 / I1Ii1I1 . oOO % IiIIii11Ii . I1Ii1I1
  Rotate = 3
  if 7 - 7: IiIIii11Ii % Oo / ooo000 - Iii1i % Oo
  if 21 - 21: Ooo0Ooo % i1iiIII111 / i1iiIII111 . Ii
  Hue = 4
  if 62 - 62: OooOoo / IiI11Ii111 + i1 . oOo0O00 % Ii / i1
  if 89 - 89: Ii + I1Ii1I1
  Contrast = 5
  if 63 - 63: ooo000 % i1 / oOO
  if 30 - 30: oOo0O00 + i1 . ooo000 - ooOOO + I1I
  Saturation = 6
  if 77 - 77: ooOOO % oOO / I11iiIi11i1I + I1I . i1
  if 4 - 4: ooOOO - oOo0O00 . Ooo0Ooo % i1 * OooOoo
  Brightness = 7
  if 76 - 76: I11iiIi11i1I . Iii1i + Ii + I11iiIi11i1I + Oo - i1iiIII111
 Config = iiii1I11IIiI1
 Crop = Ooo000oO
 Flip = OoOoOoOO
 Rotate = OoOOooo
 Hue = oOoOOo
 Contrast = OO
 Saturation = O0o0
 Brightness = iIi1iiIi
 if 75 - 75: i1iiIII111
class oOoOoo0oO0 ( II1i1I ) :
 if 16 - 16: I1I / IIiIIiIi11I1 - Oo / IiI11Ii111 . Ii
 if 62 - 62: ooOOO + i1I - i1
 if 73 - 73: i1i1i1111I
 if 61 - 61: IIiIIiIi11I1
 if 33 - 33: Iii1i . ooOOO / ooo000 + I11iiIi11i1I % ooOOO * I11iiIi11i1I
 if 51 - 51: IIiIIiIi11I1 * IIiIIiIi11I1 / oOo0O00
 if 100 - 100: ooo000 % ooo000 - Iii1i
 if 57 - 57: ooo000 / ooo000
 Columns = 1
 if 94 - 94: oOo0O00
 Image = 2
 if 61 - 61: OooOoo . oOO . Oo
 ImageAugmentation = 3
 if 70 - 70: I1I
class Oo000oO00O :
 if 56 - 56: I1I % OooOoo % OooOoo + i1I % oOo0O00
 if 1 - 1: i1I / IiIIii11Ii / Oo
 if 52 - 52: OooOoo
 if 51 - 51: i1iiIII111 * iI1iII1I1I1i - OooOoo + Ooo0Ooo * Ooo0Ooo
 if 72 - 72: Ii % Oo / Ooo0Ooo
 if 26 - 26: I11iiIi11i1I - iI1iII1I1I1i . OooOoo + ooOOO
 if 83 - 83: i1 . i1 + ooo000 - I1Ii1I1 + IiI11Ii111
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'DataPreprocessing.Transformation.Config' :
  if 66 - 66: i1 % Iii1i
  if 27 - 27: i1 + IiIIii11Ii % ooo000 / I11iiIi11i1I . oOO
  if 45 - 45: IiI11Ii111 / oOO
  if 60 - 60: Iii1i + i1i1i1111I
  if 11 - 11: IiI11Ii111 % oOo0O00 - iI1iII1I1I1i
  if 43 - 43: IIiIIiIi11I1 * iI1iII1I1I1i / iI1iII1I1I1i
  if 5 - 5: IiI11Ii111 % i1I . Ooo0Ooo
  if 59 - 59: IiI11Ii111 . IiIIii11Ii + i1iiIII111 - IIiIIiIi11I1 % iI1iII1I1I1i
  if 30 - 30: Oo - I1I . ooOOO * i1iiIII111 . IIiIIiIi11I1
  if 27 - 27: i1I % Ii . Iii1i % oOo0O00
  if 15 - 15: IIiIIiIi11I1 * Ooo0Ooo + ooOOO % Ii / I1Ii1I1 - Oo
  if 88 - 88: I11iiIi11i1I * iI1iII1I1I1i - Ooo0Ooo . i1I % Oo
  if 50 - 50: iI1iII1I1I1i % i1 / Ooo0Ooo
  if 32 - 32: Oo . ooOOO . oOO
  if "_instanceClass" in obj :
   O0OOooOOO0 = getattr ( Oo000oO00O , Oo000oO00O . Types . getName ( obj [ "_instanceClass" ] ) )
   ii1iiI1111 = getattr ( O0OOooOOO0 , O0OOooOOO0 . Types ( obj [ "_method" ] ) . name ) ( )
   ii1iiI1111 . parseJSON ( obj )
   return ii1iiI1111
  else :
   return obj
   if 66 - 66: I1Ii1I1 * i1I + i1I
 Types = oOoOoo0oO0
 Config = ooo0
 Columns = oOO0o00oOOo00
 Image = Ii1iI11
 ImageAugmentation = O00OO0
 if 9 - 9: Iii1i - I11iiIi11i1I * Oo + IiIIii11Ii * oOO
class O000oOo0 :
 def __init__ ( self , colSel : str = "None:None" , minV : float = 0 , maxV : float = 360 ) :
  if 100 - 100: I1I + i1 - Ii
  if 91 - 91: iI1iII1I1I1i / I1I - Oo
  if 68 - 68: i1I + IIiIIiIi11I1 - Iii1i
  if 64 - 64: Ooo0Ooo
  if 97 - 97: ooOOO + Oo % oOo0O00 + Iii1i . Ii
  if 96 - 96: Ii + IiIIii11Ii - Ii - i1 / Ii . Ooo0Ooo
  if 40 - 40: iI1iII1I1I1i
  if 99 - 99: I1Ii1I1 - Ooo0Ooo % I1Ii1I1 % oOO / I11iiIi11i1I
  if 85 - 85: oOo0O00 * iI1iII1I1I1i / I1I
  if 96 - 96: i1I + IIiIIiIi11I1 * i1I
  if 95 - 95: IiIIii11Ii / IiI11Ii111 . I1I - Ooo0Ooo - i1iiIII111
  if 36 - 36: IiIIii11Ii * iI1iII1I1I1i % i1 % IIiIIiIi11I1
  if 9 - 9: i1iiIII111
  if 25 - 25: OooOoo * i1I + Ooo0Ooo . IIiIIiIi11I1 * iI1iII1I1I1i
  if 16 - 16: I1I + ooo000 * Oo . oOo0O00 - i1
  if 90 - 90: ooOOO
  if 8 - 8: ooo000 + Ii
  if 6 - 6: I1I . Ooo0Ooo . ooo000
  if 64 - 64: OooOoo + Iii1i - Oo - OooOoo
  self . colSel = colSel
  if 58 - 58: iI1iII1I1I1i * iI1iII1I1I1i . I1I - i1iiIII111 * Iii1i
  self . min = minV
  if 53 - 53: iI1iII1I1I1i / i1I / IiI11Ii111
  self . max = maxV
  if 4 - 4: I1I + oOO % Oo * Ooo0Ooo - ooo000 - OooOoo
 @ property
 def range ( self ) -> float :
  if 22 - 22: OooOoo . IiIIii11Ii * i1 + i1i1i1111I
  if 51 - 51: i1I / i1iiIII111 . oOo0O00 % ooOOO - OooOoo - i1iiIII111
  if 54 - 54: oOo0O00
  if 50 - 50: I1Ii1I1 % Ii * I1I * Ooo0Ooo
  if 80 - 80: ooo000
  if 89 - 89: i1iiIII111
  if 91 - 91: Ii + I1Ii1I1 * i1i1i1111I - ooOOO / IiI11Ii111 . IIiIIiIi11I1
  if 29 - 29: OooOoo
  if 20 - 20: Ooo0Ooo . iI1iII1I1I1i - ooo000 - oOo0O00 + Iii1i * i1iiIII111
  if 30 - 30: I1Ii1I1 * I1Ii1I1 + Oo * Ooo0Ooo * ooOOO % i1
  return self . max - self . min
  if 43 - 43: I1Ii1I1 * I11iiIi11i1I
 def copy ( self ) -> 'DataPreprocessing.CircularConfig' :
  if 96 - 96: iI1iII1I1I1i . Iii1i % oOO + i1i1i1111I
  if 31 - 31: i1iiIII111 . i1 - Oo / ooo000 / iI1iII1I1I1i
  if 72 - 72: ooo000 % IiIIii11Ii + IiIIii11Ii + Ooo0Ooo / i1iiIII111 . Oo
  if 4 - 4: IiIIii11Ii . IiIIii11Ii * Iii1i - IiIIii11Ii
  if 21 - 21: Ii + ooo000 % IIiIIiIi11I1 % oOo0O00 + i1i1i1111I
  if 17 - 17: i1I + i1I
  if 90 - 90: Ooo0Ooo % I1Ii1I1 * oOO + IiI11Ii111 - OooOoo
  if 52 - 52: Ooo0Ooo + Iii1i
  if 5 - 5: I1Ii1I1 * IiIIii11Ii + IiIIii11Ii . i1i1i1111I
  if 62 - 62: IiIIii11Ii - i1I . IIiIIiIi11I1 / ooOOO % i1I
  return O000oOo0 ( colSel = self . colSel , minV = self . min , maxV = self . max )
  if 43 - 43: I1Ii1I1 . iI1iII1I1I1i
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 26 - 26: i1iiIII111 + Iii1i % i1i1i1111I
  if 80 - 80: I1Ii1I1 - I1I . Ooo0Ooo + i1i1i1111I
  if 51 - 51: ooo000 * i1iiIII111 . OooOoo
  if 90 - 90: i1 + OooOoo / ooOOO / iI1iII1I1I1i
  if 6 - 6: I11iiIi11i1I * Iii1i . ooOOO . Oo % i1I / iI1iII1I1I1i
  if 10 - 10: oOO % Ii + IiI11Ii111 % ooOOO * i1
  if 58 - 58: Oo % ooo000 / I11iiIi11i1I
  if 15 - 15: i1 % Iii1i . Iii1i % i1iiIII111
  if 66 - 66: IiI11Ii111 % i1iiIII111 . I11iiIi11i1I * oOO . Oo
  if 35 - 35: I1I
  if 28 - 28: Iii1i * Ii + oOO
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "cols" :
    if 95 - 95: Ii
    self . colSel = iiiiIi1IiiIi
   else :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 44 - 44: i1 * I11iiIi11i1I + Ooo0Ooo * i1I
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'DataPreprocessing.CircularConfig' :
  if 76 - 76: I1Ii1I1
  if 14 - 14: Oo . Ooo0Ooo
  if 90 - 90: oOo0O00 % Iii1i - i1i1i1111I / I1Ii1I1
  if 38 - 38: Ooo0Ooo - OooOoo + Oo % OooOoo
  if 91 - 91: IiIIii11Ii * I11iiIi11i1I % ooo000 / Ii / ooOOO - IiI11Ii111
  if 66 - 66: i1I + i1iiIII111 * i1i1i1111I % ooo000 / Iii1i
  if 75 - 75: i1 . i1
  if 11 - 11: Ooo0Ooo + Ooo0Ooo + IiIIii11Ii * Oo - ooo000 - IiIIii11Ii
  if 63 - 63: Oo * Iii1i / i1I + IiIIii11Ii % Ii
  if 39 - 39: i1I % ooo000
  if 38 - 38: ooo000 . IiIIii11Ii + I11iiIi11i1I . OooOoo - i1I * i1iiIII111
  if 25 - 25: i1 / Iii1i
  if 61 - 61: oOO + IIiIIiIi11I1
  OoO = O000oOo0 ( )
  OoO . parseJSON ( obj )
  return OoO
  if 13 - 13: i1I * IiIIii11Ii
class iII11iiiii :
 if 100 - 100: ooOOO - oOO + ooo000
 if 16 - 16: Iii1i * i1iiIII111 * I1I % i1 % oOo0O00
 if 5 - 5: IiIIii11Ii / ooOOO + IIiIIiIi11I1 / I11iiIi11i1I % IiIIii11Ii
 if 73 - 73: Oo % I1Ii1I1 % Ooo0Ooo . ooo000 % IiIIii11Ii
 if 49 - 49: I1Ii1I1 / IiI11Ii111 + OooOoo - Ooo0Ooo - I1Ii1I1
 if 18 - 18: oOO - i1
 if 11 - 11: i1iiIII111 - i1
 Node = OO0O0
 Transformation = Oo000oO00O
 CircularConfig = O000oOo0
 if 33 - 33: oOO
class I1I11ii :
 if 18 - 18: i1i1i1111I . IIiIIiIi11I1 - Iii1i . OooOoo - i1I
 if 38 - 38: OooOoo . ooo000 * i1I
 if 37 - 37: i1 - I1I + ooOOO
 if 13 - 13: i1 + i1i1i1111I % I1I . i1 / Oo * I11iiIi11i1I
 if 56 - 56: Ooo0Ooo * i1I - Ii * Ooo0Ooo - IIiIIiIi11I1 * ooOOO
 if 61 - 61: OooOoo * Oo . Ii . oOo0O00
 if 1 - 1: I11iiIi11i1I / i1 + iI1iII1I1I1i * I1Ii1I1 % ooo000
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] , train : 'Train' ) -> 'Config' :
  if 3 - 3: oOO
  if 58 - 58: IIiIIiIi11I1 * IiIIii11Ii % i1 * I1I
  if 96 - 96: OooOoo / I1I + i1I
  if 29 - 29: OooOoo / OooOoo + IIiIIiIi11I1 + iI1iII1I1I1i - I1Ii1I1
  if 59 - 59: IiIIii11Ii + i1iiIII111 - I1Ii1I1 . Oo
  if 85 - 85: IiIIii11Ii % i1i1i1111I / oOo0O00 . oOo0O00 % Ooo0Ooo
  if 5 - 5: ooo000 * I1I
  if 68 - 68: ooo000 % oOO
  if 63 - 63: oOo0O00 % Iii1i / oOo0O00 * i1iiIII111 - i1I
  if 99 - 99: IiIIii11Ii / I11iiIi11i1I * oOo0O00 % IIiIIiIi11I1 - Ii
  if 50 - 50: i1 * i1I * I11iiIi11i1I / i1 + OooOoo
  if 83 - 83: OooOoo . oOo0O00 + i1i1i1111I - IIiIIiIi11I1 - oOo0O00 % Ooo0Ooo
  if 96 - 96: iI1iII1I1I1i * i1i1i1111I % i1I % I11iiIi11i1I
  if 56 - 56: Ooo0Ooo * i1i1i1111I
  if 29 - 29: IiI11Ii111 + oOo0O00 * i1iiIII111 * OooOoo % i1i1i1111I
  IIii1I1ii1IIi = OOoO0o00OOO ( )
  if 99 - 99: IIiIIiIi11I1 % iI1iII1I1I1i * i1i1i1111I % IIiIIiIi11I1 * oOO
  if 81 - 81: OooOoo / Ii . Oo % Iii1i . ooOOO . I1Ii1I1
  IIii1I1ii1IIi . parseJSON ( obj , train )
  if 65 - 65: Ooo0Ooo * Ii % I1Ii1I1 - i1iiIII111
  return IIii1I1ii1IIi
  if 11 - 11: i1iiIII111 - i1iiIII111 % Oo
class o0OOo000o00 ( II1i1I ) :
 if 2 - 2: ooOOO
 if 81 - 81: IIiIIiIi11I1 % ooOOO / I1Ii1I1
 if 85 - 85: oOo0O00 - i1I
 if 51 - 51: OooOoo + oOo0O00 % I1I % Ii
 if 45 - 45: iI1iII1I1I1i
 if 16 - 16: OooOoo - i1iiIII111 * I1Ii1I1 . I1I * ooOOO
 if 27 - 27: i1 + Ooo0Ooo
 if 60 - 60: iI1iII1I1I1i * IIiIIiIi11I1 * IIiIIiIi11I1
 Config = 0
 if 57 - 57: OooOoo + ooo000
 if 99 - 99: IIiIIiIi11I1 % Ii + I1I
 Layer = 1
 if 86 - 86: Iii1i
 if 39 - 39: i1I * IiI11Ii111 - ooOOO . IIiIIiIi11I1 . i1i1i1111I - I1Ii1I1
 ComputationalUnit = 2
 if 66 - 66: Ooo0Ooo
 if 11 - 11: IiI11Ii111 % IIiIIiIi11I1 . ooo000 + Ooo0Ooo - IIiIIiIi11I1 % ooOOO
 TFHub = 3
 if 61 - 61: i1i1i1111I * iI1iII1I1I1i
 if 16 - 16: i1 + IiIIii11Ii
 NOMModel = 4
 if 50 - 50: i1 % Ii * OooOoo / IiIIii11Ii
class II1iII1I11I :
 if 63 - 63: Iii1i + IIiIIiIi11I1
 if 72 - 72: Ii
 if 85 - 85: I11iiIi11i1I / i1 * IiI11Ii111 * oOo0O00
 if 60 - 60: Ooo0Ooo + i1i1i1111I * ooo000 / i1i1i1111I
 if 34 - 34: IiI11Ii111 * ooo000 / i1 * i1I . ooo000
 if 23 - 23: ooo000 + oOo0O00 * i1 + i1I
 if 98 - 98: i1I
 def __init__ ( self , name : str = "" , nodeType : '_ModelNodeTypes' = o0OOo000o00 . Config ) :
  if 41 - 41: IiI11Ii111
  if 44 - 44: I1I - Ii . ooo000 * I1I
  if 50 - 50: Oo * Ii
  if 46 - 46: ooo000 . Ii + I11iiIi11i1I - Ii - I11iiIi11i1I + Oo
  if 12 - 12: IiIIii11Ii * I1I
  if 89 - 89: i1 - Ooo0Ooo % I1Ii1I1 + I1Ii1I1 - i1iiIII111 % i1I
  if 96 - 96: iI1iII1I1I1i - IIiIIiIi11I1 - Ii * IiIIii11Ii + oOo0O00
  if 67 - 67: Ii % i1i1i1111I - i1I / ooo000 % IiI11Ii111
  if 98 - 98: i1iiIII111 . oOO + IIiIIiIi11I1 / Ii . OooOoo
  if 74 - 74: Oo / I1I
  if 17 - 17: i1I % IIiIIiIi11I1 / Ooo0Ooo + Iii1i
  if 21 - 21: i1
  self . _nodeType = nodeType
  if 56 - 56: oOo0O00 % IiIIii11Ii . IIiIIiIi11I1 - OooOoo . IiI11Ii111
  if 9 - 9: I1Ii1I1 + IiIIii11Ii * i1I . Ooo0Ooo + i1i1i1111I
  self . name = name
  if 61 - 61: IiIIii11Ii * oOO + I1Ii1I1 % OooOoo
  if 29 - 29: IiIIii11Ii + oOO / oOO + Iii1i - I1I - Iii1i
  self . fromSource = i1i1iiIi1I ( )
  if 68 - 68: Oo - I1I + IiI11Ii111 + Ooo0Ooo * oOo0O00
  if 63 - 63: I11iiIi11i1I - oOo0O00
  self . fromNode = OO0OOoO0 ( )
  if 20 - 20: Oo / Oo . IiIIii11Ii % Ii * I11iiIi11i1I
  if 70 - 70: oOO
  self . toNode = OO0OOoO0 ( )
  if 62 - 62: oOo0O00 - Iii1i + i1iiIII111
  if 70 - 70: Iii1i
  self . _order = oo0OOOOOOo0oO0 ( )
  if 99 - 99: Ooo0Ooo % I1I - oOo0O00 - i1iiIII111 - i1 / i1
  if 39 - 39: ooOOO - i1I * i1 - I1I
  self . train = None
  if 62 - 62: OooOoo / Ooo0Ooo * I11iiIi11i1I / IiI11Ii111 . i1i1i1111I
  if 45 - 45: I1Ii1I1
  self . _dataType = tf . float32
  if 28 - 28: I1I + IIiIIiIi11I1 % oOo0O00 / i1iiIII111
  if 7 - 7: Oo / oOo0O00 % Iii1i
  self . _shape = [ [ ] ]
  if 41 - 41: ooOOO . OooOoo - Iii1i - IIiIIiIi11I1 % i1I * Ooo0Ooo
  if 21 - 21: ooOOO . i1I + iI1iII1I1I1i - Ooo0Ooo / ooo000
  self . _outputTensor = None
  self . _built = False
  self . _inputCollections = [ ]
  self . _weights = [ ]
  self . weightLogging = True
  if 3 - 3: i1iiIII111 % Oo % oOO % iI1iII1I1I1i . oOo0O00
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 63 - 63: ooo000 / IiIIii11Ii - IiI11Ii111 / I11iiIi11i1I - IiIIii11Ii % I11iiIi11i1I
  if 58 - 58: IiI11Ii111 % IiIIii11Ii * IiIIii11Ii
  if 58 - 58: i1
  if 15 - 15: oOO % ooOOO + IiI11Ii111 + i1i1i1111I - i1 - i1I
  if 41 - 41: IIiIIiIi11I1 + ooOOO
  if 62 - 62: ooOOO - iI1iII1I1I1i / I1Ii1I1 * i1i1i1111I
  if 19 - 19: ooOOO % I11iiIi11i1I
  if 59 - 59: ooo000 + IiI11Ii111 . oOO . i1I
  if 67 - 67: IiIIii11Ii + i1I - oOO * i1
  if 17 - 17: IiI11Ii111 / Iii1i . i1iiIII111 . Iii1i % oOo0O00 + IiIIii11Ii
  if 95 - 95: iI1iII1I1I1i
  pass
  if 30 - 30: oOO + oOo0O00 + i1iiIII111 . i1I
 @ staticmethod
 def nodeType ( self ) -> 'ModelNode.Types' :
  if 9 - 9: ooOOO / I1Ii1I1 + Ooo0Ooo + IIiIIiIi11I1 / Oo
  if 18 - 18: i1 % i1
  if 8 - 8: i1 + IiIIii11Ii / IiIIii11Ii / IiI11Ii111
  if 61 - 61: oOO % i1I . ooo000
  if 21 - 21: Oo / ooo000 % I11iiIi11i1I . oOO - IIiIIiIi11I1
  if 98 - 98: IIiIIiIi11I1 + oOO % IIiIIiIi11I1 / iI1iII1I1I1i / i1 - Ii
  if 76 - 76: i1 - I11iiIi11i1I % i1 * Ooo0Ooo
  if 50 - 50: i1I . i1I - I11iiIi11i1I - i1iiIII111
  if 43 - 43: Ii
  if 88 - 88: ooOOO + Ii + OooOoo - ooo000 % IiI11Ii111 / Iii1i
  return self . _nodeType
  if 88 - 88: Iii1i
 @ staticmethod
 def shape ( self ) -> 'list[list[int]]' :
  if 57 - 57: I1Ii1I1 / OooOoo * IiIIii11Ii - iI1iII1I1I1i / I11iiIi11i1I
  if 21 - 21: ooo000 + Iii1i / i1iiIII111
  if 80 - 80: i1i1i1111I * IiIIii11Ii * Ooo0Ooo
  if 64 - 64: i1i1i1111I
  if 59 - 59: I1I + oOO % iI1iII1I1I1i * I1Ii1I1
  if 36 - 36: oOO + i1I . iI1iII1I1I1i % Ii * I11iiIi11i1I % oOo0O00
  if 1 - 1: i1iiIII111 + oOO / IiIIii11Ii . I1I
  if 95 - 95: IiI11Ii111 + IIiIIiIi11I1 * Ooo0Ooo / I11iiIi11i1I
  if 28 - 28: Ii + Iii1i - i1i1i1111I + Ii / Ooo0Ooo
  if 78 - 78: I1Ii1I1 - OooOoo . Oo % i1iiIII111
  return self . _shape
  if 50 - 50: oOO / Iii1i - IIiIIiIi11I1 / i1iiIII111 % i1
 @ staticmethod
 def order ( self ) -> 'list[int]' :
  if 58 - 58: OooOoo % oOo0O00 . i1I * oOo0O00 / i1i1i1111I
  if 29 - 29: IIiIIiIi11I1 . Iii1i / I1I - i1I
  if 5 - 5: I11iiIi11i1I + Ii / oOO - I11iiIi11i1I + I1I
  if 55 - 55: Ooo0Ooo . I1Ii1I1 - oOO / Ooo0Ooo - i1iiIII111
  if 86 - 86: ooo000 . IIiIIiIi11I1 - IiIIii11Ii + i1I
  if 46 - 46: i1iiIII111 / Oo + i1iiIII111 . iI1iII1I1I1i
  if 62 - 62: IiIIii11Ii / oOo0O00 . I1Ii1I1 . oOO + IiI11Ii111 * I11iiIi11i1I
  if 71 - 71: Iii1i
  if 81 - 81: i1iiIII111 + iI1iII1I1I1i % I1I / IIiIIiIi11I1 + I11iiIi11i1I
  if 38 - 38: OooOoo - I11iiIi11i1I . Iii1i
  return self . _order
  if 20 - 20: Iii1i . i1i1i1111I + IiIIii11Ii
 @ property
 def dtype ( self ) :
  if 8 - 8: oOo0O00 * i1 % ooo000 . ooo000
  if 2 - 2: Oo * Oo - i1iiIII111 . IiIIii11Ii * ooo000
  if 56 - 56: i1
  if 83 - 83: ooOOO . IiIIii11Ii - Ii
  if 6 - 6: oOo0O00
  if 43 - 43: Ii + oOO * OooOoo % IIiIIiIi11I1 / Iii1i
  if 52 - 52: Ii % ooo000 * IiI11Ii111 + IiI11Ii111 + i1
  if 43 - 43: IiIIii11Ii * I11iiIi11i1I * i1 . ooo000
  if 28 - 28: ooo000 / IIiIIiIi11I1 + I1Ii1I1 / IiIIii11Ii + i1iiIII111
  if 99 - 99: Oo * Ii - i1 % IiIIii11Ii / i1i1i1111I
  return self . _dataType
  if 98 - 98: I1Ii1I1 * ooOOO + IiI11Ii111
 def isFinal ( self ) -> bool :
  if 81 - 81: ooo000 - i1 * IiI11Ii111 * Ii . Ii * ooOOO
  if 46 - 46: oOO % Iii1i
  if 35 - 35: oOO * Ooo0Ooo % I1Ii1I1 - Oo + Iii1i + i1I
  if 49 - 49: iI1iII1I1I1i
  if 7 - 7: I11iiIi11i1I % I1I - IIiIIiIi11I1 . i1I . I11iiIi11i1I
  if 15 - 15: oOO - Oo % Iii1i / i1
  if 81 - 81: ooo000 + Oo % I1Ii1I1 * Oo % IiIIii11Ii
  if 7 - 7: ooo000
  if 33 - 33: Ooo0Ooo + OooOoo - IiIIii11Ii
  if 57 - 57: OooOoo . IiIIii11Ii
  pass
  if 29 - 29: OooOoo . ooo000 - I11iiIi11i1I % iI1iII1I1I1i
 def switchOffWeightLogging ( self ) :
  if 51 - 51: i1I / IiIIii11Ii
  if 64 - 64: i1I * IIiIIiIi11I1 + IiIIii11Ii + oOO . i1I . I11iiIi11i1I
  if 79 - 79: iI1iII1I1I1i . i1 / i1iiIII111 . IIiIIiIi11I1
  if 13 - 13: ooOOO . ooo000 / ooOOO . ooOOO
  if 58 - 58: Ooo0Ooo
  if 43 - 43: ooOOO
  if 34 - 34: IiIIii11Ii
  self . weightLogging = False
  if 24 - 24: oOo0O00 + I11iiIi11i1I + OooOoo * IiI11Ii111
 def _clearTempTensors ( self ) :
  if 54 - 54: oOo0O00 % IiIIii11Ii * i1i1i1111I + i1I * i1 . iI1iII1I1I1i
  if 72 - 72: ooOOO
  if 77 - 77: Ooo0Ooo - Iii1i / I1I % I1I % iI1iII1I1I1i
  if 32 - 32: i1iiIII111 - I1Ii1I1 * I1Ii1I1 + Ooo0Ooo - Iii1i
  if 91 - 91: Oo + Ooo0Ooo + ooOOO + Iii1i
  if 22 - 22: Oo * IiIIii11Ii / oOo0O00 / OooOoo
  if 42 - 42: ooo000 + oOO . I1I
  self . _weights = [ ]
  if 19 - 19: OooOoo * I1I . ooOOO % Oo
 def _build ( self , buildNo : int ) :
  if 89 - 89: i1i1i1111I + i1I . IiIIii11Ii
  if 35 - 35: IiIIii11Ii * OooOoo
  if 62 - 62: IiIIii11Ii . oOO - I11iiIi11i1I
  if 82 - 82: I11iiIi11i1I
  if 36 - 36: I1Ii1I1 % Iii1i * I1Ii1I1 - i1i1i1111I - ooo000 / I1I
  if 27 - 27: I1Ii1I1 . IiI11Ii111 * I1I
  if 63 - 63: i1 . Ooo0Ooo / I1Ii1I1 - i1 - i1
  if 20 - 20: iI1iII1I1I1i / Ooo0Ooo - oOo0O00 - Ooo0Ooo
  if 79 - 79: I11iiIi11i1I % i1I . oOo0O00
  if 98 - 98: iI1iII1I1I1i % iI1iII1I1I1i * i1I + OooOoo
  self . _clearTempTensors ( )
  raise ValueError ( "Model Node cannot be built directly. Please opt for a specific layer profile like ModelNode.Layer.Convolution or a CustomLayerProfile." )
  if 74 - 74: IiI11Ii111 + I1I % i1i1i1111I
 @ staticmethod
 def updateNodeName ( nodeNameOrKey : str ) -> str :
  if 26 - 26: IiIIii11Ii - IIiIIiIi11I1 * ooo000 / Ooo0Ooo
  if 65 - 65: IiI11Ii111 * i1iiIII111 . i1
  if 52 - 52: iI1iII1I1I1i - I11iiIi11i1I * I1Ii1I1 / I1I . ooo000 . Oo
  if 92 - 92: Oo / iI1iII1I1I1i - Iii1i % i1 + Ii + I1I
  if 71 - 71: i1 % I1I / i1iiIII111 . Oo * Iii1i % Oo
  if 51 - 51: oOO + I1Ii1I1 . Ooo0Ooo / OooOoo
  if 69 - 69: Oo
  if 77 - 77: I11iiIi11i1I % IiI11Ii111
  if 83 - 83: i1i1i1111I / IiIIii11Ii . ooOOO
  if 100 - 100: i1I / oOO - IiIIii11Ii . i1 - i1i1i1111I + i1iiIII111
  if 75 - 75: Iii1i
  if 87 - 87: Iii1i - Ooo0Ooo % i1 / ooo000
  if 46 - 46: oOo0O00
  return re . sub ( r"\s" , "" , nodeNameOrKey )
  if 51 - 51: OooOoo
class OOoO0o00OOO ( II1iII1I11I ) :
 def __init__ ( self , name : str = None , unitNamespace : str = None ) :
  if 53 - 53: OooOoo / IIiIIiIi11I1 + IiI11Ii111 % OooOoo / Oo + oOO
  if 90 - 90: Oo - i1
  if 44 - 44: Ooo0Ooo
  if 17 - 17: Ii
  if 68 - 68: i1i1i1111I . IIiIIiIi11I1 + IiI11Ii111
  if 75 - 75: Iii1i * OooOoo - IiI11Ii111 * I11iiIi11i1I
  if 9 - 9: i1I
  if 79 - 79: IiIIii11Ii * Ooo0Ooo / ooo000 % Ooo0Ooo
  if 48 - 48: oOO
  if 28 - 28: i1i1i1111I % oOO - I1Ii1I1 * Oo
  if 38 - 38: iI1iII1I1I1i
  if 29 - 29: Ii / iI1iII1I1I1i % ooOOO . I1I
  if 75 - 75: I1I
  if 80 - 80: IiI11Ii111
  if 20 - 20: Ii
  if 44 - 44: ooo000 * ooo000 / IIiIIiIi11I1 . I1Ii1I1 . oOo0O00 * IIiIIiIi11I1
  if 37 - 37: iI1iII1I1I1i + I11iiIi11i1I % oOO * IiI11Ii111 % I1Ii1I1
  super ( ) . __init__ ( nodeType = o0OOo000o00 . ComputationalUnit , name = name )
  if 9 - 9: iI1iII1I1I1i / i1
  if 69 - 69: i1iiIII111
  self . _tfInit = True
  if 23 - 23: I1I % I1Ii1I1
  if 18 - 18: I1Ii1I1 - ooOOO + Oo . i1I + i1
  self . _unitNamespace = unitNamespace
  if 71 - 71: IIiIIiIi11I1 + oOo0O00 + i1i1i1111I / oOO % oOo0O00 - IiIIii11Ii
  if 77 - 77: oOO - Ii . IIiIIiIi11I1
  self . _tfFunctionName = None
  if 81 - 81: ooOOO / I1I - Ooo0Ooo - I11iiIi11i1I % i1
  if 62 - 62: IiIIii11Ii + Iii1i * ooOOO
  self . _tfParams = { }
  if 44 - 44: oOO / IiIIii11Ii - Iii1i . IIiIIiIi11I1 * iI1iII1I1I1i
  if 5 - 5: Ii % I1I * iI1iII1I1I1i . Oo / i1i1i1111I
  self . _tfMaxIncomingCount = None
  if 30 - 30: I11iiIi11i1I % oOo0O00 . I1I
  if 27 - 27: IiIIii11Ii . Ooo0Ooo
  self . _tfTrainingStage = None
  if 75 - 75: Iii1i + Ii . oOo0O00 . ooo000
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 4 - 4: IiI11Ii111
  if 87 - 87: i1iiIII111 / I1Ii1I1
  if 1 - 1: I1Ii1I1 / Ii - i1I * I1I
  if 10 - 10: ooOOO * ooo000 / i1 - i1
  if 15 - 15: oOo0O00 . oOO . I1I / Oo
  if 1 - 1: IIiIIiIi11I1
  if 11 - 11: Oo - i1I % i1iiIII111 + ooOOO - i1iiIII111 . Oo
  if 78 - 78: i1I * Iii1i + i1i1i1111I % Iii1i % i1iiIII111 . Ooo0Ooo
  if 99 - 99: IiIIii11Ii / Ooo0Ooo / IiIIii11Ii / IiI11Ii111
  if 48 - 48: IIiIIiIi11I1
  if 56 - 56: I1Ii1I1 + ooOOO
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "name" :
    setattr ( self , Ii1I , self . updateNodeName ( iiiiIi1IiiIi ) . replace ( ' ' , '' ) )
   elif Ii1I == "shape" :
    if 15 - 15: Iii1i * OooOoo
    if isinstance ( iiiiIi1IiiIi , list ) and len ( iiiiIi1IiiIi ) > 0 :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
    else :
     setattr ( self , Ii1I , [ iiiiIi1IiiIi ] )
   elif Ii1I == "_order" :
    if 91 - 91: ooo000 % IIiIIiIi11I1
    if isinstance ( iiiiIi1IiiIi , list ) and len ( iiiiIi1IiiIi ) :
     if len ( np . array ( iiiiIi1IiiIi ) ) == 2 :
      setattr ( self , Ii1I , [ s [ 0 ] for s in iiiiIi1IiiIi ] )
     else :
      setattr ( self , Ii1I , iiiiIi1IiiIi )
    else :
     setattr ( self , Ii1I , [ iiiiIi1IiiIi ] )
   elif Ii1I in [ "fromNode" , "toNode" ] :
    setattr ( self , Ii1I , [ [ s . replace ( ' ' , '' ) for s in iiiiIi1IiiIi [ 0 ] ] ] )
   elif Ii1I not in [ "_train" , "_nodeType" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 13 - 13: ooo000
    if 54 - 54: Ooo0Ooo * I1Ii1I1 . oOo0O00
  self . train = train
  if 75 - 75: IiIIii11Ii / iI1iII1I1I1i
 @ property
 def unitNamespace ( self ) -> 'str' :
  if 57 - 57: i1i1i1111I + oOo0O00 * Ii % IiIIii11Ii
  if 61 - 61: IIiIIiIi11I1
  if 44 - 44: OooOoo / IIiIIiIi11I1
  if 88 - 88: IIiIIiIi11I1 % IiIIii11Ii * ooo000 / i1iiIII111 . I11iiIi11i1I
  if 60 - 60: I11iiIi11i1I % Oo % oOO - Oo / IIiIIiIi11I1
  if 14 - 14: i1i1i1111I . ooOOO . I1Ii1I1
  if 93 - 93: I1Ii1I1 . I11iiIi11i1I + oOo0O00
  if 47 - 47: iI1iII1I1I1i - i1i1i1111I / I1I
  if 57 - 57: IIiIIiIi11I1
  if 92 - 92: i1I . Ooo0Ooo . ooo000
  return self . _unitNamespace
  if 77 - 77: i1iiIII111 + Ii * oOO
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 46 - 46: Iii1i * ooOOO / Oo . i1i1i1111I
  if 64 - 64: iI1iII1I1I1i . ooo000 . I1I . Ii
  if 15 - 15: OooOoo
  if 58 - 58: i1 % i1i1i1111I
  if 86 - 86: i1i1i1111I * I1Ii1I1 - i1 . IIiIIiIi11I1 + i1I
  if 49 - 49: ooOOO - Iii1i . i1i1i1111I
  if 73 - 73: i1iiIII111
  if 38 - 38: Ii - iI1iII1I1I1i
  if 71 - 71: i1i1i1111I + Oo
  if 54 - 54: ooOOO / I1Ii1I1 * oOo0O00
  if 85 - 85: Oo . IIiIIiIi11I1 + oOo0O00 + ooo000 * OooOoo - ooOOO
  if 97 - 97: OooOoo / Ii / Ooo0Ooo * OooOoo + i1i1i1111I
  if 11 - 11: ooOOO % Ii - I11iiIi11i1I / IiI11Ii111
  if 45 - 45: i1iiIII111
  if 79 - 79: ooOOO / Ooo0Ooo
  if self . _tfInit == False :
   OoOO = [ ]
   OoooOO0 = [ ]
   ooO0Ooo0 = [ ]
   Iii11I1I1i1i = [ ]
   for I11i1I1I11 in self . _tfParams :
    if isinstance ( I11i1I1I11 [ 0 ] , int ) :
     try :
      ooO0Ooo0 . append ( ( int ( I11i1I1I11 [ 0 ] ) , I11i1I1I11 [ 1 ] [ 'pyArgumentValue' ] ) )
     except :
      pass
    else :
     try :
      Iii11I1I1i1i . append ( I11i1I1I11 [ 0 ] + '=' + I11i1I1I11 [ 1 ] [ 'pyArgumentValue' ] )
     except :
      pass
   ooO0Ooo0 = sorted ( ooO0Ooo0 , key = lambda OOoo00ooOo00O : OOoo00ooOo00O [ 0 ] )
   ooO0Ooo0 = [ str ( x [ 1 ] ) for x in ooO0Ooo0 ]
   ooO0Ooo0 . extend ( Iii11I1I1i1i )
   if self . _tfMaxIncomingCount == 1 :
    if len ( reshape_output_name ) > 1 :
     string = '%s = %s([' % ( output_reg , self . _tfFunctionName )
     string += ',' . join ( reshape_output_name )
     string += '],'
     string += ',' . join ( ooO0Ooo0 )
     string += ')'
     OoooOO0 . append ( string )
    else :
     string = '%s = %s(' % ( output_reg , self . _tfFunctionName )
     string += reshape_output_name [ 0 ]
     if len ( ooO0Ooo0 ) > 0 :
      string += ','
      string += ',' . join ( ooO0Ooo0 )
     string += ')'
     OoooOO0 . append ( string )
   else :
    if len ( reshape_output_name ) > 1 :
     string = '%s = %s(' % ( output_reg , self . _tfFunctionName )
     string += ',' . join ( reshape_output_name )
     if len ( ooO0Ooo0 ) > 0 :
      string += ','
      string += ',' . join ( ooO0Ooo0 )
     string += ')'
     OoooOO0 . append ( string )
    else :
     string = '%s = %s(' % ( output_reg , self . _tfFunctionName )
     string += reshape_output_name [ 0 ]
     string += ',1'
     if len ( ooO0Ooo0 ) > 0 :
      string += ','
      string += ',' . join ( ooO0Ooo0 )
     string += ')'
     OoooOO0 . append ( string )
   if 82 - 82: oOo0O00 * oOo0O00 - IIiIIiIi11I1
   if 31 - 31: i1 + IiIIii11Ii
   if 84 - 84: IIiIIiIi11I1 % Ooo0Ooo / IIiIIiIi11I1 % Oo . Ooo0Ooo * I11iiIi11i1I
   if 99 - 99: IiIIii11Ii / i1i1i1111I / IIiIIiIi11I1
   if 41 - 41: ooOOO
   if 1 - 1: IIiIIiIi11I1 / i1i1i1111I . Oo * i1iiIII111 % IiI11Ii111
   if 51 - 51: iI1iII1I1I1i % Iii1i + IiI11Ii111 * I1Ii1I1 + i1I
   if 3 - 3: IiIIii11Ii * IiI11Ii111 . IiIIii11Ii
   if 62 - 62: I11iiIi11i1I / I11iiIi11i1I . iI1iII1I1I1i + OooOoo * ooo000
   if 51 - 51: ooo000 . IiI11Ii111 / I1Ii1I1 % i1i1i1111I + Ooo0Ooo
   if 82 - 82: i1i1i1111I
   if 77 - 77: Ii + ooo000 * I1Ii1I1
   if 95 - 95: IiI11Ii111 % I11iiIi11i1I . Ii % ooo000
   if 65 - 65: Oo . OooOoo
   if 86 - 86: iI1iII1I1I1i
   if 75 - 75: OooOoo % OooOoo % I1Ii1I1
   if 27 - 27: I1Ii1I1 . i1iiIII111
   if 50 - 50: OooOoo - Iii1i + I1I * I11iiIi11i1I
  if self . _tfInit :
   OoOO = [ ]
   OoooOO0 = [ ]
   if 45 - 45: Ooo0Ooo . iI1iII1I1I1i / Oo * ooOOO
   ooO0Ooo0 = [ ]
   Iii11I1I1i1i = [ ]
   for I11i1I1I11 in self . _tfParams :
    if isinstance ( I11i1I1I11 [ 0 ] , int ) :
     try :
      ooO0Ooo0 . append ( ( int ( I11i1I1I11 [ 0 ] ) , I11i1I1I11 [ 1 ] [ 'pyArgumentValue' ] ) )
     except :
      pass
    else :
     try :
      Iii11I1I1i1i . append ( I11i1I1I11 [ 0 ] + '=' + I11i1I1I11 [ 1 ] [ 'pyArgumentValue' ] )
     except :
      pass
      if 12 - 12: I1Ii1I1 + IIiIIiIi11I1
   ooO0Ooo0 = sorted ( ooO0Ooo0 , key = lambda OOoo00ooOo00O : OOoo00ooOo00O [ 0 ] )
   ooO0Ooo0 = [ str ( x [ 1 ] ) for x in ooO0Ooo0 ]
   ooO0Ooo0 . extend ( Iii11I1I1i1i )
   string = 'self.%s = %s(' % ( self . name , self . _tfFunctionName )
   string += ',' . join ( ooO0Ooo0 )
   string += ')'
   OoOO . append ( string )
   if self . _tfMaxIncomingCount == 1 :
    if len ( reshape_output_name ) > 1 :
     string = '%s = self.%s([' % ( output_reg , self . name )
     string += ',' . join ( reshape_output_name )
     string += ']'
     if self . _tfTrainingStage :
      string += ', training=training'
     string += ')'
    else :
     string = '%s = self.%s(' % ( output_reg , self . name )
     string += reshape_output_name [ 0 ]
     if self . _tfTrainingStage :
      string += ', training=training'
     string += ')'
   else :
    if len ( reshape_output_name ) > 1 :
     string = '%s = self.%s(' % ( output_reg , self . name )
     string += ',' . join ( reshape_output_name )
     if 84 - 84: I1I - I1I / IIiIIiIi11I1 + IIiIIiIi11I1 / I1Ii1I1 + Oo
     if self . _tfTrainingStage :
      string += ', training=training'
     string += ')'
    else :
     string = '%s = self.%s(' % ( output_reg , self . name )
     string += reshape_output_name [ 0 ]
     if self . _tfTrainingStage :
      string += ',1, training=training'
     string += ')'
   OoooOO0 . append ( string )
   if 87 - 87: OooOoo * IiI11Ii111 . ooOOO
   if 24 - 24: iI1iII1I1I1i
   if 77 - 77: ooOOO - Oo
   if 48 - 48: iI1iII1I1I1i % IiI11Ii111 . IiI11Ii111 * OooOoo + Ii + i1iiIII111
   if 73 - 73: i1iiIII111 * i1
   if 83 - 83: i1I
   if 47 - 47: oOO * IIiIIiIi11I1 - IiI11Ii111
   if 91 - 91: ooo000 / I1Ii1I1 + I1I - i1I - IiIIii11Ii
   if 59 - 59: I11iiIi11i1I / Oo
   if 55 - 55: OooOoo . OooOoo % i1 . Oo + i1i1i1111I . i1
   if 84 - 84: Oo . Iii1i
   if 61 - 61: IiIIii11Ii / Ii * I1Ii1I1
   if 34 - 34: ooOOO % oOo0O00 % Oo * I1Ii1I1
   if 28 - 28: OooOoo * I1Ii1I1
   if 30 - 30: oOO . IIiIIiIi11I1
  return OoOO , OoooOO0 , output_reg , inputshape [ 0 ]
  if 32 - 32: IIiIIiIi11I1 + i1I . I1I + Oo % i1
 def keras_call_combineIncomingTensors ( self , input_sources , input_tensors , input_sources_name , input_tensors_name , output_reg , buildNo = 0 ) :
  if 62 - 62: I11iiIi11i1I
  if 46 - 46: I11iiIi11i1I - IIiIIiIi11I1 / I1Ii1I1 % i1 . Oo
  if 55 - 55: I1Ii1I1 % ooo000 / Ii * Iii1i % IiI11Ii111 % I1I
  if 58 - 58: IiIIii11Ii
  if 14 - 14: i1i1i1111I / oOO - ooOOO + IiI11Ii111 * oOO
  if 72 - 72: Iii1i % I1I
  if 57 - 57: iI1iII1I1I1i + i1 * Oo % i1 . iI1iII1I1I1i / Ii
  if 86 - 86: ooOOO % I1Ii1I1 - oOo0O00
  if 47 - 47: Iii1i + IIiIIiIi11I1 - Iii1i
  if 2 - 2: IiIIii11Ii / I11iiIi11i1I + I11iiIi11i1I
  if 17 - 17: oOO + Oo
  if 86 - 86: I11iiIi11i1I
  if 4 - 4: I1Ii1I1 % i1 % i1iiIII111 % OooOoo . oOO * ooOOO
  if 63 - 63: oOO % i1iiIII111 / IIiIIiIi11I1 % IiIIii11Ii
  if 29 - 29: IiIIii11Ii . oOo0O00 - i1iiIII111 . i1
  iiIII1Ii1 = [ ]
  iiIII1Ii1 . extend ( input_sources_name )
  iiIII1Ii1 . extend ( input_tensors_name )
  ooo0o = [ ]
  ooo0o . extend ( input_sources )
  ooo0o . extend ( input_tensors )
  return ooo0o , [ ] , [ ] , iiIII1Ii1
  if 92 - 92: i1i1i1111I * i1I . i1iiIII111 + i1
 def keras_call_processOutputTensor ( self , input_shape , layer_output_name , output_reg , buildNo = 0 ) :
  if 4 - 4: IIiIIiIi11I1 / Oo / ooOOO / Ii * i1
  if 63 - 63: i1i1i1111I % Iii1i - IIiIIiIi11I1 / i1I
  if 81 - 81: Iii1i / Oo - i1I % Ii / oOo0O00 . IiIIii11Ii
  if 67 - 67: IIiIIiIi11I1 . OooOoo
  if 13 - 13: ooOOO / oOo0O00 - oOo0O00 / Ooo0Ooo
  if 72 - 72: i1 - IiIIii11Ii / i1iiIII111
  if 8 - 8: OooOoo + IiI11Ii111 % i1iiIII111 . i1
  if 50 - 50: Oo % Iii1i / I1Ii1I1 - Ii
  if 80 - 80: oOO - IiI11Ii111 * Iii1i
  if 30 - 30: i1iiIII111 * oOO . Oo
  if 73 - 73: oOO - ooOOO * i1iiIII111 + i1iiIII111 - iI1iII1I1I1i
  if 96 - 96: oOO * iI1iII1I1I1i . oOo0O00 + Ii / ooOOO + Ii
  if 82 - 82: IiIIii11Ii . i1iiIII111 * Ooo0Ooo
  if 62 - 62: i1I . Ii / Oo
  if 94 - 94: IIiIIiIi11I1 * IiI11Ii111 + IiI11Ii111 * i1
  if 5 - 5: i1i1i1111I
  return [ ] , [ ]
  if 29 - 29: i1i1i1111I * Ii + IiIIii11Ii
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 95 - 95: Ii % IIiIIiIi11I1 - i1I . ooOOO . Ooo0Ooo + IiIIii11Ii
  if 40 - 40: Iii1i + Iii1i . oOo0O00 . Iii1i . oOo0O00
  if 92 - 92: IiIIii11Ii + IiI11Ii111 + ooo000 - I11iiIi11i1I
  if 28 - 28: oOO * IiIIii11Ii - I1Ii1I1
  if 47 - 47: oOo0O00 . i1I % OooOoo % oOo0O00
  if 51 - 51: i1iiIII111 / Ooo0Ooo - i1i1i1111I . I1I
  if 68 - 68: IIiIIiIi11I1
  if 78 - 78: i1i1i1111I * I11iiIi11i1I . Oo
  if 22 - 22: ooo000 . I1Ii1I1 + IiIIii11Ii * oOO . Oo * IiIIii11Ii
  if 73 - 73: Iii1i % i1 + Oo
  if 44 - 44: iI1iII1I1I1i
  if 10 - 10: i1i1i1111I + Ooo0Ooo * ooOOO * IIiIIiIi11I1
  if 62 - 62: ooo000 * Oo / Ii * i1 * i1 / Oo
  if 75 - 75: IIiIIiIi11I1 - I1Ii1I1 . oOo0O00 + ooo000
  if 13 - 13: ooOOO % ooOOO + i1I - Ooo0Ooo
  return [ ] , [ ] , combine_output_name , input_shape
  if 37 - 37: I11iiIi11i1I * I1Ii1I1 % ooOOO
class o0oo0oooO0oO ( II1iII1I11I ) :
 def __init__ ( self , name : str = None , model_namespace : str = None ) :
  super ( ) . __init__ ( name = name , nodeType = o0OOo000o00 . LadderModel )
  if 96 - 96: ooOOO * IiI11Ii111 - I1Ii1I1 * iI1iII1I1I1i % i1iiIII111 * i1I
  if 12 - 12: oOo0O00 + i1I % Iii1i + i1I . oOo0O00 * ooo000
  if 44 - 44: ooo000 + i1I / oOo0O00 / I11iiIi11i1I % IIiIIiIi11I1
  if 72 - 72: IIiIIiIi11I1
  if 97 - 97: ooo000 - IIiIIiIi11I1
  if 54 - 54: IIiIIiIi11I1 % iI1iII1I1I1i / I11iiIi11i1I
  if 6 - 6: ooOOO / IiIIii11Ii / Oo
  self . _model_namespace = model_namespace
  self . model_params = { }
  self . model_name = ""
  if 73 - 73: oOO
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  for ( oo00OOOO , O0Oo00o0 ) in obj . items ( ) :
   if 16 - 16: IiIIii11Ii / ooo000 / OooOoo + i1I + IiI11Ii111
   if 27 - 27: iI1iII1I1I1i
   if 56 - 56: Iii1i - IiIIii11Ii % iI1iII1I1I1i - i1I + Oo
   if 4 - 4: Ooo0Ooo + I1I * i1I * Ooo0Ooo * Ii - oOo0O00
   if 36 - 36: IIiIIiIi11I1 - ooOOO . IiIIii11Ii . iI1iII1I1I1i
   if 60 - 60: OooOoo
   if 47 - 47: i1i1i1111I . IiIIii11Ii + ooOOO + oOo0O00 % IiI11Ii111 . IiI11Ii111
   if oo00OOOO == "name" :
    setattr ( self , oo00OOOO , self . updateNodeName ( O0Oo00o0 ) . replace ( ' ' , '' ) )
   elif oo00OOOO == "shape" :
    if isinstance ( O0Oo00o0 , list ) and len ( O0Oo00o0 ) > 0 :
     setattr ( self , oo00OOOO , O0Oo00o0 )
    else :
     setattr ( self , oo00OOOO , [ O0Oo00o0 ] )
   elif oo00OOOO == "_order" :
    if isinstance ( O0Oo00o0 , list ) and len ( O0Oo00o0 ) :
     if len ( np . array ( O0Oo00o0 ) ) == 2 :
      setattr ( self , oo00OOOO , [ s [ 0 ] for s in O0Oo00o0 ] )
     else :
      setattr ( self , oo00OOOO , O0Oo00o0 )
    else :
     setattr ( self , oo00OOOO , [ O0Oo00o0 ] )
   elif oo00OOOO == "model_params" :
    for OoOO0oO , O0OOO0O000OO0 in O0Oo00o0 . items ( ) :
     self . model_params [ OoOO0oO ] = O0OOO0O000OO0
   elif oo00OOOO in [ "fromNode" , "toNode" ] :
    setattr ( self , oo00OOOO , [ [ s . replace ( ' ' , '' ) for s in O0Oo00o0 [ 0 ] ] ] )
   elif oo00OOOO not in [ "_train" , "_nodeType" ] :
    setattr ( self , oo00OOOO , O0Oo00o0 )
    if 53 - 53: i1iiIII111 / ooOOO
    if 24 - 24: i1iiIII111
  self . train = train
  if 4 - 4: I1I + iI1iII1I1I1i . IIiIIiIi11I1 / IIiIIiIi11I1 * OooOoo
 @ property
 def modelNamespace ( self ) -> 'str' :
  return self . _model_namespace
  if 68 - 68: OooOoo * ooo000 - i1iiIII111 % I11iiIi11i1I * IIiIIiIi11I1 % Ii
  if 92 - 92: ooOOO % Ooo0Ooo / Iii1i - Ooo0Ooo / Ooo0Ooo
  if 79 - 79: I1Ii1I1 . Ooo0Ooo - oOo0O00 * oOO + I1Ii1I1
  if 83 - 83: I1I + IiIIii11Ii * Ii . IiI11Ii111 - ooo000
  if 14 - 14: i1 + IIiIIiIi11I1 - I11iiIi11i1I - ooOOO
  if 18 - 18: Oo - oOo0O00 - i1I
  if 9 - 9: ooo000 . Ooo0Ooo / i1iiIII111 % IIiIIiIi11I1 . I1Ii1I1
 def keras_call_combineIncomingTensors ( self , input_sources , input_tensors , input_sources_name , input_tensors_name , output_reg , buildNo = 0 ) :
  iiIII1Ii1 = [ ]
  iiIII1Ii1 . extend ( input_sources_name )
  iiIII1Ii1 . extend ( input_tensors_name )
  ooo0o = [ ]
  ooo0o . extend ( input_sources )
  ooo0o . extend ( input_tensors )
  return ooo0o , [ ] , [ ] , iiIII1Ii1
  if 44 - 44: IiIIii11Ii / Oo . IiI11Ii111 - IiIIii11Ii . Ooo0Ooo
 def keras_call_processOutputTensor ( self , input_shape , layer_output_name , output_reg , buildNo = 0 ) :
  return [ ] , [ ]
  if 79 - 79: Ii % IiI11Ii111 - OooOoo % I1I
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  return [ ] , [ ] , combine_output_name , input_shape
  if 7 - 7: Ii * I11iiIi11i1I . I1I . I1I
 def keras_call_layer_build ( self , reshape_output_name , output_reg , input_shape = None ) :
  OoOO = [ ]
  if 97 - 97: i1I + OooOoo . IIiIIiIi11I1 / i1 + Ooo0Ooo / i1I
  if 92 - 92: IiI11Ii111 + oOo0O00
  if 13 - 13: i1i1i1111I . ooo000 * i1I * IiIIii11Ii * IiI11Ii111
  if 79 - 79: Oo
  if 83 - 83: i1I / Ooo0Ooo + Ii + i1i1i1111I / oOO . OooOoo
  if 71 - 71: Oo % Ooo0Ooo + i1I + IiIIii11Ii
  if 13 - 13: OooOoo
  if 4 - 4: i1I / Ii
  if 48 - 48: Ooo0Ooo - Ooo0Ooo * i1I * OooOoo + I1I
  OoooOO0 = [ ]
  if 74 - 74: oOO / I1I * IIiIIiIi11I1
  O00O = [ ]
  for oo00OOOO , O0Oo00o0 in self . model_params . items ( ) :
   if oo00OOOO == "name" :
    self . model_name = O0Oo00o0
   else :
    O00O . append ( oo00OOOO + "=" + str ( O0Oo00o0 ) )
  O00O . append ( "input_shape=(%s, %s, %s)" % ( input_shape [ 0 ] [ 1 ] , input_shape [ 0 ] [ 2 ] , input_shape [ 0 ] [ 3 ] ) )
  if 50 - 50: IIiIIiIi11I1 - i1
  O0iiIIi1iI1iiIi = "self.%s = LadderModel.%s(" % ( self . name , self . model_name )
  O0iiIIi1iI1iiIi += ', ' . join ( O00O )
  O0iiIIi1iI1iiIi += ")"
  if 46 - 46: i1iiIII111
  OoOO . append ( O0iiIIi1iI1iiIi )
  if 46 - 46: Ooo0Ooo / iI1iII1I1I1i
  if len ( reshape_output_name ) > 1 :
   I1I111i1IiI1 = "%s = self.%s([" % ( output_reg , self . name )
   I1I111i1IiI1 += ',' . join ( reshape_output_name )
   I1I111i1IiI1 += "])"
   OoooOO0 . append ( I1I111i1IiI1 )
  elif len ( reshape_output_name ) == 1 :
   I1I111i1IiI1 = "%s = self.%s(" % ( output_reg , self . name )
   I1I111i1IiI1 += ',' . join ( reshape_output_name )
   I1I111i1IiI1 += ")"
   OoooOO0 . append ( I1I111i1IiI1 )
   if 92 - 92: IIiIIiIi11I1 * i1 % I11iiIi11i1I * I11iiIi11i1I
  return OoOO , OoooOO0 , output_reg , input_shape [ 0 ]
  if 73 - 73: i1i1i1111I % I11iiIi11i1I / Ooo0Ooo
class oOOOO0O0oo :
 if 38 - 38: iI1iII1I1I1i
 if 49 - 49: IiI11Ii111 / IiI11Ii111 - i1iiIII111 - oOo0O00 / i1iiIII111 . IIiIIiIi11I1
 if 29 - 29: I11iiIi11i1I
 if 7 - 7: oOo0O00 . Iii1i
 if 34 - 34: Iii1i
 if 59 - 59: i1I
 if 9 - 9: ooOOO % i1
 class Types ( II1i1I ) :
  if 89 - 89: Ii - I1Ii1I1
  if 55 - 55: I11iiIi11i1I - oOo0O00 . IiI11Ii111
  if 51 - 51: i1iiIII111 + Iii1i
  if 11 - 11: IiIIii11Ii / i1i1i1111I / i1i1i1111I * Oo . i1iiIII111
  if 66 - 66: ooo000 + i1 - i1i1i1111I
  if 29 - 29: Ii . i1i1i1111I * iI1iII1I1I1i * ooOOO
  if 73 - 73: iI1iII1I1I1i . IiIIii11Ii
  if 54 - 54: IIiIIiIi11I1
  Config = 0
  if 30 - 30: I1Ii1I1
  Constant = 1
  if 14 - 14: iI1iII1I1I1i * iI1iII1I1I1i / i1 / IIiIIiIi11I1 % Ii * i1i1i1111I
  Zeros = 2
  if 1 - 1: oOo0O00
  Ones = 3
  if 73 - 73: I1Ii1I1 - i1i1i1111I
  RandomNormal = 4
  if 71 - 71: I1Ii1I1 / ooOOO * Iii1i . i1i1i1111I - I1I
  TruncatedNormal = 5
  if 68 - 68: ooOOO + i1I * ooo000 - Ii
  RandomUniform = 6
  if 22 - 22: i1i1i1111I + i1 + oOO + Ii * IIiIIiIi11I1 + i1i1i1111I
  Orthogonal = 7
  if 9 - 9: Iii1i * oOo0O00 . Ii + i1iiIII111 . i1
  Identity = 8
  if 9 - 9: i1I . IiI11Ii111 + Ooo0Ooo * OooOoo . ooo000 - IiI11Ii111
  GlorotNormal = 9
  if 100 - 100: ooOOO * IIiIIiIi11I1
  GlorotUniform = 10
  if 63 - 63: Ooo0Ooo - i1iiIII111 . I11iiIi11i1I + ooo000 + OooOoo
  HeNormal = 11
  if 41 - 41: Iii1i + I1Ii1I1 + oOo0O00 / ooo000
  HeUniform = 12
  if 34 - 34: ooo000
  LecunNormal = 13
  if 76 - 76: I11iiIi11i1I * Oo - IIiIIiIi11I1
  LecunUniform = 14
  if 44 - 44: I11iiIi11i1I . IIiIIiIi11I1 / IIiIIiIi11I1
 class Config :
  if 14 - 14: oOo0O00
  if 72 - 72: ooo000 . IiIIii11Ii . Iii1i % i1I . IIiIIiIi11I1
  if 86 - 86: IIiIIiIi11I1 + oOO . I1Ii1I1
  if 52 - 52: oOO * i1iiIII111 - ooOOO . ooOOO
  if 94 - 94: oOo0O00 . OooOoo + IiI11Ii111
  if 34 - 34: ooo000 * IIiIIiIi11I1
  if 81 - 81: I11iiIi11i1I
  def __init__ ( self , referenceCallable : Callable ) :
   if 69 - 69: IiIIii11Ii
   if 6 - 6: i1iiIII111
   if 16 - 16: I11iiIi11i1I - Ooo0Ooo
   if 99 - 99: I11iiIi11i1I - ooOOO
   if 80 - 80: oOo0O00 . ooOOO / Ooo0Ooo . i1I
   if 86 - 86: oOo0O00 . Iii1i / ooo000 - oOO * i1i1i1111I
   if 57 - 57: Ii . oOO - ooOOO . Ooo0Ooo / i1I + IIiIIiIi11I1
   if 20 - 20: IiI11Ii111 / iI1iII1I1I1i * Ooo0Ooo - Oo * Ii * i1iiIII111
   if 33 - 33: iI1iII1I1I1i
   if 11 - 11: Iii1i . Ooo0Ooo - Iii1i
   self . _reference = referenceCallable
   self . constructor = ""
   if 11 - 11: IiIIii11Ii - oOO . Iii1i . IIiIIiIi11I1 - ooOOO % I1Ii1I1
  def parseJSON ( self , obj : Dict [ str , Any ] ) :
   if 65 - 65: IiIIii11Ii + Ooo0Ooo - Oo
   if 68 - 68: IIiIIiIi11I1 - Ii - Ooo0Ooo - OooOoo - i1i1i1111I * IiI11Ii111
   if 93 - 93: oOO / i1
   if 39 - 39: ooOOO . Iii1i / i1I * Oo / IiIIii11Ii
   if 21 - 21: IiIIii11Ii / IIiIIiIi11I1 % i1 % I1I
   if 55 - 55: Ii + i1I % I1Ii1I1 . Ii
   if 45 - 45: ooOOO % iI1iII1I1I1i + ooo000 * oOO % oOO
   if 4 - 4: I1Ii1I1
   if 86 - 86: ooo000 + OooOoo
   if 8 - 8: Ooo0Ooo / Iii1i . oOO % OooOoo . IiIIii11Ii
   if 63 - 63: i1i1i1111I . I1Ii1I1 - Ii * ooo000 * i1 * iI1iII1I1I1i
   for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 8 - 8: i1iiIII111 + IiI11Ii111
  @ staticmethod
  def getConfig ( ) -> Dict [ str , Any ] :
   if 46 - 46: i1iiIII111 . ooo000 . ooo000 - Ooo0Ooo . Ooo0Ooo
   if 20 - 20: IiIIii11Ii - ooo000 % I1I * Ii - OooOoo
   if 100 - 100: ooo000 / IIiIIiIi11I1 % I1I
   if 19 - 19: IiI11Ii111
   if 19 - 19: ooOOO + IiIIii11Ii
   if 6 - 6: ooo000 . ooOOO % IiI11Ii111 . oOO - iI1iII1I1I1i
   if 27 - 27: IIiIIiIi11I1 % oOO . oOo0O00 / Ii . Iii1i . Ooo0Ooo
   if 50 - 50: oOo0O00 % oOo0O00 % i1
   if 92 - 92: Iii1i / ooOOO . Ii - i1iiIII111 / Ooo0Ooo
   if 1 - 1: IiI11Ii111 % IIiIIiIi11I1 * ooo000 . i1I + i1 * IIiIIiIi11I1
   return { }
   if 48 - 48: oOo0O00 . iI1iII1I1I1i + Ii % i1iiIII111 * oOO
  def getConstructorString ( self ) -> str :
   if 32 - 32: ooOOO
   if 61 - 61: OooOoo
   if 63 - 63: i1I % I1Ii1I1 . Ooo0Ooo - IiIIii11Ii + I1I . Iii1i
   if 88 - 88: i1iiIII111
   if 81 - 81: Oo
   if 80 - 80: IIiIIiIi11I1 + oOo0O00 + I1I - I11iiIi11i1I % Iii1i
   if 70 - 70: IIiIIiIi11I1 / Iii1i + ooo000
   if 21 - 21: I11iiIi11i1I / Iii1i + I1Ii1I1 - i1iiIII111 + i1
   if 24 - 24: IiIIii11Ii
   if 89 - 89: IiIIii11Ii % i1i1i1111I
   OoIIIi = self . constructor
   I1I1Ii1Iii = [ ]
   for ( oo00OOOO , I1ioooo0o ) in self . getConfig ( ) . items ( ) :
    I1I1Ii1Iii . append ( oo00OOOO + " = " + str ( I1ioooo0o ) )
   return OoIIIi + "(" + ", " . join ( I1I1Ii1Iii ) + ")"
   if 64 - 64: Ii * IiIIii11Ii + i1i1i1111I
  def getTrainingInitializer ( self , shape : List [ int ] = None ) -> 'tf.initializers' :
   if 43 - 43: IiI11Ii111 % I1I / IIiIIiIi11I1 / Ooo0Ooo
   if 90 - 90: ooo000 / i1I % ooOOO % i1 - I11iiIi11i1I
   if 60 - 60: Ii / OooOoo % IiIIii11Ii * I1I / IiI11Ii111
   if 7 - 7: IiIIii11Ii . I1I - Ii - iI1iII1I1I1i
   if 11 - 11: Oo + I1I
   if 62 - 62: oOo0O00 % IiI11Ii111
   if 12 - 12: i1iiIII111 * oOO
   if 9 - 9: Ooo0Ooo / i1I - I1I + oOo0O00 - I1I
   if 55 - 55: I1I * oOo0O00 . i1iiIII111
   if 89 - 89: IiIIii11Ii + oOO - IiIIii11Ii . oOO . i1I
   if 41 - 41: oOo0O00
   if 49 - 49: Oo / iI1iII1I1I1i % oOO % IIiIIiIi11I1 % i1 - i1
   if 87 - 87: OooOoo
   return self . _reference ( ** self . getConfig ( ) )
   if 26 - 26: ooOOO
  @ staticmethod
  def fromConfig ( initializer : type , config : Dict [ str , Any ] ) -> 'Initializer' :
   if 20 - 20: i1 / I11iiIi11i1I
   if 68 - 68: Oo / i1I * Iii1i - i1iiIII111 / IiI11Ii111 . OooOoo
   if 64 - 64: ooOOO
   if 1 - 1: oOo0O00
   if 32 - 32: ooo000 - I11iiIi11i1I - iI1iII1I1I1i + IIiIIiIi11I1 . OooOoo
   if 50 - 50: I1Ii1I1
   if 60 - 60: I11iiIi11i1I - Ooo0Ooo % Ooo0Ooo
   if 26 - 26: Iii1i % I1I + I1I - I11iiIi11i1I
   if 8 - 8: OooOoo % I1I / i1I . Iii1i - i1i1i1111I
   if 78 - 78: I1Ii1I1 % iI1iII1I1I1i + Ii - iI1iII1I1I1i * IiIIii11Ii
   if 13 - 13: ooo000 * Oo / i1I . Ooo0Ooo % I1I
   if 52 - 52: I1Ii1I1 % i1i1i1111I % oOO - i1I
   if 50 - 50: Iii1i
   if 49 - 49: I11iiIi11i1I % I1Ii1I1 . i1I - Ii
   return initializer ( ** config )
   if 40 - 40: IiIIii11Ii / oOO / ooOOO * i1iiIII111 - Iii1i % Ooo0Ooo
 class Constant ( Config ) :
  if 70 - 70: iI1iII1I1I1i
  if 77 - 77: oOo0O00 / Oo
  if 86 - 86: iI1iII1I1I1i % iI1iII1I1I1i % I1I . Ii . oOO
  if 8 - 8: ooOOO / Iii1i % oOO % ooOOO + ooOOO
  if 68 - 68: i1I % ooOOO . i1 % I1I
  if 33 - 33: oOO + iI1iII1I1I1i - OooOoo * ooo000
  if 8 - 8: I1I . i1i1i1111I
  def __init__ ( self , value : Any = 0 ) :
   if 86 - 86: Iii1i * Ooo0Ooo - Ooo0Ooo * Ii + i1iiIII111
   if 82 - 82: IIiIIiIi11I1 % oOo0O00 * Iii1i / IIiIIiIi11I1 % oOO
   if 2 - 2: iI1iII1I1I1i / I1Ii1I1 % i1iiIII111 * i1 * Oo - OooOoo
   if 54 - 54: I11iiIi11i1I % Iii1i - i1i1i1111I + i1iiIII111 + oOO - Oo
   if 31 - 31: iI1iII1I1I1i * i1i1i1111I / I1Ii1I1 + IIiIIiIi11I1 . i1iiIII111 * ooo000
   if 18 - 18: IiI11Ii111 - ooOOO % ooOOO
   if 32 - 32: IIiIIiIi11I1 . oOO
   if 21 - 21: Ii / IiI11Ii111 + Ooo0Ooo - Ooo0Ooo
   if 18 - 18: I11iiIi11i1I
   if 40 - 40: iI1iII1I1I1i
   super ( ) . __init__ ( tf . initializers . constant )
   self . value = value
   self . constructor = "constant"
   if 67 - 67: ooo000 * Iii1i + Oo
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 43 - 43: oOo0O00 - ooo000 - Oo / IiI11Ii111
   if 79 - 79: I11iiIi11i1I - i1iiIII111 * i1iiIII111 - OooOoo * i1iiIII111 + oOo0O00
   if 20 - 20: oOO + ooo000 - iI1iII1I1I1i
   if 23 - 23: i1I / Ii % I1Ii1I1 - Ooo0Ooo / IIiIIiIi11I1
   if 79 - 79: Ooo0Ooo . Iii1i * Oo
   if 41 - 41: i1 . I1Ii1I1 % iI1iII1I1I1i
   if 92 - 92: Ooo0Ooo % oOO
   if 68 - 68: IiI11Ii111 / OooOoo
   if 26 - 26: IiI11Ii111 * ooo000 % OooOoo / ooOOO + Ooo0Ooo
   if 84 - 84: Ooo0Ooo * i1I / Ooo0Ooo - Ii . i1
   return { "value" : self . value }
   if 47 - 47: IIiIIiIi11I1 + oOO + oOO . oOo0O00
 class Zeros ( Config ) :
  if 26 - 26: i1i1i1111I * oOo0O00 * I1Ii1I1 % Ooo0Ooo
  if 19 - 19: IiIIii11Ii / ooo000 . Ii . i1i1i1111I
  if 20 - 20: oOo0O00 - Ii - Ooo0Ooo % i1i1i1111I
  if 37 - 37: i1I . Iii1i . IiI11Ii111 . Ooo0Ooo . ooo000
  if 46 - 46: i1iiIII111 % i1iiIII111 + i1 + Ii . IIiIIiIi11I1 . I11iiIi11i1I
  if 35 - 35: IIiIIiIi11I1 / oOo0O00 * I1Ii1I1 * Iii1i
  if 83 - 83: OooOoo / oOO + i1I
  def __init__ ( self ) :
   if 65 - 65: I1I * IIiIIiIi11I1 . I1Ii1I1 / Oo
   if 53 - 53: ooo000 + Oo % iI1iII1I1I1i . Ii
   if 81 - 81: ooo000 * Oo . i1i1i1111I - ooOOO / Iii1i
   if 82 - 82: Ii + Iii1i
   if 53 - 53: OooOoo / Ooo0Ooo - ooOOO
   if 32 - 32: oOo0O00 % Ooo0Ooo * i1iiIII111
   if 18 - 18: IiIIii11Ii * i1iiIII111 . oOo0O00 / IIiIIiIi11I1
   super ( ) . __init__ ( tf . initializers . zeros )
   self . constructor = "zeros"
   if 63 - 63: i1i1i1111I + Ooo0Ooo . I1Ii1I1 . IiIIii11Ii % i1I * IiIIii11Ii
 class Ones ( Config ) :
  if 25 - 25: oOO % IIiIIiIi11I1 * IiIIii11Ii + oOO % i1iiIII111 - i1I
  if 95 - 95: ooOOO . i1i1i1111I
  if 87 - 87: I1Ii1I1 + I1Ii1I1 % i1
  if 7 - 7: ooo000
  if 36 - 36: Iii1i / i1 * OooOoo * IIiIIiIi11I1 % ooOOO - oOo0O00
  if 83 - 83: i1 / OooOoo * i1I
  if 90 - 90: iI1iII1I1I1i + Ooo0Ooo % IIiIIiIi11I1
  def __init__ ( self ) :
   if 89 - 89: oOo0O00 * Ii * IIiIIiIi11I1 + OooOoo - ooo000 + ooOOO
   if 80 - 80: I11iiIi11i1I / oOo0O00 / i1I . Iii1i
   if 53 - 53: i1i1i1111I * Ii . i1I % iI1iII1I1I1i
   if 72 - 72: I1Ii1I1 + I11iiIi11i1I % I1Ii1I1
   if 75 - 75: i1i1i1111I / ooOOO - Oo / I11iiIi11i1I / OooOoo
   if 55 - 55: IiIIii11Ii % IIiIIiIi11I1 % Ii
   if 99 - 99: I11iiIi11i1I + i1I
   super ( ) . __init__ ( tf . initializers . ones )
   self . constructor = "ones"
   if 10 - 10: i1iiIII111
 class RandomNormal ( Config ) :
  if 83 - 83: i1I - i1I % i1i1i1111I
  if 47 - 47: ooOOO * ooOOO / IiIIii11Ii * IiIIii11Ii - Oo
  if 84 - 84: oOo0O00 / I1I
  if 34 - 34: iI1iII1I1I1i . Iii1i * I11iiIi11i1I
  if 99 - 99: Ooo0Ooo
  if 84 - 84: i1 . i1I
  if 43 - 43: oOo0O00 * i1iiIII111 / oOO - ooOOO * i1iiIII111
  def __init__ ( self , mean : float = 0 , stddev : float = 1.0 , seed : int = None ) :
   if 80 - 80: IIiIIiIi11I1
   if 27 - 27: Oo * I11iiIi11i1I / i1i1i1111I / Oo * I1Ii1I1 . ooo000
   if 40 - 40: Oo / I11iiIi11i1I * i1iiIII111 . ooOOO + oOO - I11iiIi11i1I
   if 75 - 75: iI1iII1I1I1i - Ii
   if 63 - 63: IiIIii11Ii
   if 4 - 4: IiI11Ii111 . Iii1i + ooo000 * OooOoo
   if 50 - 50: I1Ii1I1 / ooo000 - ooOOO / I1I * Ooo0Ooo / i1iiIII111
   if 58 - 58: IIiIIiIi11I1 . IiI11Ii111
   if 68 - 68: ooOOO
   if 95 - 95: IIiIIiIi11I1 . IiI11Ii111 % i1 * iI1iII1I1I1i
   if 78 - 78: IIiIIiIi11I1 - i1iiIII111 * I1I / i1I % IiI11Ii111
   if 56 - 56: i1I - Oo
   super ( ) . __init__ ( tf . initializers . RandomNormal )
   self . mean = mean
   self . stddev = stddev
   self . seed = seed
   self . constructor = "RandomNormal"
   if 67 - 67: ooOOO + Oo + i1I
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 70 - 70: I11iiIi11i1I / iI1iII1I1I1i + i1I * I11iiIi11i1I / ooo000 / OooOoo
   if 96 - 96: Oo . IiIIii11Ii - i1iiIII111 . i1I % i1iiIII111
   if 22 - 22: iI1iII1I1I1i + IIiIIiIi11I1 % IiIIii11Ii . i1iiIII111
   if 95 - 95: I1I / i1i1i1111I
   if 83 - 83: i1 % I1I . oOo0O00 * IIiIIiIi11I1
   if 43 - 43: IiI11Ii111 . Oo - ooo000 - IiIIii11Ii
   if 81 - 81: OooOoo
   if 15 - 15: Iii1i
   if 6 - 6: I11iiIi11i1I - Ooo0Ooo
   if 40 - 40: i1I % I11iiIi11i1I + iI1iII1I1I1i * Iii1i . Oo + OooOoo
   return { "mean" : self . mean , "stddev" : self . stddev , "seed" : self . seed }
   if 42 - 42: Ii % Ooo0Ooo
  def getTrainingInitializer ( self , shape : List [ int ] = None ) -> 'tf.initializers' :
   if 25 - 25: IiI11Ii111
   if 90 - 90: i1iiIII111
   if 28 - 28: IiI11Ii111 - I1Ii1I1 / oOO * iI1iII1I1I1i
   if 82 - 82: I1Ii1I1 * IIiIIiIi11I1 * ooo000 + I1Ii1I1 / ooo000
   if 66 - 66: IIiIIiIi11I1 % I1I + i1i1i1111I . IiIIii11Ii * ooOOO / I1I
   if 69 - 69: Iii1i / i1iiIII111 - IiI11Ii111 - I1I
   if 94 - 94: oOo0O00
   if 84 - 84: IiI11Ii111 + Oo + i1I
   if 91 - 91: ooOOO - i1I + ooo000 * ooOOO / I1I
   if 71 - 71: i1I . OooOoo * IIiIIiIi11I1
   if 58 - 58: IiIIii11Ii . i1 - Ooo0Ooo * i1iiIII111 % iI1iII1I1I1i . Ii
   if 42 - 42: oOO . IiIIii11Ii / Oo . I1I . oOO . Ooo0Ooo
   if 58 - 58: IIiIIiIi11I1 . IiIIii11Ii
   I1IIIi = self . getConfig ( )
   if 80 - 80: iI1iII1I1I1i - ooo000 * i1i1i1111I . i1iiIII111
   if I1IIIi [ "stddev" ] == "auto" :
    I1IIIi [ "stddev" ] = 1 / shape [ 0 ]
   return self . _reference ( ** I1IIIi )
   if 7 - 7: i1 + Iii1i + Iii1i . ooo000 / IiIIii11Ii * i1iiIII111
 class TruncatedNormal ( Config ) :
  if 59 - 59: oOo0O00 * IiIIii11Ii - ooo000 - IiIIii11Ii
  if 96 - 96: OooOoo / IIiIIiIi11I1 % oOo0O00 - i1i1i1111I
  if 98 - 98: i1iiIII111
  if 1 - 1: i1iiIII111 % Iii1i % OooOoo * i1
  if 32 - 32: IiI11Ii111
  if 39 - 39: I1Ii1I1 * oOo0O00 . IIiIIiIi11I1 * Iii1i
  if 54 - 54: ooo000
  def __init__ ( self , mean : float = 0 , stddev : Union [ float , str ] = 1.0 , seed : int = None ) :
   if 43 - 43: i1 - Iii1i
   if 42 - 42: I1Ii1I1 + oOO
   if 77 - 77: IIiIIiIi11I1
   if 91 - 91: Ooo0Ooo . i1I / Ii / ooo000 % Oo
   if 46 - 46: IIiIIiIi11I1
   if 15 - 15: Ooo0Ooo
   if 51 - 51: ooo000
   if 78 - 78: i1
   if 56 - 56: i1iiIII111 . Ii % Oo + Oo
   if 59 - 59: IIiIIiIi11I1 % IiI11Ii111 - I1I - IiI11Ii111 . oOo0O00 % Ooo0Ooo
   if 57 - 57: i1I
   if 80 - 80: Ii * iI1iII1I1I1i % IiI11Ii111 + Ooo0Ooo
   super ( ) . __init__ ( tf . initializers . TruncatedNormal )
   self . mean = mean
   self . stddev = stddev
   self . seed = seed
   self . constructor = "TruncatedNormal"
   if 9 - 9: IiI11Ii111 / I11iiIi11i1I
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 29 - 29: I11iiIi11i1I
   if 86 - 86: I11iiIi11i1I % IIiIIiIi11I1 + i1I - oOO
   if 66 - 66: ooOOO / iI1iII1I1I1i / IiI11Ii111 + I11iiIi11i1I - ooo000
   if 69 - 69: I1Ii1I1 - ooOOO - I1Ii1I1 % i1 * Ii . i1I
   if 92 - 92: i1iiIII111 . IIiIIiIi11I1 + i1I + IiIIii11Ii
   if 3 - 3: I1I
   if 98 - 98: iI1iII1I1I1i - OooOoo
   if 94 - 94: i1i1i1111I . ooo000 + I11iiIi11i1I - ooOOO . oOO . I1Ii1I1
   if 69 - 69: ooo000 + oOo0O00
   if 78 - 78: i1 . i1i1i1111I - i1iiIII111 - i1I . I1Ii1I1 + I1I
   return { "mean" : self . mean , "stddev" : self . stddev , "seed" : self . seed }
   if 85 - 85: IiIIii11Ii
  def getTrainingInitializer ( self , shape : List [ int ] = None ) -> 'tf.initializers' :
   if 73 - 73: i1 * oOO - i1 . Oo
   if 84 - 84: IiIIii11Ii . I11iiIi11i1I . i1i1i1111I * i1 * ooo000
   if 75 - 75: Iii1i
   if 36 - 36: Ii % Ooo0Ooo + oOo0O00 * oOo0O00
   if 77 - 77: IiIIii11Ii . oOO * i1i1i1111I
   if 43 - 43: IiI11Ii111
   if 98 - 98: ooOOO % OooOoo
   if 64 - 64: i1i1i1111I % i1i1i1111I * I1Ii1I1 % oOO - IiI11Ii111
   if 7 - 7: IiI11Ii111
   if 65 - 65: Ii * Ooo0Ooo * i1i1i1111I % oOo0O00
   if 40 - 40: Ooo0Ooo
   if 82 - 82: ooo000 * Oo . iI1iII1I1I1i - OooOoo
   if 78 - 78: Iii1i / IIiIIiIi11I1 - Ii
   I1IIIi = self . getConfig ( )
   if 72 - 72: i1iiIII111
   if I1IIIi [ "stddev" ] == "auto" :
    I1IIIi [ "stddev" ] = 1 / shape [ 0 ]
   return self . _reference ( ** I1IIIi )
   if 95 - 95: IiIIii11Ii * OooOoo % Iii1i + IiI11Ii111 + IIiIIiIi11I1
 class RandomUniform ( Config ) :
  if 63 - 63: i1I * i1iiIII111 * IIiIIiIi11I1 * oOo0O00 / Ii . i1
  if 8 - 8: IiIIii11Ii . i1i1i1111I
  if 96 - 96: i1i1i1111I - IiIIii11Ii - oOO % Ooo0Ooo % I1Ii1I1
  if 99 - 99: oOo0O00 * IiI11Ii111
  if 39 - 39: Ooo0Ooo - Oo + ooOOO % IiIIii11Ii % I1I % I1Ii1I1
  if 47 - 47: IiI11Ii111
  if 74 - 74: i1i1i1111I
  def __init__ ( self , minval : float = - 1.0 , maxval : float = 1.0 , seed : int = None ) :
   if 2 - 2: i1 - I1I
   if 34 - 34: OooOoo / IIiIIiIi11I1 - IIiIIiIi11I1 * oOO . i1iiIII111
   if 74 - 74: I1Ii1I1 * I11iiIi11i1I - I1Ii1I1
   if 31 - 31: IiIIii11Ii * IiIIii11Ii * I1I + ooOOO * ooOOO
   if 69 - 69: i1 . I11iiIi11i1I
   if 82 - 82: Oo
   if 16 - 16: i1iiIII111 * ooo000 - IiI11Ii111
   if 36 - 36: IiIIii11Ii
   if 14 - 14: oOO % IiIIii11Ii
   if 48 - 48: I1I / IIiIIiIi11I1
   if 47 - 47: I11iiIi11i1I
   if 98 - 98: IIiIIiIi11I1 % i1
   super ( ) . __init__ ( tf . initializers . RandomUniform )
   self . minval = minval
   self . maxval = maxval
   self . seed = seed
   self . constructor = "RandomUniform"
   if 16 - 16: I1Ii1I1 + OooOoo + i1 * OooOoo
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 36 - 36: OooOoo + Oo
   if 95 - 95: IiIIii11Ii % IIiIIiIi11I1
   if 74 - 74: Ooo0Ooo + oOO / IIiIIiIi11I1 . I1I
   if 29 - 29: Iii1i . ooOOO - i1iiIII111
   if 99 - 99: I11iiIi11i1I * oOo0O00 . I11iiIi11i1I
   if 22 - 22: Ii + oOO - I11iiIi11i1I / I1Ii1I1 - IiIIii11Ii
   if 95 - 95: iI1iII1I1I1i % I1Ii1I1 * i1I
   if 25 - 25: iI1iII1I1I1i * Ooo0Ooo . IiIIii11Ii / iI1iII1I1I1i % I1I * ooo000
   if 3 - 3: IiIIii11Ii . oOO + OooOoo / OooOoo - I1I
   if 91 - 91: Ooo0Ooo . IiIIii11Ii - i1i1i1111I . IiIIii11Ii . OooOoo / iI1iII1I1I1i
   return { "minval" : self . minval , "maxval" : self . maxval , "seed" : self . seed }
   if 96 - 96: I1I
 class Orthogonal ( Config ) :
  if 39 - 39: oOo0O00
  if 57 - 57: ooo000 + oOO * Ooo0Ooo % I1I
  if 95 - 95: i1 . i1I - oOO % IIiIIiIi11I1
  if 2 - 2: i1iiIII111 . I11iiIi11i1I / oOO / oOO % i1i1i1111I
  if 23 - 23: i1 / IiI11Ii111 * i1iiIII111 - IiIIii11Ii - IIiIIiIi11I1 / ooo000
  if 35 - 35: Oo + i1iiIII111 / ooo000
  if 20 - 20: Iii1i / oOO
  def __init__ ( self , gain : float = 1.0 , seed : int = None ) :
   if 85 - 85: Ooo0Ooo + ooOOO
   if 87 - 87: i1I / ooo000 % Oo
   if 27 - 27: iI1iII1I1I1i . oOO . ooo000 * Ooo0Ooo . i1I
   if 76 - 76: IiI11Ii111 / ooOOO % i1i1i1111I + ooo000 . I11iiIi11i1I * I1I
   if 67 - 67: IiI11Ii111 / i1i1i1111I / OooOoo - I11iiIi11i1I % ooo000 * Iii1i
   if 40 - 40: IIiIIiIi11I1 / IiIIii11Ii % IIiIIiIi11I1 * Ii . Ooo0Ooo / I1I
   if 82 - 82: IiIIii11Ii
   if 49 - 49: Ooo0Ooo + i1iiIII111 / Ii * i1I * ooo000
   if 79 - 79: OooOoo . i1iiIII111 / I1Ii1I1
   if 71 - 71: IiI11Ii111 % Iii1i % oOO * I11iiIi11i1I % ooo000
   if 98 - 98: I11iiIi11i1I
   super ( ) . __init__ ( tf . initializers . Orthogonal )
   self . gain = gain
   self . seed = seed
   self . constructor = "Orthogonal"
   if 9 - 9: Iii1i
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 59 - 59: oOo0O00
   if 77 - 77: I1I / ooo000 * i1 . I11iiIi11i1I - I11iiIi11i1I . i1iiIII111
   if 72 - 72: oOo0O00 % ooOOO + IIiIIiIi11I1 / Oo / I1Ii1I1 / Ooo0Ooo
   if 92 - 92: IIiIIiIi11I1 - I1I - i1 % i1I . I11iiIi11i1I . Ii
   if 39 - 39: oOo0O00 % i1
   if 6 - 6: i1I - i1iiIII111 - I11iiIi11i1I - ooOOO * I1Ii1I1
   if 16 - 16: oOO . i1i1i1111I . IIiIIiIi11I1 % iI1iII1I1I1i + I1Ii1I1
   if 77 - 77: i1
   if 14 - 14: I1Ii1I1
   if 50 - 50: iI1iII1I1I1i % ooo000 + Iii1i
   return { "gain" : self . gain , "seed" : self . seed }
   if 28 - 28: OooOoo
 class Identity ( Config ) :
  if 88 - 88: OooOoo . i1i1i1111I
  if 63 - 63: iI1iII1I1I1i . oOo0O00 . i1 / IIiIIiIi11I1 / i1iiIII111
  if 68 - 68: i1i1i1111I % oOO . IiI11Ii111 + Iii1i / Ooo0Ooo
  if 28 - 28: ooOOO
  if 15 - 15: OooOoo + I1Ii1I1 - i1i1i1111I - oOO
  if 73 - 73: Iii1i
  if 74 - 74: Oo / Iii1i . i1i1i1111I
  def __init__ ( self , gain : float = 1.0 ) :
   if 59 - 59: I1Ii1I1 * i1i1i1111I + ooo000 / I1Ii1I1 * OooOoo
   if 25 - 25: Iii1i * I1I . iI1iII1I1I1i * I1Ii1I1 . Iii1i
   if 73 - 73: i1i1i1111I % oOo0O00 % i1i1i1111I . ooo000 + ooo000 % i1i1i1111I
   if 91 - 91: Ii - iI1iII1I1I1i
   if 64 - 64: I1Ii1I1 - Ii
   if 81 - 81: IiIIii11Ii + i1I . Iii1i % I1I - IiIIii11Ii * i1
   if 31 - 31: Iii1i + Oo
   if 52 - 52: Ooo0Ooo / i1iiIII111 / Ii . i1I + ooo000 + Oo
   if 63 - 63: IiIIii11Ii . i1i1i1111I
   if 94 - 94: I1I . OooOoo / Iii1i
   super ( ) . __init__ ( tf . initializers . Identity )
   self . gain = gain
   self . constructor = "Identity"
   if 76 - 76: I1I - i1I . oOo0O00 / Iii1i
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 62 - 62: I1I . i1I + Ooo0Ooo
   if 54 - 54: i1 / Ii % i1
   if 50 - 50: I11iiIi11i1I * IiIIii11Ii
   if 62 - 62: i1 / Oo % i1I
   if 41 - 41: Iii1i . oOO . Oo + OooOoo - ooo000
   if 63 - 63: i1i1i1111I . oOo0O00 * Ooo0Ooo
   if 67 - 67: Oo * ooOOO
   if 51 - 51: Iii1i . i1I / ooOOO
   if 99 - 99: IiIIii11Ii + oOo0O00 % oOo0O00 - I1Ii1I1 * Oo . I11iiIi11i1I
   if 14 - 14: Iii1i % I1I / Iii1i / ooo000 . Oo + IiI11Ii111
   return { "gain" : self . gain }
   if 67 - 67: Iii1i % Iii1i - Oo % IiIIii11Ii - Ii
 class GlorotNormal ( Config ) :
  def __init__ ( self , seed : int = None ) :
   if 59 - 59: i1I . ooo000 / iI1iII1I1I1i
   if 61 - 61: Iii1i + ooo000 + ooo000 . I1Ii1I1 * OooOoo * I11iiIi11i1I
   if 81 - 81: IiI11Ii111 / Ooo0Ooo * IiIIii11Ii
   if 55 - 55: oOO * IIiIIiIi11I1 * Iii1i / Iii1i / ooOOO
   if 72 - 72: Iii1i . ooo000 / i1iiIII111 * i1
   if 37 - 37: oOo0O00 - ooOOO . OooOoo + IIiIIiIi11I1
   if 15 - 15: iI1iII1I1I1i % i1iiIII111 + i1i1i1111I / IiIIii11Ii + IiIIii11Ii % IiIIii11Ii
   if 2 - 2: Ii . IiI11Ii111 / Ooo0Ooo . i1I * IiIIii11Ii
   if 40 - 40: i1iiIII111 / ooOOO - iI1iII1I1I1i / OooOoo
   if 76 - 76: Ooo0Ooo / i1i1i1111I * Ii
   if 79 - 79: i1I
   if 67 - 67: i1iiIII111 + Ii
   if 83 - 83: ooOOO . Ooo0Ooo * oOo0O00 * Ii - OooOoo
   if 26 - 26: iI1iII1I1I1i . Oo + Ii - Ooo0Ooo
   if 2 - 2: IiIIii11Ii / I1Ii1I1
   if 43 - 43: i1i1i1111I / ooOOO / i1i1i1111I
   super ( ) . __init__ ( tf . initializers . GlorotNormal )
   self . seed = seed
   self . constructor = "GlorotNormal"
   if 58 - 58: I1Ii1I1 / Iii1i % IiIIii11Ii % oOo0O00
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 9 - 9: ooOOO + Ii * ooo000 . i1
   if 58 - 58: IiIIii11Ii . ooOOO % I1Ii1I1 % Oo % iI1iII1I1I1i
   if 25 - 25: I1I / ooo000 % Oo % oOO . I1Ii1I1
   if 75 - 75: IiIIii11Ii * Oo - Ii / ooo000
   if 37 - 37: Ooo0Ooo + ooo000 - iI1iII1I1I1i + oOO
   if 46 - 46: i1iiIII111 / oOO . IiIIii11Ii + Ii
   if 96 - 96: oOo0O00 . i1I / i1I % IiIIii11Ii / Iii1i - i1I
   if 75 - 75: Ooo0Ooo % Oo
   if 2 - 2: IiIIii11Ii % i1iiIII111
   if 98 - 98: ooOOO
   return { "seed" : self . seed }
   if 31 - 31: OooOoo * i1iiIII111 + Iii1i / I1Ii1I1 / oOO
 class GlorotUniform ( Config ) :
  if 98 - 98: i1I + oOO . i1I . I11iiIi11i1I
  if 5 - 5: I11iiIi11i1I / IiI11Ii111 / Ii
  if 44 - 44: Ooo0Ooo . IIiIIiIi11I1
  if 29 - 29: oOO
  if 29 - 29: i1
  if 72 - 72: Iii1i + Ooo0Ooo . IIiIIiIi11I1 * ooo000 - i1I
  if 19 - 19: i1i1i1111I * Oo % Iii1i * Iii1i + Oo - i1I
  def __init__ ( self , seed : int = None ) :
   if 59 - 59: IiI11Ii111
   if 46 - 46: oOo0O00 + ooOOO + Ooo0Ooo . i1I
   if 15 - 15: I11iiIi11i1I / Ooo0Ooo - IIiIIiIi11I1
   if 27 - 27: oOo0O00 * Oo / i1iiIII111 * IiIIii11Ii * Ooo0Ooo
   if 64 - 64: i1iiIII111 % iI1iII1I1I1i % I1Ii1I1 % i1I
   if 49 - 49: Ooo0Ooo * i1
   if 22 - 22: I1I - ooOOO / IIiIIiIi11I1 / I1I . IiI11Ii111 * i1i1i1111I
   if 74 - 74: i1iiIII111 . ooo000 - Oo + i1i1i1111I + i1 * oOo0O00
   if 25 - 25: iI1iII1I1I1i
   if 51 - 51: i1 * i1I / iI1iII1I1I1i % oOO - i1i1i1111I
   super ( ) . __init__ ( tf . initializers . GlorotUniform )
   self . seed = seed
   self . constructor = "GlorotUniform"
   if 83 - 83: Ooo0Ooo * IiIIii11Ii . i1i1i1111I * Oo % Iii1i - I1Ii1I1
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 88 - 88: i1 / i1 - iI1iII1I1I1i
   if 33 - 33: I1I * i1 - Ii % I1I . I11iiIi11i1I . ooOOO
   if 25 - 25: I1I . IIiIIiIi11I1 + Oo
   if 56 - 56: OooOoo % Oo - Oo . oOo0O00 * ooo000 - I1Ii1I1
   if 4 - 4: ooOOO / oOO - i1 - IiIIii11Ii
   if 40 - 40: ooOOO
   if 42 - 42: oOo0O00 - I1I - i1i1i1111I
   if 84 - 84: ooo000
   if 66 - 66: i1I + ooo000 / i1 - Iii1i - Iii1i
   if 70 - 70: IiI11Ii111 % i1 + I1I % Oo . oOO + IiIIii11Ii
   return { "seed" : self . seed }
   if 61 - 61: Oo * IiIIii11Ii - Iii1i - I11iiIi11i1I % Ii
 class HeNormal ( Config ) :
  if 87 - 87: I11iiIi11i1I . IiI11Ii111 * Ii
  if 97 - 97: oOo0O00 / ooo000 + I1Ii1I1 * I11iiIi11i1I % Ooo0Ooo / i1i1i1111I
  if 60 - 60: ooo000 + Ii
  if 70 - 70: Ooo0Ooo / i1i1i1111I / i1I + I1I
  if 89 - 89: I11iiIi11i1I
  if 11 - 11: OooOoo - OooOoo
  if 76 - 76: I11iiIi11i1I / Iii1i * i1iiIII111 + i1 . I11iiIi11i1I . i1
  def __init__ ( self , seed : int = None ) :
   if 36 - 36: i1i1i1111I . oOo0O00 - Ooo0Ooo - i1I + I1Ii1I1
   if 93 - 93: oOO / Ooo0Ooo * Oo % I1I
   if 30 - 30: OooOoo - I1Ii1I1 * IIiIIiIi11I1 * oOO * oOO . i1i1i1111I
   if 47 - 47: i1I / IiIIii11Ii / I11iiIi11i1I
   if 69 - 69: I1Ii1I1 . i1i1i1111I
   if 26 - 26: i1i1i1111I - Ii - i1 * i1
   if 65 - 65: IIiIIiIi11I1 . iI1iII1I1I1i % ooo000
   if 2 - 2: IIiIIiIi11I1 % oOo0O00
   if 77 - 77: IIiIIiIi11I1
   if 21 - 21: ooOOO * I11iiIi11i1I % Iii1i . i1iiIII111
   super ( ) . __init__ ( tf . initializers . he_normal )
   self . seed = seed
   self . constructor = "he_normal"
   if 89 - 89: i1
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 76 - 76: Ooo0Ooo
   if 62 - 62: I1Ii1I1 . I11iiIi11i1I % i1 * IiI11Ii111 - i1
   if 78 - 78: i1iiIII111 % i1I * Ii / OooOoo % iI1iII1I1I1i / I11iiIi11i1I
   if 13 - 13: i1I - i1 + i1I
   if 41 - 41: i1I - I11iiIi11i1I
   if 94 - 94: I1Ii1I1 / Ii
   if 57 - 57: oOo0O00 * I11iiIi11i1I
   if 54 - 54: i1i1i1111I
   if 44 - 44: I1Ii1I1 * Ii / ooo000 * IIiIIiIi11I1
   if 71 - 71: i1i1i1111I
   return { "seed" : self . seed }
   if 87 - 87: ooo000 + Ii - ooOOO . i1i1i1111I * OooOoo
 class HeUniform ( Config ) :
  if 72 - 72: ooOOO
  if 38 - 38: I1Ii1I1 . oOO . Ooo0Ooo / OooOoo
  if 37 - 37: oOo0O00 - i1iiIII111 % I1Ii1I1 - iI1iII1I1I1i / oOO
  if 83 - 83: i1i1i1111I - i1 - iI1iII1I1I1i / Ooo0Ooo - Iii1i
  if 91 - 91: IiI11Ii111 / i1iiIII111 * i1i1i1111I * i1
  if 53 - 53: i1I % Ooo0Ooo . IIiIIiIi11I1 + i1i1i1111I + Ooo0Ooo
  if 76 - 76: i1 + ooo000 - i1 * i1 * IIiIIiIi11I1
  def __init__ ( self , seed : int = None ) :
   if 95 - 95: i1i1i1111I - ooOOO % IiIIii11Ii
   if 29 - 29: iI1iII1I1I1i - IIiIIiIi11I1 - I11iiIi11i1I
   if 47 - 47: IiI11Ii111 / i1iiIII111 + i1 % i1i1i1111I - oOO
   if 88 - 88: I1I * oOo0O00 - oOO + I1Ii1I1 % I1I
   if 98 - 98: Ii - OooOoo + ooOOO + Iii1i + I1Ii1I1
   if 45 - 45: Ii - Oo / I11iiIi11i1I - I1Ii1I1
   if 80 - 80: oOO % i1i1i1111I % ooo000
   if 98 - 98: Iii1i
   if 30 - 30: Ooo0Ooo * I1Ii1I1 / oOo0O00 % Iii1i
   if 29 - 29: Iii1i * I1I + ooOOO - I1Ii1I1 . Ooo0Ooo
   super ( ) . __init__ ( tf . initializers . he_uniform )
   self . seed = seed
   self . constructor = "he_uniform"
   if 79 - 79: I11iiIi11i1I . ooo000 * i1iiIII111 + Iii1i . I11iiIi11i1I
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 53 - 53: IiI11Ii111
   if 76 - 76: IIiIIiIi11I1 . I11iiIi11i1I * IiI11Ii111 / I1I
   if 87 - 87: i1
   if 17 - 17: Ii + IIiIIiIi11I1 / i1I + I1Ii1I1 + IiIIii11Ii
   if 6 - 6: ooo000
   if 48 - 48: IiIIii11Ii + IIiIIiIi11I1 + I11iiIi11i1I + ooo000
   if 28 - 28: oOO / Iii1i . IIiIIiIi11I1 * Iii1i * ooo000 + Ii
   if 44 - 44: I1I - oOo0O00 % Oo
   if 7 - 7: Iii1i - Ooo0Ooo . Oo - i1i1i1111I - i1iiIII111
   if 25 - 25: iI1iII1I1I1i
   return { "seed" : self . seed }
   if 49 - 49: I1Ii1I1 . oOo0O00 + IiIIii11Ii * ooo000
 class LecunNormal ( Config ) :
  if 77 - 77: i1I * I11iiIi11i1I . oOo0O00 . I1I
  if 30 - 30: IiI11Ii111 - i1iiIII111 - i1iiIII111 - ooOOO + Iii1i - ooo000
  if 72 - 72: I1Ii1I1 + Ooo0Ooo
  if 3 - 3: i1 / oOO % I1Ii1I1
  if 81 - 81: i1I % i1I - ooo000
  if 49 - 49: oOO . Oo * iI1iII1I1I1i % I11iiIi11i1I + Ii % oOo0O00
  if 14 - 14: Iii1i * Ooo0Ooo / i1
  def __init__ ( self , seed : int = None ) :
   if 40 - 40: ooOOO - Oo + ooo000 / i1I . i1
   if 58 - 58: I1Ii1I1 . IiI11Ii111 / Iii1i / oOo0O00 % oOo0O00
   if 28 - 28: I1Ii1I1
   if 11 - 11: i1iiIII111 + i1iiIII111
   if 57 - 57: IiI11Ii111 % Ii . I1Ii1I1 - ooo000 + ooo000
   if 97 - 97: OooOoo - Ii / I1I - IiIIii11Ii - iI1iII1I1I1i
   if 68 - 68: i1i1i1111I - IiIIii11Ii
   if 14 - 14: oOo0O00
   if 13 - 13: IIiIIiIi11I1 - iI1iII1I1I1i
   if 62 - 62: IiI11Ii111 - i1I + I1I * OooOoo
   super ( ) . __init__ ( tf . initializers . lecun_normal )
   self . seed = seed
   self . constructor = "lecun_normal"
   if 93 - 93: IiI11Ii111 + ooo000
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 62 - 62: i1i1i1111I - i1I
   if 54 - 54: i1iiIII111 + i1I - OooOoo . Iii1i
   if 78 - 78: ooOOO + Iii1i * I1Ii1I1
   if 69 - 69: ooOOO % I1I + I11iiIi11i1I % ooo000 / iI1iII1I1I1i % ooo000
   if 74 - 74: i1 . ooo000 * ooo000
   if 63 - 63: I11iiIi11i1I % I11iiIi11i1I - IiI11Ii111
   if 75 - 75: Iii1i % IIiIIiIi11I1 % Ooo0Ooo % i1
   if 73 - 73: oOo0O00
   if 16 - 16: i1 * i1I + IiI11Ii111 . IiI11Ii111 + Ii
   if 88 - 88: ooOOO + ooOOO - I1Ii1I1
   return { "seed" : self . seed }
   if 59 - 59: iI1iII1I1I1i
 class LecunUniform ( Config ) :
  if 18 - 18: ooOOO + OooOoo + IIiIIiIi11I1
  if 72 - 72: Ii . i1iiIII111 % iI1iII1I1I1i + I1Ii1I1
  if 71 - 71: Ii + i1iiIII111 - IiI11Ii111 . i1
  if 79 - 79: ooOOO
  if 49 - 49: i1
  if 58 - 58: oOO / i1 . Ooo0Ooo + IiI11Ii111 % IiI11Ii111
  if 89 - 89: Iii1i
  def __init__ ( self , seed : int = None ) :
   if 72 - 72: IiIIii11Ii * IIiIIiIi11I1 % iI1iII1I1I1i - IIiIIiIi11I1 . Iii1i + Oo
   if 25 - 25: IiI11Ii111 * IiI11Ii111 / I1Ii1I1 * ooo000 + iI1iII1I1I1i
   if 79 - 79: oOo0O00 * ooo000 * i1i1i1111I / IIiIIiIi11I1
   if 100 - 100: I11iiIi11i1I . I1Ii1I1 - Ooo0Ooo - iI1iII1I1I1i
   if 95 - 95: i1i1i1111I - i1 - oOO / I1I - oOO
   if 16 - 16: I1I . OooOoo
   if 96 - 96: oOo0O00 / IiI11Ii111 * Ooo0Ooo % oOo0O00
   if 4 - 4: ooo000 + IiIIii11Ii - i1I + iI1iII1I1I1i - Iii1i
   if 100 - 100: ooo000 / ooOOO + i1
   if 33 - 33: i1iiIII111 * Oo + Oo / iI1iII1I1I1i * ooo000
   super ( ) . __init__ ( tf . initializers . lecun_uniform )
   self . seed = seed
   self . constructor = "lecun_uniform"
   if 22 - 22: oOO
  def getConfig ( self ) -> Dict [ str , Any ] :
   if 84 - 84: i1i1i1111I
   if 90 - 90: IiI11Ii111 % i1
   if 33 - 33: oOO / Iii1i . i1I * Iii1i / IiIIii11Ii
   if 32 - 32: Iii1i + IiIIii11Ii + I11iiIi11i1I - Ooo0Ooo
   if 80 - 80: Ii % i1i1i1111I . I1Ii1I1 % I1I
   if 25 - 25: i1iiIII111
   if 18 - 18: ooOOO . i1iiIII111 . iI1iII1I1I1i
   if 42 - 42: ooOOO * OooOoo * Ooo0Ooo - Ooo0Ooo % i1i1i1111I
   if 84 - 84: iI1iII1I1I1i - i1I
   if 96 - 96: i1 / i1
   return { "seed" : self . seed }
   if 43 - 43: oOo0O00 % Iii1i / oOO . ooOOO
class OOOoO00o0 :
 if 92 - 92: Ooo0Ooo . i1i1i1111I + Iii1i
 if 28 - 28: oOO
 if 40 - 40: IIiIIiIi11I1
 if 32 - 32: Ooo0Ooo / OooOoo + ooOOO / Ooo0Ooo * IiIIii11Ii + oOo0O00
 if 55 - 55: OooOoo . Ii * oOO / Ooo0Ooo + I1Ii1I1 - Ooo0Ooo
 if 34 - 34: Ii * IiI11Ii111 . I11iiIi11i1I
 if 80 - 80: I11iiIi11i1I * IiI11Ii111
 def __init__ ( self , initializer : 'Train.Variable.Initializer.Config' = oOOOO0O0oo . TruncatedNormal ( ) , l1Loss : bool = False , l2Loss : bool = False , l1Decay : float = None , l2Decay : float = None , device : str = None ) :
  if 15 - 15: I1I * I1I + i1iiIII111
  if 82 - 82: i1iiIII111 / Ooo0Ooo * OooOoo
  if 69 - 69: Iii1i - I11iiIi11i1I - i1 . oOo0O00 % iI1iII1I1I1i * i1iiIII111
  if 10 - 10: ooOOO * Ii
  if 60 - 60: IiI11Ii111 + I11iiIi11i1I . i1iiIII111 * IiIIii11Ii . oOO * OooOoo
  if 86 - 86: IiIIii11Ii . i1iiIII111 * ooOOO
  if 54 - 54: i1i1i1111I + Ii / IiI11Ii111 - Ooo0Ooo . Oo . IiI11Ii111
  if 93 - 93: iI1iII1I1I1i % iI1iII1I1I1i / OooOoo
  if 43 - 43: i1 . Oo
  if 41 - 41: ooo000 + i1 + ooOOO % OooOoo + oOO
  if 3 - 3: ooOOO + Iii1i * i1I . I1I / i1I . IiIIii11Ii
  if 7 - 7: IIiIIiIi11I1 % Iii1i / I1I + i1I
  if 4 - 4: i1
  if 98 - 98: I1I * IiI11Ii111 / I1Ii1I1
  if 50 - 50: i1iiIII111 . IiIIii11Ii
  self . initializer = initializer
  self . l1Loss = l1Loss
  self . l2Loss = l2Loss
  self . l1Decay = l1Decay
  self . l2Decay = l2Decay
  self . device = device
  if 99 - 99: IiIIii11Ii + ooo000 * I11iiIi11i1I / IiI11Ii111 + IiIIii11Ii - ooo000
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 45 - 45: oOO - i1 * IiI11Ii111 / IiI11Ii111 / oOo0O00 % I1I
  if 10 - 10: i1I
  if 88 - 88: oOO . I11iiIi11i1I % IiIIii11Ii
  if 98 - 98: iI1iII1I1I1i % I1Ii1I1 % Iii1i % i1I
  if 44 - 44: I11iiIi11i1I / IiI11Ii111 / I11iiIi11i1I - I1I
  if 2 - 2: oOO . oOO % IiIIii11Ii - i1I * I11iiIi11i1I * oOo0O00
  if 52 - 52: Iii1i * oOo0O00 - Ooo0Ooo + i1iiIII111 / ooo000 * iI1iII1I1I1i
  if 1 - 1: iI1iII1I1I1i / Oo
  if 69 - 69: iI1iII1I1I1i % I11iiIi11i1I + i1iiIII111 - i1I . Ii % OooOoo
  if 5 - 5: OooOoo + ooOOO . i1I - Ii
  if 60 - 60: i1I / ooo000 . ooOOO
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "initializer" :
    setattr ( self , Ii1I , getattr ( oOOOO0O0oo , iiiiIi1IiiIi [ "_type" ] ) ( ) )
    getattr ( self , Ii1I ) . parseJSON ( iiiiIi1IiiIi )
   else :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 69 - 69: IIiIIiIi11I1 - IiI11Ii111 / I1Ii1I1
 def create ( self , name : str , shape : List [ int ] , dtype : 'tf.DType' = tf . float32 , defaultDevice : str = "/cpu:0" ) -> 'tf.Variable' :
  if 6 - 6: ooOOO + ooOOO
  if 2 - 2: i1 - Oo * IIiIIiIi11I1 % oOO . IiI11Ii111 * Iii1i
  if 16 - 16: I1Ii1I1
  if 8 - 8: IIiIIiIi11I1 - I1Ii1I1
  if 79 - 79: i1i1i1111I * ooo000 * ooOOO % Ooo0Ooo / ooo000 . Ooo0Ooo
  if 85 - 85: IIiIIiIi11I1 + Iii1i . i1I - i1
  if 45 - 45: i1iiIII111 - Ooo0Ooo
  if 47 - 47: Iii1i * oOO
  if 32 - 32: I1I
  if 2 - 2: i1i1i1111I . ooo000 * I11iiIi11i1I . I1Ii1I1 / i1iiIII111 . I1Ii1I1
  if 73 - 73: Ii
  if 64 - 64: ooo000 . ooOOO - I1I
  if 5 - 5: Iii1i - OooOoo + i1 % ooo000 . IIiIIiIi11I1
  if 18 - 18: oOo0O00 / ooo000
  if 95 - 95: IIiIIiIi11I1 + Ii . ooo000
  if 7 - 7: Ooo0Ooo . i1 - iI1iII1I1I1i - I11iiIi11i1I
  with tf . device ( self . device or defaultDevice ) :
   if 69 - 69: i1i1i1111I / Oo + Oo % Ii . iI1iII1I1I1i
   i1II111i1i = tf . compat . v1 . get_variable ( name , shape , initializer = self . initializer if isinstance ( self . initializer , tf . keras . initializers . Initializer ) else self . initializer . getTrainingInitializer ( shape = shape ) , dtype = dtype )
   if 84 - 84: iI1iII1I1I1i
   if 8 - 8: ooo000 + iI1iII1I1I1i + Ooo0Ooo * i1iiIII111 * IiIIii11Ii % iI1iII1I1I1i
  if self . l1Loss :
   Ooo0oO0O0O0 = tf . reduce_sum ( i1II111i1i )
   tf . compat . v1 . add_to_collection ( "losses" , Ooo0oO0O0O0 if ( self . l1Decay is None or self . l1Decay == 1 ) else tf . multiply ( Ooo0oO0O0O0 , self . l1Decay , name = "l1Loss" ) )
   if 76 - 76: IIiIIiIi11I1 + i1i1i1111I % i1I . IiI11Ii111 % I1I % IIiIIiIi11I1
   if 68 - 68: ooo000 % I1Ii1I1 + I1I
  if self . l2Loss :
   iIiiIi = tf . nn . l2_loss ( i1II111i1i )
   tf . compat . v1 . add_to_collection ( "losses" , iIiiIi if ( self . l2Decay is None or self . l2Decay == 1 ) else tf . multiply ( iIiiIi , self . l2Decay , name = "l2Loss" ) )
   if 4 - 4: oOO % Iii1i / iI1iII1I1I1i
   if 5 - 5: Iii1i
  return i1II111i1i
  if 20 - 20: IiIIii11Ii - ooOOO + IiIIii11Ii - I1I
class OoOo0oOooOo0o :
 if 7 - 7: I11iiIi11i1I + I1Ii1I1
 if 12 - 12: ooo000 / i1 / oOO . Ii
 if 96 - 96: Iii1i % I11iiIi11i1I % Ooo0Ooo
 if 89 - 89: Oo
 if 22 - 22: Iii1i % oOo0O00 + i1
 if 8 - 8: iI1iII1I1I1i + OooOoo - Oo . OooOoo
 if 57 - 57: ooo000
 class Tensors :
  if 67 - 67: Iii1i
  if 73 - 73: iI1iII1I1I1i . Ooo0Ooo - IiIIii11Ii / i1i1i1111I / i1iiIII111
  if 20 - 20: I1I - iI1iII1I1I1i * i1i1i1111I . Iii1i
  if 58 - 58: ooo000
  if 69 - 69: Ooo0Ooo % Ooo0Ooo + oOo0O00 * Oo
  if 38 - 38: IiIIii11Ii / oOo0O00 % oOO - i1I
  if 43 - 43: iI1iII1I1I1i * oOo0O00
  def __init__ ( self , results : 'tf.Tensor' , weights : List [ 'tf.Tensor' ] ) :
   if 24 - 24: i1iiIII111 / iI1iII1I1I1i - ooo000
   if 69 - 69: IIiIIiIi11I1 % IIiIIiIi11I1 * i1I / i1i1i1111I + ooo000
   if 81 - 81: i1 . I1Ii1I1 * i1 * IIiIIiIi11I1
   if 95 - 95: Oo
   if 34 - 34: Iii1i * IiIIii11Ii % Ii * iI1iII1I1I1i * i1i1i1111I * IiIIii11Ii
   if 83 - 83: IiI11Ii111
   if 79 - 79: i1 * i1 / oOo0O00 . IIiIIiIi11I1
   if 63 - 63: i1I + Ooo0Ooo
   if 10 - 10: IiIIii11Ii . IiI11Ii111 * IiIIii11Ii * i1 * I11iiIi11i1I / oOo0O00
   if 12 - 12: i1I / Iii1i * I1Ii1I1 - oOO
   if 95 - 95: i1iiIII111 . Ooo0Ooo * Ii - I1I * Iii1i
   if 74 - 74: IiIIii11Ii . I11iiIi11i1I . ooOOO / ooOOO / i1I
   self . results = results
   if 27 - 27: i1iiIII111 / I11iiIi11i1I - I11iiIi11i1I . IIiIIiIi11I1
   self . weights = weights
   if 57 - 57: i1 * IIiIIiIi11I1 + oOo0O00 / ooOOO * Oo
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'Train.Variable.LinearTransform' :
  if 91 - 91: ooo000 - Oo / IIiIIiIi11I1 % oOo0O00
  if 31 - 31: IiI11Ii111
  if 53 - 53: oOo0O00 - IiI11Ii111 / I1I
  if 18 - 18: i1 % oOo0O00 * IIiIIiIi11I1 % Iii1i
  if 78 - 78: I1Ii1I1 * i1iiIII111 % Ooo0Ooo . I1Ii1I1 * i1I % Ii
  if 72 - 72: ooOOO + OooOoo % ooo000
  if 18 - 18: I1I - Oo / i1iiIII111 / I11iiIi11i1I
  if 13 - 13: oOO * iI1iII1I1I1i
  if 51 - 51: ooOOO / ooOOO . IiI11Ii111 . iI1iII1I1I1i
  if 96 - 96: iI1iII1I1I1i + i1iiIII111 - I1Ii1I1
  if 99 - 99: ooo000 + IiI11Ii111
  if 52 - 52: Oo + i1I - i1i1i1111I / IiIIii11Ii - i1i1i1111I
  if 60 - 60: i1
  if 48 - 48: OooOoo * oOO * i1iiIII111 + iI1iII1I1I1i + i1iiIII111 . Iii1i
  if 81 - 81: IiIIii11Ii
  OO00oOOOO0O0 = OoOo0oOooOo0o ( )
  OO00oOOOO0O0 . parseJSON ( obj )
  return OO00oOOOO0O0
  if 39 - 39: i1
 def __init__ ( self , weightConfig : 'Train.Variable.Config' = None , biasConfig : 'Train.Variable.Config' = None ) :
  if 70 - 70: Oo / iI1iII1I1I1i / Ii - oOO - I1I / IiIIii11Ii
  if 78 - 78: I1Ii1I1 % OooOoo * ooOOO
  if 47 - 47: oOO + oOO
  if 16 - 16: I1I . i1 + Oo + IIiIIiIi11I1
  if 55 - 55: oOo0O00 + Oo - Oo + i1I . Oo * Ii
  if 84 - 84: oOo0O00
  if 87 - 87: i1I / i1i1i1111I * I1Ii1I1 * i1I
  if 65 - 65: i1iiIII111 / ooOOO % oOO + Iii1i * Oo * OooOoo
  if 59 - 59: OooOoo . IIiIIiIi11I1 - Oo * i1iiIII111
  if 50 - 50: i1iiIII111 % IiI11Ii111 / i1I . iI1iII1I1I1i . ooOOO + IIiIIiIi11I1
  if 73 - 73: I11iiIi11i1I . I1I . Iii1i
  if 97 - 97: I1Ii1I1 % i1I / Ii * ooOOO - Oo
  self . weightConfig = weightConfig
  if 78 - 78: i1iiIII111 - oOo0O00 % OooOoo . i1I * i1
  self . biasConfig = biasConfig
  if 60 - 60: i1iiIII111 + Ooo0Ooo / i1iiIII111 * oOO
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 58 - 58: Iii1i % I1Ii1I1
  if 31 - 31: i1iiIII111 - I1Ii1I1 - Ii - oOO . Iii1i
  if 47 - 47: Iii1i % Oo * oOO % Iii1i % Iii1i
  if 90 - 90: Iii1i . i1iiIII111
  if 25 - 25: OooOoo % ooo000 % IIiIIiIi11I1 % I1Ii1I1
  if 93 - 93: OooOoo * I1I . iI1iII1I1I1i . Ii . i1i1i1111I % Ooo0Ooo
  if 74 - 74: I1Ii1I1 / i1I / ooo000 - ooo000 * Oo / IiIIii11Ii
  if 35 - 35: IiIIii11Ii
  if 90 - 90: i1I
  if 72 - 72: iI1iII1I1I1i
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if iiiiIi1IiiIi is None or iiiiIi1IiiIi == "null" :
    setattr ( self , Ii1I , None )
   else :
    if not hasattr ( self , Ii1I ) or getattr ( self , Ii1I ) is None :
     setattr ( self , Ii1I , OOOoO00o0 ( ) )
    if iiiiIi1IiiIi is not None :
     getattr ( self , Ii1I ) . parseJSON ( iiiiIi1IiiIi )
     if 1 - 1: iI1iII1I1I1i / OooOoo * I1Ii1I1 % IiI11Ii111 * OooOoo + oOO
 def buildOn ( self , incomingTensor : 'tf.Tensor' , toUnit : int = 1 , axis : int = - 1 , weightSharing : 'tf.Tensor' = None , defaultDevice : str = "/cpu:0" ) -> 'Train.Variable.LinearTransform.Tensors' :
  if 53 - 53: oOO + i1
  if 40 - 40: ooo000 / oOO / oOO % ooOOO - IiI11Ii111
  if 42 - 42: i1i1i1111I % IiI11Ii111 . OooOoo
  if 99 - 99: i1 / IiIIii11Ii + I11iiIi11i1I % iI1iII1I1I1i + I11iiIi11i1I / i1
  if 34 - 34: I1I * I11iiIi11i1I * Oo % Ooo0Ooo
  if 11 - 11: Iii1i % i1iiIII111 + IIiIIiIi11I1 % I1I + OooOoo . i1I
  if 53 - 53: ooOOO
  if 93 - 93: Ii % IiI11Ii111 * i1i1i1111I + iI1iII1I1I1i - i1I
  if 42 - 42: I1Ii1I1 * Ii * iI1iII1I1I1i / I11iiIi11i1I % Oo % ooOOO
  if 43 - 43: i1i1i1111I % oOO . IiI11Ii111
  if 16 - 16: I1Ii1I1 * ooOOO % I11iiIi11i1I + oOo0O00
  if 69 - 69: ooOOO - ooOOO % Ii . I1Ii1I1 % I1Ii1I1 - oOO
  if 100 - 100: IiIIii11Ii - oOO * IIiIIiIi11I1 . I1Ii1I1 * Iii1i
  if 8 - 8: Iii1i * iI1iII1I1I1i + i1i1i1111I . IIiIIiIi11I1 % oOo0O00
  if 27 - 27: i1iiIII111 * i1iiIII111 - OooOoo * IiI11Ii111 * i1iiIII111 / IiIIii11Ii
  if 90 - 90: Ooo0Ooo * Iii1i % oOO
  if 35 - 35: Iii1i % Oo . oOO + Oo
  iiI1iI11 = weightSharing
  OoooOo00oO0O = [ ]
  IIIi1II1IiI1I = [ * incomingTensor . shape ]
  if 63 - 63: ooo000 - Ii / oOO
  if 28 - 28: OooOoo - oOO * IiI11Ii111
  if axis < 0 :
   axis = len ( IIIi1II1IiI1I ) + axis
   if 4 - 4: Ii . Ooo0Ooo . ooOOO / iI1iII1I1I1i * oOo0O00
   if 81 - 81: I11iiIi11i1I . ooOOO . Ii / OooOoo * I1I / Iii1i
  if ( axis >= len ( IIIi1II1IiI1I ) ) or ( axis < 0 ) :
   raise ValueError ( "Linear Transformation axis should within the dimension of the incoming tensor." )
  elif axis == 0 :
   raise ValueError ( "Linear Transformation cannot be taken on the batch dimension." )
   if 41 - 41: IiIIii11Ii - i1 - Ooo0Ooo / I1Ii1I1 % I11iiIi11i1I
   if 62 - 62: iI1iII1I1I1i + IiIIii11Ii + OooOoo + i1iiIII111
  if axis < len ( IIIi1II1IiI1I ) :
   O0Oo0OOO = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , IIIi1II1IiI1I [ axis : ] , 1 )
   incomingTensor = tf . reshape ( incomingTensor , [ * self . setAsReshape ( IIIi1II1IiI1I [ : axis ] ) , O0Oo0OOO ] )
   IIIi1II1IiI1I = [ * incomingTensor . shape ]
   if 46 - 46: ooOOO - i1 + i1
   if 37 - 37: I11iiIi11i1I % OooOoo + ooOOO % I11iiIi11i1I
  OoOo00OOo = False
  if axis > 1 :
   incomingTensor = tf . transpose ( incomingTensor , [ * [ s for s in range ( 1 , len ( IIIi1II1IiI1I ) - 1 ) ] , 0 , len ( IIIi1II1IiI1I ) - 1 ] )
   OoOo00OOo = True
   if 43 - 43: ooo000 * I1I / Ii - IiI11Ii111 - Oo + i1i1i1111I
   if 67 - 67: i1I
  if iiI1iI11 is None :
   if 51 - 51: I1I . iI1iII1I1I1i % IiI11Ii111 + i1iiIII111 + ooOOO % I1Ii1I1
   if 23 - 23: Oo % I1I * OooOoo / i1i1i1111I + IiI11Ii111
   if self . weightConfig is not None :
    iiI1iI11 = self . weightConfig . create ( "weight" , [ * IIIi1II1IiI1I [ 1 : - 1 ] , incomingTensor . shape [ - 1 ] , toUnit ] , dtype = incomingTensor . dtype , defaultDevice = defaultDevice )
    OoooOo00oO0O . append ( iiI1iI11 )
    Ooo0oo00OO0OO = tf . matmul ( incomingTensor , iiI1iI11 )
    if 25 - 25: ooOOO . IiI11Ii111 % i1I . I11iiIi11i1I
    if 43 - 43: iI1iII1I1I1i / ooOOO . Ooo0Ooo / ooOOO % IIiIIiIi11I1
   else :
    Ooo0oo00OO0OO = incomingTensor
    if 33 - 33: oOo0O00 / ooo000 - I11iiIi11i1I * i1I % I1I
    if 92 - 92: i1i1i1111I - i1i1i1111I - I11iiIi11i1I * IIiIIiIi11I1 * iI1iII1I1I1i
  else :
   OoooOo00oO0O . append ( iiI1iI11 )
   Ooo0oo00OO0OO = tf . matmul ( incomingTensor , iiI1iI11 )
   if 50 - 50: i1iiIII111 * Ii % oOO
   if 38 - 38: IiI11Ii111 . Ooo0Ooo
  if self . biasConfig is not None :
   OoOo0o0oooO = self . biasConfig . create ( "bias" , [ toUnit ] , dtype = incomingTensor . dtype , defaultDevice = defaultDevice )
   oo0O00o0oOo0o = tf . nn . bias_add ( Ooo0oo00OO0OO , OoOo0o0oooO )
   OoooOo00oO0O . append ( OoOo0o0oooO )
   if 18 - 18: IiIIii11Ii . IIiIIiIi11I1 + Ii + OooOoo
   if 81 - 81: i1iiIII111 + IiIIii11Ii % iI1iII1I1I1i % i1I - i1iiIII111
  else :
   oo0O00o0oOo0o = Ooo0oo00OO0OO
   if 48 - 48: I1Ii1I1 . I11iiIi11i1I - i1 . IIiIIiIi11I1 . I11iiIi11i1I
   if 31 - 31: Oo / i1 % i1I + oOo0O00
  if OoOo00OOo :
   oo0O00o0oOo0o = tf . transpose ( oo0O00o0oOo0o , [ len ( IIIi1II1IiI1I ) - 2 , * [ s for s in range ( 0 , len ( IIIi1II1IiI1I ) - 2 ) ] , len ( IIIi1II1IiI1I ) - 1 ] )
   if 14 - 14: i1 * ooOOO
   if 42 - 42: I1Ii1I1 * I1Ii1I1 / I11iiIi11i1I + I1Ii1I1 . oOo0O00
  return OoOo0oOooOo0o . Tensors ( oo0O00o0oOo0o , OoooOo00oO0O )
  if 45 - 45: i1i1i1111I - ooo000 . I1Ii1I1
 @ staticmethod
 def createBasicConfig ( weightAvg : float = 0.0 , weightStdDev : Union [ float , str ] = 0.04 , weightL1Loss : bool = False , weightL2Loss : bool = True ,
 weightL1Decay : float = 1 , weightL2Decay : float = 0.004 , biasInitial = 0.001 ) -> 'Train.Variable.LinearTransform' :
  if 90 - 90: I1I + Oo + IiI11Ii111 + OooOoo
  if 66 - 66: OooOoo / Ii - I1I / Oo
  if 60 - 60: Ii * I11iiIi11i1I / i1i1i1111I
  if 6 - 6: IIiIIiIi11I1 . i1 - ooOOO + I1I
  if 27 - 27: Ooo0Ooo * I1Ii1I1 . ooo000
  if 27 - 27: IiIIii11Ii * ooo000
  if 36 - 36: ooo000
  if 82 - 82: oOO % IIiIIiIi11I1
  if 5 - 5: OooOoo + Oo
  if 47 - 47: i1i1i1111I * i1 + Oo + OooOoo - I1I * ooo000
  if 65 - 65: ooOOO . oOo0O00 * oOO
  if 47 - 47: Ii - OooOoo
  if 93 - 93: oOo0O00 + IIiIIiIi11I1
  if 20 - 20: Ii + i1iiIII111
  if 93 - 93: Ii / i1i1i1111I - Oo
  if 29 - 29: Iii1i . IiIIii11Ii + I11iiIi11i1I * OooOoo % IIiIIiIi11I1
  if 47 - 47: I1I / Ii + IIiIIiIi11I1 % IiIIii11Ii . oOO - i1
  if 29 - 29: IiIIii11Ii + i1 - I11iiIi11i1I
  if 48 - 48: i1i1i1111I % OooOoo % ooOOO % IiI11Ii111 / i1I
  return OoOo0oOooOo0o ( weightConfig = None if weightAvg is None else OOOoO00o0 ( initializer = oOOOO0O0oo . TruncatedNormal ( mean = weightAvg , stddev = weightStdDev ) ,
 l1Loss = weightL1Loss , l2Loss = weightL2Loss , l1Decay = weightL1Decay , l2Decay = weightL2Decay ) ,
 biasConfig = None if biasInitial is None else OOOoO00o0 ( initializer = oOOOO0O0oo . Constant ( value = biasInitial ) ) )
  if 100 - 100: I11iiIi11i1I + i1I - Ii % Ii
 @ staticmethod
 def setAsReshape ( self , shape : List [ Union [ int , 'tf.compat.v1.Dimension' ] ] ) -> List [ int ] :
  if 45 - 45: IIiIIiIi11I1 + I1I * I11iiIi11i1I / iI1iII1I1I1i . OooOoo % ooo000
  if 81 - 81: i1I . oOo0O00 * oOo0O00 . ooOOO
  if 59 - 59: Oo . i1iiIII111 - Iii1i
  if 43 - 43: ooo000 * i1iiIII111 + IiI11Ii111 % IiI11Ii111
  if 82 - 82: ooo000 . oOO + i1I - OooOoo - I1I / I1Ii1I1
  if 38 - 38: ooOOO . i1
  if 3 - 3: ooo000
  if 31 - 31: i1I . Ii . i1I - Oo - i1 * ooo000
  if 98 - 98: i1I + i1i1i1111I
  if 98 - 98: oOo0O00 . OooOoo * OooOoo . ooo000 % OooOoo . OooOoo
  if 28 - 28: Ooo0Ooo % Oo
  if 35 - 35: OooOoo
  if 82 - 82: oOo0O00 + OooOoo / ooOOO
  if len ( [ s for s in shape if s in [ None , - 1 ] ] ) > 1 :
   raise ValueError ( "Shapes with more than 2 dynamic dimension is not reshapeable." )
   if 95 - 95: I1Ii1I1 / i1 + OooOoo . OooOoo / Ii
  return [ ( lambda O0oo0 : - 1 if O0oo0 is None else O0oo0 ) ( s ) for s in shape ]
  if 2 - 2: Oo
class i11i111iI :
 if 85 - 85: Ii + i1I
 if 63 - 63: i1 . i1 + IiI11Ii111 / ooo000 + Oo
 if 82 - 82: I1Ii1I1 - ooOOO % I11iiIi11i1I * ooOOO
 if 53 - 53: ooo000 - Ii + IiI11Ii111 % iI1iII1I1I1i - IiIIii11Ii % I1I
 if 49 - 49: ooOOO
 if 1 - 1: Iii1i / iI1iII1I1I1i * IiI11Ii111 . ooo000 . i1
 if 31 - 31: OooOoo . I1I - i1iiIII111 . Ooo0Ooo
 Initializer = oOOOO0O0oo
 Config = OOOoO00o0
 LinearTransform = OoOo0oOooOo0o
 if 61 - 61: Ooo0Ooo / IIiIIiIi11I1 . I1I * I1Ii1I1 - OooOoo % oOo0O00
 @ staticmethod
 def getFromGraph ( name : str , device : str = '/cpu:0' ) -> 'tf.Variable' :
  if 42 - 42: oOO * IIiIIiIi11I1 % iI1iII1I1I1i * I1I - oOO
  if 93 - 93: oOo0O00 / I11iiIi11i1I / i1i1i1111I / Ooo0Ooo + IiI11Ii111 / I1Ii1I1
  if 22 - 22: I11iiIi11i1I / i1
  if 26 - 26: i1i1i1111I * I11iiIi11i1I / I1Ii1I1 + I1Ii1I1 * I1I
  if 44 - 44: ooo000 . IIiIIiIi11I1 / Iii1i * oOo0O00 % Ii
  if 93 - 93: ooOOO . i1i1i1111I + oOo0O00 / I1Ii1I1 + i1I / OooOoo
  if 33 - 33: iI1iII1I1I1i - Iii1i * I11iiIi11i1I
  if 86 - 86: i1 % i1 % IiIIii11Ii * ooOOO . I1Ii1I1 - IiI11Ii111
  if 89 - 89: iI1iII1I1I1i / ooOOO
  if 15 - 15: i1iiIII111 / i1 % I1I
  if 92 - 92: I11iiIi11i1I - i1I * IiI11Ii111 + IiI11Ii111 . Iii1i
  if 44 - 44: i1I . ooOOO
  if 44 - 44: IiIIii11Ii - IiIIii11Ii % I11iiIi11i1I . I1Ii1I1 * IiIIii11Ii
  if 62 - 62: I1Ii1I1 / I1I
  if 2 - 2: IIiIIiIi11I1
  with tf . device ( device ) :
   I1IO0OOO00O = tf . compat . v1 . get_variable ( name )
   if 22 - 22: Oo % oOO + IiIIii11Ii / ooo000 * Ii + oOO
   if 82 - 82: OooOoo % OooOoo * Iii1i - I1Ii1I1
  return I1IO0OOO00O
  if 43 - 43: IiIIii11Ii * ooOOO
 @ staticmethod
 def setAsReshape ( shape : List [ Union [ int , 'tf.compat.v1.Dimension' ] ] ) -> List [ int ] :
  if 81 - 81: Oo
  if 96 - 96: IiIIii11Ii . Ooo0Ooo + oOo0O00 / OooOoo . Ooo0Ooo - iI1iII1I1I1i
  if 54 - 54: Iii1i % i1I * Ii + i1iiIII111 * ooo000 % oOo0O00
  if 62 - 62: i1
  if 26 - 26: I1Ii1I1 + i1iiIII111 + OooOoo / Iii1i
  if 56 - 56: i1 + Ooo0Ooo / i1i1i1111I
  if 38 - 38: Ii + I1I
  if 62 - 62: IiIIii11Ii
  if 20 - 20: I1I + Ii . i1i1i1111I % Ooo0Ooo + i1 % Iii1i
  if 80 - 80: i1 + i1i1i1111I * I1Ii1I1 * IiIIii11Ii / ooo000 / ooOOO
  if 76 - 76: iI1iII1I1I1i + iI1iII1I1I1i % Ooo0Ooo . iI1iII1I1I1i
  if 84 - 84: ooo000 * oOo0O00 + I11iiIi11i1I / i1 - iI1iII1I1I1i . Iii1i
  if 59 - 59: Ii . i1i1i1111I * Ii * OooOoo . oOo0O00
  if len ( [ s for s in shape if s in [ None , - 1 ] ] ) > 1 :
   raise ValueError ( "Shapes with more than 2 dynamic dimension is not reshapeable." )
   if 38 - 38: IiIIii11Ii . IiI11Ii111 - oOo0O00 * Oo / Oo
  return [ ( lambda O0oo0 : - 1 if O0oo0 is None else O0oo0 ) ( s ) for s in shape ]
  if 95 - 95: oOo0O00 - i1I * Iii1i * ooOOO . ooOOO
class i1iIi1i1i1I1 :
 if 23 - 23: oOo0O00
 if 73 - 73: Iii1i / Ooo0Ooo * Ii + i1i1i1111I + OooOoo
 if 10 - 10: iI1iII1I1I1i
 if 6 - 6: I1I + Iii1i . IiIIii11Ii + I1I . IiIIii11Ii . I11iiIi11i1I
 if 66 - 66: i1iiIII111 % ooo000 . Iii1i - Ooo0Ooo
 if 57 - 57: Oo * Oo + ooOOO
 if 67 - 67: i1i1i1111I + i1iiIII111
 class Types ( II1i1I ) :
  if 52 - 52: i1I
  Concat = 1
  if 45 - 45: ooOOO
  if 93 - 93: IIiIIiIi11I1 - Ii
  if 88 - 88: i1iiIII111 . i1
  if 70 - 70: Oo . Oo + i1i1i1111I . Ooo0Ooo
  if 23 - 23: Oo - I1I + IiI11Ii111 + ooOOO / Ii . ooo000
  if 14 - 14: i1iiIII111 - ooOOO . IIiIIiIi11I1 * i1iiIII111 / I1I + Oo
  if 90 - 90: IIiIIiIi11I1
  if 26 - 26: I1Ii1I1 . Iii1i / OooOoo - i1iiIII111
  Sum = 3
  if 94 - 94: oOO
  if 83 - 83: I1Ii1I1 + Iii1i + oOO
  Multiply = 4
  if 67 - 67: Ii * IiI11Ii111 * i1I - OooOoo
  if 41 - 41: Ooo0Ooo / Ii
  Blend = 5
  if 13 - 13: i1I . IiI11Ii111 * i1 % i1I . ooOOO . Ii
 class MergeDimMethods ( II1i1I ) :
  if 4 - 4: I11iiIi11i1I % I1Ii1I1 . IiI11Ii111 * Oo - i1I
  if 18 - 18: I1Ii1I1 * I11iiIi11i1I % oOo0O00 - i1i1i1111I * i1I + ooOOO
  if 80 - 80: ooOOO + I1I
  if 39 - 39: Ii + ooo000 / ooOOO - I1Ii1I1 * i1 - oOO
  if 91 - 91: IiI11Ii111 * Ooo0Ooo - oOO + i1i1i1111I
  if 11 - 11: i1iiIII111
  if 9 - 9: OooOoo % iI1iII1I1I1i
  if 19 - 19: Iii1i / Ooo0Ooo * IIiIIiIi11I1
  SubSample = 1
  if 61 - 61: I11iiIi11i1I % ooo000 / iI1iII1I1I1i - I11iiIi11i1I
  if 9 - 9: IIiIIiIi11I1
  SpaceToDepth = 2
  if 1 - 1: OooOoo * Ii + IiI11Ii111 % IiIIii11Ii / i1i1i1111I
  if 92 - 92: I1I / Oo * iI1iII1I1I1i + I1Ii1I1 % oOO . I1Ii1I1
  MaxPool = 3
  if 86 - 86: ooo000 - i1i1i1111I
  if 91 - 91: I1Ii1I1 * i1i1i1111I . OooOoo - i1I
  MeanPool = 4
  if 42 - 42: OooOoo . ooo000 - oOO . i1I - Oo - i1i1i1111I
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'ModelNode.Layer.Incoming.Config' :
  if 3 - 3: Iii1i + i1 * Iii1i % i1I * I1Ii1I1
  if 85 - 85: IIiIIiIi11I1 * IIiIIiIi11I1 - Ooo0Ooo / I11iiIi11i1I . i1 - I1I
  if 28 - 28: IiIIii11Ii % ooo000 . ooo000 - IIiIIiIi11I1 * Ooo0Ooo
  if 2 - 2: IiIIii11Ii + I11iiIi11i1I . Iii1i * Ii * Ii + IiI11Ii111
  if 7 - 7: Ii / IiI11Ii111 - IiIIii11Ii / i1I . I11iiIi11i1I
  if 5 - 5: Ooo0Ooo + oOo0O00 + i1i1i1111I
  if 75 - 75: oOo0O00 * OooOoo . I1I + i1i1i1111I - ooo000
  if 7 - 7: I1Ii1I1 . i1I % IiI11Ii111
  if 6 - 6: i1i1i1111I - Oo % I11iiIi11i1I * Oo
  if 95 - 95: oOO % Ooo0Ooo / IIiIIiIi11I1
  if 67 - 67: Iii1i % OooOoo / i1i1i1111I
  if 58 - 58: i1I + i1i1i1111I * IIiIIiIi11I1 . Ooo0Ooo
  if 57 - 57: Iii1i + Ii * ooOOO
  if 25 - 25: I1I + Oo * iI1iII1I1I1i + IiIIii11Ii
  iIi11i1Iii1 = getattr ( i1iIi1i1i1I1 , i1iIi1i1i1I1 . Types . getName ( obj [ "_instanceClass" ] ) ) ( )
  iIi11i1Iii1 . parseJSON ( obj )
  return iIi11i1Iii1
  if 8 - 8: IIiIIiIi11I1 - oOo0O00
 class Config :
  if 72 - 72: IiIIii11Ii - IIiIIiIi11I1 - I1I + i1iiIII111
  if 10 - 10: ooOOO / IIiIIiIi11I1 * oOo0O00
  if 26 - 26: IIiIIiIi11I1 / I11iiIi11i1I . I1Ii1I1 . iI1iII1I1I1i . oOO
  if 6 - 6: I1I . oOO - Iii1i . Iii1i . OooOoo / Iii1i
  if 65 - 65: ooOOO / Oo
  if 99 - 99: IiI11Ii111 . IiI11Ii111 * i1I . iI1iII1I1I1i
  if 45 - 45: I11iiIi11i1I * IiIIii11Ii % ooo000 . ooo000
  def __init__ ( self , method : 'ModelNode.Layer.Incoming.Types' = None , axis : int = - 1 , coreNode : 'ModelNode.Layer.Config' = None , mergeDim : 'ModelNode.Layer.Incoming.MergeDimMethods' = None ) :
   if 11 - 11: IIiIIiIi11I1 . ooOOO - ooOOO + Ii % ooOOO
   if 29 - 29: ooo000 + i1i1i1111I * OooOoo - I1Ii1I1 / iI1iII1I1I1i
   if 89 - 89: Ooo0Ooo / Iii1i . ooOOO + Ii
   if 22 - 22: Iii1i - I1Ii1I1 * oOo0O00 % IiIIii11Ii - i1iiIII111 * i1I
   if 19 - 19: I11iiIi11i1I
   if 76 - 76: oOO - ooo000 % ooOOO
   if 80 - 80: I1I / i1I * ooOOO - I1I + IiI11Ii111
   if 9 - 9: I1Ii1I1 . oOO / oOO + Ooo0Ooo - i1i1i1111I
   if 82 - 82: ooOOO + i1 / iI1iII1I1I1i
   if 30 - 30: Ii * Ii % i1iiIII111 % iI1iII1I1I1i
   if 44 - 44: iI1iII1I1I1i * IiI11Ii111
   if 40 - 40: I1I - I11iiIi11i1I . I1I * ooOOO
   if 24 - 24: Iii1i % I1Ii1I1 . i1I + IIiIIiIi11I1 / i1iiIII111 % I1Ii1I1
   if method is None or method not in i1iIi1i1i1I1 . Types :
    raise ValueError ( "Required incoming configurations is not supported." )
    if 26 - 26: i1i1i1111I - i1i1i1111I + I1Ii1I1
   self . _instanceClass = method
   if 15 - 15: ooo000 - Iii1i * IiI11Ii111 % Ooo0Ooo
   self . coreNode = coreNode
   if 6 - 6: Iii1i
   if mergeDim is None :
    mergeDim = i1iIi1i1i1I1 . MergeDimMethods . SubSample
   elif mergeDim not in i1iIi1i1i1I1 . MergeDimMethods :
    raise ValueError ( "Required incoming configurations is not supported." )
    if 49 - 49: I11iiIi11i1I + iI1iII1I1I1i % I1Ii1I1 % oOo0O00
   self . mergeDim = mergeDim
   if 17 - 17: Ooo0Ooo + oOO + i1I / oOO / ooOOO + Ii
   if not ( isinstance ( axis , int ) and axis >= - 1 ) :
    raise ValueError ( "axis should be an integer greater than or equal to -1." )
    if 81 - 81: oOo0O00 + i1iiIII111 * i1 . oOO % I1I - I11iiIi11i1I
   self . axis = axis
   if 26 - 26: ooo000 + IiI11Ii111 - I11iiIi11i1I . ooOOO . IiI11Ii111 + I11iiIi11i1I
  @ property
  def instanceClass ( self ) -> 'ModelNode.Layer.Incoming.Types' :
   if 51 - 51: OooOoo
   if 78 - 78: i1iiIII111 - I1Ii1I1 / oOO * i1 * IiIIii11Ii . I1I
   if 3 - 3: iI1iII1I1I1i . Oo % Ii % oOo0O00
   if 91 - 91: IIiIIiIi11I1 * Ooo0Ooo % i1i1i1111I . Ii + I11iiIi11i1I
   if 91 - 91: i1 / i1iiIII111 + I1Ii1I1 . I11iiIi11i1I % IiI11Ii111 / ooOOO
   if 45 - 45: I11iiIi11i1I . I1I / IIiIIiIi11I1
   if 72 - 72: oOo0O00 . IIiIIiIi11I1 * oOo0O00 * IiIIii11Ii / Iii1i
   if 59 - 59: I11iiIi11i1I / Ii / I1I
   if 77 - 77: Ii * Ii * iI1iII1I1I1i
   if 66 - 66: iI1iII1I1I1i - i1iiIII111 + Ii . i1iiIII111
   return self . _instanceClass
   if 25 - 25: IIiIIiIi11I1 + ooo000 * Ii * i1 * iI1iII1I1I1i - I1I
  def __repr__ ( self ) -> str :
   if 28 - 28: ooOOO . ooOOO / ooOOO - i1i1i1111I
   if 46 - 46: Ooo0Ooo
   if 95 - 95: IiI11Ii111 / i1iiIII111
   if 56 - 56: i1i1i1111I * ooOOO * I1Ii1I1 % ooOOO
   if 84 - 84: oOo0O00 - oOO
   if 44 - 44: iI1iII1I1I1i
   if 68 - 68: iI1iII1I1I1i * IiIIii11Ii
   if 96 - 96: I1I - ooo000 . ooOOO . ooo000
   if 4 - 4: IIiIIiIi11I1
   if 86 - 86: IiI11Ii111 . oOo0O00 - Iii1i
   return "<ModelNode.Layer.Incoming: method: \"" + str ( self ) + "\">"
   if 93 - 93: Ii
  def __str__ ( self ) -> str :
   if 94 - 94: i1iiIII111 / I11iiIi11i1I - i1iiIII111 / Ooo0Ooo % OooOoo
   if 58 - 58: oOO / IIiIIiIi11I1 - ooo000 - ooOOO + Iii1i
   if 18 - 18: IIiIIiIi11I1 + Oo
   if 37 - 37: I1I . ooOOO - Iii1i
   if 100 - 100: I1Ii1I1 % Ooo0Ooo
   if 46 - 46: i1iiIII111 - i1I / ooo000 / IiIIii11Ii - I1Ii1I1 - iI1iII1I1I1i
   if 48 - 48: ooOOO + i1 . oOo0O00
   if 75 - 75: i1I % IiI11Ii111 / IiIIii11Ii - IiIIii11Ii % i1 + ooo000
   if 85 - 85: I1Ii1I1 * Ii / i1I
   if 34 - 34: i1iiIII111 . ooOOO + ooo000 - IiIIii11Ii
   return self . instanceClass . name
   if 65 - 65: I1I * Iii1i % oOO . iI1iII1I1I1i * IiI11Ii111 - I1Ii1I1
  def parseJSON ( self , obj : Dict [ str , Any ] ) :
   if 58 - 58: ooOOO
   if 31 - 31: i1iiIII111 % OooOoo * iI1iII1I1I1i % IiIIii11Ii . I11iiIi11i1I
   if 30 - 30: ooOOO * Iii1i / OooOoo
   if 75 - 75: iI1iII1I1I1i * i1 * i1iiIII111 % ooOOO + I1Ii1I1
   if 36 - 36: OooOoo
   if 79 - 79: Iii1i % Ooo0Ooo + I11iiIi11i1I
   if 68 - 68: IiI11Ii111 * oOO * IiI11Ii111 * Ii
   if 70 - 70: ooo000 - ooOOO / I1Ii1I1 * I1Ii1I1 - iI1iII1I1I1i + iI1iII1I1I1i
   if 14 - 14: IiIIii11Ii
   if 58 - 58: I1I - oOO - i1iiIII111 . Oo - ooo000
   if 21 - 21: IIiIIiIi11I1
   for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
    if Ii1I not in [ "_instanceClass" , "mergeDim" , "method" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 28 - 28: i1i1i1111I - I11iiIi11i1I / IIiIIiIi11I1 * I1I
 class Concat ( Config ) :
  if 9 - 9: I1I . i1I . Oo
  if 51 - 51: Oo - I1Ii1I1 - ooo000 + IiI11Ii111
  if 93 - 93: i1I % Ooo0Ooo * ooo000 - i1i1i1111I / I11iiIi11i1I
  if 18 - 18: iI1iII1I1I1i + i1I
  if 81 - 81: OooOoo / IIiIIiIi11I1 + oOO - iI1iII1I1I1i - iI1iII1I1I1i . Oo
  if 51 - 51: ooOOO . i1I % iI1iII1I1I1i + IiI11Ii111
  if 19 - 19: oOO - I1Ii1I1 + I1I
  def __init__ ( self , coreNode : 'ModelNode.Layer.Config' = None , axis : int = - 1 , mergeDim : int = None ) :
   if 41 - 41: I11iiIi11i1I % Ii
   if 4 - 4: oOo0O00 / i1 . i1 - i1iiIII111 + ooOOO
   if 17 - 17: Oo - IiIIii11Ii . i1iiIII111
   if 67 - 67: i1i1i1111I / oOO
   if 15 - 15: i1i1i1111I + i1i1i1111I - Iii1i % Iii1i - Ooo0Ooo
   if 59 - 59: Ooo0Ooo * IiI11Ii111 * Oo / I1I
   if 13 - 13: i1iiIII111 + oOO / I1I / ooo000
   if 38 - 38: i1iiIII111 + Iii1i
   if 29 - 29: i1 / I1Ii1I1 * i1i1i1111I
   if 5 - 5: I1Ii1I1
   if 44 - 44: ooo000 * i1iiIII111 - IiI11Ii111
   if 9 - 9: i1I % IiI11Ii111 * IiIIii11Ii
   super ( ) . __init__ ( i1iIi1i1i1I1 . Types . Concat , axis , coreNode , mergeDim )
   if 74 - 74: Ii - Oo / IIiIIiIi11I1 * Iii1i
 class ElementWiseConfig ( Config ) :
  if 47 - 47: OooOoo % oOO + I1Ii1I1 / Ii
  if 9 - 9: i1iiIII111 / IiIIii11Ii + ooo000
  if 25 - 25: IiI11Ii111 - I11iiIi11i1I % i1 * Ooo0Ooo
  if 65 - 65: Ooo0Ooo / oOo0O00 * oOo0O00 * oOo0O00
  if 75 - 75: Iii1i . ooo000 * OooOoo / iI1iII1I1I1i - I1I
  if 73 - 73: Iii1i * ooo000
  if 91 - 91: ooOOO
  def __init__ ( self , method : int = None , coreNode : 'ModelNode.Layer.Config' = None , axis : int = - 1 , mergeDim : int = None , transformGate : int = None ,
 transformConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ,
 dimensionMappingConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ) :
   if 18 - 18: OooOoo + IiI11Ii111 % i1i1i1111I / IiI11Ii111 . I1Ii1I1
   if 35 - 35: I1I + i1iiIII111 * Ooo0Ooo . IiI11Ii111
   if 85 - 85: I1Ii1I1 % i1I . I1I % I11iiIi11i1I
   if 62 - 62: Oo . OooOoo
   if 3 - 3: OooOoo % i1I
   if 79 - 79: i1I / Ii % IiIIii11Ii . IiIIii11Ii . IiI11Ii111
   if 45 - 45: Ooo0Ooo - Ooo0Ooo . oOO
   if 97 - 97: ooo000
   if 66 - 66: i1
   if 5 - 5: Iii1i * i1iiIII111 . ooOOO
   if 54 - 54: i1i1i1111I . I1I * ooOOO . i1 / Ooo0Ooo
   if 1 - 1: ooOOO - I1Ii1I1 / Oo
   if 95 - 95: Oo
   if 45 - 45: i1iiIII111 % IiI11Ii111 % OooOoo
   if 74 - 74: IIiIIiIi11I1
   if 77 - 77: IiI11Ii111 . IiI11Ii111 - Ii * i1i1i1111I % ooo000 / oOo0O00
   super ( ) . __init__ ( method , axis , coreNode , mergeDim )
   if 9 - 9: Ooo0Ooo * i1I + Iii1i / IiIIii11Ii
   if transformGate is not None and not ( isinstance ( transformGate , int ) and transformGate >= - 1 ) :
    raise ValueError ( "transformGate should be an integer greater than or equal to -1." )
   self . transformGate = transformGate
   if 74 - 74: I1I % Iii1i - i1I
   if transformGate is not None and ( transformConfig is None or not ( isinstance ( transformConfig , i11i111iI . LinearTransform ) ) ) :
    raise ValueError ( "Where transform gate is needed, transformConfig should be passed with a Train.Variable.LinearTransform object." )
   self . transformConfig = transformConfig
   if 4 - 4: Ooo0Ooo
   self . dimensionMappingConfig = dimensionMappingConfig
   if 67 - 67: Oo
  def parseJSON ( self , obj : Dict [ str , Any ] ) :
   if 97 - 97: i1iiIII111
   if 85 - 85: Ooo0Ooo * Iii1i
   if 80 - 80: I1I + oOo0O00 % I1I + ooOOO
   if 78 - 78: OooOoo / Iii1i . Ooo0Ooo % Ii
   if 15 - 15: i1iiIII111 / Iii1i / IiIIii11Ii
   if 29 - 29: Ooo0Ooo + I1Ii1I1
   if 40 - 40: oOO % oOO * oOO * oOo0O00 . IIiIIiIi11I1 % Ii
   if 34 - 34: oOO + i1iiIII111 * IiIIii11Ii + Oo
   if 88 - 88: I1I % oOo0O00 / i1iiIII111 . iI1iII1I1I1i
   if 97 - 97: Oo + i1I . IiIIii11Ii / i1I / Iii1i . i1
   if 66 - 66: i1i1i1111I % ooo000 * IIiIIiIi11I1 - Iii1i - IiIIii11Ii % OooOoo
   for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
    if Ii1I in [ "transformConfig" , "dimensionMappingConfig" ] :
     setattr ( self , Ii1I , i11i111iI . LinearTransform ( ) )
     getattr ( self , Ii1I ) . parseJSON ( iiiiIi1IiiIi )
    elif Ii1I not in [ "_instanceClass" , "mergeDim" , "method" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 10 - 10: I11iiIi11i1I + I11iiIi11i1I - Ii * I1I + IiI11Ii111
     if 34 - 34: Iii1i % Ii
     if 66 - 66: I11iiIi11i1I * OooOoo % oOO + i1iiIII111 * I11iiIi11i1I - I1I
 class Sum ( ElementWiseConfig ) :
  if 78 - 78: Ii % IIiIIiIi11I1 / I1I . IIiIIiIi11I1 - i1i1i1111I / OooOoo
  if 7 - 7: oOO % i1I - oOo0O00
  if 67 - 67: Ii / ooOOO - I11iiIi11i1I
  if 59 - 59: I1I . Iii1i + i1I * Oo + ooOOO
  if 2 - 2: i1i1i1111I . Oo % i1
  if 91 - 91: i1i1i1111I - Ii - Ii . I11iiIi11i1I + oOo0O00 + Oo
  if 93 - 93: I1I / ooOOO * Oo % i1I . i1iiIII111 + I1Ii1I1
  def __init__ ( self , coreNode : 'ModelNode.Layer.Config' = None , axis : int = - 1 , mergeDim : int = None , transformGate : int = None ,
 transformConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ,
 dimensionMappingConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ) :
   if 41 - 41: i1I / OooOoo - i1iiIII111
   if 47 - 47: ooOOO . Oo + i1I / oOO
   if 58 - 58: i1i1i1111I
   if 8 - 8: OooOoo / i1iiIII111 . i1I / Oo + IIiIIiIi11I1
   if 56 - 56: Oo
   if 13 - 13: i1 % ooOOO / Ii
   if 77 - 77: i1iiIII111 * Ooo0Ooo / OooOoo . Oo
   if 50 - 50: i1I * I11iiIi11i1I + Ii . Iii1i
   if 10 - 10: I1Ii1I1
   if 91 - 91: Iii1i / Oo
   if 54 - 54: ooo000 % IiIIii11Ii + ooo000 * iI1iII1I1I1i
   if 32 - 32: oOO / I1I
   if 50 - 50: Oo + i1 + oOo0O00 + I1Ii1I1 - I1Ii1I1
   if 65 - 65: IIiIIiIi11I1
   if 34 - 34: Ii % I1I + i1I % Iii1i * IiI11Ii111 + IiIIii11Ii
   super ( ) . __init__ ( i1iIi1i1i1I1 . Types . Sum , coreNode , axis , mergeDim , transformGate , transformConfig , dimensionMappingConfig )
   if 1 - 1: ooOOO * I11iiIi11i1I / i1i1i1111I * oOO - i1
 class Multiply ( ElementWiseConfig ) :
  if 51 - 51: iI1iII1I1I1i + IIiIIiIi11I1
  if 23 - 23: Iii1i
  if 90 - 90: I1Ii1I1 - oOo0O00 - Ii . i1I + i1i1i1111I
  if 45 - 45: i1I - i1i1i1111I % i1iiIII111 + i1i1i1111I + oOo0O00 % i1I
  if 46 - 46: I1Ii1I1 + Ooo0Ooo % i1 + i1iiIII111 * OooOoo / Oo
  if 62 - 62: oOO / oOo0O00
  if 19 - 19: IIiIIiIi11I1 % I1Ii1I1 * i1I
  def __init__ ( self , coreNode : 'ModelNode.Layer.Config' = None , axis : int = - 1 , mergeDim : int = None , transformGate : int = None ,
 transformConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ,
 dimensionMappingConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ) :
   if 69 - 69: I1Ii1I1
   if 3 - 3: i1i1i1111I % iI1iII1I1I1i
   if 23 - 23: Oo + i1 * ooOOO * OooOoo
   if 5 - 5: i1iiIII111 * I11iiIi11i1I - Oo
   if 32 - 32: oOo0O00
   if 47 - 47: IiIIii11Ii / Ii / Ii / OooOoo
   if 36 - 36: i1
   if 3 - 3: Oo
   if 15 - 15: oOo0O00 . Ooo0Ooo
   if 39 - 39: i1i1i1111I / i1 + iI1iII1I1I1i
   if 83 - 83: Iii1i % i1iiIII111 + IiI11Ii111 * OooOoo
   if 95 - 95: IIiIIiIi11I1 - Iii1i
   if 85 - 85: Ii - oOo0O00
   if 73 - 73: IiI11Ii111 - IIiIIiIi11I1 * i1I % I11iiIi11i1I
   if 58 - 58: IiIIii11Ii / i1I - oOo0O00 - i1i1i1111I . IiIIii11Ii / Iii1i
   super ( ) . __init__ ( i1iIi1i1i1I1 . Types . Multiply , coreNode , axis , mergeDim , transformGate , transformConfig , dimensionMappingConfig )
   if 58 - 58: oOo0O00 - IiI11Ii111 % iI1iII1I1I1i - iI1iII1I1I1i / ooo000 * I1I
 class Blend ( ElementWiseConfig ) :
  if 28 - 28: I11iiIi11i1I - Ii . Oo - IiI11Ii111 . oOo0O00
  if 64 - 64: IiIIii11Ii . I1Ii1I1 * OooOoo
  if 6 - 6: i1i1i1111I
  if 19 - 19: oOo0O00 . OooOoo / IiIIii11Ii * i1I
  if 93 - 93: OooOoo / I1I
  if 98 - 98: oOo0O00 . I1I / Ooo0Ooo . Ooo0Ooo . ooo000
  if 95 - 95: IIiIIiIi11I1 * oOo0O00 + i1I - Ii - IIiIIiIi11I1
  def __init__ ( self , coreNode : 'ModelNode.Layer.Config' = None , axis : int = - 1 , mergeDim : int = None , transformGate : int = None ,
 transformConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ,
 dimensionMappingConfig : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform ( weightConfig = i11i111iI . Config ( initializer = i11i111iI . Initializer . TruncatedNormal ( mean = 0.0 , stddev = 0.05 ) ) ) ,
 learnableBlend : bool = False ) :
   if 15 - 15: IiI11Ii111
   if 68 - 68: i1iiIII111 % Oo . IiIIii11Ii . oOO - OooOoo - i1
   if 75 - 75: I1I
   if 64 - 64: i1iiIII111
   if 83 - 83: ooo000 % I1Ii1I1 . ooo000
   if 39 - 39: ooo000 / I1Ii1I1
   if 93 - 93: I11iiIi11i1I + oOo0O00 % ooo000
   if 95 - 95: iI1iII1I1I1i / ooOOO . oOO - IiIIii11Ii - Iii1i
   if 67 - 67: IiIIii11Ii . iI1iII1I1I1i * i1i1i1111I * IIiIIiIi11I1 . ooOOO % oOo0O00
   if 36 - 36: Ii
   if 20 - 20: ooOOO - IiI11Ii111 % I1Ii1I1 + oOo0O00 + iI1iII1I1I1i / IiI11Ii111
   if 27 - 27: Ooo0Ooo - oOo0O00 . oOO + ooo000
   if 95 - 95: Oo . I11iiIi11i1I % Ooo0Ooo . i1i1i1111I
   if 68 - 68: IIiIIiIi11I1 * iI1iII1I1I1i
   if 83 - 83: iI1iII1I1I1i + iI1iII1I1I1i
   if 37 - 37: iI1iII1I1I1i - oOo0O00 % OooOoo + i1 - i1
   super ( ) . __init__ ( i1iIi1i1i1I1 . Types . Blend , coreNode , axis , mergeDim , transformGate , transformConfig , dimensionMappingConfig )
   self . learnableBlend = learnableBlend
   if 83 - 83: Oo * I11iiIi11i1I * Oo % Ooo0Ooo + i1iiIII111 - oOo0O00
class iI11II1 ( II1i1I ) :
 if 57 - 57: Iii1i - iI1iII1I1I1i * Ii % iI1iII1I1I1i - Ii
 if 40 - 40: IiIIii11Ii * I1I + Iii1i . IIiIIiIi11I1 . Oo / ooOOO
 if 14 - 14: I1Ii1I1 - IiIIii11Ii
 if 76 - 76: I1Ii1I1 . i1I
 if 81 - 81: ooo000 + OooOoo - Ii + IiIIii11Ii + i1iiIII111
 if 83 - 83: i1iiIII111 / IIiIIiIi11I1 . oOo0O00 - oOO * Ooo0Ooo + i1iiIII111
 if 20 - 20: oOo0O00 - ooOOO / iI1iII1I1I1i / OooOoo + OooOoo % OooOoo
 if 4 - 4: Ii / ooOOO
 Relu = 1
 if 10 - 10: Ooo0Ooo
 Sigmoid = 2
 if 38 - 38: Ii - I1Ii1I1 - i1iiIII111 - Ii / Oo
 Tanh = 3
 if 93 - 93: iI1iII1I1I1i % Ii - IiI11Ii111
 HardSigmoid = 4
 if 53 - 53: iI1iII1I1I1i / IiIIii11Ii / Ii . i1I
 Linear = 5
 if 31 - 31: i1I . i1iiIII111
 Relu6 = 6
 if 50 - 50: I1I % Ii / Iii1i + IiIIii11Ii - ooo000 . i1I
 Selu = 7
 if 50 - 50: i1iiIII111 . I11iiIi11i1I % ooOOO + IiIIii11Ii * I1I / ooo000
 Elu = 8
 if 33 - 33: i1i1i1111I + Iii1i . I1Ii1I1 . oOO . i1I
 Softplus = 9
 if 49 - 49: Ii - Ii + OooOoo - i1
 Softsign = 10
 if 24 - 24: IiIIii11Ii
 Crelu = 11
 if 16 - 16: i1iiIII111 - IiI11Ii111 . IIiIIiIi11I1 - I1Ii1I1 % Ooo0Ooo % Iii1i
@ staticmethod
def OooO0oO ( activationName : 'Train.Activation' ) -> Callable :
 if 23 - 23: IIiIIiIi11I1 . Ii
 if 37 - 37: Ii . iI1iII1I1I1i
 if 59 - 59: OooOoo / oOO
 if 60 - 60: IiI11Ii111 % I11iiIi11i1I + i1I
 if 25 - 25: IIiIIiIi11I1 - I1Ii1I1 + ooo000 % i1i1i1111I . ooo000 - IIiIIiIi11I1
 if 86 - 86: I1I - I11iiIi11i1I % Oo . i1i1i1111I . I1I
 if 5 - 5: I1Ii1I1 + i1I * I1I / i1 % I1Ii1I1 + OooOoo
 if 27 - 27: i1iiIII111 - ooOOO . I11iiIi11i1I + Iii1i
 if 51 - 51: I1Ii1I1 / ooOOO + IiI11Ii111 % oOO - Ooo0Ooo + Ii
 if 36 - 36: I1Ii1I1
 if 54 - 54: ooo000
 if 93 - 93: i1iiIII111 + oOo0O00 * iI1iII1I1I1i / i1 % i1I / i1I
 if 61 - 61: OooOoo
 return { iI11II1 . Relu : tf . nn . relu , iI11II1 . Relu6 : tf . nn . relu6 , iI11II1 . Crelu : tf . nn . crelu , iI11II1 . Elu : tf . nn . elu ,
 iI11II1 . Selu : tf . nn . selu , iI11II1 . Softplus : tf . nn . softplus , iI11II1 . Softsign : tf . nn . softsign ,
 iI11II1 . Sigmoid : tf . nn . sigmoid , iI11II1 . Tanh : tf . nn . tanh , iI11II1 . HardSigmoid : tf . keras . backend . hard_sigmoid ,
 iI11II1 . Linear : lambda OOoo00ooOo00O : OOoo00ooOo00O } [ activationName ]
 if 16 - 16: ooo000 * ooo000 . IiI11Ii111
class I1Iiii1I1 :
 if 98 - 98: IiIIii11Ii * oOo0O00 + i1I . Ii * I1I + IIiIIiIi11I1
 if 60 - 60: I1Ii1I1
 if 80 - 80: iI1iII1I1I1i - i1iiIII111 . I1I . Ooo0Ooo + i1 / iI1iII1I1I1i
 if 24 - 24: ooOOO - ooo000 + Iii1i
 if 38 - 38: i1i1i1111I + i1I . Ii % i1iiIII111 - ooo000
 if 94 - 94: I1Ii1I1 / ooo000
 if 63 - 63: Oo . IIiIIiIi11I1 . i1iiIII111 % I1Ii1I1 . IiIIii11Ii
 class Types ( II1i1I ) :
  if 78 - 78: iI1iII1I1I1i / i1I / ooo000 . oOo0O00 % OooOoo / OooOoo
  if 78 - 78: i1 + oOO
  if 33 - 33: oOO
  if 57 - 57: ooo000 - IIiIIiIi11I1 . ooo000
  if 48 - 48: I1Ii1I1 - ooOOO / I11iiIi11i1I + i1 % Ooo0Ooo - Iii1i
  if 64 - 64: I1I % oOo0O00 / I11iiIi11i1I . I1I / IIiIIiIi11I1
  if 66 - 66: Oo - IiIIii11Ii
  if 82 - 82: ooo000 / I11iiIi11i1I - ooo000 - I11iiIi11i1I * Iii1i
  Config = 0
  if 70 - 70: IIiIIiIi11I1
  if 76 - 76: i1iiIII111 - Ii / Iii1i
  Default = 1
  if 7 - 7: IIiIIiIi11I1 / IiIIii11Ii
  if 2 - 2: Ooo0Ooo / Iii1i * IIiIIiIi11I1 + IiI11Ii111 . OooOoo
  Flatten = 2
  if 72 - 72: i1
  if 29 - 29: ooOOO . Oo / IIiIIiIi11I1 / oOo0O00
  Reshape = 3
  if 58 - 58: i1I - i1
  if 75 - 75: OooOoo * Ooo0Ooo
  SelectChannel = 4
  if 93 - 93: IiI11Ii111 % i1I + ooOOO + IIiIIiIi11I1 / OooOoo - IiI11Ii111
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'ModelNode.Layer.Output.Config' :
  if 32 - 32: i1 * i1I - I1I % oOo0O00 / IIiIIiIi11I1 . I1Ii1I1
  if 66 - 66: IiI11Ii111
  if 45 - 45: Oo % Ooo0Ooo * I11iiIi11i1I . i1I . I11iiIi11i1I
  if 97 - 97: IiI11Ii111
  if 69 - 69: Ii * Iii1i + I1I % ooo000 / I1Ii1I1
  if 57 - 57: oOo0O00 + i1iiIII111
  if 17 - 17: IiIIii11Ii - IiI11Ii111
  if 34 - 34: IIiIIiIi11I1 - i1
  if 18 - 18: IIiIIiIi11I1 * I1Ii1I1 / Oo / IiIIii11Ii + OooOoo / i1iiIII111
  if 7 - 7: ooo000
  if 80 - 80: I1Ii1I1 / iI1iII1I1I1i % IiIIii11Ii + i1i1i1111I . ooo000
  if 44 - 44: Ooo0Ooo . oOO . I1Ii1I1 - i1I + Oo + i1
  if 26 - 26: Ooo0Ooo - Iii1i * i1iiIII111 * i1iiIII111 - OooOoo
  if 83 - 83: ooo000 - oOo0O00 * i1i1i1111I - i1i1i1111I * I11iiIi11i1I
  i1iI = getattr ( I1Iiii1I1 , I1Iiii1I1 . Types . getName ( obj [ "_instanceClass" ] ) ) ( )
  i1iI . parseJSON ( obj )
  return i1iI
  if 20 - 20: i1I * Oo
 class Config :
  if 75 - 75: oOO . ooo000 + IiIIii11Ii + Ooo0Ooo . Ooo0Ooo / i1I
  if 89 - 89: i1iiIII111 % ooo000 . Ooo0Ooo - IiIIii11Ii * IiI11Ii111 + IiI11Ii111
  if 97 - 97: IiI11Ii111 . Ooo0Ooo - iI1iII1I1I1i % Ii - I1Ii1I1
  if 18 - 18: ooOOO - oOo0O00
  if 74 - 74: IiIIii11Ii % Oo * i1 + Iii1i - ooOOO * I1I
  if 88 - 88: oOo0O00 / Oo % Ooo0Ooo
  if 20 - 20: Oo / iI1iII1I1I1i - ooOOO - ooOOO
  def __init__ ( self , method : 'ModelNode.Layer.Output.Types' = None ) :
   if 19 - 19: Oo / I1Ii1I1
   if 88 - 88: Oo / i1I * IIiIIiIi11I1
   if 25 - 25: i1I . i1 . iI1iII1I1I1i + Oo / iI1iII1I1I1i
   if 42 - 42: Ii
   if 85 - 85: IiIIii11Ii % oOO
   if 31 - 31: i1iiIII111 % I11iiIi11i1I . I1I * I1Ii1I1 / Oo - Iii1i
   if 39 - 39: i1iiIII111 / I1I . i1iiIII111
   if 84 - 84: I1I * oOo0O00 * i1i1i1111I / iI1iII1I1I1i
   if 10 - 10: i1i1i1111I * i1 - IiIIii11Ii / iI1iII1I1I1i + i1i1i1111I
   if 90 - 90: I1I + I11iiIi11i1I / I1Ii1I1
   if method is None or not method in I1Iiii1I1 . Types :
    raise ValueError ( "Required output method is not supported." )
    if 42 - 42: IIiIIiIi11I1 . oOO - i1I
   self . _instanceClass = method
   if 19 - 19: OooOoo * ooo000 . OooOoo % i1I % ooOOO * i1iiIII111
  def parseJSON ( self , obj : Dict [ str , Any ] ) :
   if 99 - 99: Ii * I11iiIi11i1I / IiIIii11Ii + Oo - oOO
   if 54 - 54: Oo * I11iiIi11i1I % Ooo0Ooo . I1Ii1I1 * IiIIii11Ii
   if 38 - 38: I1I % oOo0O00 . i1 + Ooo0Ooo * i1iiIII111
   if 13 - 13: I11iiIi11i1I / Ooo0Ooo
   if 15 - 15: iI1iII1I1I1i - oOo0O00
   if 50 - 50: Ooo0Ooo
   if 13 - 13: i1iiIII111 . i1 + iI1iII1I1I1i / Iii1i
   if 62 - 62: i1 * IIiIIiIi11I1 - OooOoo . ooOOO - Iii1i - Ooo0Ooo
   if 78 - 78: i1i1i1111I / Oo / iI1iII1I1I1i
   if 68 - 68: Iii1i + ooo000 * iI1iII1I1I1i % IiI11Ii111 / Ooo0Ooo
   if 58 - 58: ooOOO . i1i1i1111I
   for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
    if Ii1I not in [ "_instanceClass" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 71 - 71: IiI11Ii111 / i1i1i1111I / Oo % ooo000
  @ property
  def instanceClass ( self ) -> 'ModelNode.Layer.Incoming.Types' :
   if 57 - 57: iI1iII1I1I1i * oOO + ooOOO - ooOOO - Iii1i
   if 100 - 100: IiI11Ii111
   if 19 - 19: IiIIii11Ii + Oo / i1iiIII111 - Iii1i + ooo000 + Oo
   if 56 - 56: oOo0O00
   if 91 - 91: ooOOO % Ii
   if 30 - 30: OooOoo - IIiIIiIi11I1 - oOo0O00 + iI1iII1I1I1i + Ooo0Ooo
   if 76 - 76: i1I . i1i1i1111I + OooOoo + Ii + IiIIii11Ii % ooo000
   if 26 - 26: Ii * I11iiIi11i1I / i1iiIII111 + I1Ii1I1
   if 65 - 65: I1I / I1I . IiI11Ii111 / Ooo0Ooo % IIiIIiIi11I1
   if 66 - 66: I1I + IiIIii11Ii
   return self . _instanceClass
   if 69 - 69: IiIIii11Ii * i1I % IiI11Ii111 . iI1iII1I1I1i - i1 - I11iiIi11i1I
  def __repr__ ( self ) -> str :
   if 47 - 47: i1I - OooOoo / ooOOO + IIiIIiIi11I1 / Ooo0Ooo
   if 26 - 26: I1Ii1I1 - IIiIIiIi11I1 % i1i1i1111I . iI1iII1I1I1i
   if 15 - 15: I1I + i1iiIII111 * i1iiIII111 % IiIIii11Ii
   if 25 - 25: IiIIii11Ii + Ooo0Ooo . i1I * IiI11Ii111 % i1iiIII111
   if 65 - 65: IiI11Ii111 / oOO + i1 - IiI11Ii111 . iI1iII1I1I1i % OooOoo
   if 67 - 67: ooOOO + iI1iII1I1I1i . i1I
   if 27 - 27: oOo0O00 % i1i1i1111I / i1I + Oo * I1Ii1I1 + i1i1i1111I
   if 46 - 46: Ii + ooo000 % iI1iII1I1I1i
   if 50 - 50: OooOoo + oOO
   if 47 - 47: Ii + Iii1i + I1Ii1I1 + IIiIIiIi11I1
   if 82 - 82: Iii1i - IiIIii11Ii / iI1iII1I1I1i + ooo000 - Ii / iI1iII1I1I1i
   return "<OutputConfig: method: \"" + str ( self ) + "\">"
   if 85 - 85: IiI11Ii111 % i1iiIII111 - Iii1i . i1I
  def __str__ ( self ) -> str :
   if 4 - 4: IiIIii11Ii * IiI11Ii111 . Iii1i + IIiIIiIi11I1
   if 22 - 22: Ooo0Ooo + Oo
   if 47 - 47: ooOOO . i1i1i1111I . Ii - OooOoo % OooOoo % OooOoo
   if 7 - 7: i1iiIII111 / I1I . Iii1i % I1Ii1I1 . i1I
   if 89 - 89: i1i1i1111I . i1i1i1111I * oOo0O00
   if 57 - 57: iI1iII1I1I1i * IiI11Ii111 / i1I
   if 8 - 8: IiIIii11Ii + OooOoo + IIiIIiIi11I1 / I1I % IiI11Ii111 * Iii1i
   if 33 - 33: IiIIii11Ii - oOo0O00 - ooo000 + oOo0O00 % oOo0O00
   if 18 - 18: I1I / i1 / oOO * oOO
   if 40 - 40: i1iiIII111 - i1I . I1I . oOo0O00 * I1I % Ii
   return self . instanceClass . name
   if 72 - 72: i1i1i1111I + I1I
 class Default ( Config ) :
  if 6 - 6: Ooo0Ooo
  if 7 - 7: ooOOO * ooOOO * Ii % I1I
  if 47 - 47: i1I * oOo0O00 / IIiIIiIi11I1 . IIiIIiIi11I1 * I1I * I1I
  if 37 - 37: i1 * Ii * iI1iII1I1I1i * oOO . OooOoo * Oo
  if 81 - 81: i1i1i1111I / Iii1i - I1I - I1Ii1I1 % i1
  if 9 - 9: iI1iII1I1I1i - I11iiIi11i1I * i1i1i1111I . Iii1i * oOO
  if 8 - 8: oOO / oOO
  def __init__ ( self ) :
   if 31 - 31: IIiIIiIi11I1 % OooOoo . IiIIii11Ii * iI1iII1I1I1i
   if 78 - 78: IiIIii11Ii / oOo0O00 - ooOOO
   if 85 - 85: i1i1i1111I
   if 78 - 78: I1I * oOo0O00 + I1Ii1I1 - ooo000 % i1I / i1I
   if 90 - 90: oOo0O00 / I1Ii1I1 . I11iiIi11i1I / ooOOO
   if 80 - 80: i1 . i1i1i1111I
   if 61 - 61: IiI11Ii111 + ooOOO . Iii1i + Ii % Iii1i % I1I
   super ( ) . __init__ ( I1Iiii1I1 . Types . Default )
   if 80 - 80: IIiIIiIi11I1 + I11iiIi11i1I / IiI11Ii111 - IiI11Ii111 / i1 + i1I
 class Flatten ( Config ) :
  if 82 - 82: Iii1i
  if 50 - 50: i1 - I1I / I1Ii1I1 % ooo000 - I1I + oOo0O00
  if 70 - 70: I1Ii1I1 . oOo0O00 * ooo000 % I11iiIi11i1I - i1I % I1Ii1I1
  if 31 - 31: oOO + i1iiIII111 + I1Ii1I1 * i1i1i1111I . Iii1i
  if 88 - 88: IiIIii11Ii
  if 87 - 87: oOo0O00 + oOo0O00 % IIiIIiIi11I1
  if 77 - 77: iI1iII1I1I1i . ooOOO
  def __init__ ( self , axis : int = 1 ) :
   if 8 - 8: oOO . Iii1i - I1I
   if 87 - 87: Oo / iI1iII1I1I1i
   if 59 - 59: IiI11Ii111 % OooOoo . IiIIii11Ii
   if 100 - 100: IiI11Ii111 * i1 % i1I
   if 10 - 10: I1I
   if 23 - 23: ooOOO
   if 14 - 14: i1 . IIiIIiIi11I1 * I11iiIi11i1I / Ii . IiI11Ii111 / iI1iII1I1I1i
   if 23 - 23: iI1iII1I1I1i + IiIIii11Ii + OooOoo . I1I - iI1iII1I1I1i
   if 8 - 8: IIiIIiIi11I1 . Ooo0Ooo % I1I * Iii1i / I1Ii1I1 / IiIIii11Ii
   if 14 - 14: Ooo0Ooo - oOO - IiI11Ii111 % I1Ii1I1
   super ( ) . __init__ ( I1Iiii1I1 . Types . Flatten )
   self . axis = axis
   if 16 - 16: oOo0O00 - Ooo0Ooo
 class Reshape ( Config ) :
  if 21 - 21: I1I
  if 28 - 28: i1I + IiIIii11Ii * oOO
  if 23 - 23: IiIIii11Ii % IiIIii11Ii - I1Ii1I1 - i1I . IiI11Ii111 / i1iiIII111
  if 77 - 77: i1I
  if 94 - 94: oOo0O00 + oOo0O00 . IiIIii11Ii - iI1iII1I1I1i / Ooo0Ooo
  if 26 - 26: I1Ii1I1 % Ooo0Ooo + I11iiIi11i1I + IiIIii11Ii
  if 70 - 70: IIiIIiIi11I1 + Ooo0Ooo - IiIIii11Ii % i1iiIII111
  def __init__ ( self , shape : List [ int ] = ( - 1 , ) ) :
   if 87 - 87: Iii1i - Oo + Ooo0Ooo % IiIIii11Ii
   if 7 - 7: IiI11Ii111 - i1I * ooOOO - i1iiIII111
   if 9 - 9: IiIIii11Ii
   if 75 - 75: i1iiIII111 . OooOoo % Ooo0Ooo + iI1iII1I1I1i % oOo0O00 . I1Ii1I1
   if 55 - 55: IiI11Ii111 - IiI11Ii111 - IiIIii11Ii
   if 6 - 6: Ii % ooo000 + Iii1i - ooo000 * I11iiIi11i1I / I1Ii1I1
   if 65 - 65: oOo0O00 . Ooo0Ooo . OooOoo
   if 98 - 98: Iii1i + I1Ii1I1 * IiI11Ii111 . I1Ii1I1
   if 24 - 24: Oo / i1 / oOO
   if 2 - 2: oOo0O00 % ooOOO
   super ( ) . __init__ ( I1Iiii1I1 . Types . Reshape )
   self . shape = shape
   if 90 - 90: IIiIIiIi11I1 / i1 - Oo + oOo0O00
 class SelectChannel ( Config ) :
  if 66 - 66: i1I + i1i1i1111I - Oo + OooOoo
  if 87 - 87: ooOOO + oOO + i1 % oOO * i1iiIII111
  if 29 - 29: i1iiIII111 / oOo0O00 % IiI11Ii111 % IiI11Ii111 * IiI11Ii111 * i1i1i1111I
  if 56 - 56: i1 + IiI11Ii111 + i1iiIII111 * OooOoo / oOO
  if 92 - 92: i1iiIII111 * OooOoo . i1I . Ii
  if 9 - 9: IIiIIiIi11I1 . oOo0O00 * iI1iII1I1I1i % i1i1i1111I / Oo
  if 11 - 11: Ooo0Ooo % I1I / Ooo0Ooo
  def __init__ ( self , axis : int = 1 , channel : int = 0 ) :
   if 4 - 4: IiI11Ii111 % Oo * i1iiIII111 . Iii1i * oOo0O00
   if 87 - 87: ooo000 % Oo * IiI11Ii111
   if 84 - 84: ooOOO * Iii1i . IiIIii11Ii * IiI11Ii111
   if 63 - 63: I1I % oOo0O00 + IiIIii11Ii
   if 77 - 77: I1Ii1I1 + Iii1i . oOo0O00 * Iii1i / I11iiIi11i1I * oOo0O00
   if 12 - 12: oOO / Ooo0Ooo * ooOOO + Ii % iI1iII1I1I1i
   if 71 - 71: i1iiIII111 / Ii + IiIIii11Ii * oOo0O00
   if 16 - 16: IiI11Ii111 . i1I . I1I
   if 59 - 59: iI1iII1I1I1i - iI1iII1I1I1i . i1I
   if 49 - 49: ooo000 . Ooo0Ooo . ooOOO % I1I . Oo + I1Ii1I1
   if 70 - 70: I1I % IiI11Ii111 - i1iiIII111
   super ( ) . __init__ ( I1Iiii1I1 . Types . SelectChannel )
   self . axis = axis
   self . channel = channel
   if 100 - 100: IiIIii11Ii % I1Ii1I1 % IIiIIiIi11I1
class oO00ooO00oOO0 ( II1iII1I11I ) :
 if 87 - 87: IiI11Ii111 + Ooo0Ooo . I11iiIi11i1I . I1Ii1I1 * Ooo0Ooo - Oo
 if 3 - 3: I1Ii1I1
 if 92 - 92: i1i1i1111I + OooOoo
 if 4 - 4: IiIIii11Ii + ooo000 % Oo % IIiIIiIi11I1 + I1I
 if 91 - 91: ooOOO % oOO / IiIIii11Ii
 if 82 - 82: I1I - IIiIIiIi11I1 / i1I + ooOOO % i1i1i1111I % i1
 if 94 - 94: IIiIIiIi11I1 * I11iiIi11i1I * Iii1i - oOO . I11iiIi11i1I
 def __init__ ( self , layerType : 'ModelNode.Layer.Types' ,
 name : str = None , layerUnits : int = 150 , final : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 0.004 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.004 , biasInitial = 0.001 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict [ str , Any ] = { } ,
 batchNorm : bool = True , batchNormParams : Dict [ str , Any ] = { } , dropout : float = 1 ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 12 - 12: i1i1i1111I * i1 . IIiIIiIi11I1 / i1iiIII111 % I1Ii1I1 * I1I
  if 26 - 26: ooOOO
  if 31 - 31: i1i1i1111I + iI1iII1I1I1i
  if 2 - 2: Oo - IIiIIiIi11I1 / IIiIIiIi11I1 % Ooo0Ooo % i1 / I11iiIi11i1I
  if 63 - 63: Ii * i1i1i1111I % I1Ii1I1 / Ii / I11iiIi11i1I
  if 19 - 19: oOo0O00 . oOo0O00
  if 67 - 67: i1 * Oo + IiI11Ii111
  if 63 - 63: Oo % ooOOO - IiIIii11Ii % Oo - Ii
  if 38 - 38: i1iiIII111 * IiI11Ii111
  if 76 - 76: Iii1i
  if 91 - 91: I11iiIi11i1I / I1Ii1I1 + ooOOO / IIiIIiIi11I1 . Oo . oOO
  if 100 - 100: Oo / IIiIIiIi11I1 / ooOOO - ooOOO / i1 . Ii
  if 44 - 44: IIiIIiIi11I1 * I1Ii1I1 % i1i1i1111I + i1 - i1 / IiIIii11Ii
  if 67 - 67: i1
  if 53 - 53: I1Ii1I1 / i1i1i1111I . i1iiIII111 * IiI11Ii111 / IIiIIiIi11I1
  if 79 - 79: IiIIii11Ii % ooo000 + i1i1i1111I / i1i1i1111I
  if 50 - 50: Ii . I1Ii1I1 - I11iiIi11i1I . OooOoo
  if 14 - 14: Iii1i + iI1iII1I1I1i
  if 100 - 100: Ooo0Ooo - i1iiIII111 + I1I * OooOoo - OooOoo % Oo
  if 97 - 97: i1iiIII111 / Oo . i1 . ooOOO + ooo000 % oOO
  if 89 - 89: Iii1i + OooOoo % i1i1i1111I % oOo0O00 % I11iiIi11i1I
  if 75 - 75: IiIIii11Ii + i1I + IiI11Ii111 + OooOoo - IiIIii11Ii
  if name is not None and O0oO ( name ) not in [ "str" , "String" ] :
   raise ValueError ( "Layer Profile Name must be a string" )
   if 63 - 63: OooOoo + Oo * iI1iII1I1I1i
  super ( ) . __init__ ( nodeType = o0OOo000o00 . Layer , name = name )
  if 47 - 47: i1I / i1I + ooOOO . ooo000
  if 42 - 42: oOo0O00
  self . _layerType = layerType
  if 39 - 39: Ooo0Ooo + IiIIii11Ii * IIiIIiIi11I1
  if 40 - 40: oOo0O00 . i1iiIII111 * i1iiIII111 / I11iiIi11i1I / I11iiIi11i1I
  if 69 - 69: oOo0O00 - i1iiIII111 - oOO . i1 % ooOOO . i1
  self . layerUnits = layerUnits
  if 11 - 11: oOo0O00 % i1i1i1111I / IiI11Ii111 / Oo
  self . linearTransform = linearTransform
  if 29 - 29: IiI11Ii111 * IIiIIiIi11I1 % ooOOO + I11iiIi11i1I
  self . batchNorm = batchNorm
  if 29 - 29: IIiIIiIi11I1 / IIiIIiIi11I1 - iI1iII1I1I1i / Oo * IiIIii11Ii
  self . batchNormParams = batchNormParams
  if 33 - 33: ooOOO / Oo
  self . activation = activation
  if 22 - 22: I1I . I1I % ooOOO
  self . activationParams = activationParams
  if 97 - 97: I1Ii1I1
  self . incomingConfig = incomingConfig
  if 37 - 37: I1Ii1I1 / iI1iII1I1I1i / Ii / iI1iII1I1I1i
  self . outputConfig = outputConfig
  if 39 - 39: IiI11Ii111
  if 62 - 62: IIiIIiIi11I1 / Ii . Ooo0Ooo
  if 31 - 31: IiI11Ii111 / IiI11Ii111
  self . _final = final
  if 72 - 72: oOO * iI1iII1I1I1i - i1 / I1Ii1I1 + Iii1i . I11iiIi11i1I
  if 44 - 44: iI1iII1I1I1i / IiIIii11Ii + oOO * Ooo0Ooo / i1
  if 21 - 21: I11iiIi11i1I
  self . dropout = dropout
  if 78 - 78: Oo + Ii * oOO
  self . _dropoutTensor = None
  if 67 - 67: i1I % i1I * I11iiIi11i1I
  self . act_dict = { iI11II1 . Relu . value : '\'relu\'' ,
 iI11II1 . Relu6 . value : 'tf.nn.relu6' ,
 iI11II1 . Crelu . value : 'tf.nn.crelu' ,
 iI11II1 . Elu . value : '\'elu\'' ,
 iI11II1 . Selu . value : '\'selu\'' ,
 iI11II1 . Softplus . value : '\'softplus\'' ,
 iI11II1 . Softsign . value : '\'softsign\'' ,
 iI11II1 . Tanh . value : '\'tanh\'' ,
 iI11II1 . HardSigmoid . value : '\'hard_sigmoid\'' ,
 iI11II1 . Sigmoid . value : '\'sigmoid\'' ,
 iI11II1 . Linear . value : 'None' ,
 }
  if 91 - 91: I11iiIi11i1I . Oo . IiI11Ii111 % I1Ii1I1 + Oo % IIiIIiIi11I1
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 91 - 91: oOo0O00 / Iii1i / ooOOO - I1I / i1I
  if 96 - 96: i1iiIII111 + oOo0O00 / I1I / i1I + iI1iII1I1I1i * Oo
  if 99 - 99: OooOoo - Iii1i * Ii + I1I % I1Ii1I1
  if 38 - 38: I1I + Ii
  if 4 - 4: i1i1i1111I * iI1iII1I1I1i * Oo / I1I - i1
  if 18 - 18: i1 * I11iiIi11i1I . IIiIIiIi11I1
  if 98 - 98: ooOOO + IIiIIiIi11I1
  if 65 - 65: Iii1i % IIiIIiIi11I1
  if 16 - 16: I1Ii1I1 . IiIIii11Ii
  if 64 - 64: i1I % IiI11Ii111 - Ii . oOo0O00 / Oo
  if 73 - 73: I1Ii1I1 * I1Ii1I1 - oOo0O00 + IiI11Ii111 * IiIIii11Ii
  if 23 - 23: iI1iII1I1I1i
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "_langMap" :
    setattr ( self , Ii1I , ( { mk : mv for mk , mv in iiiiIi1IiiIi } ) if isinstance ( iiiiIi1IiiIi , list ) else iiiiIi1IiiIi )
   elif Ii1I == "shape" :
    if 50 - 50: i1i1i1111I % OooOoo + I1I % i1i1i1111I . i1I
    if isinstance ( iiiiIi1IiiIi , list ) and len ( iiiiIi1IiiIi ) :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
    else :
     setattr ( self , Ii1I , [ iiiiIi1IiiIi ] )
   elif Ii1I == "_order" :
    if 60 - 60: i1I % Oo + ooo000 - IiIIii11Ii
    if isinstance ( iiiiIi1IiiIi , list ) and len ( iiiiIi1IiiIi ) :
     if len ( np . array ( iiiiIi1IiiIi ) ) == 2 :
      setattr ( self , Ii1I , [ s [ 0 ] for s in iiiiIi1IiiIi ] )
     else :
      setattr ( self , Ii1I , iiiiIi1IiiIi )
    else :
     setattr ( self , Ii1I , [ iiiiIi1IiiIi ] )
   elif Ii1I == "linearTransform" :
    if iiiiIi1IiiIi is not None :
     setattr ( self , Ii1I , i11i111iI . LinearTransform . createFromJSON ( iiiiIi1IiiIi ) )
    else :
     setattr ( self , Ii1I , None )
   elif Ii1I == "incomingConfig" :
    setattr ( self , Ii1I , i1iIi1i1i1I1 . createFromJSON ( iiiiIi1IiiIi ) )
   elif Ii1I == "outputConfig" :
    if iiiiIi1IiiIi is not None :
     setattr ( self , Ii1I , I1Iiii1I1 . createFromJSON ( iiiiIi1IiiIi ) )
    else :
     setattr ( self , Ii1I , None )
   elif Ii1I == "compareTensorIdx" :
    setattr ( self , "lossDppKey" , iiiiIi1IiiIi )
   elif Ii1I == "convDilation" :
    if 8 - 8: oOO
    if ( not hasattr ( train , "oldVersion" ) ) or train . oldVersion < 190305 :
     setattr ( self , Ii1I , iiiiIi1IiiIi + 1 )
    else :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
   elif Ii1I == "name" :
    if 7 - 7: IiIIii11Ii
    setattr ( self , Ii1I , self . updateNodeName ( iiiiIi1IiiIi ) )
   elif Ii1I == "refLayerName" :
    if 36 - 36: OooOoo . iI1iII1I1I1i - ooo000
    setattr ( self , Ii1I , self . updateNodeName ( iiiiIi1IiiIi ) if iiiiIi1IiiIi is not None else iiiiIi1IiiIi )
   elif Ii1I == "activation" or "Activation" in Ii1I :
    setattr ( self , Ii1I , iI11II1 ( iiiiIi1IiiIi ) )
   elif Ii1I not in [ "train" , "_layerType" , "_nodeType" , "_taskType" ] :
    setattr ( self , Ii1I , self . enumParser ( Ii1I , iiiiIi1IiiIi ) )
    if 8 - 8: OooOoo
    if 29 - 29: ooo000
  self . train = train
  if 18 - 18: IiIIii11Ii - Iii1i . Ii
 def enumParser ( self , k : str , v : Any ) -> Any :
  if 3 - 3: Ooo0Ooo - oOO
  if 45 - 45: i1 + IIiIIiIi11I1 % i1 * oOO
  if 35 - 35: i1i1i1111I * oOO * IiIIii11Ii + I11iiIi11i1I
  if 10 - 10: Ii / Oo / i1I / i1i1i1111I
  if 69 - 69: Ooo0Ooo / I1I
  if 61 - 61: Oo + i1i1i1111I
  if 18 - 18: I11iiIi11i1I * I1I . i1i1i1111I * OooOoo . ooo000
  return v
  if 20 - 20: Iii1i - IiIIii11Ii
 def isFinal ( self ) -> bool :
  if 5 - 5: oOo0O00 - I1Ii1I1 % IiIIii11Ii * I1Ii1I1
  if 20 - 20: i1iiIII111 / ooo000 + ooOOO + ooo000 - i1
  if 10 - 10: i1i1i1111I % IiIIii11Ii + IiI11Ii111 + Ii
  if 27 - 27: i1 + oOo0O00 + I1I / iI1iII1I1I1i
  if 21 - 21: Ooo0Ooo - ooo000 - OooOoo
  if 22 - 22: IIiIIiIi11I1 * i1i1i1111I - oOo0O00 - iI1iII1I1I1i
  if 76 - 76: ooOOO
  if 46 - 46: OooOoo / I1Ii1I1 + Ii
  if 47 - 47: ooOOO - IiIIii11Ii / IiI11Ii111 + oOO - Ii
  if 49 - 49: IIiIIiIi11I1 / IiI11Ii111 . ooo000
  if 6 - 6: I1I * I11iiIi11i1I + IIiIIiIi11I1 % i1i1i1111I / Ooo0Ooo . Ii
  return isinstance ( self , IIi11Iii )
  if 13 - 13: i1iiIII111 * I1Ii1I1 + Iii1i + IiIIii11Ii . ooOOO . I1I
 def _build ( self , buildNo : int ) :
  if 82 - 82: Ii % I11iiIi11i1I * oOO - Iii1i
  if 68 - 68: i1iiIII111 / IiIIii11Ii % I11iiIi11i1I + i1 * Ooo0Ooo
  if 34 - 34: oOO + IiIIii11Ii - IiI11Ii111
  if 58 - 58: IIiIIiIi11I1 % OooOoo + oOo0O00 + i1I / Ii
  if 94 - 94: ooo000 / I1Ii1I1 % IIiIIiIi11I1
  if 42 - 42: ooOOO % IIiIIiIi11I1 % I11iiIi11i1I * i1iiIII111
  if 8 - 8: I11iiIi11i1I - Ooo0Ooo * I1Ii1I1 - i1 + I11iiIi11i1I . Oo
  if 43 - 43: oOO . iI1iII1I1I1i - IiI11Ii111 % IiIIii11Ii + Oo
  if 14 - 14: I1Ii1I1 / Ooo0Ooo + i1i1i1111I - i1I * IiI11Ii111
  if 76 - 76: i1iiIII111 - I1Ii1I1
  self . _clearTempTensors ( )
  raise ValueError ( "ModelNode.Layer.Config cannot be built directly. Please opt for a specific layer profile like ModelNode.Layer.Convolution or a CustomLayerProfile." )
  if 28 - 28: Iii1i . OooOoo . IiI11Ii111 * IiIIii11Ii
 def _clearTempTensors ( self ) :
  if 79 - 79: I1I - i1i1i1111I + IIiIIiIi11I1 % iI1iII1I1I1i + IiIIii11Ii . I1I
  if 24 - 24: i1I
  if 92 - 92: i1i1i1111I - i1
  if 88 - 88: i1i1i1111I . oOo0O00 + ooOOO - IiI11Ii111 . I1Ii1I1 - i1I
  if 85 - 85: Ii . Ooo0Ooo / IIiIIiIi11I1
  if 42 - 42: ooo000 . i1 % I11iiIi11i1I / ooOOO % Ii
  if 10 - 10: iI1iII1I1I1i
  self . _weights = [ ]
  self . _dropoutTensor = None
  if 10 - 10: i1 . IIiIIiIi11I1
 def _getTensorsFromPreviousNodes ( self , buildNo : int = 0 ) -> List [ 'tf.Tensor' ] :
  if 4 - 4: Oo - ooOOO % iI1iII1I1I1i - Ii % oOO
  if 60 - 60: i1 * I1I - Oo * Ooo0Ooo
  if 74 - 74: IiIIii11Ii - IiI11Ii111
  if 22 - 22: Ooo0Ooo + i1i1i1111I . Iii1i . ooo000
  if 82 - 82: iI1iII1I1I1i * oOo0O00 - Iii1i . iI1iII1I1I1i % Ii
  if 9 - 9: OooOoo / ooo000 + i1i1i1111I - Iii1i % ooo000
  if 13 - 13: I11iiIi11i1I
  if 44 - 44: Ii - Iii1i
  if 64 - 64: Iii1i
  if 13 - 13: OooOoo
  if 97 - 97: Oo / I1Ii1I1
  if 90 - 90: I1I % Ii % Oo + Ii
  if 16 - 16: oOO
  return [ n . _outputTensor for n in self . fromNode [ buildNo ] ]
  if 9 - 9: i1I - ooOOO / i1I * Iii1i . iI1iII1I1I1i - Ooo0Ooo
 def _getTensorsFromPreviousSources ( self , buildNo : int = 0 ) -> List [ 'tf.Tensor' ] :
  if 79 - 79: i1i1i1111I - Oo . IiI11Ii111 + i1i1i1111I + i1i1i1111I
  if 100 - 100: I1Ii1I1 / OooOoo % OooOoo * IiIIii11Ii
  if 15 - 15: ooOOO - i1I / I11iiIi11i1I + ooo000 * Oo
  if 56 - 56: Oo / IIiIIiIi11I1 . OooOoo . i1iiIII111
  if 33 - 33: ooo000 % i1iiIII111 + Ii
  if 21 - 21: I1Ii1I1 + i1i1i1111I * OooOoo % ooOOO + I11iiIi11i1I * Ii
  if 43 - 43: IiIIii11Ii - i1iiIII111 % I1Ii1I1 . OooOoo + OooOoo + Ooo0Ooo
  if 28 - 28: I1Ii1I1 + i1
  if 15 - 15: i1iiIII111 - I11iiIi11i1I + IIiIIiIi11I1 - I1I . Iii1i / OooOoo
  if 3 - 3: I1I . OooOoo % i1 . Oo
  if 100 - 100: iI1iII1I1I1i - iI1iII1I1I1i - oOo0O00 + I1Ii1I1 % I1Ii1I1
  if 66 - 66: oOO - IIiIIiIi11I1 . IiI11Ii111 / Ii . IiI11Ii111 + Ooo0Ooo
  if 30 - 30: i1I
  return [ self . train . _sourceTensors [ dppKey ] for dppKey in self . fromSource [ buildNo ] ]
  if 50 - 50: iI1iII1I1I1i - I1Ii1I1 - ooo000 % Ii
 def _getTensorsFromAvailableInputs ( self , buildNo : int = 0 ) -> List [ 'tf.Tensor' ] :
  if 81 - 81: IiI11Ii111 * Ooo0Ooo
  if 84 - 84: IiI11Ii111 % Ii . ooOOO
  if 92 - 92: Ooo0Ooo . IiI11Ii111 + ooOOO + i1iiIII111
  if 82 - 82: oOo0O00 + IiIIii11Ii - iI1iII1I1I1i - Oo * i1
  if 89 - 89: Oo - I1I + I1Ii1I1 + I11iiIi11i1I - i1I * I1I
  if 82 - 82: iI1iII1I1I1i % I1I
  if 19 - 19: ooo000 - Ooo0Ooo
  if 42 - 42: oOO * oOo0O00 * OooOoo
  if 64 - 64: oOo0O00 % oOo0O00 - i1iiIII111
  if 81 - 81: Ii * Iii1i / Iii1i
  if 20 - 20: oOo0O00 . ooo000 / i1iiIII111 - oOo0O00 % I1I + oOO
  if 71 - 71: OooOoo / i1
  if 40 - 40: i1 * IiIIii11Ii / ooo000
  return [ * self . _getTensorsFromPreviousSources ( buildNo = buildNo ) , * self . _getTensorsFromPreviousNodes ( buildNo = buildNo ) ]
  if 54 - 54: OooOoo / IiI11Ii111 % Ooo0Ooo * IIiIIiIi11I1 + IiIIii11Ii
 def _combineIncomingTensors ( self , buildNo : int = 0 ) -> 'tf.Tensor' :
  if 39 - 39: OooOoo * Iii1i * IiI11Ii111 / Iii1i % Oo
  if 26 - 26: iI1iII1I1I1i * ooo000
  if 10 - 10: IiIIii11Ii . iI1iII1I1I1i * Iii1i - oOo0O00 . i1i1i1111I
  if 15 - 15: IiIIii11Ii
  if 96 - 96: ooo000 . I1I / IiIIii11Ii . IiI11Ii111 / ooOOO
  if 21 - 21: Oo . oOO + ooo000 - Ii + i1I
  if 100 - 100: ooo000
  if 26 - 26: IiIIii11Ii - IiIIii11Ii . IiI11Ii111 - Oo / IiIIii11Ii
  if 9 - 9: IiI11Ii111
  if 72 - 72: Ii
  if 4 - 4: ooOOO % i1 + Ii . iI1iII1I1I1i / i1 - OooOoo
  if 97 - 97: ooo000
  if 43 - 43: oOo0O00 % iI1iII1I1I1i / Ooo0Ooo * I1I
  self . _inputCollections = iiiIII1i = [ * self . _getTensorsFromPreviousSources ( buildNo = buildNo ) , * self . _getTensorsFromPreviousNodes ( buildNo = buildNo ) ]
  if 89 - 89: i1i1i1111I . i1 + Ii . i1iiIII111 - IiI11Ii111 / I11iiIi11i1I
  if 61 - 61: ooOOO
  iiiIII1i = [ tf . cast ( node , self . _dataType ) if node . dtype != self . _dataType else node for node in iiiIII1i ]
  if 14 - 14: Ooo0Ooo / oOo0O00 * OooOoo
  if 76 - 76: ooo000 . ooOOO
  if len ( iiiIII1i ) == 0 :
   raise ValueError ( "There is no input layers for this layer (" + self . name + ")." )
   if 94 - 94: oOo0O00 . I11iiIi11i1I / I1I * I11iiIi11i1I
   if 96 - 96: Ooo0Ooo
  elif len ( iiiIII1i ) == 1 :
   O0o0000OOoO0O = iiiIII1i [ 0 ]
   if 85 - 85: i1 + i1I % IIiIIiIi11I1 + i1iiIII111
   if 18 - 18: IIiIIiIi11I1 % oOo0O00 / IiI11Ii111 + i1I - oOO
  else :
   if 76 - 76: I1Ii1I1 / i1iiIII111 + oOo0O00 + ooOOO . OooOoo
   iiiIII1i = [ node if len ( node . shape ) > 1 else tf . reshape ( node , [ node . shape [ 0 ] , 1 ] ) for node in iiiIII1i ]
   if 16 - 16: Iii1i
   if 15 - 15: i1I * ooo000 % Oo
   I1IIIi111 = None
   I111IIi1I = [ tuple ( O0oo0 for O0oo0 in tensor . shape ) for tensor in iiiIII1i ]
   i1Ii1 = min ( [ len ( O0oo0 ) for O0oo0 in I111IIi1I ] )
   i11i1I1Ii1I1i = self . incomingConfig . instanceClass in [ i1iIi1i1i1I1 . Types . Sum , i1iIi1i1i1I1 . Types . Multiply , i1iIi1i1i1I1 . Types . Blend ]
   if 82 - 82: I1I - IIiIIiIi11I1 - I1I
   if 14 - 14: I1Ii1I1 + oOo0O00
   if self . incomingConfig . coreNode is None :
    if 47 - 47: IIiIIiIi11I1 * Oo . Oo / Oo * i1i1i1111I
    OOo = [ ( ooOoooO0OOo , tensor ) for ooOoooO0OOo , tensor in enumerate ( iiiIII1i ) if len ( tensor . shape ) == i1Ii1 and ooOoooO0OOo >= len ( self . fromSource [ buildNo ] ) ]
    if 86 - 86: oOO + I1I
    if 53 - 53: i1I + I1Ii1I1
    III = [ ( ooOoooO0OOo , functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO . value , tensor . shape [ 1 : - 1 ] , 1 ) ) for ooOoooO0OOo , tensor in OOo ]
    O0O0O = min ( [ O0oo0 for ooOoooO0OOo , O0oo0 in III ] )
    IiII1111iiII1iII = [ ooOoooO0OOo for ooOoooO0OOo , O0oo0 in III if O0oo0 == O0O0O ] [ 0 ]
    if 21 - 21: I1I - Ooo0Ooo % I1I + I1I * Ooo0Ooo . i1i1i1111I
   else :
    if 99 - 99: IiI11Ii111 . IiI11Ii111
    if self . incomingConfig . coreNode not in self . fromNode [ buildNo ] :
     raise ValueError ( "Core node not in the from node list." )
     if 19 - 19: oOO - IIiIIiIi11I1 * oOo0O00 % IIiIIiIi11I1 / IIiIIiIi11I1
     if 43 - 43: i1iiIII111
    IiII1111iiII1iII = len ( self . fromSource [ buildNo ] ) + self . fromNode [ buildNo ] . index ( self . incomingConfig . coreNode )
    if 29 - 29: iI1iII1I1I1i * Ii / i1I * iI1iII1I1I1i
    if 96 - 96: ooo000 . IiI11Ii111 - i1I
   I1IIIi111 = iiiIII1i [ IiII1111iiII1iII ]
   if 14 - 14: OooOoo * oOO * ooo000 + i1iiIII111 % ooOOO % oOo0O00
   if 11 - 11: i1I + I1I / i1i1i1111I . i1i1i1111I
   O00OOooO0oo0 = tuple ( O0oo0 for O0oo0 in I1IIIi111 . shape )
   if 6 - 6: Iii1i * i1 * i1 - I1Ii1I1
   if 30 - 30: Oo + i1iiIII111 % OooOoo / i1i1i1111I % IiIIii11Ii - ooo000
   iiI1i11Ii11I1 = ( len ( O00OOooO0oo0 ) - 1 ) if self . incomingConfig . axis == - 1 else self . incomingConfig . axis
   if 38 - 38: ooOOO + I1I + Iii1i . oOo0O00 - iI1iII1I1I1i + IIiIIiIi11I1
   if 61 - 61: oOo0O00 . IiIIii11Ii - Oo
   if iiI1i11Ii11I1 >= len ( O00OOooO0oo0 ) :
    if 65 - 65: ooo000 . i1
    raise ValueError ( "Axis is larger than or equal to the length of core node's shape." )
    if 26 - 26: i1 + i1
   elif any ( [ ( None in O0oo0 [ 1 : ] ) for O0oo0 in I111IIi1I ] ) :
    if 91 - 91: Ii / iI1iII1I1I1i + IiIIii11Ii * iI1iII1I1I1i
    raise ValueError ( "There should be no varied dimensions on dimension 1 or above." )
    if 89 - 89: ooo000 - iI1iII1I1I1i . I1Ii1I1 . Iii1i + iI1iII1I1I1i
   elif not all ( [ all ( [ ( dim == O00OOooO0oo0 [ ooOoooO0OOo + 1 ] or dim % O00OOooO0oo0 [ ooOoooO0OOo + 1 ] == 0 ) for ooOoooO0OOo , dim in enumerate ( O0oo0 [ 1 : iiI1i11Ii11I1 ] ) ] ) for O0oo0 in I111IIi1I ] ) :
    if 93 - 93: Ooo0Ooo - ooo000 . IiIIii11Ii % Iii1i
    raise ValueError ( "Some incoming layers are not having the same dimension or multiplicative dimension as the core node along the dimensions before the concatenation axis." )
    if 66 - 66: OooOoo * i1i1i1111I - Ii
    if 54 - 54: Ooo0Ooo % IiIIii11Ii + I1I * ooo000 / ooOOO
   for ooOoooO0OOo , ooOoOOoo00 in enumerate ( iiiIII1i ) :
    if 64 - 64: ooOOO . I1Ii1I1 . ooOOO
    if len ( I111IIi1I [ ooOoooO0OOo ] ) > iiI1i11Ii11I1 + 1 :
     I1I1I = I111IIi1I [ ooOoooO0OOo ] [ iiI1i11Ii11I1 : ]
     IIiiii111ii = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , I1I1I , 1 )
     iiiIII1i [ ooOoooO0OOo ] = tf . reshape ( ooOoOOoo00 , [ * i11i111iI . setAsReshape ( I111IIi1I [ ooOoooO0OOo ] [ : iiI1i11Ii11I1 ] ) , IIiiii111ii ] )
     if 66 - 66: ooo000 . I1I * oOO % Oo
     if 76 - 76: i1I * OooOoo
    elif len ( I111IIi1I [ ooOoooO0OOo ] ) <= iiI1i11Ii11I1 :
     iiiIII1i [ ooOoooO0OOo ] = tf . reshape ( ooOoOOoo00 , i11i111iI . setAsReshape ( [ ( I111IIi1I [ ooOoooO0OOo ] [ dimIdx ] if dimIdx < len ( I111IIi1I [ ooOoooO0OOo ] ) else 1 ) for dimIdx in range ( 0 , iiI1i11Ii11I1 ) ] ) )
     I111IIi1I [ ooOoooO0OOo ] = tuple ( O0oo0 for O0oo0 in iiiIII1i [ ooOoooO0OOo ] . shape )
     if 62 - 62: i1I
     if 13 - 13: i1I % oOO / IiI11Ii111 . IIiIIiIi11I1 % IiI11Ii111
    if I111IIi1I [ ooOoooO0OOo ] [ : iiI1i11Ii11I1 ] != O00OOooO0oo0 [ : iiI1i11Ii11I1 ] :
     if 17 - 17: Ooo0Ooo
     o0oOO0oo0o0O = [ ( None if ( dim is None or O00OOooO0oo0 [ dimIdx ] is None ) else int ( dim / O00OOooO0oo0 [ dimIdx ] ) ) for dimIdx , dim in enumerate ( I111IIi1I [ ooOoooO0OOo ] [ : iiI1i11Ii11I1 ] ) ]
     if 92 - 92: i1iiIII111 * OooOoo * Ooo0Ooo / OooOoo
     if 40 - 40: i1iiIII111 . I11iiIi11i1I / i1 % I11iiIi11i1I / Oo
     if self . incomingConfig . mergeDim in [ i1iIi1i1i1I1 . MergeDimMethods . SpaceToDepth , i1iIi1i1i1I1 . MergeDimMethods . SubSample ] :
      if len ( o0oOO0oo0o0O ) == 3 and ( o0oOO0oo0o0O [ 1 ] == o0oOO0oo0o0O [ 2 ] ) and iiI1i11Ii11I1 == len ( O00OOooO0oo0 ) - 1 :
       if 52 - 52: i1i1i1111I + IIiIIiIi11I1 - i1i1i1111I / I1I
       if 11 - 11: oOo0O00 - i1 % i1 . OooOoo + IIiIIiIi11I1
       iiiIII1i [ ooOoooO0OOo ] = tf . nn . space_to_depth ( ooOoOOoo00 , o0oOO0oo0o0O [ 1 ] )
      else :
       oO0oOO0 = ooOoOOoo00
       o0oO0OoOo0o = [ ]
       ooOO00oOo = I111IIi1I [ ooOoooO0OOo ] [ iiI1i11Ii11I1 ]
       if 69 - 69: I1I
       if 37 - 37: i1
       if 43 - 43: I1I
       Ii1II1I1 = 0
       OO00OO0OO = [ ]
       for o0O , iiI in enumerate ( o0oOO0oo0o0O ) :
        if iiI is not None and iiI > 1 :
         oO0oOO0 = tf . convert_to_tensor ( tf . split ( oO0oOO0 , iiI , axis = ( o0O + Ii1II1I1 ) ) )
         ooOO00oOo *= iiI
         Ii1II1I1 += 1
         OO00OO0OO . append ( True )
        else :
         OO00OO0OO . append ( False )
         if 42 - 42: IIiIIiIi11I1 % ooOOO - IiIIii11Ii . I1I . i1i1i1111I
         if 44 - 44: I1I
       Oo000OO = Ii1II1I1
       for O0o0OOOOOooOo , O0oo0 in enumerate ( OO00OO0OO ) :
        if O0oo0 :
         Ii1II1I1 -= 1
         o0oO0OoOo0o . append ( Ii1II1I1 )
        else :
         o0oO0OoOo0o . append ( Oo000OO + O0o0OOOOOooOo )
       Ii1111iIiiIII = set ( range ( 0 , len ( oO0oOO0 . shape ) ) ) - set ( o0oO0OoOo0o )
       o0oO0OoOo0o = [ * o0oO0OoOo0o , * Ii1111iIiiIII ]
       if 18 - 18: IiI11Ii111 * Ooo0Ooo - IiIIii11Ii - I1Ii1I1 - Ii
       if 54 - 54: Ii * IiI11Ii111 / I1I / ooo000
       oO0oOO0 = tf . transpose ( oO0oOO0 , o0oO0OoOo0o )
       if 57 - 57: iI1iII1I1I1i - oOo0O00 + Ii . oOO * I1I + i1I
       if 61 - 61: Oo
       iiiIII1i [ ooOoooO0OOo ] = tf . reshape ( oO0oOO0 , [ * i11i111iI . setAsReshape ( [ preShape for preShape in oO0oOO0 . shape [ : iiI1i11Ii11I1 ] ] ) , ooOO00oOo ] )
       if 67 - 67: Ii * Iii1i
       if 28 - 28: Ii + i1 % I11iiIi11i1I + IIiIIiIi11I1 / Oo * IIiIIiIi11I1
      if self . incomingConfig . mergeDim == i1iIi1i1i1I1 . MergeDimMethods . SubSample :
       iiiIII1i [ ooOoooO0OOo ] = iiiIII1i [ ooOoooO0OOo ] [ ... , 0 : I111IIi1I [ ooOoooO0OOo ] [ iiI1i11Ii11I1 ] ]
       if 26 - 26: OooOoo * I1I . Iii1i . ooo000 - oOo0O00 - Ooo0Ooo
       if 90 - 90: I11iiIi11i1I . IIiIIiIi11I1 + I11iiIi11i1I
     elif self . incomingConfig . mergeDim in [ i1iIi1i1i1I1 . MergeDimMethods . MaxPool , i1iIi1i1i1I1 . MergeDimMethods . MeanPool ] :
      if 66 - 66: IiI11Ii111 * I11iiIi11i1I - I11iiIi11i1I % oOo0O00
      if None in o0oOO0oo0o0O [ 1 : ] :
       raise ValueError ( "There should be no varied dimensions on dimension 1 or above." )
       if 45 - 45: IIiIIiIi11I1 * IiIIii11Ii % i1I - i1i1i1111I - Oo
       if 38 - 38: iI1iII1I1I1i . oOo0O00 % i1i1i1111I - IiI11Ii111 * Ii
      iiiIII1i [ ooOoooO0OOo ] = tf . nn . pool ( ooOoOOoo00 , o0oOO0oo0o0O [ 1 : ] , "MAX" if self . incomingConfig == i1iIi1i1i1I1 . MergeDimMethods . MaxPool else "AVG" , "VALID" )
      if 49 - 49: I1Ii1I1 * i1I / Oo + oOO . I1I
      if 18 - 18: I11iiIi11i1I * ooo000 - Ooo0Ooo % oOO
   if self . incomingConfig . instanceClass == i1iIi1i1i1I1 . Types . Concat :
    if 85 - 85: I11iiIi11i1I % OooOoo + Iii1i . I1Ii1I1 / ooo000
    oooOoOooOoo0 = tuple ( O0oo0 for O0oo0 in iiiIII1i [ 0 ] . shape )
    if not all ( [ all ( [ ( O0oo0 == oooOoOooOoo0 [ ooOoooO0OOo ] or ooOoooO0OOo == iiI1i11Ii11I1 ) for ooOoooO0OOo , O0oo0 in enumerate ( n . shape ) ] ) for n in iiiIII1i ] ) :
     raise ValueError ( "If it's concat, all dimensions of incoming tensors should be equal, except the axis dimension." )
    O0o0000OOoO0O = tf . concat ( iiiIII1i , axis = iiI1i11Ii11I1 )
    if 57 - 57: Oo + I1I / I1Ii1I1 + i1I
    if 37 - 37: IIiIIiIi11I1 + Ii - i1I / i1i1i1111I - Iii1i
   elif i11i1I1Ii1I1i :
    if 70 - 70: i1I * i1I / IIiIIiIi11I1
    I111IIi1I = [ tuple ( O0oo0 for O0oo0 in tensor . shape ) for tensor in iiiIII1i ]
    I1IIIi111 = iiiIII1i [ IiII1111iiII1iII ]
    O00OOooO0oo0 = tuple ( O0oo0 for O0oo0 in I1IIIi111 . shape )
    if 7 - 7: I1I + Ooo0Ooo % oOO
    if 57 - 57: OooOoo . i1I * Ooo0Ooo - IIiIIiIi11I1
    with tf . compat . v1 . variable_scope ( self . name + "DimMap" , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     for ooOoooO0OOo , ooOoOOoo00 in enumerate ( iiiIII1i ) :
      if I111IIi1I [ ooOoooO0OOo ] != O00OOooO0oo0 :
       I1111Iiiii = self . incomingConfig . dimensionMappingConfig . buildOn ( I111IIi1I [ ooOoooO0OOo ] , toUnit = O00OOooO0oo0 [ - 1 ] , defaultDevice = self . train . device )
       I111IIi1I [ ooOoooO0OOo ] = I1111Iiiii . results
       self . _weights . extend ( I1111Iiiii . weights )
       if 5 - 5: i1I + oOo0O00 . Iii1i . ooOOO / Oo
       if 87 - 87: I1I . ooOOO - i1 / IIiIIiIi11I1
    if self . incomingConfig . transformGate is not None :
     if 93 - 93: i1i1i1111I / I1I
     if len ( iiiIII1i ) == 2 :
      if 39 - 39: oOo0O00 / oOo0O00 . iI1iII1I1I1i * I11iiIi11i1I . IIiIIiIi11I1 % ooo000
      if self . incomingConfig . transformGate == - 1 :
       iI1111I1i = self . fromSource [ buildNo ]
       ii = self . fromNode [ buildNo ]
       if len ( iI1111I1i ) > 0 :
        oO0oo0OoO = 0
        oO00OooooO0o0 = iiiIII1i [ 0 ]
       else :
        O0O = min ( [ lp . _order [ buildNo ] for lp in ii ] )
        oO0oo0OoO = [ ooOoooO0OOo for ooOoooO0OOo , lp in enumerate ( ii ) if lp . _order [ buildNo ] == O0O ] [ 0 ]
        oO00OooooO0o0 = iiiIII1i [ oO0oo0OoO ]
      else :
       oOOoOoOOOoO = [ ooOoooO0OOo for ooOoooO0OOo , lp in enumerate ( self . fromNode [ buildNo ] ) if lp == self . incomingConfig . transformGate ] [ 0 ]
       oO00OooooO0o0 = iiiIII1i [ oOOoOoOOOoO ]
       if 41 - 41: Ooo0Ooo % Ooo0Ooo % I1I / I11iiIi11i1I - iI1iII1I1I1i + iI1iII1I1I1i
      with tf . compat . v1 . variable_scope ( self . name + "TransGate" , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
       Iii = self . incomingConfig . transformConfig . buildOn ( oO00OooooO0o0 , toUnit = O00OOooO0oo0 [ - 1 ] , defaultDevice = self . train . device )
      iI11Ii1I1 = tf . nn . sigmoid ( Iii . results )
      self . _weights . extend ( Iii . weights )
      ii1I = [ ( ( 1 - iI11Ii1I1 ) if tIdx == oO0oo0OoO else iI11Ii1I1 ) for tIdx , tensor in enumerate ( iiiIII1i ) ]
      if 74 - 74: ooOOO / i1iiIII111 + iI1iII1I1I1i / I11iiIi11i1I
      if 38 - 38: Iii1i . i1
     else :
      if 78 - 78: I11iiIi11i1I - Ii * oOo0O00 - i1iiIII111 - i1I
      o0O000O000O0 = [ ]
      with tf . compat . v1 . variable_scope ( self . name + "TransGate" , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
       for ooOoOOoo00 in iiiIII1i :
        Iii = self . incomingConfig . transformConfig . buildOn ( ooOoOOoo00 , toUnit = O00OOooO0oo0 [ - 1 ] , defaultDevice = self . train . device )
        o0O000O000O0 . append ( Iii . results )
        self . _weights . extend ( Iii . weights )
      ii1I = tf . nn . softmax ( tf . transpose ( tf . convert_to_tensor ( o0O000O000O0 ) , perm = [ * [ dimIdx for dimIdx in range ( 1 , iiI1i11Ii11I1 + 2 ) ] , 0 ] ) )
      if 35 - 35: I1I * I1Ii1I1 * I1I . i1I * OooOoo
      if 22 - 22: ooo000 % IIiIIiIi11I1 % I1I . IIiIIiIi11I1
     OO0OOOO00OOoo = [ tensor * ii1I [ tIdx ] for tIdx , tensor in enumerate ( iiiIII1i ) ]
     if 75 - 75: Ooo0Ooo + oOo0O00
     if 27 - 27: I11iiIi11i1I
     if self . incomingConfig . instanceClass == i1iIi1i1i1I1 . Types . Sum :
      O0o0000OOoO0O = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o + OoOo0o0oooO , OO0OOOO00OOoo )
      if 15 - 15: OooOoo / I1Ii1I1
      if 45 - 45: Iii1i + i1i1i1111I + I1Ii1I1 / Ooo0Ooo
     elif self . incomingConfig . instanceClass == i1iIi1i1i1I1 . Types . Multiply :
      O0o0000OOoO0O = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , OO0OOOO00OOoo )
      if 51 - 51: IiIIii11Ii / Iii1i * i1I
      if 36 - 36: iI1iII1I1I1i + Oo / oOo0O00
     elif self . incomingConfig . instanceClass == i1iIi1i1i1I1 . Types . Blend :
      Iii1IIII = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , OO0OOOO00OOoo )
      if 1 - 1: OooOoo % I11iiIi11i1I
      if 8 - 8: Ii . OooOoo . i1iiIII111 + I11iiIi11i1I
      if self . incomingConfig . learnableBlend :
       O0OII1i11i1ii1 = i11i111iI . Config ( initializer = i11i111iI . Initializer . Constant ( 1 ) )
       iII11i11I1 = O0OII1i11i1ii1 . create ( self . name + "BlendAlpha" , [ len ( OO0OOOO00OOoo ) ] , defaultDevice = self . train . device )
       IiIi11I1iI = [ tensor * iII11i11I1 [ tIdx ] for tIdx , tensor in enumerate ( iiiIII1i ) ]
       oooOoO00000oO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o + OoOo0o0oooO , IiIi11I1iI )
       if 70 - 70: IiIIii11Ii / Oo / IiI11Ii111 % I11iiIi11i1I
       O0OII1i11i1ii1 = i11i111iI . Config ( initializer = i11i111iI . Initializer . Constant ( len ( OO0OOOO00OOoo ) ) )
       II1Ii1iiIi = O0OII1i11i1ii1 . create ( self . name + "BlendBeta" , [ 1 ] , defaultDevice = self . train . device )
       O0o0000OOoO0O = oooOoO00000oO - Iii1IIII * II1Ii1iiIi
       if 77 - 77: IiIIii11Ii * oOO . iI1iII1I1I1i - OooOoo / Ooo0Ooo
       if 85 - 85: I1Ii1I1 - i1i1i1111I % iI1iII1I1I1i . iI1iII1I1I1i - iI1iII1I1I1i - oOO
      else :
       oooOoO00000oO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o + OoOo0o0oooO , OO0OOOO00OOoo )
       O0o0000OOoO0O = oooOoO00000oO - Iii1IIII * len ( OO0OOOO00OOoo )
       if 53 - 53: i1 * IiI11Ii111 * i1i1i1111I - oOO
   else :
    raise ValueError ( "Incoming method --- " , self . incomingConfig . instanceClass . name , " is not supported yet." )
    if 9 - 9: IiIIii11Ii . i1I * ooOOO - I11iiIi11i1I - i1I
  return O0o0000OOoO0O
  if 73 - 73: Ii / IiIIii11Ii
 def _commonLayerOps ( self , operatedLayer : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 28 - 28: ooOOO - Ooo0Ooo . ooOOO / ooo000 / Ii . i1
  if 31 - 31: oOO + IIiIIiIi11I1
  if 64 - 64: IiIIii11Ii - Oo
  if 68 - 68: IiI11Ii111 + IiI11Ii111 . Ooo0Ooo % i1i1i1111I - I1I
  if 19 - 19: Iii1i + i1 - IIiIIiIi11I1 + ooOOO / iI1iII1I1I1i
  if 52 - 52: oOO % IiIIii11Ii
  if 61 - 61: I11iiIi11i1I - i1iiIII111
  if 5 - 5: iI1iII1I1I1i
  if 18 - 18: oOo0O00 * I11iiIi11i1I / IiIIii11Ii * Iii1i % Iii1i
  if 75 - 75: I11iiIi11i1I % Ooo0Ooo - i1I * ooOOO / i1iiIII111
  if 89 - 89: i1iiIII111
  if 9 - 9: Iii1i % I11iiIi11i1I + iI1iII1I1I1i
  if 96 - 96: IiI11Ii111 + IIiIIiIi11I1
  if 48 - 48: oOo0O00 / i1 + ooo000
  if self . batchNorm :
   O0oO000OOoooo0OO = tf . compat . v1 . layers . batch_normalization ( operatedLayer , training = self . train . _bnTensor , ** self . batchNormParams )
  else :
   O0oO000OOoooo0OO = operatedLayer
   if 49 - 49: i1i1i1111I * i1 + Ii / OooOoo . Iii1i - OooOoo
   if 59 - 59: Ii * Ooo0Ooo - IiI11Ii111
  if self . activation is not None :
   O0oO000OOoooo0OO = OooO0oO ( self . activation ) ( O0oO000OOoooo0OO , ** self . activationParams )
   if 61 - 61: i1I - oOO / Ii * Oo + IiIIii11Ii + i1
   if 71 - 71: IiI11Ii111 * Iii1i * Ooo0Ooo . I11iiIi11i1I
  if self . dropout < 1 :
   self . _dropoutTensor = tf . compat . v1 . placeholder ( tf . float32 )
   O0oO000OOoooo0OO = tf . nn . dropout ( O0oO000OOoooo0OO , ( 1. - self . _dropoutTensor ) )
   if 10 - 10: IIiIIiIi11I1 . i1iiIII111
  return O0oO000OOoooo0OO
  if 1 - 1: Iii1i
 def _processOutputTensor ( self , finalTensor : 'tf.Tensor' ) -> 'tf.Tensor' :
  if 52 - 52: i1i1i1111I % IiIIii11Ii + IiIIii11Ii % i1 % i1I
  if 85 - 85: ooOOO / ooOOO
  if 41 - 41: i1iiIII111 - I1I / I1Ii1I1
  if 17 - 17: oOo0O00
  if 96 - 96: oOo0O00 % i1i1i1111I + IiI11Ii111 / i1I % IiIIii11Ii
  if 84 - 84: iI1iII1I1I1i
  if 52 - 52: I1I % Ii / oOO / i1iiIII111 . Ooo0Ooo
  if 75 - 75: Ii % Iii1i - IiIIii11Ii
  if 95 - 95: Ooo0Ooo * IiIIii11Ii % i1i1i1111I * Ooo0Ooo . Ooo0Ooo / Oo
  if 84 - 84: OooOoo
  if 67 - 67: Ii + I11iiIi11i1I * Oo * i1i1i1111I
  if 59 - 59: ooo000 . i1I
  if 77 - 77: OooOoo % i1i1i1111I
  if 36 - 36: oOO / I11iiIi11i1I - i1I
  o0oo0o0OoO = self . outputConfig
  if 19 - 19: I11iiIi11i1I
  if 46 - 46: i1iiIII111
  if o0oo0o0OoO . instanceClass == I1Iiii1I1 . Types . Default :
   return finalTensor
   if 50 - 50: oOO
   if 25 - 25: i1I . OooOoo . Ooo0Ooo * ooOOO . oOO * IiIIii11Ii
  elif o0oo0o0OoO . instanceClass == I1Iiii1I1 . Types . Flatten :
   if self . outputConfig . axis == 0 or self . outputConfig . axis == - len ( finalTensor . shape ) :
    raise ValueError ( "Axis cannot be flattened on the batch axis." )
   elif self . outputConfig . axis >= len ( finalTensor . shape ) or self . outputConfig . axis < - len ( finalTensor . shape ) :
    raise ValueError ( "Flattening axis is out of range." )
   O00o0O = finalTensor . shape
   oo0OOOOo0oO = O00o0O [ o0oo0o0OoO . axis : ]
   IIiiii111ii = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , oo0OOOOo0oO , 1 )
   return tf . reshape ( finalTensor , [ * i11i111iI . setAsReshape ( O00o0O [ : o0oo0o0OoO . axis ] ) , IIiiii111ii ] )
   if 83 - 83: IiIIii11Ii
   if 33 - 33: oOo0O00 - IIiIIiIi11I1 % i1iiIII111 . ooo000 - OooOoo
  elif o0oo0o0OoO . instanceClass == I1Iiii1I1 . Types . Reshape :
   if 29 - 29: Ii
   O0OOoOooo00oOo = [ * o0oo0o0OoO . shape ]
   if 54 - 54: IiIIii11Ii * Ooo0Ooo - IiIIii11Ii . Iii1i
   if 45 - 45: I11iiIi11i1I . IiIIii11Ii + iI1iII1I1I1i * i1iiIII111 - IIiIIiIi11I1
   I1i1i1IIIiI = round ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , [ s for s in O0OOoOooo00oOo if s not in [ None , - 1 ] ] , 1 ) )
   if 20 - 20: Ii % I1I * OooOoo + i1I . ooo000
   if 3 - 3: Iii1i . iI1iII1I1I1i / ooOOO - i1i1i1111I - oOo0O00
   I1iiiii11iiI = round ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , [ s for s in finalTensor . shape if s is not None ] , 1 ) )
   if 83 - 83: OooOoo * IIiIIiIi11I1 / I1I - oOO
   if 14 - 14: Iii1i / IiI11Ii111
   if I1iiiii11iiI % I1i1i1IIIiI != 0 :
    raise ValueError ( "The newly requested shape is not compatible with the layer original output shape." )
    if 69 - 69: ooOOO . IiIIii11Ii
    if 21 - 21: oOO - Iii1i
   ooOoooO0OOo = O0OOoOooo00oOo [ 1 : ] . index ( - 1 ) if - 1 in O0OOoOooo00oOo [ 1 : ] else O0OOoOooo00oOo [ 1 : ] . index ( None ) if None in O0OOoOooo00oOo [ 1 : ] else - 1
   if ooOoooO0OOo == - 1 :
    if I1iiiii11iiI == I1i1i1IIIiI :
     return tf . reshape ( finalTensor , [ * i11i111iI . setAsReshape ( O0OOoOooo00oOo ) ] )
    else :
     raise ValueError ( "The newly requested shape is not compatible with the layer original output shape." )
   else :
    O0OOoOooo00oOo [ ooOoooO0OOo ] = round ( I1iiiii11iiI / I1i1i1IIIiI )
    return tf . reshape ( finalTensor , [ * i11i111iI . setAsReshape ( O0OOoOooo00oOo ) ] )
    if 27 - 27: I1I - I1Ii1I1 / I11iiIi11i1I
 def _updateOrder ( self , buildNo : int = 0 ) :
  if 57 - 57: OooOoo * Ooo0Ooo + i1iiIII111
  if 52 - 52: Ooo0Ooo - Ii % i1iiIII111 * Ii % Ii
  if 7 - 7: oOO + IiIIii11Ii % I1I * Oo % IIiIIiIi11I1 + IiIIii11Ii
  if 7 - 7: i1iiIII111
  if 35 - 35: oOO * i1iiIII111
  if 59 - 59: oOO . Ii * iI1iII1I1I1i - ooOOO % IiI11Ii111
  if 93 - 93: oOo0O00
  if 68 - 68: IiIIii11Ii . Oo * ooOOO + Ooo0Ooo - i1i1i1111I
  if 77 - 77: i1iiIII111 % Oo + i1i1i1111I - Iii1i . IiIIii11Ii - Ooo0Ooo
  if 19 - 19: Ooo0Ooo - oOO % oOo0O00 + i1iiIII111
  self . _order [ buildNo ] = max ( [ 0 , * [ o0OoOOOOO00O . _order [ buildNo ] for o0OoOOOOO00O in self . fromNode [ buildNo ] ] ] ) + 1
  for o0OoOOOOO00O in self . toNode [ buildNo ] :
   o0OoOOOOO00O . _updateOrder ( buildNo = buildNo )
   if 80 - 80: I1Ii1I1 . i1 * oOo0O00 + i1 / oOO
 def appendNode ( self , layerProfile : 'ModelNode.Layer.Config' , buildNo : int = 0 ) :
  if 14 - 14: I1Ii1I1 / Ooo0Ooo - I11iiIi11i1I + oOo0O00
  if 79 - 79: I11iiIi11i1I . ooo000 * oOo0O00 . I1Ii1I1 - I11iiIi11i1I % i1
  if 52 - 52: i1iiIII111 * oOO
  if 8 - 8: I1I + i1i1i1111I / IiIIii11Ii * I1I . I1I . IiIIii11Ii
  if 56 - 56: Oo
  if 57 - 57: I1Ii1I1
  if 63 - 63: IIiIIiIi11I1 + oOo0O00 / iI1iII1I1I1i + I1I % iI1iII1I1I1i
  if 22 - 22: i1 / Oo % ooo000 - IiI11Ii111 . Ooo0Ooo * oOO
  if 21 - 21: I11iiIi11i1I + oOO
  if 44 - 44: ooOOO % I1I * I1I . i1iiIII111 * IIiIIiIi11I1 * oOo0O00
  if 2 - 2: oOo0O00 - ooOOO - iI1iII1I1I1i . IiI11Ii111 / IIiIIiIi11I1
  if 20 - 20: Ooo0Ooo * IIiIIiIi11I1 . Ooo0Ooo + iI1iII1I1I1i + IIiIIiIi11I1
  if self . _final :
   raise ValueError ( "Layer cannot be appended on a Task Layer." )
  elif layerProfile in self . toNode [ buildNo ] :
   raise ValueError ( "Layer already connected." )
   if 76 - 76: ooo000 . I11iiIi11i1I . oOo0O00 / OooOoo + i1iiIII111
   if 16 - 16: I11iiIi11i1I
  self . toNode [ buildNo ] . append ( layerProfile )
  layerProfile . fromNode [ buildNo ] . append ( self )
  self . train . updateLayerOrder ( layerProfile , buildNo = buildNo )
  if 5 - 5: ooOOO + i1iiIII111 + i1I . OooOoo * oOo0O00
 def addSources ( self , * sources : Union [ str , 'DataPreprocessing.Node.Config' ] , clear : bool = False , buildNo : int = 0 ) :
  if 14 - 14: I11iiIi11i1I / i1 - oOo0O00
  if 71 - 71: i1i1i1111I . i1i1i1111I - iI1iII1I1I1i
  if 7 - 7: ooo000 * IiI11Ii111 + oOo0O00 . i1iiIII111 + i1 / IIiIIiIi11I1
  if 89 - 89: Iii1i / IiIIii11Ii . ooo000
  if 79 - 79: ooOOO
  if 56 - 56: ooo000 . oOo0O00 * IiIIii11Ii . i1 - IIiIIiIi11I1 / Ooo0Ooo
  if 67 - 67: IiI11Ii111 . I1I . ooOOO
  if 10 - 10: I11iiIi11i1I - Iii1i . Iii1i % Oo - IiIIii11Ii % IIiIIiIi11I1
  if 83 - 83: oOo0O00
  if 45 - 45: oOo0O00
  if 75 - 75: ooOOO . IiIIii11Ii % i1iiIII111
  if 69 - 69: IIiIIiIi11I1 % I1I
  if 50 - 50: iI1iII1I1I1i . IiI11Ii111 / Ooo0Ooo - i1i1i1111I * I11iiIi11i1I
  if 7 - 7: i1 + I11iiIi11i1I % ooo000 . oOo0O00 % I11iiIi11i1I
  if clear :
   self . fromSource [ buildNo ] . clear ( )
   if 18 - 18: I1Ii1I1 * Iii1i / IiI11Ii111 % Ii
   if 59 - 59: oOo0O00
  for O0oo0 in sources :
   if isinstance ( O0oo0 , Oo0ooo0OO0 ) :
    self . fromSource [ buildNo ] . append ( O0oo0 . key )
   elif isinstance ( O0oo0 , str ) :
    self . fromSource [ buildNo ] . append ( O0oo0 )
   else :
    raise ValueError ( "Not supported type of data source is added into a layer." )
    if 93 - 93: ooOOO + Iii1i + Iii1i / Iii1i
   self . train . updateLayerOrder ( self , buildNo = buildNo )
   if 49 - 49: ooOOO . Oo + IiI11Ii111 * Ii % i1i1i1111I % I11iiIi11i1I
 def setSymmetricLayer ( self , builtLayerList : Dict [ str , bool ] , useSymmetricWeights : bool = True , startFromThis : bool = False , untilLayer : Union [ str , 'ModelNode.Layer.Config' ] = None , buildNo : int = 0 ) :
  if 62 - 62: Ii / Iii1i
  if 23 - 23: ooo000 * OooOoo / I1Ii1I1 - I1Ii1I1
  if 27 - 27: Ooo0Ooo / i1iiIII111 % ooOOO . I1I
  if 19 - 19: Ii - i1I + ooOOO . i1 - I1I + i1iiIII111
  if 19 - 19: IiIIii11Ii - ooOOO
  if 76 - 76: IiIIii11Ii . I1I
  if 73 - 73: oOo0O00 / Oo + IiIIii11Ii / IiI11Ii111
  if 76 - 76: OooOoo + Ii - ooo000 * Ii
  if 92 - 92: IiI11Ii111
  if 72 - 72: iI1iII1I1I1i * iI1iII1I1I1i / Iii1i + i1iiIII111 * i1i1i1111I
  if 34 - 34: i1 * ooo000 . i1i1i1111I + IiI11Ii111 . i1i1i1111I % I1I
  if 56 - 56: oOo0O00 - Ii * I1Ii1I1
  if 90 - 90: I1Ii1I1 + Ii - Ii
  if 53 - 53: i1I % I1Ii1I1
  if 22 - 22: ooOOO % I1I
  if 47 - 47: IiI11Ii111 % oOO / IiI11Ii111 * i1iiIII111
  O0ooOo0OOO = [ oO0OOOOOOoo for oO0OOOOOOoo in self . fromNode [ buildNo ] ]
  O0oOO = self . fromSource [ buildNo ]
  if 53 - 53: iI1iII1I1I1i + I1I . Iii1i . i1i1i1111I
  if 22 - 22: i1i1i1111I * i1
  if len ( O0ooOo0OOO ) + len ( O0oOO ) > 0 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be set with a symmetric network." )
   if 29 - 29: I11iiIi11i1I * IiIIii11Ii - ooOOO / i1i1i1111I / oOo0O00 + I11iiIi11i1I
   if 28 - 28: i1iiIII111 + oOo0O00 - i1I
  Ii11iIiIIi = self . _copySymmetricLayerConfig ( useSymmetricWeights , buildNo = buildNo )
  if startFromThis :
   Ii11iIiIIi . attachTo ( * self . train . getEndingNodes ( buildNo = buildNo ) , buildNo = buildNo )
  else :
   Ii11iIiIIi . attachTo ( * [ self . train . modelNodes [ oO0OOOOOOoo . name + "_Sym" ] for oO0OOOOOOoo in self . toNode [ buildNo ] ] , buildNo = buildNo )
  builtLayerList [ self . name ] = True
  if 5 - 5: i1iiIII111 / i1 * I1Ii1I1 + IiIIii11Ii . i1i1i1111I
  if 63 - 63: oOo0O00 * ooo000
  for oO0OOOOOOoo in O0ooOo0OOO :
   if 54 - 54: Ooo0Ooo
   if builtLayerList [ oO0OOOOOOoo . name ] == False and all ( [ builtLayerList [ toL . name ] for toL in oO0OOOOOOoo . toNode [ buildNo ] ] ) :
    oO0OOOOOOoo . setSymmetricLayer ( builtLayerList , buildNo = buildNo )
    if 69 - 69: i1I % OooOoo * ooOOO * Oo - IIiIIiIi11I1 + i1iiIII111
    if 54 - 54: Iii1i
  for O0oo0 in O0oOO :
   iiii1i = self . train . getLayersUsingSource ( * O0oo0 , buildNo = buildNo )
   if all ( [ builtLayerList [ toL . name ] for toL in iiii1i ] ) :
    IiiiI11 = self . train . getDataSource ( * O0oo0 )
    if IiiiI11 . dtype in [ tf . int64 , tf . int32 ] :
     Ii11iIiIIi = ii1II ( classCount = - 1 , lossDppKey = O0oo0 )
    else :
     Ii11iIiIIi = IiIi ( lossDppKey = O0oo0 )
    Ii11iIiIIi . attachTo ( * [ self . train . modelNodes [ oO0OOOOOOoo . name + "_Sym" ] for oO0OOOOOOoo in iiii1i ] , buildNo = buildNo )
    if 81 - 81: OooOoo - Oo
 def _copySymmetricLayerConfig ( self , useSymmetricWeights : bool = True , buildNo : int = 0 ) -> 'ModelNode.Layer.Config' :
  if 38 - 38: I1I + Oo - i1iiIII111
  if 83 - 83: ooOOO
  if 42 - 42: IiI11Ii111
  if 51 - 51: iI1iII1I1I1i % oOO - Ii % i1i1i1111I
  if 87 - 87: IiIIii11Ii
  if 98 - 98: I1I . Ooo0Ooo / oOo0O00 % I1I / I1Ii1I1
  if 91 - 91: I1I - IiIIii11Ii + Ooo0Ooo + Ii % I1I / ooo000
  if 95 - 95: I1I * Ii . iI1iII1I1I1i + i1I . iI1iII1I1I1i
  if 32 - 32: oOO / Oo
  if 46 - 46: i1iiIII111 + iI1iII1I1I1i / oOO
  if 94 - 94: I1Ii1I1 - ooo000 * I1Ii1I1 . I1I
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 43 - 43: Iii1i + i1I * Iii1i / IiI11Ii111
  return self . copy ( self . name + "_Sym" )
  if 79 - 79: Ooo0Ooo % IiI11Ii111 % IiI11Ii111 . IiIIii11Ii * Iii1i
 def copy ( self , name : str ) -> 'ModelNode.Layer.Config' :
  if 62 - 62: Ooo0Ooo % i1I - i1I - IiI11Ii111 % I1I % I11iiIi11i1I
  if 14 - 14: Oo * i1I * oOO + iI1iII1I1I1i * ooOOO
  if 50 - 50: I1Ii1I1
  if 31 - 31: IiI11Ii111 . Iii1i * OooOoo . i1i1i1111I + i1iiIII111 + Oo
  if 64 - 64: ooo000 % iI1iII1I1I1i / I1I
  if 43 - 43: I1Ii1I1 / IIiIIiIi11I1
  if 5 - 5: i1I % IiI11Ii111
  if 52 - 52: I11iiIi11i1I - oOO - oOO + ooOOO
  if 28 - 28: i1i1i1111I
  if 50 - 50: Ii . ooo000
  if 46 - 46: oOo0O00
  if 90 - 90: iI1iII1I1I1i + IiI11Ii111 / IiIIii11Ii - oOo0O00 * I1I
  if 11 - 11: i1iiIII111
  if 46 - 46: i1i1i1111I - Ii * Ii / OooOoo
  if self . _built :
   raise ValueError ( "This layer (" + self . name + ") cannot be copied because it has been built." )
   if 60 - 60: Ooo0Ooo % oOO . oOO
  elif not isinstance ( self , oO00ooO00oOO0 ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 75 - 75: ooo000 % iI1iII1I1I1i % IiI11Ii111
   if 25 - 25: oOo0O00 % ooOOO / I1Ii1I1
  return oO00ooO00oOO0 ( name = name , layerUnits = self . layerUnits , final = self . _final ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams , dropout = self . dropout ,
 outputConfig = self . outputConfig )
  if 25 - 25: ooOOO
 def appendOn ( self , layerOrSource : Union [ 'ModelNode.Layer.Config' , 'DataPreprocessing.Node.Config' ] , buildNo : int = 0 ) -> 'ModelNode.Layer.Config' :
  if 73 - 73: I1Ii1I1 + Oo * I1Ii1I1
  if 45 - 45: Ooo0Ooo % Ooo0Ooo . Iii1i / I11iiIi11i1I % oOO . Ii
  if 88 - 88: i1I . IiI11Ii111 * i1I
  if 15 - 15: oOo0O00 . Oo * oOo0O00
  if 1 - 1: oOO . Iii1i + i1i1i1111I
  if 91 - 91: ooOOO * IIiIIiIi11I1
  if 81 - 81: I1Ii1I1 * ooo000 % i1
  if 54 - 54: I1Ii1I1 . Ooo0Ooo / oOo0O00
  if 58 - 58: ooOOO + i1
  if 90 - 90: I1Ii1I1 * i1iiIII111 + IiI11Ii111 / ooo000 * Iii1i
  if 38 - 38: Iii1i + oOO
  if 11 - 11: ooOOO + IiIIii11Ii / i1 * i1I
  if 90 - 90: ooo000 * i1iiIII111 % I1Ii1I1 * Ooo0Ooo - I1Ii1I1 % Iii1i
  if 73 - 73: oOO
  if 83 - 83: I1Ii1I1 . oOo0O00 / ooo000 - ooOOO . I1Ii1I1
  if isinstance ( layerOrSource , oO00ooO00oOO0 ) :
   if 100 - 100: IiI11Ii111 . Iii1i - Iii1i / iI1iII1I1I1i % i1I
   if layerOrSource . train is None :
    raise ValueError ( "The layer on which this layer append is not specified in any training models." )
    if 91 - 91: IiI11Ii111
   layerOrSource . train . appendNode ( self , appendAt = layerOrSource , buildNo = buildNo )
   if 56 - 56: IiIIii11Ii / i1iiIII111 . i1i1i1111I % IIiIIiIi11I1 . I1I + i1
  elif isinstance ( layerOrSource , Oo0ooo0OO0 ) :
   if 16 - 16: OooOoo . IiIIii11Ii * i1 / IIiIIiIi11I1
   if layerOrSource . source is None :
    raise ValueError ( "The DataPreprocessing.Node.Config object on which this layer append is not specified in any training sources." )
   elif layerOrSource . train is None :
    raise ValueError ( "The Source.Config object containing this DataPreprocessing.Node.Config object on which this layer append is not specified in any training models." )
    if 77 - 77: oOO . Ii - i1 + iI1iII1I1I1i
   layerOrSource . train . appendNode ( self , appendAt = layerOrSource , buildNo = buildNo )
   if 98 - 98: oOO + I1Ii1I1 - I1I + iI1iII1I1I1i
  else :
   if 12 - 12: Ii / Oo * i1 + i1
   raise ValueError ( "`layerOrSource` must be a ModelNode.Layer.Config or DataPreprocessing.Node.Config object." )
   if 30 - 30: Iii1i
  return self
  if 26 - 26: ooo000 + i1I
 def attachTo ( self , * layerOrSources : Union [ 'ModelNode.Layer.Config' , 'DataPreprocessing.Node.Config' ] , buildNo : int = 0 ) -> 'ModelNode.Layer.Config' :
  if 54 - 54: ooOOO - I1I . i1
  if 9 - 9: IiIIii11Ii
  if 12 - 12: I11iiIi11i1I - IiI11Ii111 / oOO + oOo0O00 * I1Ii1I1
  if 19 - 19: Ooo0Ooo * i1i1i1111I / oOo0O00 + I1I
  if 3 - 3: Iii1i % oOo0O00 / i1I * i1 . i1i1i1111I
  if 46 - 46: i1iiIII111 * ooo000 / IIiIIiIi11I1 - i1i1i1111I
  if 27 - 27: Ooo0Ooo + I1I * i1i1i1111I + oOo0O00
  if 42 - 42: I11iiIi11i1I / OooOoo
  if 28 - 28: I1I + oOo0O00
  if 66 - 66: I1Ii1I1 + IiI11Ii111 * IiI11Ii111 - I1I % ooOOO * IiI11Ii111
  if 53 - 53: iI1iII1I1I1i - oOO + i1
  if 83 - 83: I1Ii1I1 + Oo
  if 86 - 86: Iii1i - ooo000 * Iii1i + oOo0O00 - i1i1i1111I
  if 19 - 19: i1i1i1111I * i1iiIII111
  if 36 - 36: OooOoo
  if any ( [ not ( isinstance ( ls , oO00ooO00oOO0 ) or isinstance ( ls , Oo0ooo0OO0 ) ) for ls in layerOrSources ] ) :
   raise ValueError ( "`layerOrSource` must be a ModelNode.Layer.Config or DataPreprocessing.Node.Config object." )
   if 40 - 40: I11iiIi11i1I - Iii1i / iI1iII1I1I1i
   if 43 - 43: Oo
  else :
   oO0o = [ ls . train for ls in layerOrSources ]
   if oO0o [ 0 ] is None or any ( [ t != oO0o [ 0 ] for t in oO0o ] ) :
    raise ValueError ( "All of the previous layer or sources must be within the same training model." )
    if 25 - 25: i1I + ooOOO . Iii1i . IiIIii11Ii * ooo000 / IiI11Ii111
    if 81 - 81: Ooo0Ooo / I1Ii1I1 + OooOoo - i1i1i1111I
  oO0o [ 0 ] . attachNode ( self , * layerOrSources , buildNo = buildNo )
  if 24 - 24: i1iiIII111 + I1I + IIiIIiIi11I1 - Ooo0Ooo
  return self
  if 66 - 66: IiI11Ii111 - IIiIIiIi11I1 - oOo0O00 * IIiIIiIi11I1 - I1Ii1I1 * ooo000
 def updateOnDemand ( self , ** kwargs ) :
  if 77 - 77: I1I - i1i1i1111I . i1 * i1 / OooOoo
  if 63 - 63: oOO % Oo / Iii1i - Ooo0Ooo / IIiIIiIi11I1
  if 16 - 16: ooo000 % oOo0O00 . oOo0O00 % Oo % oOO
  if 46 - 46: oOo0O00
  if 95 - 95: Ooo0Ooo + Ooo0Ooo . Ii * I1I
  if 70 - 70: i1iiIII111 % OooOoo * ooo000
  if 4 - 4: I1Ii1I1 % I11iiIi11i1I / i1I - i1iiIII111
  pass
  if 91 - 91: oOo0O00 . Iii1i . ooo000 % ooo000
 def printWhenTraining ( self , * tensors ) :
  if 9 - 9: IiI11Ii111 + IiI11Ii111 / I1Ii1I1 / i1iiIII111 * I11iiIi11i1I - IiI11Ii111
  if 6 - 6: i1iiIII111 % Ooo0Ooo . Iii1i % Ii / i1
  if 37 - 37: IIiIIiIi11I1 * i1i1i1111I * I1Ii1I1 . OooOoo . I1I - Iii1i
  if 84 - 84: I11iiIi11i1I / IiIIii11Ii
  if 82 - 82: Oo + OooOoo * OooOoo % iI1iII1I1I1i . OooOoo
  if 19 - 19: I1I . i1
  if 48 - 48: OooOoo % i1 / oOO % IiIIii11Ii % Oo . Oo
  if 31 - 31: i1I % IIiIIiIi11I1 - oOO / iI1iII1I1I1i * I1Ii1I1 % iI1iII1I1I1i
  if 71 - 71: iI1iII1I1I1i - I1Ii1I1 % ooo000 / Iii1i
  if 82 - 82: oOo0O00 * OooOoo / ooo000 % i1iiIII111 - Oo
  self . train . _printTensors [ len ( self . train . _printTensors ) : ] = tensors
  if 39 - 39: ooOOO * ooo000 % i1iiIII111
 def keras_call_combineIncomingTensors ( self , input_sources : List [ List [ Optional [ int ] ] ] , input_tensors : List [ List [ Optional [ int ] ] ]
 , input_sources_name : List [ str ] , input_tensors_name : List [ str ] , output_reg : str , buildNo : int = 0 ) :
  if 59 - 59: Iii1i / OooOoo - Iii1i
  if 49 - 49: oOo0O00 . oOO * oOo0O00 * IiI11Ii111 % Oo
  if 76 - 76: iI1iII1I1I1i * Ii / i1I / i1i1i1111I % i1i1i1111I
  if 27 - 27: Iii1i
  if 67 - 67: I1I / Oo % oOo0O00
  if 11 - 11: oOO * i1i1i1111I . iI1iII1I1I1i * Ooo0Ooo % i1
  if 25 - 25: i1iiIII111
  if 1 - 1: i1I + Ii + oOo0O00 + i1
  if 22 - 22: i1I . i1I / Iii1i % OooOoo
  if 91 - 91: ooOOO + Ooo0Ooo . ooo000 . I1I % Ooo0Ooo
  if 23 - 23: I11iiIi11i1I . I11iiIi11i1I * i1iiIII111
  if 15 - 15: Ooo0Ooo * OooOoo / I11iiIi11i1I / I1I . Iii1i - i1iiIII111
  if 62 - 62: oOo0O00 * Ii . IIiIIiIi11I1 / I1Ii1I1 - Ooo0Ooo / i1iiIII111
  if 77 - 77: i1iiIII111 . IiIIii11Ii / oOO
  if 27 - 27: i1i1i1111I + i1 - IIiIIiIi11I1 + i1i1i1111I % Oo
  if 53 - 53: Ooo0Ooo + I11iiIi11i1I - ooOOO
  if 62 - 62: I1I
  if 22 - 22: Ii % Ii . IiI11Ii111 / Oo * I11iiIi11i1I + i1iiIII111
  ooo0o = [ ]
  ooo0o . extend ( input_sources )
  ooo0o . extend ( input_tensors )
  iiIII1Ii1 = [ ]
  iiIII1Ii1 . extend ( input_sources_name )
  iiIII1Ii1 . extend ( input_tensors_name )
  iI1iiiiIIi = [ output_reg + '_' + str ( IiIIiiII ) for IiIIiiII in range ( len ( iiIII1Ii1 ) ) ]
  iIiI11I1i11ii = [ 0 for IiIIiiII in range ( len ( iiIII1Ii1 ) ) ]
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if len ( ooo0o ) == 0 :
   raise ValueError ( "There is no input layers for this layer (" + self . name + ")." )
  elif len ( ooo0o ) == 1 :
   I111II11Ii = ooo0o [ 0 ]
   iiII1I1iIi = iiIII1Ii1 [ 0 ]
  else :
   if 2 - 2: ooOOO * i1 - oOO . I1Ii1I1 . I1Ii1I1 % Oo
   ii1I1iI1i1I1i = [ 0 for x in ooo0o ]
   if 3 - 3: oOo0O00 + i1I - iI1iII1I1I1i
   for ooOoooO0OOo , OOo00oOoOo in enumerate ( ooo0o ) :
    if len ( OOo00oOoOo ) == 1 :
     if 69 - 69: oOo0O00 % i1iiIII111 / Ooo0Ooo % oOo0O00 / Iii1i % Iii1i
     string = 'self.%s_combine_%d_%d = tf.keras.layers.Reshape((1,))' % ( self . name , ooOoooO0OOo , ii1I1iI1i1I1i [ ooOoooO0OOo ] )
     ooo0oOOooO . append ( string )
     if iIiI11I1i11ii [ ooOoooO0OOo ] == 0 :
      iIiI11I1i11ii [ ooOoooO0OOo ] = 1
      I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
      oO = iiIII1Ii1 [ ooOoooO0OOo ]
     else :
      I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
      oO = iI1iiiiIIi [ ooOoooO0OOo ]
     string = '%s = self.%s_combine_%d_%d(%s)' % ( I1111iiI , self . name , ooOoooO0OOo , ii1I1iI1i1I1i [ ooOoooO0OOo ] , oO )
     ii1I1iI1i1I1i [ ooOoooO0OOo ] += 1
     if 14 - 14: i1i1i1111I + i1i1i1111I * Ii / Iii1i / iI1iII1I1I1i
   i1Ii1 = min ( [ len ( O0oo0 ) for O0oo0 in ooo0o ] )
   i11i1I1Ii1I1i = self . incomingConfig . instanceClass in [ i1iIi1i1i1I1 . Types . Sum , i1iIi1i1i1I1 . Types . Multiply , i1iIi1i1i1I1 . Types . Blend ]
   OOoo00O00OO = [ ]
   if self . incomingConfig . coreNode is None :
    for oo00Oo0O0o0o , OOo00oOoOo in enumerate ( input_tensors ) :
     if len ( OOo00oOoOo ) == i1Ii1 :
      III = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , OOo00oOoOo [ 1 : - 1 ] , 1 )
      OOoo00O00OO . append ( ( oo00Oo0O0o0o + len ( input_sources ) , III ) )
    OOoo00O00OO = sorted ( OOoo00O00OO , key = lambda OOoo00ooOo00O : OOoo00ooOo00O [ 1 ] )
    IiII1111iiII1iII = OOoo00O00OO [ 0 ] [ 0 ]
   else :
    if 69 - 69: ooo000 % OooOoo % ooOOO / ooOOO
    if self . incomingConfig . coreNode not in self . fromNode [ buildNo ] :
     raise ValueError ( "Core node not in the from node list." )
     if 33 - 33: i1iiIII111
    IiII1111iiII1iII = len ( input_sources ) + self . fromNode [ buildNo ] . index ( self . incomingConfig . coreNode )
   O00OOooO0oo0 = ooo0o [ IiII1111iiII1iII ]
   iiI1i11Ii11I1 = ( len ( O00OOooO0oo0 ) - 1 ) if self . incomingConfig . axis == - 1 else self . incomingConfig . axis
   for O0oo0 in ooo0o :
    if 48 - 48: oOo0O00 / iI1iII1I1I1i - i1i1i1111I / i1
    if 100 - 100: I1I - ooo000 * Iii1i / i1I * i1i1i1111I
    if 53 - 53: ooOOO
    print ( O0oo0 )
    if 75 - 75: Oo + I1Ii1I1 - i1i1i1111I / Iii1i % iI1iII1I1I1i . Ii
   if iiI1i11Ii11I1 >= len ( O00OOooO0oo0 ) :
    if 90 - 90: I11iiIi11i1I - i1 - OooOoo - Oo
    raise ValueError ( "Axis is larger than or equal to the length of core node's shape." )
    if 90 - 90: oOO + I1I % I11iiIi11i1I + Ii + oOo0O00
   elif any ( [ ( None in O0oo0 [ 1 : ] ) for O0oo0 in ooo0o ] ) :
    if 62 - 62: IiIIii11Ii
    raise ValueError ( "There should be no varied dimensions on dimension 1 or above." )
    if 89 - 89: I1Ii1I1 . i1iiIII111 - IiIIii11Ii - ooo000
   elif not all ( [ all ( [ ( dim == O00OOooO0oo0 [ ooOoooO0OOo + 1 ] or dim % O00OOooO0oo0 [ ooOoooO0OOo + 1 ] == 0 ) for ooOoooO0OOo , dim in enumerate ( O0oo0 [ 1 : iiI1i11Ii11I1 ] ) ] ) for O0oo0 in ooo0o ] ) :
    if 89 - 89: Ooo0Ooo . ooo000 + ooo000
    raise ValueError ( "Some incoming layers are not having the same dimension or multiplicative dimension as the core node along the dimensions before the concatenation axis." )
   if 54 - 54: i1iiIII111 . Oo - Oo . OooOoo
   if 5 - 5: Oo . Iii1i % i1iiIII111 * I11iiIi11i1I
   for ooOoooO0OOo , OOo00oOoOo in enumerate ( ooo0o ) :
    if 99 - 99: IiIIii11Ii / Ooo0Ooo % i1I - Ooo0Ooo / I1Ii1I1
    if 47 - 47: OooOoo + iI1iII1I1I1i + i1i1i1111I - Iii1i + i1 * I1I
    if 45 - 45: I11iiIi11i1I * ooOOO * Ii % Ooo0Ooo % i1i1i1111I
    if 65 - 65: I11iiIi11i1I * I1I * ooOOO . I1I
    if 36 - 36: i1I / IiI11Ii111
    if 86 - 86: IiIIii11Ii % OooOoo / Iii1i . i1i1i1111I
    if 92 - 92: i1I / oOO
    if 73 - 73: i1I . Iii1i
    if 36 - 36: Ii
    if 32 - 32: IiIIii11Ii - oOo0O00 % i1I * Iii1i
    if len ( OOo00oOoOo ) > iiI1i11Ii11I1 + 1 :
     I1I1I = OOo00oOoOo [ iiI1i11Ii11I1 : ]
     IIiiii111ii = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , I1I1I , 1 )
     II = OOo00oOoOo [ : iiI1i11Ii11I1 ]
     II . append ( IIiiii111ii )
     string = 'self.%s_combine_%d_%d = tf.keras.layers.Reshape((' % ( self . name , ooOoooO0OOo , ii1I1iI1i1I1i [ ooOoooO0OOo ] )
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += ',))'
     ooo0oOOooO . append ( string )
     if iIiI11I1i11ii [ ooOoooO0OOo ] == 0 :
      iIiI11I1i11ii [ ooOoooO0OOo ] = 1
      I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
      oO = iiIII1Ii1 [ ooOoooO0OOo ]
     else :
      I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
      oO = iI1iiiiIIi [ ooOoooO0OOo ]
     string = '%s = self.%s_combine_%d_%d(%s)' % ( I1111iiI , self . name , ooOoooO0OOo , ii1I1iI1i1I1i [ ooOoooO0OOo ] , oO )
     OooOoO00 . append ( string )
     ii1I1iI1i1I1i [ ooOoooO0OOo ] += 1
     ooo0o [ ooOoooO0OOo ] = II
    elif len ( OOo00oOoOo ) <= iiI1i11Ii11I1 :
     OooOO0Oo000o0 = iiI1i11Ii11I1 - len ( OOo00oOoOo ) + 1
     II = OOo00oOoOo . copy ( )
     for IiIIiiII in range ( OooOO0Oo000o0 ) :
      II . append ( 1 )
     string = 'self.%s_combine_%d_%d = tf.keras.layers.Reshape((' % ( self . name , ooOoooO0OOo , ii1I1iI1i1I1i [ ooOoooO0OOo ] )
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += ',))'
     ooo0oOOooO . append ( string )
     if iIiI11I1i11ii [ ooOoooO0OOo ] == 0 :
      iIiI11I1i11ii [ ooOoooO0OOo ] = 1
      I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
      oO = iiIII1Ii1 [ ooOoooO0OOo ]
     else :
      I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
      oO = iI1iiiiIIi [ ooOoooO0OOo ]
     string = '%s = self.%s_combine_%d_%d(%s)' % ( I1111iiI , self . name , ooOoooO0OOo , ii1I1iI1i1I1i [ ooOoooO0OOo ] , oO )
     OooOoO00 . append ( string )
     ii1I1iI1i1I1i [ ooOoooO0OOo ] += 1
     ooo0o [ ooOoooO0OOo ] = II
    if OOo00oOoOo [ : iiI1i11Ii11I1 ] != O00OOooO0oo0 [ : iiI1i11Ii11I1 ] :
     if 42 - 42: OooOoo . iI1iII1I1I1i * IiI11Ii111 * Iii1i % ooOOO
     o0oOO0oo0o0O = [ ( None if ( dim is None or O00OOooO0oo0 [ dimIdx ] is None ) else int ( dim / O00OOooO0oo0 [ dimIdx ] ) ) for dimIdx , dim in enumerate ( ooo0o [ ooOoooO0OOo ] [ : iiI1i11Ii11I1 ] ) ]
     print ( o0oOO0oo0o0O )
     o0o00o0o = ( - 1 , ) + tuple ( O00OOooO0oo0 [ 1 : iiI1i11Ii11I1 ] ) + ( OOo00oOoOo [ - 1 ] * functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , o0oOO0oo0o0O [ 1 : ] ) , )
     O0oOoO0OoO = [ o0o00o0o [ 1 ] ]
     for IiIIiiII in range ( len ( o0o00o0o [ 1 : iiI1i11Ii11I1 ] ) - 1 ) :
      O0oOoO0OoO . append ( o0o00o0o [ IiIIiiII + 2 ] * O0oOoO0OoO [ IiIIiiII ] )
     I1IiI1IIi = [ 1 , 0 ] + [ IiIIiiII + 2 for IiIIiiII in range ( len ( o0o00o0o ) - 1 ) ]
     Oo0O0oOO0000 = o0oOO0oo0o0O [ 1 : ]
     if 60 - 60: i1i1i1111I % ooOOO * OooOoo . i1iiIII111 + I1Ii1I1
     if self . incomingConfig . mergeDim in [ i1iIi1i1i1I1 . MergeDimMethods . SpaceToDepth , i1iIi1i1i1I1 . MergeDimMethods . SubSample ] :
      if iIiI11I1i11ii [ ooOoooO0OOo ] == 0 :
       iIiI11I1i11ii [ ooOoooO0OOo ] = 1
       I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
       oO = iiIII1Ii1 [ ooOoooO0OOo ]
      else :
       I1111iiI = iI1iiiiIIi [ ooOoooO0OOo ]
       oO = iI1iiiiIIi [ ooOoooO0OOo ]
      string = '%s = self.general_s2d(%s, %s, %s, %s, %s, %s)' % ( I1111iiI , oO , '[-1,' + ',' . join ( [ str ( x ) for x in OOo00oOoOo [ 1 : ] ] ) + ']' , '[' + ',' . join ( [ str ( x ) for x in o0o00o0o ] ) + ']'
      # Ii - Ii + IIiIIiIi11I1 % i1iiIII111
 , '[' + ',' . join ( [ str ( x ) for x in O0oOoO0OoO ] ) + ']' , '[' + ',' . join ( [ str ( x ) for x in I1IiI1IIi ] ) + ']'
 , '[' + ',' . join ( [ str ( x ) for x in Oo0O0oOO0000 ] ) + ']' )
      OooOoO00 . append ( string )
      ooo0o [ ooOoooO0OOo ] = o0o00o0o
      if 44 - 44: i1iiIII111
      if self . incomingConfig . mergeDim == i1iIi1i1i1I1 . MergeDimMethods . SubSample :
       if 56 - 56: oOo0O00 + oOO
       string = '%s = %s[...,0:%d]' % ( I1111iiI , I1111iiI , O00OOooO0oo0 [ - 1 ] )
       OooOoO00 . append ( string )
       ooo0o [ ooOoooO0OOo ] = O00OOooO0oo0
       if 11 - 11: oOO * ooo000 % I11iiIi11i1I - IiIIii11Ii % Iii1i
       if 13 - 13: Oo % i1I
     elif self . incomingConfig . mergeDim in [ i1iIi1i1i1I1 . MergeDimMethods . MaxPool , i1iIi1i1i1I1 . MergeDimMethods . MeanPool ] :
      if 26 - 26: Ii - ooOOO - i1i1i1111I * I1Ii1I1 + Iii1i
      if None in o0oOO0oo0o0O [ 1 : ] :
       raise ValueError ( "There should be no varied dimensions on dimension 1 or above." )
       if 13 - 13: IiI11Ii111 + oOO
       if 40 - 40: I1Ii1I1 % oOO
       if 85 - 85: oOo0O00
       if 3 - 3: I1Ii1I1 - IIiIIiIi11I1 + oOO
       if 56 - 56: I1I * iI1iII1I1I1i + I1I / I1Ii1I1 - i1 - i1
   if self . incomingConfig . instanceClass == i1iIi1i1i1I1 . Types . Concat :
    iIIII = 0
    for ooOoooO0OOo , OOo00oOoOo in enumerate ( ooo0o ) :
     iIIII += OOo00oOoOo [ iiI1i11Ii11I1 ]
    I111II11Ii = list ( ooo0o [ 0 ] ) . copy ( )
    I111II11Ii [ iiI1i11Ii11I1 ] = iIIII
    Ooo0o = [ ]
    for ooOoooO0OOo , OO0OoOO00oo in enumerate ( iIiI11I1i11ii ) :
     if OO0OoOO00oo == 0 :
      Ooo0o . append ( iiIII1Ii1 [ ooOoooO0OOo ] )
     else :
      Ooo0o . append ( iI1iiiiIIi [ ooOoooO0OOo ] )
    string = '%s = tf.keras.layers.concatenate([' % output_reg + ',' . join ( Ooo0o ) + '],axis =%d)' % iiI1i11Ii11I1
    OooOoO00 . append ( string )
    iiII1I1iIi = output_reg
    if 61 - 61: i1I . i1i1i1111I % i1I * I11iiIi11i1I % ooOOO
   elif i11i1I1Ii1I1i :
    raise ValueError ( "Not implement" )
   else :
    raise ValueError ( "Not implement" )
  return I111II11Ii , ooo0oOOooO , OooOoO00 , iiII1I1iIi
  if 51 - 51: i1i1i1111I - Iii1i - i1I % IiIIii11Ii
 def keras_call_processOutputTensor ( self , input_shape : List [ Optional [ int ] ] , layer_output_name : str , output_reg : str , buildNo : int = 0 ) :
  if 16 - 16: Ii
  if 28 - 28: ooo000 + I1Ii1I1 * IIiIIiIi11I1 + ooo000 * i1i1i1111I / Ii
  if 93 - 93: Ii % I11iiIi11i1I / IiIIii11Ii . i1I - i1iiIII111 * IiIIii11Ii
  if 3 - 3: Ii
  if 98 - 98: ooOOO + IiIIii11Ii . Ooo0Ooo
  if 99 - 99: i1 * IiIIii11Ii . iI1iII1I1I1i * I1Ii1I1
  if 64 - 64: OooOoo - Iii1i / I1Ii1I1
  if 15 - 15: oOO + I1Ii1I1 % I1I % i1I
  if 90 - 90: i1iiIII111
  if 25 - 25: Oo . i1 * IIiIIiIi11I1 * ooo000
  if 90 - 90: iI1iII1I1I1i . Iii1i / I1I * ooOOO / IiI11Ii111 % I1I
  if 100 - 100: iI1iII1I1I1i / IIiIIiIi11I1
  if 47 - 47: IIiIIiIi11I1 - ooOOO % ooo000 - oOO
  if 42 - 42: ooOOO / Oo
  if 98 - 98: oOo0O00 % Ooo0Ooo / oOO
  if 78 - 78: Ii % iI1iII1I1I1i - IIiIIiIi11I1 + oOo0O00 * Ooo0Ooo
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if layer_output_name != output_reg :
   I1111iiI = output_reg
   oO = layer_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 45 - 45: iI1iII1I1I1i + IiIIii11Ii % oOo0O00 - i1i1i1111I + i1I
  if ( self . outputConfig is None ) or ( self . outputConfig . instanceClass == I1Iiii1I1 . Types . Default ) :
   return ooo0oOOooO , OooOoO00
   if 23 - 23: iI1iII1I1I1i / i1 % ooOOO
   if 50 - 50: OooOoo * IiI11Ii111 * oOO * i1i1i1111I + ooo000
  elif self . outputConfig . instanceClass == I1Iiii1I1 . Types . Flatten :
   string = 'self.%s_output_reshape = tf.keras.layers.Flatten()' % self . name
   ooo0oOOooO . append ( string )
   string = '%s = self.%s_output_reshape(%s)' % ( I1111iiI , self . name , oO )
   OooOoO00 . append ( string )
   return ooo0oOOooO , OooOoO00
   if 45 - 45: I11iiIi11i1I / IIiIIiIi11I1
  elif self . outputConfig . instanceClass == I1Iiii1I1 . Types . Reshape :
   if 27 - 27: i1i1i1111I . iI1iII1I1I1i % IIiIIiIi11I1
   o0oOO0 = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ 1 : ] , 1 )
   OOOOo0O00 = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , self . _shape [ buildNo ] [ 1 : ] , 1 )
   if o0oOO0 != OOOOo0O00 :
    raise ValueError ( "Item shape does not equalt to the output shape." )
    if 10 - 10: I1I
   string = 'self.%s_output_reshape = tf.keras.layers.Reshape((' % self . name
   string += ',' . join ( [ str ( int ( x ) ) for x in self . _shape [ buildNo ] [ 1 : ] ] )
   string += '))'
   ooo0oOOooO . append ( string )
   string = '%s = self.%s_output_reshape(%s)' % ( I1111iiI , self . name , oO )
   OooOoO00 . append ( string )
   return ooo0oOOooO , OooOoO00
   if 9 - 9: iI1iII1I1I1i % IIiIIiIi11I1 / i1I - Ii - Ooo0Ooo
 def get_initiallizer ( self , key = 'weightConfig' ) :
  if 86 - 86: I11iiIi11i1I % ooo000 * oOo0O00 - I1Ii1I1 * Iii1i
  if 43 - 43: Iii1i * i1iiIII111 * oOO - ooo000 + OooOoo / i1i1i1111I
  if 52 - 52: Ooo0Ooo + i1iiIII111
  if 12 - 12: ooo000 * Oo + i1 + OooOoo . i1i1i1111I
  if 38 - 38: i1
  if 92 - 92: IiI11Ii111 / IIiIIiIi11I1 % Ii % Ooo0Ooo % I11iiIi11i1I
  if 55 - 55: ooOOO . Ooo0Ooo - Ii
  if 14 - 14: IiIIii11Ii . i1 % Ooo0Ooo % iI1iII1I1I1i
  if 5 - 5: i1iiIII111
  if 48 - 48: I1Ii1I1 / oOo0O00 - OooOoo . ooo000 + i1iiIII111 + OooOoo
  if 89 - 89: IiI11Ii111 * IIiIIiIi11I1 + iI1iII1I1I1i % i1iiIII111 / ooo000 . oOO
  if 31 - 31: I1Ii1I1 . I1Ii1I1
  if 60 - 60: i1i1i1111I . i1i1i1111I / Ii % OooOoo . ooOOO . IiI11Ii111
  return "initializers." + getattr ( self . linearTransform , key ) . initializer . getConstructorString ( )
  if 67 - 67: Ii
 def get_regularizer ( self , key = 'weightConfig' ) :
  if 93 - 93: iI1iII1I1I1i + i1iiIII111 * IiIIii11Ii + IIiIIiIi11I1 - i1
  if 38 - 38: I1I * oOO / i1 / i1i1i1111I % OooOoo / i1i1i1111I
  if 71 - 71: Ooo0Ooo / i1I - ooOOO * I11iiIi11i1I % IiIIii11Ii / i1I
  if 66 - 66: I11iiIi11i1I . ooo000 + I11iiIi11i1I % I1I - i1I / iI1iII1I1I1i
  if 41 - 41: i1iiIII111 + OooOoo - Oo - I1I * iI1iII1I1I1i
  if 7 - 7: ooOOO / ooo000 + I11iiIi11i1I % IiIIii11Ii + oOO % IiI11Ii111
  if 93 - 93: IiI11Ii111
  if 8 - 8: Iii1i - oOo0O00 % I11iiIi11i1I - I1I
  if 7 - 7: Ooo0Ooo / ooo000 + i1iiIII111 * I11iiIi11i1I
  if 69 - 69: oOO % I1Ii1I1 - ooOOO + ooo000 + i1
  i11Ii1i1iII1i = getattr ( self . linearTransform , key ) . l1Loss
  iiiiiiiI1ii1 = getattr ( self . linearTransform , key ) . l2Loss
  oO0Oo = getattr ( self . linearTransform , key ) . l1Decay
  O0OoOoo0 = getattr ( self . linearTransform , key ) . l2Decay
  if ( i11Ii1i1iII1i and iiiiiiiI1ii1 ) and ( oO0Oo != 0 and O0OoOoo0 != 0 ) :
   return 'regularizers.l1_l2(l1=%g, l2=%g)' % ( float ( oO0Oo ) , float ( O0OoOoo0 ) )
  if i11Ii1i1iII1i and oO0Oo != 0 :
   return 'regularizers.l1(%g)' % ( float ( oO0Oo ) )
  if iiiiiiiI1ii1 and O0OoOoo0 != 0 :
   return 'regularizers.l2(%g)' % ( float ( O0OoOoo0 ) )
  return 'None'
  if 58 - 58: IiIIii11Ii - IiI11Ii111 . Ii . I1I
class IIi11Iii ( oO00ooO00oOO0 ) :
 if 23 - 23: Ooo0Ooo * Iii1i
 if 61 - 61: iI1iII1I1I1i + I11iiIi11i1I
 if 96 - 96: I1Ii1I1 / iI1iII1I1I1i - ooOOO
 if 69 - 69: ooOOO - i1 * i1i1i1111I
 if 100 - 100: I1I
 if 18 - 18: oOO / IiIIii11Ii
 if 33 - 33: Ooo0Ooo - IIiIIiIi11I1
 def __init__ ( self , taskType : 'ModelNode.Layer.Task.Types' , name : str = "" , lossDppKey : str = "target" , measurement : str = "accuracy" , measurementOptions : Dict [ str , Any ] = { } , cuzBuild : Callable = None ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 0.04 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.004 , biasInitial = 0.001 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict [ str , Any ] = { } ,
 batchNorm : bool = True , batchNormParams : Dict [ str , Any ] = { } , dropout : float = 1 ,
 totalTasks = 1 , taskDimension = 1 , buildNo = 0 , weightDecayRate = 0.004 , biasInitial = 0.001 , weightAvg = 0 , weightStdDev = 0.04 , weightL1Loss = False , weightL2Loss = True ) :
  if 31 - 31: IiIIii11Ii
  if 71 - 71: I1Ii1I1 % IiI11Ii111 . Ooo0Ooo
  if 96 - 96: IiI11Ii111 + Ooo0Ooo % oOO
  if 20 - 20: I1I + i1i1i1111I
  if 18 - 18: i1i1i1111I * IiIIii11Ii / I11iiIi11i1I + IiI11Ii111 % I1I % IiI11Ii111
  if 22 - 22: Iii1i / oOO - ooOOO . OooOoo . iI1iII1I1I1i + Iii1i
  if 85 - 85: Ii - IIiIIiIi11I1 - I1Ii1I1 % oOo0O00
  if 33 - 33: oOo0O00 + IIiIIiIi11I1 * IiI11Ii111 + i1i1i1111I - i1 . Oo
  if 48 - 48: I11iiIi11i1I - I1I - Ii . oOo0O00 / ooo000 / oOo0O00
  if 41 - 41: Ooo0Ooo * i1I / Ooo0Ooo + oOo0O00 % IiIIii11Ii
  if 66 - 66: Oo * Iii1i
  if 74 - 74: I1I
  if 45 - 45: IiIIii11Ii * IIiIIiIi11I1 % ooo000 / I1Ii1I1 / IIiIIiIi11I1
  if 45 - 45: I1Ii1I1
  if 63 - 63: IiI11Ii111 . ooo000 / I1Ii1I1 + Iii1i . i1 / oOO
  if 100 - 100: I11iiIi11i1I / Iii1i % i1 - Ooo0Ooo
  if 54 - 54: oOo0O00 * IIiIIiIi11I1 % ooo000 . IiI11Ii111 * i1I + IiI11Ii111
  if 1 - 1: Oo * ooo000 % ooOOO * i1 / Ooo0Ooo + OooOoo
  if 25 - 25: Iii1i + i1i1i1111I / Oo . IIiIIiIi11I1 % Iii1i
  if 88 - 88: Iii1i
  if 6 - 6: I1Ii1I1 / Ii / i1 + I1Ii1I1 / Ii
  if 70 - 70: i1I / IiIIii11Ii * Ii - i1I % I11iiIi11i1I
  if 4 - 4: ooo000 - iI1iII1I1I1i . Oo
  if 2 - 2: oOo0O00
  if 61 - 61: ooOOO / IiIIii11Ii - IiI11Ii111 % Oo * Oo
  if 63 - 63: Ii % ooo000
  if 54 - 54: ooo000 . I11iiIi11i1I % I11iiIi11i1I
  if 47 - 47: Ooo0Ooo * I1Ii1I1 . I1I - Oo
  if 55 - 55: i1
  if 45 - 45: OooOoo
  if 89 - 89: Iii1i + I1I - OooOoo
  super ( ) . __init__ ( o00OoOo0O0O00 . Task , name = name , layerUnits = - 1 , final = True ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , dropout = dropout ,
 outputConfig = None )
  if 41 - 41: ooo000 + Ooo0Ooo % iI1iII1I1I1i - ooo000
  if 99 - 99: ooOOO * IiI11Ii111 - ooOOO . I11iiIi11i1I / Iii1i + Iii1i
  self . _taskType = taskType
  if 1 - 1: Oo
  if 28 - 28: I1I + I11iiIi11i1I - IIiIIiIi11I1 + Oo
  self . measurement = measurement
  if 3 - 3: I11iiIi11i1I / I1I / OooOoo / i1iiIII111
  if 93 - 93: oOO * i1 * IIiIIiIi11I1 / I1Ii1I1 - OooOoo * I1I
  self . measurementOptions = measurementOptions
  if 93 - 93: i1iiIII111 + Ii
  if 15 - 15: Oo + IIiIIiIi11I1 - ooo000
  self . lossDppKey = lossDppKey
  if 48 - 48: Ooo0Ooo % i1i1i1111I - Ii . Ii
  if 3 - 3: i1i1i1111I % I11iiIi11i1I . ooo000
  if 21 - 21: ooOOO * IiI11Ii111 - IiI11Ii111 / I1I / I11iiIi11i1I + i1I
  if 11 - 11: OooOoo . i1I - ooo000
  self . _targetTensors = None
  if 29 - 29: i1iiIII111
  if 90 - 90: IiIIii11Ii * I11iiIi11i1I * Ii
  self . _predictionTensors = None
  if 84 - 84: I11iiIi11i1I
  self . _evalTotal = 0
  self . _evalCumScore = 0
  self . _evalCumList = [ ]
  self . _evalTotList = [ ]
  self . _customizeBuild = cuzBuild
  if 62 - 62: i1iiIII111 - i1iiIII111 - Oo
 def _clearTempTensors ( self ) :
  if 89 - 89: I11iiIi11i1I . i1
  if 95 - 95: OooOoo % IIiIIiIi11I1 / oOO . ooOOO + ooo000 + oOO
  if 82 - 82: Oo . I1I * oOO
  if 12 - 12: IiIIii11Ii % oOo0O00
  if 14 - 14: I1Ii1I1 + i1 % ooo000 / ooOOO * i1iiIII111
  if 59 - 59: i1i1i1111I
  if 61 - 61: i1 / Ii - Ii . Ooo0Ooo
  super ( ) . _clearTempTensors ( )
  self . _predictionTensors = None
  self . _clearEvalInfo ( )
  if 47 - 47: Ii - IiIIii11Ii
 def _clearEvalInfo ( self ) :
  if 38 - 38: IIiIIiIi11I1 % I1Ii1I1 . i1I - i1i1i1111I / Ii * oOO
  if 20 - 20: IIiIIiIi11I1 / i1iiIII111 - IiI11Ii111 - IiI11Ii111
  if 91 - 91: Iii1i * Iii1i - Oo + Ooo0Ooo % IiI11Ii111
  if 50 - 50: IiI11Ii111
  if 47 - 47: Oo - oOO . oOO / i1I
  if 17 - 17: Iii1i
  if 62 - 62: Ooo0Ooo % i1 + IiIIii11Ii
  self . _evalTotal = 0
  self . _evalCumScore = 0
  self . _evalCumList = [ ]
  self . _evalTotList = [ ]
  if 72 - 72: i1I . IIiIIiIi11I1
 def _updateOrder ( self , buildNo : int = 0 ) :
  if 42 - 42: ooo000 / I1I
  if 15 - 15: OooOoo % i1I % Ooo0Ooo
  if 75 - 75: I11iiIi11i1I
  if 88 - 88: IIiIIiIi11I1 . ooo000 + Ooo0Ooo % I1I
  if 33 - 33: ooOOO * ooo000 % ooOOO
  if 86 - 86: I1Ii1I1 / Ooo0Ooo . i1I % OooOoo * i1iiIII111 + I11iiIi11i1I
  if 100 - 100: Iii1i . I1I
  if 45 - 45: oOO . IiIIii11Ii - i1 - oOo0O00 + IiI11Ii111
  if 13 - 13: I11iiIi11i1I . IiIIii11Ii % oOo0O00 / oOO % i1i1i1111I / IiI11Ii111
  if 97 - 97: I1Ii1I1 - iI1iII1I1I1i
  self . _order [ buildNo ] = max ( [ * [ lp . _order [ buildNo ] for lp in self . train . getEndingNodes ( buildNo = buildNo ) if lp != self ] , * [ lp . _order [ buildNo ] for lp in self . fromNode [ buildNo ] ] , 0 ] ) + 1
  if 57 - 57: oOo0O00 / IIiIIiIi11I1 . I1I % I11iiIi11i1I / i1i1i1111I
 def getTraceTarget ( self ) :
  if 72 - 72: ooo000
  if 85 - 85: IIiIIiIi11I1 . Oo - Iii1i . i1
  if 37 - 37: I1Ii1I1
  if 7 - 7: Ooo0Ooo / IIiIIiIi11I1 . i1iiIII111 + iI1iII1I1I1i
  if 97 - 97: IIiIIiIi11I1 . IiI11Ii111 * i1i1i1111I
  if 65 - 65: I11iiIi11i1I * Iii1i . Ii
  if 4 - 4: i1i1i1111I
  if 30 - 30: I1Ii1I1 . Oo
  if 36 - 36: Iii1i % Iii1i + i1i1i1111I . i1 * i1I
  if 21 - 21: IiIIii11Ii
  if self . lossDppKey not in self . train . traceItems :
   raise ValueError ( "Trace Item Structure not matching with training source structure." )
   if 85 - 85: i1i1i1111I % OooOoo % IIiIIiIi11I1 - ooOOO / i1 + iI1iII1I1I1i
  OOo000O = self . train . traceItems [ self . lossDppKey ]
  if 55 - 55: Oo % oOO + I1I * ooo000 / i1iiIII111
  return [ [ self . lossDppKey , tii , * ti ] for tii , ti in enumerate ( self . train . dppNodes [ self . lossDppKey ] . getPrintableItems ( OOo000O , recovered = False ) ) ]
  if 80 - 80: IIiIIiIi11I1 + i1I . oOo0O00 . I11iiIi11i1I
 def getTraceItems ( self , allPredictedValues : Optional [ Dict [ str , 'np.ndarray' ] ] = None , buildNo : int = 0 ) -> List [ List [ Any ] ] :
  if 60 - 60: Oo * I1Ii1I1 % IiI11Ii111 * I11iiIi11i1I . i1 / I11iiIi11i1I
  if 17 - 17: IiIIii11Ii - Oo - IIiIIiIi11I1 % i1I % oOO - i1i1i1111I
  if 18 - 18: Ooo0Ooo - IiI11Ii111 * Oo % ooo000
  if 94 - 94: I1Ii1I1 % iI1iII1I1I1i * Iii1i - I11iiIi11i1I * Ooo0Ooo
  if 90 - 90: iI1iII1I1I1i + oOO + Ooo0Ooo * IiIIii11Ii
  if 77 - 77: i1iiIII111 - iI1iII1I1I1i % Ooo0Ooo - IIiIIiIi11I1
  if 28 - 28: I11iiIi11i1I * Ii . i1iiIII111 - Ooo0Ooo . OooOoo % I1I
  if 84 - 84: IIiIIiIi11I1 / i1 / i1 % iI1iII1I1I1i + i1i1i1111I + I1Ii1I1
  if 56 - 56: I11iiIi11i1I % i1iiIII111 - Ii - iI1iII1I1I1i
  if 32 - 32: IiIIii11Ii % ooo000 + IiIIii11Ii . i1i1i1111I / I1I - OooOoo
  if 9 - 9: Iii1i / i1iiIII111
  if 66 - 66: oOO * I1Ii1I1 % I11iiIi11i1I * I11iiIi11i1I
  if 2 - 2: I1Ii1I1 * i1I
  if 85 - 85: IIiIIiIi11I1 + IiI11Ii111 - I1I
  if self . lossDppKey not in self . train . traceItems :
   raise ValueError ( "Trace Item Structure not matching with training source structure." )
   if 8 - 8: oOO % IIiIIiIi11I1 / Ii * IiI11Ii111 - i1I
  iii111iI = ( self . train . predict ( x = self . train . traceItems , buildNo = buildNo ) if allPredictedValues is None else allPredictedValues ) [ self . name ]
  return [ [ self . lossDppKey , pii , * pi ] for pii , pi in enumerate ( self . train . dppNodes [ self . lossDppKey ] . getPrintableItems ( iii111iI ) ) ]
  if 95 - 95: oOo0O00 / IiI11Ii111 + i1i1i1111I
 def getVisualTarget ( self ) :
  if 73 - 73: iI1iII1I1I1i + oOO . oOO + ooo000
  if 63 - 63: Oo
  if 91 - 91: oOo0O00 / I11iiIi11i1I % i1iiIII111 * i1I
  if 49 - 49: I1I + Ooo0Ooo
  if 48 - 48: IiI11Ii111 . Oo + OooOoo - ooo000 * I1Ii1I1 - ooOOO
  if 2 - 2: ooo000 % oOO / IIiIIiIi11I1 * i1i1i1111I . i1
  if 19 - 19: IiIIii11Ii
  if 51 - 51: Ii - IiI11Ii111 . I11iiIi11i1I . iI1iII1I1I1i
  if 16 - 16: Iii1i . i1iiIII111 + IiI11Ii111 * i1I
  if 77 - 77: Ii * IIiIIiIi11I1
  if self . lossDppKey not in self . train . visualItems :
   raise ValueError ( "Visual Item Structure not matching with training source structure." )
   if 11 - 11: oOO % Iii1i * I1Ii1I1 / i1 . Oo
  oooOOo0 = self . train . visualItems [ self . lossDppKey ]
  if 12 - 12: oOo0O00 / IIiIIiIi11I1 . ooOOO * i1i1i1111I
  return [ [ self . lossDppKey , tii , * ti ] for tii , ti in enumerate ( self . train . dppNodes [ self . lossDppKey ] . getPrintableItems ( oooOOo0 , recovered = False ) ) ]
  if 36 - 36: IiIIii11Ii + i1iiIII111 + I1Ii1I1 . i1
 def getVisualItems ( self , allPredictedValues : Optional [ Dict [ str , 'np.ndarray' ] ] = None , buildNo : int = 0 ) -> List [ List [ Any ] ] :
  if 27 - 27: i1I + Ooo0Ooo . oOo0O00
  if 96 - 96: IiIIii11Ii . Ooo0Ooo * I1I - I1I . ooo000
  if 26 - 26: Ooo0Ooo % oOo0O00
  if 66 - 66: Iii1i + iI1iII1I1I1i . ooOOO + I1I
  if 42 - 42: Iii1i + i1i1i1111I
  if 73 - 73: Ooo0Ooo
  if 47 - 47: ooOOO - iI1iII1I1I1i
  if 3 - 3: Ooo0Ooo * Ooo0Ooo % IIiIIiIi11I1 * IIiIIiIi11I1
  if 65 - 65: I1I . i1i1i1111I + i1iiIII111 + ooOOO / oOO + Ooo0Ooo
  if 36 - 36: i1iiIII111 . IiIIii11Ii / i1I . ooOOO . I1I
  if 45 - 45: I11iiIi11i1I . Ii + I1I - OooOoo % ooOOO % ooo000
  if 47 - 47: I1I
  if 19 - 19: Ii . oOo0O00 . i1I % Oo
  if 23 - 23: i1 + ooOOO % Iii1i - IiI11Ii111
  if self . lossDppKey not in self . train . visualItems :
   raise ValueError ( "Visual Item Structure not matching with training source structure." )
   if 72 - 72: i1I
  iii111iI = ( self . train . predict ( x = self . train . visualItems , buildNo = buildNo ) if allPredictedValues is None else allPredictedValues ) [ self . name ]
  return [ [ self . lossDppKey , pii , * pi ] for pii , pi in enumerate ( self . train . dppNodes [ self . lossDppKey ] . getPrintableItems ( iii111iI ) ) ]
  if 21 - 21: IiIIii11Ii . IiI11Ii111 . ooo000 . i1 / OooOoo % i1
 def copy ( self , name ) :
  if 51 - 51: i1I + i1
  if 18 - 18: IiIIii11Ii - Oo - IiI11Ii111 . oOo0O00 / i1I
  if 96 - 96: OooOoo
  if 66 - 66: Iii1i / Ooo0Ooo . i1 / Oo % I1I % IiI11Ii111
  if 22 - 22: Oo + IIiIIiIi11I1 - i1I
  if 12 - 12: ooo000 - i1I . Iii1i - IIiIIiIi11I1
  if 80 - 80: Oo
  if 61 - 61: OooOoo % i1
  if 30 - 30: i1I + i1 . I1I * I1I + IiIIii11Ii . i1
  if 46 - 46: oOO / OooOoo - oOo0O00 * IiIIii11Ii
  if 90 - 90: ooOOO . Iii1i * ooOOO % ooOOO . IIiIIiIi11I1 - i1i1i1111I
  raise ValueError ( "Task Layer is not copyable." )
  if 97 - 97: I1Ii1I1 % IiI11Ii111 % I1Ii1I1 % i1i1i1111I
 def _build ( self , buildNo : int ) :
  if 69 - 69: oOo0O00 / ooo000 + I1Ii1I1 % ooo000 . ooo000 / OooOoo
  if 77 - 77: I1I . Ooo0Ooo % oOo0O00 * iI1iII1I1I1i
  if 30 - 30: I1Ii1I1 * I1I
  if 18 - 18: I1Ii1I1 + Ooo0Ooo
  if 26 - 26: I1I % I11iiIi11i1I - i1i1i1111I * I1Ii1I1
  if 44 - 44: oOo0O00 . OooOoo + I11iiIi11i1I
  if 100 - 100: ooOOO % IiIIii11Ii - Iii1i % ooOOO
  if 34 - 34: i1i1i1111I + Ooo0Ooo - I1I + ooOOO
  if 35 - 35: Iii1i
  if 45 - 45: oOo0O00 % Ii * i1iiIII111 - I1Ii1I1
  self . _clearTempTensors ( )
  if 97 - 97: I1Ii1I1 / i1 % OooOoo
  if 35 - 35: oOO + ooOOO / IiIIii11Ii
  if all ( [ n . _built for n in self . fromNode [ buildNo ] ] ) :
   if 16 - 16: IiIIii11Ii % Iii1i + IiI11Ii111 % IIiIIiIi11I1 - i1iiIII111
   O00o = self . _combineIncomingTensors ( buildNo = buildNo )
   OOo0oo0Oo = self . _targetTensors = self . train . _sourceTensors [ self . lossDppKey ]
   if 24 - 24: oOo0O00
   if 25 - 25: iI1iII1I1I1i - ooOOO . oOo0O00 % IIiIIiIi11I1 % oOo0O00 / I11iiIi11i1I
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 33 - 33: Ooo0Ooo / IiIIii11Ii . I11iiIi11i1I / i1 * Iii1i
    if self . _customizeBuild is not None :
     tf . compat . v1 . add_to_collection ( 'losses' , self . _customizeBuild ( self , O00o , OOo0oo0Oo ) )
    else :
     raise ValueError ( "Task Layer is not buildable unless custom build function is given. Other Task Layer classes like ModelNode.Layer.Task.Classifier or ModelNode.Layer.Task.Regressor can be used instead." )
     if 42 - 42: OooOoo % Ii * Ii % I11iiIi11i1I
   self . _built = True
   if 23 - 23: IIiIIiIi11I1
 def partialEvaluate ( self , allTestData , allPredictedResults ) :
  if 83 - 83: IiI11Ii111 . I11iiIi11i1I % I1Ii1I1 / i1I . OooOoo
  if 46 - 46: Oo * Iii1i
  if 83 - 83: ooOOO % I1I / IiIIii11Ii * ooOOO * i1I - i1i1i1111I
  if 28 - 28: I1Ii1I1
  if 63 - 63: i1I / Iii1i % i1iiIII111 / Iii1i . Iii1i
  if 87 - 87: IIiIIiIi11I1 / IiI11Ii111
  if 72 - 72: iI1iII1I1I1i + i1I
  if 74 - 74: i1 % IiI11Ii111 + ooOOO * I1Ii1I1 / Ooo0Ooo
  if 5 - 5: I1Ii1I1 / oOo0O00
  if 7 - 7: iI1iII1I1I1i . Ii - i1 . oOO - Oo
  if 63 - 63: IiIIii11Ii
  pass
  if 7 - 7: i1iiIII111 % oOo0O00 / Iii1i - I11iiIi11i1I
 def getTestScore ( self ) :
  if 66 - 66: IiIIii11Ii % I1Ii1I1 % Ii * i1iiIII111 % Oo
  if 46 - 46: I1Ii1I1
  if 18 - 18: Ooo0Ooo % Ii - i1I . IiI11Ii111 % iI1iII1I1I1i * oOo0O00
  if 74 - 74: Oo . Oo - IiIIii11Ii
  if 75 - 75: i1
  if 52 - 52: IIiIIiIi11I1 % IIiIIiIi11I1 / OooOoo
  if 90 - 90: Iii1i % OooOoo . i1iiIII111
  pass
  if 78 - 78: I11iiIi11i1I - I11iiIi11i1I + I1I * i1 + OooOoo
 def recoverPredictedResults ( self , predictedData ) :
  if 73 - 73: iI1iII1I1I1i * Ooo0Ooo % IIiIIiIi11I1 * i1iiIII111 . I1Ii1I1 + i1I
  if 89 - 89: IiI11Ii111 * i1iiIII111 % IIiIIiIi11I1
  if 11 - 11: iI1iII1I1I1i + IIiIIiIi11I1 * Ii . i1i1i1111I - IiI11Ii111
  if 11 - 11: Ii * IiIIii11Ii / i1 / i1 - IiI11Ii111 + OooOoo
  if 15 - 15: I1Ii1I1 - ooOOO / i1iiIII111 . i1i1i1111I * i1iiIII111 + oOO
  if 93 - 93: Ooo0Ooo * i1 - ooOOO . i1 * oOO
  if 60 - 60: ooo000
  if 15 - 15: i1iiIII111
  if 39 - 39: Oo . I11iiIi11i1I
  if 98 - 98: i1iiIII111 % ooOOO % Oo % OooOoo % ooo000
  if 42 - 42: i1iiIII111 % IIiIIiIi11I1 . i1 / ooo000 - oOo0O00 - oOO
  if 16 - 16: i1i1i1111I / iI1iII1I1I1i / ooOOO
  if 3 - 3: i1i1i1111I . oOO % Oo . Iii1i . i1 - oOO
  return self . train . dppNodes [ self . lossDppKey ] . recoverToRawData ( predictedData )
  if 22 - 22: ooOOO + i1
 def get_initiallizer ( self , key = 'weightConfig' ) :
  if 21 - 21: ooOOO + i1iiIII111 % I11iiIi11i1I . IiI11Ii111
  if 81 - 81: Oo % i1I * I11iiIi11i1I - i1iiIII111 * i1i1i1111I + iI1iII1I1I1i
  if 77 - 77: IiIIii11Ii
  if 37 - 37: i1I - oOO
  if 6 - 6: ooOOO / IiI11Ii111 + ooOOO * IiI11Ii111 % Iii1i / oOo0O00
  if 79 - 79: I11iiIi11i1I . IiI11Ii111 . i1i1i1111I
  if 5 - 5: Ooo0Ooo
  if 76 - 76: IiI11Ii111 - i1i1i1111I % IiI11Ii111
  if 69 - 69: I1I / i1i1i1111I / IIiIIiIi11I1 - I1Ii1I1 % ooo000 - oOo0O00
  if 3 - 3: Ii / IiIIii11Ii - i1iiIII111 . i1I % Iii1i % Ooo0Ooo
  if 36 - 36: I11iiIi11i1I
  if 15 - 15: ooo000
  if 58 - 58: Ii
  return "initializers." + getattr ( self . linearTransform , key ) . initializer . getConstructorString ( ) . replace ( 'auto' , '0.05' )
  if 74 - 74: iI1iII1I1I1i
 def get_regularizer ( self , key = 'weightConfig' ) :
  if 80 - 80: Oo + i1iiIII111 . I1Ii1I1 % Iii1i
  if 70 - 70: I1I + IIiIIiIi11I1 * i1I + ooOOO
  if 46 - 46: oOO + IiI11Ii111 / i1i1i1111I / IiIIii11Ii % Ooo0Ooo * ooo000
  if 94 - 94: ooOOO + i1 % iI1iII1I1I1i + Oo % Ooo0Ooo / I11iiIi11i1I
  if 71 - 71: Oo * IIiIIiIi11I1 . oOO * i1 - I1Ii1I1
  if 8 - 8: IiI11Ii111
  if 60 - 60: I1I
  if 3 - 3: I11iiIi11i1I * iI1iII1I1I1i . Ooo0Ooo * OooOoo
  if 32 - 32: i1iiIII111 / I11iiIi11i1I + Oo % IiI11Ii111 . Oo * I1Ii1I1
  if 95 - 95: Ooo0Ooo - IiIIii11Ii . oOO . Iii1i
  if 58 - 58: oOo0O00 + ooOOO / iI1iII1I1I1i - Iii1i - Ii
  if 33 - 33: IiIIii11Ii / iI1iII1I1I1i % i1iiIII111 - i1i1i1111I - i1iiIII111 / ooOOO
  if 39 - 39: oOo0O00 % i1I - IiIIii11Ii
  i11Ii1i1iII1i = getattr ( self . linearTransform , key ) . l1Loss
  iiiiiiiI1ii1 = getattr ( self . linearTransform , key ) . l2Loss
  oO0Oo = getattr ( self . linearTransform , key ) . l1Decay
  O0OoOoo0 = getattr ( self . linearTransform , key ) . l2Decay
  if ( i11Ii1i1iII1i and iiiiiiiI1ii1 ) and ( oO0Oo != 0 and O0OoOoo0 != 0 ) :
   return 'regularizers.l1_l2(l1=%g, l2=%g)' % ( float ( oO0Oo ) , float ( O0OoOoo0 ) )
  if i11Ii1i1iII1i and oO0Oo != 0 :
   return 'regularizers.l1(%g)' % ( float ( oO0Oo ) )
  if iiiiiiiI1ii1 and O0OoOoo0 != 0 :
   return 'regularizers.l2(%g)' % ( float ( O0OoOoo0 ) )
   if 12 - 12: i1i1i1111I - i1I + Iii1i % ooOOO . Iii1i
  return 'None'
  if 89 - 89: i1iiIII111 . oOo0O00 + i1I + I1Ii1I1 - IiIIii11Ii
class iIi11I1i ( IIi11Iii ) :
 def __init__ ( self , name : str = "Task" , classCount : int = 1 , lossDppKey : str = "target" , measurement : str = "accuracy" , measurementOptions : Dict [ str , Any ] = { } ,
 # Ii * ooo000 - ooo000 - IiIIii11Ii - OooOoo
 # oOo0O00 * Iii1i / i1
 # i1iiIII111
 # i1I % Iii1i - IiIIii11Ii - oOO
 # Oo
 # IiIIii11Ii + Ii
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = "auto" , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.0 , biasInitial = 0.0 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict [ str , Any ] = { } ,
 buildNo = 0 , weightDecayRate = 0 , weightL1Loss = False , weightL2Loss = True , weightAvg = 0 , weightStdDev = "auto" , biasInitial = 0.0 ) :
  if 61 - 61: i1 % i1 - Ii + IiI11Ii111
  if 54 - 54: Ii % i1I . OooOoo / Oo - Ooo0Ooo - I1Ii1I1
  if 27 - 27: i1 * I1Ii1I1 + Iii1i - iI1iII1I1I1i . iI1iII1I1I1i
  if 23 - 23: i1iiIII111 + i1i1i1111I % OooOoo / Ooo0Ooo
  if 13 - 13: ooOOO + OooOoo
  if 58 - 58: i1i1i1111I
  if 86 - 86: I1I / OooOoo / Ii * I1Ii1I1 . i1iiIII111
  if 88 - 88: ooOOO . ooo000
  if 61 - 61: Iii1i + Oo - IiIIii11Ii % i1 / i1i1i1111I . i1iiIII111
  if 52 - 52: I11iiIi11i1I * i1iiIII111 / Ooo0Ooo
  if 23 - 23: iI1iII1I1I1i % I1I + Oo * ooOOO % i1 % i1
  if 49 - 49: OooOoo % IiIIii11Ii . OooOoo
  if 91 - 91: ooOOO - I11iiIi11i1I + i1i1i1111I - ooo000 - I1I
  if 84 - 84: Ii / OooOoo / Oo / oOO - I11iiIi11i1I
  if 6 - 6: Oo . OooOoo % i1iiIII111 . i1iiIII111
  if 63 - 63: i1i1i1111I * IiIIii11Ii / Oo
  if 23 - 23: oOO
  if 70 - 70: I1I * oOo0O00
  if 2 - 2: IIiIIiIi11I1 . i1i1i1111I % oOo0O00 % i1iiIII111 + IiIIii11Ii * IIiIIiIi11I1
  if 56 - 56: i1I - ooo000 * IiIIii11Ii / Ooo0Ooo / Oo - Oo
  if 63 - 63: OooOoo
  if 6 - 6: IiIIii11Ii + IIiIIiIi11I1
  if 89 - 89: iI1iII1I1I1i . ooo000 + IiIIii11Ii
  if 80 - 80: I1I / Ii . I1Ii1I1 / I1Ii1I1 + i1 / iI1iII1I1I1i
  if 12 - 12: oOo0O00 - I1I / I1I * IiIIii11Ii
  super ( ) . __init__ ( I1iiiiIi1iIi . Types . Classifier , name = name , lossDppKey = lossDppKey , measurement = measurement , measurementOptions = measurementOptions ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = False )
  self . trainingConfig = { }
  self . comparisons = [ ]
  self . applyGradient = [ ]
  self . optimizer_dict = { 'adam' : 'tf.keras.optimizers.Adam' ,
 'rmsprop' : 'tf.keras.optimizers.RMSprop' ,
 'grad' : 'tf.keras.optimizers.SGD' ,
 'momentum' : 'tf.compat.v1.train.MomentumOptimizer' ,
 'adagrad' : 'tf.keras.optimizers.Adagrad' ,
 'adadelta' : 'tf.keras.optimizers.Adadelta' ,
 'ftrl' : 'tf.keras.optimizers.Ftrl' }
  self . loss_dict = {
 'binary_crossentropy' : 'tf.reduce_mean(tf.keras.losses.binary_crossentropy' ,
 'categorical_crossentropy' : 'tf.reduce_mean(tf.keras.losses.categorical_crossentropy' ,
 'categorical_hinge' : 'tf.reduce_mean(tf.keras.losses.categorical_hinge' ,
 'cosine_similarity' : 'tf.reduce_mean(tf.keras.losses.cosine_similarity' ,
 'hinge' : 'tf.reduce_mean(tf.keras.losses.hinge' ,
 'KLD' : 'tf.reduce_mean(tf.keras.losses.KLD' ,
 'logcosh' : 'tf.reduce_mean(tf.keras.losses.logcosh' ,
 'MAE' : 'tf.reduce_mean(tf.keras.losses.MAE' ,
 'MAPE' : 'tf.reduce_mean(tf.keras.losses.MAPE' ,
 'MSE' : 'tf.reduce_mean(tf.keras.losses.MSE' ,
 'MSLE' : 'tf.reduce_mean(tf.keras.losses.MSLE' ,
 'poisson' : 'tf.reduce_mean(tf.keras.losses.poisson' ,
 'sparse_categorical_crossentropy' : 'tf.reduce_mean(tf.keras.losses.sparse_categorical_crossentropy' ,
 'squared_hinge' : 'tf.reduce_mean(tf.keras.losses.squared_hinge'
 }
  self . metrics_dict = {
 'binary_crossentropy' : tf . keras . metrics . BinaryAccuracy ( ) ,
 'categorical_crossentropy' : tf . keras . metrics . CategoricalAccuracy ( ) ,
 'categorical_hinge' : tf . keras . metrics . CategoricalHinge ( ) ,
 'cosine_similarity' : tf . keras . metrics . CosineSimilarity ( ) ,
 'hinge' : tf . keras . metrics . Hinge ( ) ,
 'KLD' : tf . keras . metrics . KLDivergence ( ) ,
 'logcosh' : tf . keras . metrics . LogCoshError ( ) ,
 'MAE' : tf . keras . metrics . MeanAbsoluteError ( ) ,
 'MAPE' : tf . keras . metrics . MeanAbsolutePercentageError ( ) ,
 'MSE' : tf . keras . metrics . MeanSquaredError ( ) ,
 'MSLE' : tf . keras . metrics . MeanSquaredLogarithmicError ( ) ,
 'poisson' : tf . keras . metrics . Poisson ( ) ,
 'sparse_categorical_crossentropy' : tf . keras . metrics . SparseCategoricalAccuracy ( ) ,
 'squared_hinge' : tf . keras . metrics . SquaredHinge ( )
 }
  self . _evalTotal = { }
  self . _evalCumScore = { }
  self . _evalCumList = { }
  self . _evalTotList = { }
  self . _evalMetricResult = { }
  if 79 - 79: I1I % Ii * IIiIIiIi11I1 - ooOOO - Ii / Oo
 def _clearEvalInfo ( self ) :
  if 94 - 94: IIiIIiIi11I1
  if 98 - 98: i1i1i1111I / i1i1i1111I . IiI11Ii111 . Iii1i . ooOOO * ooo000
  if 5 - 5: i1iiIII111
  if 24 - 24: oOo0O00 . i1iiIII111 % Ooo0Ooo - ooo000 % IiIIii11Ii * i1i1i1111I
  if 3 - 3: IiI11Ii111 % IiIIii11Ii
  if 27 - 27: I1Ii1I1 * iI1iII1I1I1i / I11iiIi11i1I * i1
  if 74 - 74: IiI11Ii111 * Iii1i
  self . _evalTotal = { }
  self . _evalCumScore = { }
  self . _evalCumList = { }
  self . _evalTotList = { }
  self . _evalMetricResult = { }
  if 22 - 22: I1Ii1I1 / ooOOO + I11iiIi11i1I
 def keras_call ( self , i ) :
  OoOO = [ ]
  if 70 - 70: IIiIIiIi11I1 . IiI11Ii111 - Ooo0Ooo * iI1iII1I1I1i + IIiIIiIi11I1
  if 52 - 52: I1I + IiIIii11Ii % IiI11Ii111
  if 22 - 22: Oo % Ooo0Ooo + i1i1i1111I / oOo0O00 / i1iiIII111
  if 88 - 88: iI1iII1I1I1i + ooOOO
  if 75 - 75: i1i1i1111I * ooo000 . I11iiIi11i1I . iI1iII1I1I1i + Oo % oOO
  if 21 - 21: I1I / ooOOO
  if 87 - 87: i1I * ooOOO + iI1iII1I1I1i
  if 86 - 86: oOo0O00 % IiIIii11Ii % ooo000
  if 100 - 100: oOo0O00 * i1iiIII111 + ooOOO . Oo / IiIIii11Ii
  if 60 - 60: i1I % i1i1i1111I
  if 33 - 33: Ii - IIiIIiIi11I1
  if 9 - 9: i1I / i1i1i1111I
  ooOOO0Oooo = [ ]
  OO00oO = [ ]
  if 93 - 93: I1I . I1Ii1I1 - Ooo0Ooo . iI1iII1I1I1i - I1I
  Iii111iII1 = [ ]
  try :
   Iii111iII1 = self . applyGradient
   Iii111iII1 = map ( lambda OOoo00ooOo00O : 'self.' + OOoo00ooOo00O , Iii111iII1 )
  except :
   pass
   if 51 - 51: IIiIIiIi11I1 . i1iiIII111
  ii111i1i111 = { }
  ii111i1i111 [ 'initialLearningRate' ] = self . trainingConfig [ 'initialLearningRate' ]
  ii111i1i111 [ 'learningRate' ] = self . trainingConfig [ 'initialLearningRate' ]
  ii111i1i111 [ 'learningRateDecay' ] = self . trainingConfig [ 'learningRateDecay' ]
  if ii111i1i111 [ 'learningRateDecay' ] == True :
   ii111i1i111 [ 'learningRateDecayFactor' ] = self . trainingConfig [ 'learningRateDecayFactor' ]
   ii111i1i111 [ 'numEpochsPerDecay' ] = self . trainingConfig [ 'numEpochsPerDecay' ]
  else :
   ii111i1i111 [ 'learningRateDecayFactor' ] = 0
   ii111i1i111 [ 'numEpochsPerDecay' ] = 0
   if 11 - 11: I1I * i1iiIII111 * iI1iII1I1I1i . IiI11Ii111 / I11iiIi11i1I
  OoOO . append ( 'self.%s_learningConfig = %s' % ( self . name , str ( ii111i1i111 ) ) )
  OoOO . append ( 'self.%s_optimizer = %s(learning_rate=self.%s_learningConfig["learningRate"])' % ( self . name , self . optimizer_dict [ self . trainingConfig [ 'optimizer' ] ] , self . name ) )
  if 39 - 39: i1iiIII111 * Iii1i + Ii + I11iiIi11i1I - Oo
  for ooOOoO0OO0Oo in self . comparisons :
   IIi1I1iIi1iII = self . keras_loss ( ooOOoO0OO0Oo [ 'measurement' ] )
   Oo0O00O = ooOOoO0OO0Oo [ 'target' ] . replace ( ' ' , '' )
   oooOOO0oo0OO = ooOOoO0OO0Oo [ 'input' ] . replace ( ' ' , '' )
   ooOOO0Oooo . append ( '%s(self.%s_output,self.%s_output))' % ( IIi1I1iIi1iII , Oo0O00O , oooOOO0oo0OO ) )
  ooOOO0Oooo = ' + ' . join ( ooOOO0Oooo )
  if 42 - 42: Iii1i + OooOoo . OooOoo
  if 18 - 18: IiI11Ii111
  if 88 - 88: I11iiIi11i1I * oOO + I1I . OooOoo . Ii
  o0i1i1ii1ii1I = ', ' . join ( Iii111iII1 )
  if 9 - 9: Ooo0Ooo - iI1iII1I1I1i % ooo000 . I11iiIi11i1I
  if 26 - 26: I1Ii1I1 % I1Ii1I1 % Ooo0Ooo - oOo0O00 - Iii1i . Iii1i
  if 77 - 77: IIiIIiIi11I1 - i1iiIII111 / oOo0O00 * Ooo0Ooo % IiIIii11Ii / IiI11Ii111
  oooooOOooooOo = 'self.%s_loss_grad = 0\n' % self . name
  oooooOOooooOo += '\t\tfor g in [%s]:\n' % o0i1i1ii1ii1I
  oooooOOooooOo += '\t\t\tfor loss in g.losses:\n'
  oooooOOooooOo += '\t\t\t\tself.%s_loss_grad += loss\n' % self . name
  if 33 - 33: Ooo0Ooo / ooOOO * Ooo0Ooo - i1 % Ii - Ooo0Ooo
  if 61 - 61: Ooo0Ooo + oOo0O00 + I1I . i1i1i1111I * I11iiIi11i1I + I1Ii1I1
  if 24 - 24: i1i1i1111I
  oooooOOooooOo += '\t\tself.%s_loss = %s + self.%s_loss_grad\n' % ( self . name , ooOOO0Oooo , self . name )
  if 80 - 80: i1iiIII111 + IIiIIiIi11I1 * Iii1i / IiIIii11Ii + i1 + I1Ii1I1
  I111IIIiiI1II = [ ]
  I111IIIiiI1II . append ( 'self.%s_loss' % self . name )
  if 2 - 2: I1I % ooo000 * Ii
  if 60 - 60: oOO / I11iiIi11i1I
  if 37 - 37: I1I % OooOoo % oOO * oOO * Ooo0Ooo
  if 50 - 50: I11iiIi11i1I % Oo . ooo000 . i1iiIII111 * I1Ii1I1
  if 68 - 68: oOo0O00 + I1I * Ii
  if 41 - 41: I1I * Ooo0Ooo
  IIi = [ ]
  if 84 - 84: iI1iII1I1I1i . I1Ii1I1 * ooOOO - OooOoo
  i1Iii11IiI11 = True
  for iiiiIi1IiiIi in self . applyGradient :
   if not iiiiIi1IiiIi is None :
    i1Iii11IiI11 = False
    IIi . append ( 'self.%s.trainable_variables' % iiiiIi1IiiIi )
   else :
    IIi . append ( 'self.trainable_variables' )
    break
  if i1Iii11IiI11 :
   IIi . append ( 'self.trainable_variables' )
   if 30 - 30: IIiIIiIi11I1 - oOO * i1i1i1111I % ooOOO . I11iiIi11i1I
  IIi = '+' . join ( IIi )
  if 48 - 48: IiIIii11Ii . Iii1i % IiIIii11Ii * I1Ii1I1 + oOo0O00
  if 72 - 72: oOo0O00 % Ii * Oo + oOo0O00
  OO00oO . append ( '# Task %s updates the trainable variables' % i )
  OO00oO . append ( 'if task_order == %s:' % i )
  OO00oO . append ( '\tgrads = tape.gradient(tf.reduce_mean(self.%s_loss), %s)' % ( self . name , IIi ) )
  OO00oO . append ( '\tself.%s_optimizer.apply_gradients(zip(grads, %s))' % ( self . name , IIi ) )
  if 64 - 64: ooOOO
  return OoOO , [ oooooOOooooOo , I111IIIiiI1II ] , OO00oO
  if 1 - 1: I11iiIi11i1I % IIiIIiIi11I1 - IiIIii11Ii % i1iiIII111 . ooo000 * IiI11Ii111
 def keras_loss ( self , loss_name = 'categorical_crossentropy' ) :
  if 76 - 76: i1I / Oo
  return self . loss_dict [ loss_name ]
  if 83 - 83: i1I - Ii
  if 81 - 81: ooo000
  if 71 - 71: Iii1i + IIiIIiIi11I1 + i1 - Iii1i / IiI11Ii111
  if 89 - 89: IIiIIiIi11I1 + IiI11Ii111 * oOo0O00 . i1iiIII111 . i1I
  if 24 - 24: OooOoo + ooo000 - iI1iII1I1I1i - Oo + Ooo0Ooo
  if 44 - 44: ooOOO - Ooo0Ooo
  if 95 - 95: oOO - Ooo0Ooo + iI1iII1I1I1i / Oo
  if 49 - 49: ooo000 / Oo . Oo
  if 52 - 52: i1I + OooOoo + i1i1i1111I + Oo - Ooo0Ooo
  if 67 - 67: IIiIIiIi11I1 + I1Ii1I1 % Ooo0Ooo + i1
  if 35 - 35: I1I * i1iiIII111 / Iii1i . i1i1i1111I . I1Ii1I1 . oOO
  if 67 - 67: Oo * ooOOO
  if 74 - 74: ooOOO . Ii . i1i1i1111I . OooOoo * i1i1i1111I . iI1iII1I1I1i
 def keras_get_loss ( self ) :
  if 40 - 40: oOO + i1iiIII111 . IIiIIiIi11I1 * i1I
  if 56 - 56: i1I
  if 36 - 36: I11iiIi11i1I / Ii
  if 24 - 24: I1Ii1I1 . i1iiIII111 + oOO * ooOOO / Iii1i - I11iiIi11i1I
  if 4 - 4: Ii - I1Ii1I1 % I11iiIi11i1I - IiIIii11Ii * ooOOO - I1I
  if 53 - 53: I1Ii1I1 + ooOOO + oOo0O00 / iI1iII1I1I1i * I1Ii1I1 . ooo000
  if 80 - 80: i1iiIII111
  if 85 - 85: ooo000 - IiI11Ii111 - OooOoo
  if 1 - 1: I1Ii1I1 * iI1iII1I1I1i % OooOoo / i1
  if 90 - 90: I11iiIi11i1I
  return '%s_loss = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits\\\n\t\t(labels=self.%s_target, logits=self.%s_output, name=\'crossEntropyPerExample\'))' % ( self . name , self . name , self . name )
  if 83 - 83: I11iiIi11i1I . i1 - oOo0O00 / ooOOO
 def recoverPredictedResults ( self , predictedData , lossDppKey ) :
  if 45 - 45: iI1iII1I1I1i % IiIIii11Ii
  if 6 - 6: i1I / Iii1i * I1I * i1iiIII111 % ooo000
  if 90 - 90: Ii % oOO / ooOOO + OooOoo . iI1iII1I1I1i
  if 67 - 67: OooOoo - ooo000
  if 71 - 71: IiI11Ii111 + Oo + oOo0O00 * IiI11Ii111 - ooOOO . oOo0O00
  if 59 - 59: IiIIii11Ii . IIiIIiIi11I1 / IiI11Ii111
  if 22 - 22: Iii1i * Iii1i - OooOoo % i1
  if 88 - 88: Iii1i / Iii1i * I1Ii1I1 . IIiIIiIi11I1 % oOO
  if 2 - 2: IIiIIiIi11I1 * oOO * ooOOO / Ooo0Ooo
  if 41 - 41: I1I + IiI11Ii111 . OooOoo / I1Ii1I1 / OooOoo . I11iiIi11i1I
  if 71 - 71: ooo000
  if 80 - 80: I1I
  if 41 - 41: I1Ii1I1 / OooOoo * I1Ii1I1 / OooOoo - i1
  if 40 - 40: ooOOO / ooo000 . Ii
  return self . train . dppNodes [ lossDppKey ] . recoverToRawData ( predictedData )
  if 67 - 67: I11iiIi11i1I % i1i1i1111I
 def partialEvaluate ( self , testData : Union [ 'np.ndarray' , List [ Any ] ] , allPredictedResults : Union [ 'np.ndarray' , List [ Any ] ] , comparison : Dict [ str , 'np.ndarray' ] = None ) :
  if 33 - 33: IiI11Ii111 % oOO + I1Ii1I1 * I1Ii1I1 * I1I
  if 88 - 88: I1Ii1I1 / I11iiIi11i1I
  if 94 - 94: ooo000 - IiI11Ii111 . i1I
  if 73 - 73: Ii . Oo % ooo000 % I1I
  if 19 - 19: i1
  if 83 - 83: i1iiIII111 - I1Ii1I1
  if 11 - 11: IiIIii11Ii + ooOOO + iI1iII1I1I1i
  if 17 - 17: Iii1i - Ii
  if 34 - 34: IiI11Ii111 % ooOOO - I1Ii1I1 + i1iiIII111 / IiI11Ii111
  if 88 - 88: Ii / IIiIIiIi11I1 / I11iiIi11i1I + IiIIii11Ii
  if 83 - 83: I11iiIi11i1I
  if 28 - 28: i1 + Ii / ooo000 . Iii1i
  if 83 - 83: Iii1i / iI1iII1I1I1i * i1 - ooo000 - IIiIIiIi11I1
  if 98 - 98: IiIIii11Ii % I11iiIi11i1I % iI1iII1I1I1i
  if 63 - 63: i1iiIII111
  ooOo0 = self . name + '_' + comparison [ "input" ] + '_' + comparison [ "target" ]
  Iiii1111I1i = comparison [ "metrics" ]
  O0O0OOo0oO0 = testData . shape [ 0 ]
  if 68 - 68: OooOoo
  if 96 - 96: iI1iII1I1I1i . ooo000 % ooOOO / Ii % IiI11Ii111 % IiIIii11Ii
  if Iiii1111I1i == "accuracy" or Iiii1111I1i == "sparse_categorical_crossentropy" :
   i1iIII = testData == allPredictedResults
   try :
    self . _evalCumScore [ ooOo0 ] += ( i1iIII == True ) . sum ( )
    self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
   except :
    self . _evalCumScore [ ooOo0 ] = ( i1iIII == True ) . sum ( )
    self . _evalTotal [ ooOo0 ] = O0O0OOo0oO0
  elif Iiii1111I1i == "nmi" or Iiii1111I1i == "f1score" :
   try :
    self . _evalCumList [ ooOo0 ] [ len ( self . _evalCumList ) : ] = [ * np . reshape ( allPredictedResults , [ - 1 ] ) ]
    self . _evalTotList [ ooOo0 ] [ len ( self . _evalCumList ) : ] = [ * np . reshape ( testData , [ - 1 ] ) ]
   except :
    self . _evalCumList [ ooOo0 ] [ len ( self . _evalCumList ) : ] = [ * np . reshape ( allPredictedResults , [ - 1 ] ) ]
    self . _evalTotList [ ooOo0 ] [ len ( self . _evalCumList ) : ] = [ * np . reshape ( testData , [ - 1 ] ) ]
  elif Iiii1111I1i == "MSE" or Iiii1111I1i == "PSNR" or Iiii1111I1i == "SMAPE" :
   if ooOo0 not in self . _evalCumScore :
    self . _evalCumScore [ ooOo0 ] = 0
    self . _evalTotal [ ooOo0 ] = 0
    if 15 - 15: i1 * OooOoo - i1i1i1111I . IIiIIiIi11I1
    if 94 - 94: i1i1i1111I . iI1iII1I1I1i . i1iiIII111 + ooo000 + iI1iII1I1I1i - oOo0O00
   if ( self . train . traceItems is None and comparison [ "target" ] in self . train . dppNodes ) or ( self . train . traceItems is not None and comparison [ "target" ] in self . train . traceItems ) :
    IiiiI11 = self . train . dppNodes [ comparison [ "target" ] ]
    O0O0OOo0oO0 = testData . size
    if Iiii1111I1i == "MSE" or Iiii1111I1i == "PSNR" :
     if 62 - 62: Oo + Ii
     if ( not hasattr ( IiiiI11 , "circular" ) ) or ( len ( IiiiI11 . circular ) == 0 ) :
      self . _evalCumScore [ ooOo0 ] += np . sum ( np . square ( np . subtract ( testData , allPredictedResults ) ) )
      self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
     elif Iiii1111I1i != "PSNR" :
      for ooOoooO0OOo in range ( 0 , IiiiI11 . getShape ( ) [ 1 ] ) :
       if ooOoooO0OOo in IiiiI11 . colToCircular :
        iI1Ii1IiI = IiiiI11 . circular [ IiiiI11 . colToCircular [ ooOoooO0OOo ] ]
        O0Ooo , iIi1iII11I = iI1Ii1IiI . min , iI1Ii1IiI . max
        Ii11IiIIiiI = iIi1iII11I - O0Ooo
        self . _evalCumScore [ ooOo0 ] += np . sum ( np . square ( np . minimum ( np . mod ( ( testData [ : , ooOoooO0OOo ] - allPredictedResults [ : , ooOoooO0OOo ] ) + Ii11IiIIiiI , Ii11IiIIiiI ) , np . mod ( ( allPredictedResults [ : , ooOoooO0OOo ] - testData [ : , ooOoooO0OOo ] ) + Ii11IiIIiiI , Ii11IiIIiiI ) ) ) )
       else :
        self . _evalCumScore [ ooOo0 ] += np . sum ( np . square ( np . subtract ( testData [ : , ooOoooO0OOo ] , allPredictedResults [ : , ooOoooO0OOo ] ) ) )
      self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
     else :
      raise ValueError ( "PSNR is not supported for circular data." )
    elif Iiii1111I1i == "SMAPE" :
     if ( not hasattr ( IiiiI11 , "circular" ) ) or len ( IiiiI11 . circular ) == 0 :
      self . _evalCumScore [ ooOo0 ] += np . sum ( np . abs ( np . subtract ( testData , allPredictedResults ) ) / ( ( np . abs ( testData ) + np . abs ( allPredictedResults ) ) / 2 ) )
      self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
     else :
      raise ValueError ( "SMAPE is not supported for circular data." )
   else :
    if Iiii1111I1i == "MSE" or Iiii1111I1i == "PSNR" :
     self . _evalCumScore [ ooOo0 ] += np . sum ( np . square ( np . subtract ( testData , allPredictedResults ) ) )
     self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
    elif Iiii1111I1i == "SMAPE" :
     self . _evalCumScore [ ooOo0 ] += np . sum ( np . abs ( np . subtract ( testData , allPredictedResults ) ) / ( ( np . abs ( testData ) + np . abs ( allPredictedResults ) ) / 2 ) )
     self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
  elif Iiii1111I1i in self . metrics_dict :
   OOOO00000o0Oo = self . metrics_dict [ Iiii1111I1i ]
   OOOO00000o0Oo . update_state ( testData , allPredictedResults )
   if 90 - 90: IIiIIiIi11I1 - I11iiIi11i1I % i1 . Iii1i
   try :
    self . _evalCumScore [ ooOo0 ] += OOOO00000o0Oo . result ( ) . numpy ( ) * O0O0OOo0oO0
    self . _evalTotal [ ooOo0 ] += O0O0OOo0oO0
   except :
    self . _evalCumScore [ ooOo0 ] = OOOO00000o0Oo . result ( ) . numpy ( ) * O0O0OOo0oO0
    if 22 - 22: OooOoo % Iii1i / Iii1i
    self . _evalTotal [ ooOo0 ] = O0O0OOo0oO0
    if 72 - 72: oOo0O00 / Oo
 def getTestScore ( self , comparison : Dict [ str , 'np.ndarray' ] = None ) :
  if 69 - 69: i1iiIII111 . i1iiIII111 * Iii1i * I1I
  if 79 - 79: Ii / I11iiIi11i1I / I1I . ooOOO + Oo / i1
  if 57 - 57: Oo / i1I / Iii1i + oOO + oOO % Oo
  if 99 - 99: IIiIIiIi11I1 % IiIIii11Ii * i1I % i1 - OooOoo
  if 89 - 89: i1I * OooOoo
  if 62 - 62: IiI11Ii111 . OooOoo % i1 % i1I * oOO
  if 51 - 51: Oo % Ii
  if 54 - 54: ooOOO . Ooo0Ooo
  if 59 - 59: I1I - i1 . i1i1i1111I % i1I - i1i1i1111I
  if 74 - 74: ooo000 % Ii - iI1iII1I1I1i
  if 84 - 84: IiI11Ii111 * Ooo0Ooo % ooOOO + ooOOO
  if 76 - 76: Oo
  if 70 - 70: Ii . i1iiIII111 . ooOOO
  ooOo0 = self . name + '_' + comparison [ "input" ] + '_' + comparison [ "target" ]
  Iiii1111I1i = comparison [ "metrics" ]
  if ( Iiii1111I1i in self . metrics_dict ) or ( Iiii1111I1i == "accuracy" or Iiii1111I1i == "MSE" or Iiii1111I1i == "SMAPE" ) :
   return self . _evalCumScore [ ooOo0 ] / self . _evalTotal [ ooOo0 ]
  elif Iiii1111I1i == "nmi" :
   return normalized_mutual_info_score ( self . _evalTotList [ ooOo0 ] , self . _evalCumList [ ooOo0 ] )
  elif Iiii1111I1i == "PSNR" :
   return 10 * math . log10 ( ( self . measurementOptions [ "max" ] ) ** 2 / ( self . _evalCumScore [ ooOo0 ] / self . _evalTotal [ ooOo0 ] ) )
  elif Iiii1111I1i in self . metrics_dict :
   return self . _evalCumScore [ ooOo0 ] / self . _evalTotal [ ooOo0 ]
   if 86 - 86: I1Ii1I1 - i1iiIII111
 def getTraceItems ( self , allPredictedValues : Optional [ Dict [ str , 'np.ndarray' ] ] = None , buildNo : int = 0 , comparison : Dict [ str , 'np.ndarray' ] = None ) -> List [ List [ Any ] ] :
  if 43 - 43: Iii1i / Oo * Ii % I11iiIi11i1I
  if 64 - 64: I11iiIi11i1I + oOo0O00
  if 23 - 23: OooOoo . I1Ii1I1
  if 83 - 83: I1Ii1I1 - IiIIii11Ii - Oo / IiIIii11Ii * IIiIIiIi11I1 / OooOoo
  if 31 - 31: Oo
  if 90 - 90: oOo0O00 / ooo000 . ooo000
  if 30 - 30: Ooo0Ooo / iI1iII1I1I1i - i1I + OooOoo - iI1iII1I1I1i
  if 57 - 57: i1I . ooOOO % Iii1i - IiIIii11Ii
  if 25 - 25: ooo000 + i1iiIII111 * iI1iII1I1I1i * Ii + ooo000 % oOO
  if 30 - 30: oOO * IiI11Ii111 - I11iiIi11i1I
  if 63 - 63: Ooo0Ooo
  if 89 - 89: I1Ii1I1 - OooOoo % i1I
  if 12 - 12: I1I - Iii1i - i1 + IiI11Ii111
  if 1 - 1: i1i1i1111I . Iii1i . IIiIIiIi11I1 . IIiIIiIi11I1 * oOO
  if 31 - 31: I11iiIi11i1I
  if 21 - 21: I1I - ooOOO - i1I . IIiIIiIi11I1 % Ii * I1I
  if comparison [ "target" ] not in self . train . traceItems :
   raise ValueError ( "Trace Item Structure not matching with training source structure." )
   if 24 - 24: Ii + I11iiIi11i1I
  iii111iI = ( self . train . predict ( x = self . train . traceItems , buildNo = buildNo ) if allPredictedValues is None else allPredictedValues ) [ self . name + '_' + comparison [ "input" ] + '_' + comparison [ "target" ] ]
  return [ [ comparison [ "target" ] , pii , * pi ] for pii , pi in enumerate ( self . train . dppNodes [ comparison [ "target" ] ] . getPrintableItems ( iii111iI ) ) ]
  if 12 - 12: i1 / OooOoo % IIiIIiIi11I1 / oOo0O00 + IiIIii11Ii
class ii1II ( IIi11Iii ) :
 def __init__ ( self , name : str = "classifier" , classCount : int = 1 , lossDppKey : str = "target" , measurement : str = "accuracy" , measurementOptions : Dict [ str , Any ] = { } ,
 # IiIIii11Ii * oOo0O00 * oOo0O00
 # iI1iII1I1I1i / IIiIIiIi11I1 % IiI11Ii111 * I1Ii1I1
 # iI1iII1I1I1i + iI1iII1I1I1i * i1i1i1111I
 # Iii1i + ooo000 - ooo000 % iI1iII1I1I1i
 # ooOOO % Iii1i / ooo000 * I1I . IIiIIiIi11I1
 # oOO % I1I / ooo000 - i1i1i1111I
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = "auto" , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.0 , biasInitial = 0.0 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict [ str , Any ] = { } ,
 buildNo = 0 , weightDecayRate = 0 , weightL1Loss = False , weightL2Loss = True , weightAvg = 0 , weightStdDev = "auto" , biasInitial = 0.0 ) :
  if 72 - 72: IiI11Ii111 + I1I
  if 4 - 4: I11iiIi11i1I - i1I - IiI11Ii111 . I1Ii1I1 . I11iiIi11i1I
  if 10 - 10: I1Ii1I1 . ooo000
  if 28 - 28: oOO * IiIIii11Ii . Ooo0Ooo
  if 62 - 62: Ii
  if 23 - 23: I1Ii1I1 / i1iiIII111 * Oo * IiI11Ii111
  if 26 - 26: Ooo0Ooo + OooOoo
  if 99 - 99: oOo0O00 + IIiIIiIi11I1 / I1Ii1I1 * I1Ii1I1 % I11iiIi11i1I
  if 33 - 33: Oo
  if 22 - 22: OooOoo * Ii . ooOOO
  if 32 - 32: i1I . i1i1i1111I
  if 70 - 70: Oo % OooOoo
  if 38 - 38: ooo000 % Ooo0Ooo * iI1iII1I1I1i - I11iiIi11i1I
  if 27 - 27: I1I
  if 13 - 13: IiI11Ii111 / ooOOO * IiI11Ii111 . IiI11Ii111
  if 28 - 28: i1i1i1111I + IIiIIiIi11I1 / oOO - ooOOO
  if 68 - 68: oOo0O00
  if 95 - 95: IiI11Ii111 . ooo000 * i1I - Oo % oOo0O00 % i1iiIII111
  if 9 - 9: Iii1i / ooOOO % Ooo0Ooo % i1 + I11iiIi11i1I
  if 44 - 44: i1I
  if 34 - 34: IiIIii11Ii
  if 52 - 52: IiIIii11Ii + i1I * ooOOO / Oo . Ii
  if 60 - 60: oOO / IiI11Ii111 - IiI11Ii111
  if 61 - 61: i1iiIII111 / IIiIIiIi11I1
  if 94 - 94: i1iiIII111 * OooOoo . i1iiIII111 / i1 % Oo * I1Ii1I1
  super ( ) . __init__ ( I1iiiiIi1iIi . Types . Classifier , name = name , lossDppKey = lossDppKey , measurement = measurement , measurementOptions = measurementOptions ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = False )
  self . classCount = classCount
  if 98 - 98: I1Ii1I1 - IiIIii11Ii
 def copy ( self , name ) -> 'ModelNode.Layer.Task.Classifier' :
  if 35 - 35: i1I * i1iiIII111 + Iii1i
  if 32 - 32: iI1iII1I1I1i . i1iiIII111 % OooOoo % ooOOO + IIiIIiIi11I1 - iI1iII1I1I1i
  if 20 - 20: ooo000 % iI1iII1I1I1i
  if 86 - 86: I1I % Iii1i % i1iiIII111 - i1i1i1111I
  if 53 - 53: Iii1i % ooo000
  if 55 - 55: IIiIIiIi11I1 - IiI11Ii111
  if 39 - 39: IiI11Ii111
  if 89 - 89: iI1iII1I1I1i . iI1iII1I1I1i / OooOoo * IiI11Ii111 / Oo
  if 64 - 64: oOO + I1I . i1i1i1111I - oOo0O00
  if 82 - 82: oOo0O00 + Iii1i + I1Ii1I1 * i1i1i1111I % IiIIii11Ii % ooo000
  if 43 - 43: i1iiIII111
  if 96 - 96: oOO + i1i1i1111I + ooOOO * I1Ii1I1 % OooOoo
  if 69 - 69: ooo000 + Ii
  if 91 - 91: i1I / i1
  if isinstance ( self , ii1II ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 46 - 46: i1i1i1111I
   if 85 - 85: I11iiIi11i1I + ooo000 * Ooo0Ooo / IiI11Ii111
  return ii1II ( name = name , classCount = self . classCount , lossDppKey = self . lossDppKey , measurement = self . measurement ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams )
  if 32 - 32: Ii * oOO + ooo000 + IIiIIiIi11I1 . Iii1i
 def _build ( self , buildNo : int ) :
  if 85 - 85: i1iiIII111 / Oo * IIiIIiIi11I1
  if 48 - 48: i1i1i1111I / I1Ii1I1 - i1i1i1111I - oOO . ooOOO
  if 42 - 42: i1i1i1111I / iI1iII1I1I1i + i1I * ooo000
  if 14 - 14: i1iiIII111 - Ii
  if 68 - 68: IiI11Ii111 * IIiIIiIi11I1 % i1iiIII111 + i1iiIII111 % I1I
  if 61 - 61: IIiIIiIi11I1 % I11iiIi11i1I % Ooo0Ooo . Ooo0Ooo * I11iiIi11i1I
  if 82 - 82: IiI11Ii111
  if 52 - 52: Oo . oOO % I11iiIi11i1I
  if 71 - 71: oOo0O00 + IIiIIiIi11I1 * I1Ii1I1 / i1i1i1111I
  if 61 - 61: I11iiIi11i1I - oOo0O00 + iI1iII1I1I1i + IIiIIiIi11I1 + iI1iII1I1I1i * Iii1i
  self . _clearTempTensors ( )
  if 51 - 51: I11iiIi11i1I
  if 99 - 99: i1iiIII111 + I11iiIi11i1I % I1I * oOO + Ooo0Ooo + oOo0O00
  if all ( [ n . _built for n in self . fromNode [ buildNo ] ] ) :
   if 97 - 97: I1Ii1I1 / IiIIii11Ii - i1i1i1111I + i1iiIII111 . IiIIii11Ii - OooOoo
   O0oO000OOoooo0OO = self . _combineIncomingTensors ( buildNo = buildNo )
   OoOOO0 = self . _targetTensors = tf . cast ( self . train . _sourceTensors [ self . lossDppKey ] , tf . int32 )
   if 73 - 73: oOO . IiIIii11Ii . iI1iII1I1I1i / OooOoo % Iii1i
   if 6 - 6: ooOOO + i1 - Ooo0Ooo . ooOOO * Ooo0Ooo
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 6 - 6: ooo000 * oOo0O00 * I1I % I1Ii1I1
    II11i11 = tuple ( s for s in O0oO000OOoooo0OO . shape )
    i1iI1 = tuple ( s for s in OoOOO0 . shape )
    if 32 - 32: IiIIii11Ii / I11iiIi11i1I + i1I + I1Ii1I1 * I1Ii1I1 % Iii1i
    if 51 - 51: i1iiIII111 - ooOOO / IiI11Ii111 - iI1iII1I1I1i
    if 90 - 90: Ii
    i1ii = False
    if i1iI1 [ - 1 ] == 1 :
     OoOOO0 = tf . reshape ( OoOOO0 , [ * i1iI1 [ : - 2 ] , - 1 ] )
     i1iI1 = tuple ( s for s in OoOOO0 . shape )
     i1ii = True
     if 6 - 6: I1I
     if 22 - 22: ooo000 - i1i1i1111I - oOO - I11iiIi11i1I . I11iiIi11i1I * ooo000
    if self . classCount == - 1 :
     self . classCount = self . train . dppNodes [ self . lossDppKey ] . getClassCount ( )
     if 33 - 33: IiI11Ii111 * i1I * i1i1i1111I
     if 51 - 51: IIiIIiIi11I1 - Ooo0Ooo
    o00O = len ( i1iI1 )
    if II11i11 [ : o00O ] != i1iI1 [ : o00O ] :
     raise ValueError ( "The shape of the output of previous layers cannot match with the target tensor." )
     if 98 - 98: Ii + i1i1i1111I
     if 20 - 20: Oo % IiIIii11Ii
    III1i = self . linearTransform . buildOn ( O0oO000OOoooo0OO , axis = o00O , toUnit = self . classCount , defaultDevice = self . train . device )
    O0oO000OOoooo0OO = III1i . results
    self . _weights . extend ( III1i . weights )
    if 62 - 62: i1I
    if 60 - 60: ooo000 * ooo000 . oOo0O00 / OooOoo
    iii1iI1iiI = tf . argmax ( tf . nn . softmax ( O0oO000OOoooo0OO ) , axis = o00O )
    self . _predictionTensors = tf . reshape ( iii1iI1iiI , [ * i11i111iI . setAsReshape ( iii1iI1iiI . shape ) , 1 ] ) if i1ii else iii1iI1iiI
    if 60 - 60: ooo000 + oOO . i1
    if 38 - 38: ooOOO - Oo % i1iiIII111 - iI1iII1I1I1i . oOO
    OoOOO0 = tf . cast ( OoOOO0 , tf . int64 )
    iiii = tf . nn . sparse_softmax_cross_entropy_with_logits ( labels = OoOOO0 , logits = O0oO000OOoooo0OO , name = 'crossEntropyPerExample' )
    o0OOoo = tf . reduce_mean ( iiii , name = 'crossEntropy' )
    tf . compat . v1 . add_to_collection ( 'losses' , o0OOoo )
    if 63 - 63: Iii1i . i1 * iI1iII1I1I1i
   self . _built = True
   if 45 - 45: oOo0O00
 def partialEvaluate ( self , allTestData : Union [ 'np.ndarray' , List [ Any ] ] , allPredictedResults : Union [ 'np.ndarray' , List [ Any ] ] ) :
  if 14 - 14: oOO + Ooo0Ooo * ooo000 * I11iiIi11i1I
  if 88 - 88: I1Ii1I1 % IiI11Ii111 / iI1iII1I1I1i * I1I * OooOoo
  if 57 - 57: Ii - I11iiIi11i1I / IiI11Ii111 + I1I - IiIIii11Ii
  if 47 - 47: Iii1i * OooOoo . i1i1i1111I
  if 85 - 85: i1I * ooOOO . i1I * i1I * IiIIii11Ii
  if 17 - 17: i1iiIII111 / IiIIii11Ii % i1
  if 1 - 1: i1I
  if 50 - 50: i1I + IIiIIiIi11I1 * Ii
  if 44 - 44: ooOOO + i1I + Oo % i1iiIII111 + OooOoo
  if 99 - 99: Iii1i
  if 18 - 18: I1I
  if 65 - 65: IIiIIiIi11I1 * iI1iII1I1I1i . i1 . Ooo0Ooo * Iii1i
  ooo = np . array ( allTestData [ self . lossDppKey ] )
  ooo = self . recoverPredictedResults ( ooo )
  if 1 - 1: oOo0O00
  if 53 - 53: IiI11Ii111 - IiIIii11Ii - i1i1i1111I / Ii . I11iiIi11i1I
  if self . measurement == "accuracy" :
   i1iIII = ooo == allPredictedResults
   O0O0OOo0oO0 = ooo . size
   self . _evalCumScore += ( i1iIII == True ) . sum ( )
   self . _evalTotal += O0O0OOo0oO0
  elif self . measurement == "nmi" :
   self . _evalCumList [ len ( self . _evalCumList ) : ] = [ * np . reshape ( allPredictedResults , [ - 1 ] ) ]
   self . _evalTotList [ len ( self . _evalCumList ) : ] = [ * np . reshape ( ooo , [ - 1 ] ) ]
   if 37 - 37: i1iiIII111 - I1Ii1I1 + i1iiIII111 + Ooo0Ooo * I11iiIi11i1I
 def getTestScore ( self ) :
  if 50 - 50: I1Ii1I1 / IiI11Ii111
  if 8 - 8: i1iiIII111 * oOo0O00 + iI1iII1I1I1i . Iii1i . ooo000 + IIiIIiIi11I1
  if 28 - 28: OooOoo * I1I % Ooo0Ooo * Ii % iI1iII1I1I1i
  if 2 - 2: I11iiIi11i1I + IIiIIiIi11I1 * i1 / i1iiIII111
  if 98 - 98: I1I * i1I % i1iiIII111 * iI1iII1I1I1i . IiIIii11Ii
  if 82 - 82: oOo0O00 . iI1iII1I1I1i
  if 62 - 62: Ii
  if 40 - 40: Iii1i / iI1iII1I1I1i * OooOoo - i1 - I1Ii1I1
  if 47 - 47: oOO / iI1iII1I1I1i / oOo0O00
  if 28 - 28: OooOoo / ooo000 * OooOoo / Ii + Ooo0Ooo
  if self . measurement == "accuracy" :
   return self . _evalCumScore / self . _evalTotal
  elif self . measurement == "nmi" :
   return normalized_mutual_info_score ( self . _evalTotList , self . _evalCumList )
   if 27 - 27: I1I % i1 - OooOoo
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 30 - 30: i1i1i1111I
  if 34 - 34: Ooo0Ooo + IiIIii11Ii - i1 . I11iiIi11i1I
  if 8 - 8: oOo0O00 + oOO . I1Ii1I1 + I1I . i1I
  if 64 - 64: Ii
  if 16 - 16: ooOOO . I1I + Ii / Ii + oOO % Ii
  if 75 - 75: ooOOO / i1I . Iii1i - I11iiIi11i1I . IIiIIiIi11I1
  if 52 - 52: I11iiIi11i1I + IiIIii11Ii - I11iiIi11i1I + oOo0O00 * OooOoo
  if 21 - 21: iI1iII1I1I1i / ooo000 - I11iiIi11i1I
  if 46 - 46: IiIIii11Ii + Ooo0Ooo * oOo0O00 + OooOoo
  if 75 - 75: IIiIIiIi11I1 - i1iiIII111
  if 3 - 3: IiI11Ii111
  if 27 - 27: OooOoo + Ooo0Ooo
  if 57 - 57: ooOOO % I1Ii1I1 / I1Ii1I1
  if 12 - 12: Ii - IiIIii11Ii % I1I / I11iiIi11i1I
  if 14 - 14: oOO % i1i1i1111I - oOo0O00
  i1i1IIII1iiiI = self . train . dppNodes [ self . lossDppKey ] . getShape ( )
  i1i1IIII1iiiI = [ x if x != 'None' else None for x in i1i1IIII1iiiI ]
  Ii1I1iIiiiI = [ 'self.%s_target = tf.cast(batch_source[\'%s\'],tf.int64)' % ( self . name , self . lossDppKey ) , ]
  if i1i1IIII1iiiI [ - 1 ] == 1 :
   II = [ * i1i1IIII1iiiI [ : - 2 ] , - 1 ]
   string = 'self.%s_target = tf.reshape(self.%s_target,(' % ( self . name , self . name )
   string += ',' . join ( [ str ( int ( x ) ) for x in II ] )
   string += ',))'
   Ii1I1iIiiiI . append ( string )
  Ii1I1iIiiiI . append ( 'self.%s_output = %s' % ( self . name , reshape_output_name ) )
  return [ ] , Ii1I1iIiiiI , reshape_output_name , inputshape
  if 44 - 44: I1I + iI1iII1I1I1i / oOo0O00 / iI1iII1I1I1i - Ooo0Ooo * I1I
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg , buildNo = 0 ) :
  if 8 - 8: i1iiIII111 - IiIIii11Ii % OooOoo % Ooo0Ooo - oOo0O00 + ooo000
  if 80 - 80: IiIIii11Ii . oOO * IIiIIiIi11I1 % Iii1i / i1
  if 92 - 92: i1iiIII111 % Oo % oOo0O00 + OooOoo
  if 73 - 73: I1I * oOO - Ooo0Ooo - IiI11Ii111 . Iii1i
  if 59 - 59: i1iiIII111 . i1i1i1111I - Oo
  if 92 - 92: IiIIii11Ii + Ii . IIiIIiIi11I1
  if 39 - 39: oOO * oOO . ooo000 % ooo000 % Oo
  if 12 - 12: I11iiIi11i1I % Iii1i % i1i1i1111I
  if 63 - 63: I11iiIi11i1I
  if 57 - 57: iI1iII1I1I1i % Iii1i
  if 11 - 11: Ooo0Ooo / I1I % Oo * ooo000 + ooOOO / I1Ii1I1
  if 8 - 8: IiIIii11Ii . i1i1i1111I * ooo000 . IiI11Ii111
  if 99 - 99: IiI11Ii111 - i1iiIII111 . i1 + i1iiIII111
  if 98 - 98: oOO - OooOoo
  if 95 - 95: IiI11Ii111
  if 39 - 39: i1i1i1111I - Iii1i % OooOoo * i1 * IIiIIiIi11I1 / Oo
  ooo0oOOooO , OooOoO00 = [ ] , [ ]
  if 5 - 5: i1 - i1iiIII111 / IiIIii11Ii - OooOoo % I1Ii1I1 . i1
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = combine_output_name
  if 5 - 5: I11iiIi11i1I + IiI11Ii111
  if 73 - 73: i1iiIII111 . ooOOO - i1i1i1111I / OooOoo - Ii . ooOOO
  if 51 - 51: i1i1i1111I . I11iiIi11i1I
  II11i11 = input_shape
  i1iI1 = self . train . dppNodes [ self . lossDppKey ] . getShape ( )
  i1iI1 = [ x if x != 'None' else None for x in i1iI1 ]
  if 89 - 89: iI1iII1I1I1i * i1i1i1111I . oOO % IIiIIiIi11I1
  if 69 - 69: Iii1i + i1iiIII111
  i1ii = False
  if i1iI1 [ - 1 ] == 1 :
   i1ii = True
   if 39 - 39: IiI11Ii111 + Oo / oOO
   if 14 - 14: OooOoo . IiIIii11Ii
  if self . classCount == - 1 :
   self . classCount = self . train . dppNodes [ self . lossDppKey ] . getClassCount ( )
   if 38 - 38: i1I . IIiIIiIi11I1 % ooOOO / Oo
   if 31 - 31: Iii1i * ooOOO + Iii1i
  o00O = len ( i1iI1 ) - 1
  if 58 - 58: IIiIIiIi11I1 + oOO . ooo000 * OooOoo
  if II11i11 [ : o00O ] != i1iI1 [ : o00O ] :
   raise ValueError ( "The shape of the output of previous layers cannot match with the target tensor." )
  if II11i11 != [ * i1iI1 [ : - 1 ] , self . classCount ] :
   iiI1i11Ii11I1 = o00O
   if iiI1i11Ii11I1 == len ( II11i11 ) - 1 :
    pass
   elif iiI1i11Ii11I1 == 1 :
    II = II11i11 [ 0 : iiI1i11Ii11I1 ]
    II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ iiI1i11Ii11I1 : ] , 1 ) )
    string = 'self.%s_auto_reshape2 = tf.keras.layers.Flatten()' % self . name
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape2(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
    oO = I1111iiI
    II11i11 = II
   elif iiI1i11Ii11I1 > 1 and iiI1i11Ii11I1 < len ( II11i11 ) - 1 :
    II = II11i11 [ 0 : iiI1i11Ii11I1 ]
    II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ iiI1i11Ii11I1 : ] , 1 ) )
    string = 'self.%s_auto_reshape2 = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape2(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
    oO = I1111iiI
    II11i11 = II
   else :
    raise ValueError ( "Linear Transformation axis should within the dimension of the incoming tensor." )
    if 81 - 81: I1I + oOO - Oo * i1i1i1111I / oOo0O00
   oO00oOooO0O = 'self.%s_auto_reshape3 = tf.keras.layers.Dense(%d, kernel_initializer=%s, bias_initializer=%s, kernel_regularizer=%s, bias_regularizer=%s)' % ( self . name , self . classCount , self . get_initiallizer ( ) , self . get_initiallizer ( key = "biasConfig" ) , self . get_regularizer ( ) , self . get_regularizer ( key = "biasConfig" ) )
   if 94 - 94: I11iiIi11i1I * i1iiIII111 + oOO
   ooo0oOOooO . append ( oO00oOooO0O )
   Ii1I1iIiiiI = '%s = self.%s_auto_reshape3(%s)' % ( I1111iiI , self . name , oO )
   OooOoO00 . append ( Ii1I1iIiiiI )
   oO = I1111iiI
   iiII1I1iIi = I1111iiI
  else :
   pass
   if 39 - 39: I1Ii1I1
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , [ * i1iI1 [ : - 1 ] , self . classCount ]
  if 17 - 17: IIiIIiIi11I1 - ooo000
 def keras_get_loss ( self ) :
  if 88 - 88: OooOoo
  if 13 - 13: Ooo0Ooo . IIiIIiIi11I1 - i1iiIII111 / iI1iII1I1I1i / i1I
  if 25 - 25: oOo0O00 * ooOOO + Oo + i1I * ooo000 . iI1iII1I1I1i
  if 63 - 63: OooOoo * Iii1i . oOO
  if 25 - 25: Ooo0Ooo
  if 27 - 27: oOo0O00 + IIiIIiIi11I1 / Iii1i . I11iiIi11i1I * I1Ii1I1 + i1iiIII111
  if 57 - 57: ooOOO + i1 / i1 - I1I + ooOOO * i1I
  if 59 - 59: I11iiIi11i1I + Ooo0Ooo
  if 67 - 67: I1I % I1Ii1I1 / i1 + Iii1i + I1Ii1I1
  if 24 - 24: ooOOO - ooo000 * i1I * Iii1i
  return '%s_loss = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits\\\n\t\t(labels=self.%s_target, logits=self.%s_output, name=\'crossEntropyPerExample\'))' % ( self . name , self . name , self . name )
  if 25 - 25: ooOOO % IIiIIiIi11I1
class IiIi ( IIi11Iii ) :
 if 15 - 15: Iii1i - i1iiIII111
 if 68 - 68: IIiIIiIi11I1 * i1iiIII111 * I1Ii1I1 / I1Ii1I1
 if 11 - 11: I1Ii1I1 * Ii * oOo0O00 . OooOoo . ooOOO / OooOoo
 if 7 - 7: oOO / IIiIIiIi11I1
 if 82 - 82: oOo0O00 % IiIIii11Ii
 if 99 - 99: Ii + Ii
 if 17 - 17: i1iiIII111
 def __init__ ( self , name : str = "regressor" , lossDppKey : str = "target" , loss : str = "MSE" , measurement : str = "MSE" , measurementOptions : Dict [ str , Any ] = { } ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 0.5 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.0 , biasInitial = 0.0 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict [ str , Any ] = { } ,
 multiTask = ( 1 , ) , buildNo = 0 , weightDecayRate = 0 , weightL1Loss = False , weightL2Loss = True , weightAvg = 0 , weightStdDev = 0.5 , biasInitial = 0.0 ) :
  if 85 - 85: i1 - I1I % ooo000 - i1I - I1I + Ooo0Ooo
  if 44 - 44: IiI11Ii111 - IiI11Ii111 + IiI11Ii111 . IIiIIiIi11I1 % oOO
  if 89 - 89: Oo * oOo0O00 / oOo0O00
  if 41 - 41: i1 + I1Ii1I1 * ooo000 % IIiIIiIi11I1 - IIiIIiIi11I1 / i1iiIII111
  if 75 - 75: oOO / i1i1i1111I / I11iiIi11i1I
  if 83 - 83: ooo000 % ooo000 . ooo000 - i1 / oOo0O00
  if 24 - 24: IiI11Ii111 . Oo . ooOOO + Oo * ooo000
  if 66 - 66: IiI11Ii111 + iI1iII1I1I1i
  if 59 - 59: IiIIii11Ii
  if 87 - 87: i1I * i1i1i1111I . ooOOO
  if 5 - 5: ooOOO + ooo000 - Oo + I1Ii1I1
  if 55 - 55: ooOOO * Iii1i % IiIIii11Ii - i1
  if 45 - 45: I1I
  if 66 - 66: IiIIii11Ii + Ooo0Ooo
  if 22 - 22: i1 / IiI11Ii111 + Ooo0Ooo + Oo + i1iiIII111
  if 89 - 89: OooOoo / I1I * IiI11Ii111 . IIiIIiIi11I1 + ooo000
  if 5 - 5: Ooo0Ooo % Ooo0Ooo - IiIIii11Ii
  if 86 - 86: I1Ii1I1 . i1I + I1I % i1
  if 100 - 100: Oo + ooo000 + IIiIIiIi11I1
  if 75 - 75: I1I % i1I % IiIIii11Ii / I1Ii1I1
  if 79 - 79: oOo0O00
  if 83 - 83: IIiIIiIi11I1 / i1iiIII111 / I1Ii1I1 * Ii % I11iiIi11i1I
  if 29 - 29: i1i1i1111I
  if 90 - 90: I11iiIi11i1I * iI1iII1I1I1i - ooOOO * ooOOO
  if 100 - 100: Ooo0Ooo % iI1iII1I1I1i % OooOoo / Iii1i
  self . loss = measurement if ( loss == None ) else loss
  super ( ) . __init__ ( I1iiiiIi1iIi . Types . Regressor , name = name , lossDppKey = lossDppKey , measurement = measurement , measurementOptions = measurementOptions ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = False )
  if 59 - 59: oOO
 def _build ( self , buildNo : int ) :
  if 12 - 12: ooo000
  if 79 - 79: Oo + oOO * OooOoo
  if 51 - 51: i1i1i1111I - iI1iII1I1I1i % Ii * Oo * i1iiIII111
  if 30 - 30: oOO % iI1iII1I1I1i * Iii1i + ooOOO + i1I . i1i1i1111I
  if 75 - 75: oOo0O00 % IiI11Ii111 * i1iiIII111 % Oo * Oo
  if 62 - 62: ooo000 / oOo0O00 . OooOoo
  if 19 - 19: Iii1i + IiIIii11Ii + I1Ii1I1 . I1Ii1I1
  if 68 - 68: I11iiIi11i1I + I1I % iI1iII1I1I1i * oOO . Ii . i1
  if 45 - 45: ooOOO * i1i1i1111I / i1I % Oo
  if 5 - 5: oOo0O00
  self . _clearTempTensors ( )
  if 83 - 83: ooOOO / Ii - OooOoo . IiIIii11Ii % ooOOO
  if 86 - 86: i1I % iI1iII1I1I1i * ooo000 / Oo / i1iiIII111 * Ii
  if all ( [ n . _built for n in self . fromNode [ buildNo ] ] ) :
   if 66 - 66: Iii1i
   O0oO000OOoooo0OO = self . _combineIncomingTensors ( buildNo = buildNo )
   OoOOO0 = self . _targetTensors = self . train . _sourceTensors [ self . lossDppKey ]
   if 71 - 71: iI1iII1I1I1i - ooOOO . OooOoo * i1I
   if 46 - 46: IiI11Ii111 - I1I . ooOOO + Ii * ooOOO - OooOoo
   if 96 - 96: I1Ii1I1 % IiIIii11Ii / I11iiIi11i1I % oOO + IIiIIiIi11I1 % ooo000
   if 80 - 80: oOO . Ooo0Ooo * I11iiIi11i1I + oOo0O00 * I1Ii1I1 . i1i1i1111I
   II11i11 = tuple ( s for s in O0oO000OOoooo0OO . shape )
   i1iI1 = tuple ( s for s in OoOOO0 . shape )
   if 20 - 20: i1I + ooo000
   if 5 - 5: I1I % Ii - ooo000
   if II11i11 == i1iI1 :
    self . _predictionTensors = O0oO000OOoooo0OO
    if 19 - 19: i1 / OooOoo + ooOOO - I1I
    if 49 - 49: Oo
   else :
    with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     if 32 - 32: IIiIIiIi11I1 % i1iiIII111 . Oo - I1Ii1I1 - IiI11Ii111
     if 65 - 65: IiIIii11Ii - I11iiIi11i1I + IIiIIiIi11I1
     if len ( i1iI1 ) == 1 :
      OoOOO0 = tf . reshape ( OoOOO0 , [ * i11i111iI . setAsReshape ( i1iI1 ) , 1 ] )
      i1iI1 = tuple ( s for s in OoOOO0 . shape )
      if 6 - 6: i1I . ooOOO - Oo - ooo000 + IiI11Ii111 % ooOOO
      if 66 - 66: IiIIii11Ii % ooo000
      if 93 - 93: Oo
     OO0OOO00Oo = 0
     for IIIi1iii1Ii in range ( 0 , min ( len ( II11i11 ) , len ( i1iI1 ) ) ) :
      if II11i11 [ IIIi1iii1Ii ] != i1iI1 [ IIIi1iii1Ii ] :
       break
      OO0OOO00Oo += 1
     if OO0OOO00Oo == len ( II11i11 ) :
      O0oO000OOoooo0OO = tf . reshape ( O0oO000OOoooo0OO , [ * i11i111iI . setAsReshape ( II11i11 ) , 1 ] )
      if 79 - 79: I1I % ooo000 / Iii1i * oOO / ooo000
      if 15 - 15: iI1iII1I1I1i + oOo0O00 * I1I / oOO - iI1iII1I1I1i / I11iiIi11i1I
     iiIi1II11 = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , i1iI1 [ OO0OOO00Oo : ] , 1 ) if OO0OOO00Oo < len ( i1iI1 ) else 1
     III1i = self . linearTransform . buildOn ( O0oO000OOoooo0OO , axis = OO0OOO00Oo , toUnit = iiIi1II11 , defaultDevice = self . train . device )
     O0oO000OOoooo0OO = III1i . results
     self . _weights . extend ( III1i . weights )
     if 3 - 3: ooo000 + OooOoo . ooOOO . Ooo0Ooo
     if 44 - 44: ooo000 + Ooo0Ooo + ooo000
     if len ( i1iI1 ) != len ( O0oO000OOoooo0OO . shape ) :
      O0oO000OOoooo0OO = tf . reshape ( O0oO000OOoooo0OO , [ * i11i111iI . setAsReshape ( i1iI1 ) ] )
      if 29 - 29: I1I - I1I - oOO * Oo * IiI11Ii111 / OooOoo
     self . _predictionTensors = O0oO000OOoooo0OO
     if 85 - 85: I1I / Ii
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 37 - 37: Ii . i1
    OoOOO0 = tf . cast ( OoOOO0 , O0oO000OOoooo0OO . dtype )
    IiiiI11 = self . train . dppNodes [ self . lossDppKey ]
    if self . loss == "MSE" :
     if ( not hasattr ( IiiiI11 , "circular" ) ) or len ( IiiiI11 . circular ) == 0 :
      oOo0oooooOO = tf . reduce_mean ( tf . math . squared_difference ( OoOOO0 , O0oO000OOoooo0OO ) )
      tf . compat . v1 . add_to_collection ( 'losses' , oOo0oooooOO )
     else :
      for ooOoooO0OOo in range ( 0 , IiiiI11 . getShape ( ) [ 1 ] ) :
       if ooOoooO0OOo in IiiiI11 . colToCircular :
        iI1Ii1IiI = IiiiI11 . circular [ IiiiI11 . colToCircular [ ooOoooO0OOo ] ]
        O0Ooo , iIi1iII11I = iI1Ii1IiI . min , iI1Ii1IiI . max
        Ii11IiIIiiI = iIi1iII11I - O0Ooo
        II11I1iii1i1 = tf . math . mod ( ( O0oO000OOoooo0OO [ : , ooOoooO0OOo ] - O0Ooo ) , Ii11IiIIiiI )
        iiii1IIII1i = tf . math . mod ( ( OoOOO0 [ : , ooOoooO0OOo ] - O0Ooo ) , Ii11IiIIiiI )
        II11I1iii1i1 = tf . minimum ( tf . math . mod ( ( II11I1iii1i1 - iiii1IIII1i ) + Ii11IiIIiiI , Ii11IiIIiiI ) , tf . math . mod ( ( iiii1IIII1i - II11I1iii1i1 ) + Ii11IiIIiiI , Ii11IiIIiiI ) )
        oOo0oooooOO = tf . reduce_mean ( tf . square ( II11I1iii1i1 ) )
        tf . compat . v1 . add_to_collection ( 'losses' , oOo0oooooOO )
       else :
        oOo0oooooOO = tf . reduce_mean ( tf . math . squared_difference ( OoOOO0 [ : , ooOoooO0OOo ] , O0oO000OOoooo0OO [ : , ooOoooO0OOo ] ) )
        tf . compat . v1 . add_to_collection ( 'losses' , oOo0oooooOO )
    else :
     raise ValueError ( "Requested loss type is not supported." )
   self . _built = True
   if 85 - 85: Ii + IIiIIiIi11I1 * oOo0O00 * i1i1i1111I % i1i1i1111I
 def partialEvaluate ( self , allTestData , predictedData ) :
  if 29 - 29: oOO / I1I / i1I - oOo0O00 - IiI11Ii111
  if 31 - 31: Ooo0Ooo / i1 % i1 . Iii1i % Iii1i
  if 92 - 92: i1 / I1I % Ooo0Ooo / iI1iII1I1I1i * I1I * ooo000
  if 9 - 9: Ii * IIiIIiIi11I1 + Ooo0Ooo
  if 10 - 10: IiIIii11Ii + i1i1i1111I - i1iiIII111 * Oo % I11iiIi11i1I
  if 15 - 15: Iii1i . IiI11Ii111 - oOo0O00 % OooOoo * I1Ii1I1 % I1Ii1I1
  if 31 - 31: IiI11Ii111
  if 63 - 63: i1I % i1iiIII111 * I11iiIi11i1I * I1I % OooOoo * Ii
  if 9 - 9: oOO
  if 77 - 77: i1i1i1111I * IIiIIiIi11I1 . i1 / OooOoo / IIiIIiIi11I1
  if 39 - 39: I11iiIi11i1I - Ii / IiI11Ii111 . ooOOO + Iii1i . I11iiIi11i1I
  if 69 - 69: ooOOO + ooOOO
  ooo = np . array ( allTestData [ self . lossDppKey ] )
  IiiiI11 = self . train . dppNodes [ self . lossDppKey ]
  ooo = self . recoverPredictedResults ( ooo )
  if 20 - 20: IIiIIiIi11I1 / OooOoo + ooOOO
  if 77 - 77: IIiIIiIi11I1 . i1iiIII111 % oOO
  O0O0OOo0oO0 = ooo . size
  if self . measurement == "MSE" or self . measurement == "PSNR" :
   if ( not hasattr ( IiiiI11 , "circular" ) ) or len ( IiiiI11 . circular ) == 0 :
    self . _evalCumScore += np . sum ( np . square ( np . subtract ( ooo , predictedData ) ) )
    self . _evalTotal += O0O0OOo0oO0
   elif self . measurement != "PSNR" :
    for ooOoooO0OOo in range ( 0 , IiiiI11 . getShape ( ) [ 1 ] ) :
     if ooOoooO0OOo in IiiiI11 . colToCircular :
      iI1Ii1IiI = IiiiI11 . circular [ IiiiI11 . colToCircular [ ooOoooO0OOo ] ]
      O0Ooo , iIi1iII11I = iI1Ii1IiI . min , iI1Ii1IiI . max
      Ii11IiIIiiI = iIi1iII11I - O0Ooo
      self . _evalCumScore += np . sum ( np . square ( np . minimum ( np . mod ( ( ooo [ : , ooOoooO0OOo ] - predictedData [ : , ooOoooO0OOo ] ) + Ii11IiIIiiI , Ii11IiIIiiI ) , np . mod ( ( predictedData [ : , ooOoooO0OOo ] - ooo [ : , ooOoooO0OOo ] ) + Ii11IiIIiiI , Ii11IiIIiiI ) ) ) )
     else :
      self . _evalCumScore += np . sum ( np . square ( np . subtract ( ooo [ : , ooOoooO0OOo ] , predictedData [ : , ooOoooO0OOo ] ) ) )
    self . _evalTotal += O0O0OOo0oO0
   else :
    raise ValueError ( "PSNR is not supported for circular data." )
  elif self . measurement == "SMAPE" :
   if ( not hasattr ( IiiiI11 , "circular" ) ) or len ( IiiiI11 . circular ) == 0 :
    self . _evalCumScore += np . sum ( np . abs ( np . subtract ( ooo , predictedData ) ) / ( ( np . abs ( ooo ) + np . abs ( predictedData ) ) / 2 ) )
    self . _evalTotal += O0O0OOo0oO0
   else :
    raise ValueError ( "SMAPE is not supported for circular data." )
    if 34 - 34: IIiIIiIi11I1 * OooOoo . i1I / OooOoo
 def getTestScore ( self ) :
  if self . measurement == "MSE" or self . measurement == "SMAPE" :
   if 65 - 65: I1I * Ii . i1i1i1111I % iI1iII1I1I1i + IiI11Ii111 . i1i1i1111I
   if 2 - 2: i1 * i1I * iI1iII1I1I1i
   if 99 - 99: I1Ii1I1 * oOo0O00 / Iii1i . OooOoo * oOo0O00
   if 19 - 19: i1iiIII111 . ooo000 % I1I
   if 14 - 14: ooo000
   if 98 - 98: oOO - oOo0O00
   if 37 - 37: oOO
   if 60 - 60: oOO - Ooo0Ooo % IIiIIiIi11I1 . Ooo0Ooo
   if 82 - 82: I1Ii1I1 - Ooo0Ooo % Iii1i / I1Ii1I1 + i1I
   return self . _evalCumScore / self . _evalTotal
  elif self . measurement == "PSNR" :
   return 10 * math . log10 ( ( self . measurementOptions [ "max" ] ) ** 2 / ( self . _evalCumScore / self . _evalTotal ) )
   if 64 - 64: oOO * i1i1i1111I * Ii
 def keras_build ( self ) :
  if 12 - 12: i1i1i1111I + Iii1i . OooOoo % i1I + I1Ii1I1 * I1I
  if 7 - 7: Oo + IIiIIiIi11I1 . oOO - I1Ii1I1
  if 42 - 42: i1iiIII111
  if 20 - 20: Iii1i % oOo0O00 . Ooo0Ooo % IiIIii11Ii . ooOOO
  if 54 - 54: IiIIii11Ii . I11iiIi11i1I . i1I + i1iiIII111 * i1i1i1111I
  if 61 - 61: ooOOO . Ii / IIiIIiIi11I1 + Iii1i / iI1iII1I1I1i % oOO
  if 70 - 70: OooOoo + i1 - I1Ii1I1 / I11iiIi11i1I
  if 33 - 33: i1 . I1I / i1iiIII111
  if 71 - 71: I1Ii1I1 . i1i1i1111I * I1I . IIiIIiIi11I1 - Iii1i . OooOoo
  if 31 - 31: oOO + OooOoo
  III1i1II = self . batch_target ( self . lossDppKey )
  i1Ii = self . get_loss_function ( )
  return [ III1i1II , i1Ii ]
  if 34 - 34: ooo000
 class batch_target :
  if 13 - 13: i1iiIII111 / i1 + oOo0O00
  if 75 - 75: I11iiIi11i1I
  if 74 - 74: IiIIii11Ii + i1iiIII111
  if 58 - 58: Ooo0Ooo + oOo0O00 * i1 * i1 / ooOOO . Iii1i
  if 28 - 28: i1iiIII111
  if 71 - 71: I11iiIi11i1I
  if 16 - 16: I11iiIi11i1I * i1 + i1iiIII111
  def __init__ ( self , lossDppKey ) :
   if 1 - 1: IiI11Ii111 / IiIIii11Ii / Ii % IiI11Ii111
   if 77 - 77: i1i1i1111I % ooOOO % i1
   if 57 - 57: I1I / i1i1i1111I
   if 23 - 23: I11iiIi11i1I / IiIIii11Ii - ooo000 + i1iiIII111 % Ii
   if 21 - 21: oOO . Iii1i
   if 48 - 48: oOo0O00 % IIiIIiIi11I1
   if 87 - 87: OooOoo % IiI11Ii111 - i1i1i1111I + I1Ii1I1 / ooOOO * ooo000
   if 42 - 42: oOO
   if 25 - 25: IiI11Ii111 + ooOOO . Oo - I1Ii1I1 * Oo . ooOOO
   if 6 - 6: i1I - i1 % Iii1i + iI1iII1I1I1i . i1i1i1111I - Ooo0Ooo
   self . lossDppKey = lossDppKey
   if 81 - 81: Oo
  def get_target ( self , batch_source ) :
   if 95 - 95: oOO
   if 93 - 93: Oo / i1 - IiI11Ii111 + i1I * I1I - I1Ii1I1
   if 13 - 13: i1 + i1 * IiI11Ii111
   if 60 - 60: Oo / i1iiIII111 - OooOoo
   if 70 - 70: I1Ii1I1 . I1Ii1I1 * Iii1i + Ii
   if 5 - 5: i1I + I1I
   if 64 - 64: oOO + oOO . i1iiIII111 / Ii . OooOoo / oOO
   if 61 - 61: Iii1i + I11iiIi11i1I * IIiIIiIi11I1 % IIiIIiIi11I1 + I11iiIi11i1I * ooOOO
   if 18 - 18: i1i1i1111I + oOO
   if 87 - 87: I1Ii1I1
   if 56 - 56: Oo / oOo0O00 * i1I
   if 18 - 18: I11iiIi11i1I * i1i1i1111I + i1 - ooOOO * oOo0O00
   if 63 - 63: i1I * IIiIIiIi11I1 / IiI11Ii111 * Ooo0Ooo
   return batch_source [ self . lossDppKey ]
   if 79 - 79: IiI11Ii111 / OooOoo * IiIIii11Ii . i1i1i1111I + iI1iII1I1I1i + Iii1i
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None , buildNo = 0 ) :
  if 33 - 33: I1I * i1 * Iii1i
  if 38 - 38: IiI11Ii111 + ooOOO
  if 72 - 72: IiIIii11Ii
  if 73 - 73: OooOoo % ooo000 * IIiIIiIi11I1 % oOo0O00 + i1
  if 31 - 31: I1I - ooOOO . Iii1i * IiI11Ii111 / i1 . Iii1i
  if 7 - 7: Iii1i . IiI11Ii111 / i1i1i1111I . oOo0O00 . Iii1i
  if 63 - 63: i1I + oOO - Ooo0Ooo
  if 22 - 22: Ooo0Ooo
  if 28 - 28: oOo0O00 % oOo0O00 * i1
  if 8 - 8: oOo0O00 / IIiIIiIi11I1 + i1iiIII111
  if 46 - 46: I11iiIi11i1I
  if 19 - 19: OooOoo % I11iiIi11i1I
  if 82 - 82: Oo % i1i1i1111I - iI1iII1I1I1i / i1i1i1111I * i1I
  if 42 - 42: oOO % IIiIIiIi11I1 . OooOoo / Oo - ooo000 + i1
  if 45 - 45: OooOoo + oOo0O00 % Ooo0Ooo
  if 67 - 67: oOO / I1Ii1I1 - I1I . I1Ii1I1
  Ii1I1iIiiiI = [ 'self.%s_target = batch_source[\'%s\']' % ( self . name , self . lossDppKey ) , ]
  if len ( self . _shape [ buildNo ] ) == 1 :
   self . _shape [ buildNo ] = [ None , 1 ]
   string = 'self.%s_target = tf.keras.layers.Reshape((1,))(self.%s_target)' % ( self . name , self . name )
   Ii1I1iIiiiI . append ( string )
  Ii1I1iIiiiI . append ( 'self.%s_output = %s' % ( self . name , reshape_output_name ) )
  return [ ] , Ii1I1iIiiiI , reshape_output_name , inputshape
  if 26 - 26: OooOoo / IIiIIiIi11I1 / oOo0O00 . ooOOO % i1
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg , buildNo = 0 ) :
  if 18 - 18: oOo0O00 * I1Ii1I1 . IiIIii11Ii - i1iiIII111
  if 71 - 71: I1Ii1I1 % IiIIii11Ii + oOO
  if 7 - 7: i1 / Oo
  if 4 - 4: I11iiIi11i1I . ooOOO + oOO * Iii1i * i1iiIII111
  if 96 - 96: ooOOO . I11iiIi11i1I / I1Ii1I1 % i1 - ooOOO - i1I
  if 6 - 6: ooOOO % ooOOO * i1i1i1111I - i1i1i1111I % I1I
  if 19 - 19: Ooo0Ooo . i1i1i1111I / oOo0O00
  if 53 - 53: i1
  if 28 - 28: iI1iII1I1I1i + i1 / IIiIIiIi11I1
  if 8 - 8: i1iiIII111 + IiIIii11Ii
  if 97 - 97: I1I - oOO + ooOOO . IiIIii11Ii . iI1iII1I1I1i - Oo
  if 72 - 72: iI1iII1I1I1i
  if 33 - 33: OooOoo / I1I * Ooo0Ooo % IiIIii11Ii - OooOoo
  if 69 - 69: Oo + ooOOO * i1I . I11iiIi11i1I . iI1iII1I1I1i / ooOOO
  if 41 - 41: ooOOO - Ooo0Ooo + i1I + IiI11Ii111 * IiIIii11Ii / Iii1i
  if 63 - 63: i1 / i1 - oOo0O00 - I1I
  ooo0oOOooO , OooOoO00 = [ ] , [ ]
  II11i11 = list ( input_shape )
  i1iI1 = [ x if x != 'None' else None for x in self . _shape [ buildNo ] ]
  if 48 - 48: Oo - I1Ii1I1
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = combine_output_name
  if 13 - 13: i1 - IIiIIiIi11I1 . Ii
  if II11i11 == i1iI1 :
   pass
   if 84 - 84: IiI11Ii111
   if 43 - 43: Iii1i / I1Ii1I1 + ooo000 % OooOoo / i1
  else :
   if 9 - 9: I1Ii1I1
   if 52 - 52: i1iiIII111 * oOo0O00 - IIiIIiIi11I1
   if len ( i1iI1 ) == 1 :
    i1iI1 = [ None , 1 ]
    if 34 - 34: IiI11Ii111 + ooo000 / IIiIIiIi11I1 - i1iiIII111 / Oo / ooo000
    if 3 - 3: oOo0O00 / I1Ii1I1 . i1I % ooOOO - Iii1i
    if 80 - 80: i1I * I1I
   OO0OOO00Oo = 0
   for IIIi1iii1Ii in range ( 0 , min ( len ( II11i11 ) , len ( i1iI1 ) ) ) :
    if II11i11 [ IIIi1iii1Ii ] != i1iI1 [ IIIi1iii1Ii ] :
     break
    OO0OOO00Oo += 1
   if OO0OOO00Oo == len ( II11i11 ) :
    string = 'self.%s_auto_reshape1 = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in II11i11 [ 1 : ] ] )
    string += ',1))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape1(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
    oO = I1111iiI
    II11i11 . append ( 1 )
    if 35 - 35: ooo000 * IIiIIiIi11I1 + I1I % i1 + IiI11Ii111
    if 91 - 91: I1Ii1I1 - i1iiIII111 . oOo0O00
   iiIi1II11 = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , i1iI1 [ OO0OOO00Oo : ] , 1 ) if OO0OOO00Oo < len ( i1iI1 ) else 1
   if 20 - 20: OooOoo - iI1iII1I1I1i - I11iiIi11i1I . IiI11Ii111 % I1Ii1I1 * Ooo0Ooo
   if 95 - 95: i1i1i1111I . Ooo0Ooo / i1I . i1i1i1111I
   iiI1i11Ii11I1 = OO0OOO00Oo
   print ( iiI1i11Ii11I1 )
   if iiI1i11Ii11I1 == len ( II11i11 ) - 1 :
    pass
   elif iiI1i11Ii11I1 == 1 :
    II = II11i11 [ 0 : iiI1i11Ii11I1 ]
    II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ iiI1i11Ii11I1 : ] , 1 ) )
    string = 'self.%s_auto_reshape2 = tf.keras.layers.Flatten()' % self . name
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape2(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
    oO = I1111iiI
    II11i11 = II
   elif iiI1i11Ii11I1 > 1 and iiI1i11Ii11I1 < len ( II11i11 ) - 1 :
    II = II11i11 [ 0 : iiI1i11Ii11I1 ]
    II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ iiI1i11Ii11I1 : ] , 1 ) )
    string = 'self.%s_auto_reshape2 = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape2(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
    oO = I1111iiI
    II11i11 = II
   else :
    raise ValueError ( "Linear Transformation axis should within the dimension of the incoming tensor." )
    if 53 - 53: i1 - OooOoo / iI1iII1I1I1i . iI1iII1I1I1i
    if 45 - 45: i1i1i1111I + ooOOO + IIiIIiIi11I1 - I1Ii1I1 * Iii1i
   oO00oOooO0O = 'self.%s_auto_reshape3 = tf.keras.layers.Dense(%d, activation = \'relu\')' % ( self . name , iiIi1II11 )
   if 99 - 99: i1 + iI1iII1I1I1i / ooo000
   ooo0oOOooO . append ( oO00oOooO0O )
   Ii1I1iIiiiI = '%s = self.%s_auto_reshape3(%s)' % ( I1111iiI , self . name , oO )
   OooOoO00 . append ( Ii1I1iIiiiI )
   oO = I1111iiI
   if 76 - 76: Oo % Ooo0Ooo * iI1iII1I1I1i / ooo000
   if 20 - 20: i1I / Ii - ooo000
   if 29 - 29: Ii
   if len ( i1iI1 ) != len ( II11i11 ) :
    string = 'self.%s_auto_reshape4 = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in i1iI1 [ 1 : ] ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape4(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
    if 60 - 60: I1Ii1I1 % I1I / oOO * i1i1i1111I % IIiIIiIi11I1
   iiII1I1iIi = I1111iiI
   if 65 - 65: IiIIii11Ii / i1 - I1Ii1I1 % i1i1i1111I
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , i1iI1
  if 14 - 14: oOO - ooo000 . ooo000 / i1I * I11iiIi11i1I
 def keras_get_loss ( self ) :
  if 62 - 62: i1iiIII111 / Oo * IiIIii11Ii . IiI11Ii111
  if 60 - 60: oOo0O00 + Ooo0Ooo
  if 67 - 67: Ii . oOo0O00 % iI1iII1I1I1i
  if 79 - 79: iI1iII1I1I1i + i1I * i1I / ooo000 / Oo * ooo000
  if 53 - 53: IiI11Ii111 * Ii
  if 70 - 70: OooOoo % ooo000 % ooo000 % i1
  if 83 - 83: IIiIIiIi11I1 * Ooo0Ooo - IiI11Ii111 / ooo000
  if 50 - 50: OooOoo + IIiIIiIi11I1
  if 31 - 31: Iii1i . IiIIii11Ii - Iii1i + ooOOO
  if 2 - 2: ooOOO % I1I . i1 % i1I % Oo . i1i1i1111I
  if 59 - 59: oOO / OooOoo * Iii1i
  return '%s_loss = tf.reduce_mean(tf.math.squared_difference(self.%s_target, tf.cast(self.%s_output, self.%s_target.dtype)))' % ( self . name , self . name , self . name , self . name )
  if 83 - 83: Iii1i % IIiIIiIi11I1 - i1I * I11iiIi11i1I
class I1iiiiIi1iIi :
 class Types ( II1i1I ) :
  if 93 - 93: ooo000 % I11iiIi11i1I . IiIIii11Ii / i1i1i1111I - Ooo0Ooo - ooOOO
  if 6 - 6: Iii1i % OooOoo
  if 72 - 72: OooOoo
  if 22 - 22: oOo0O00 * oOo0O00
  if 50 - 50: Ooo0Ooo . i1i1i1111I + IiIIii11Ii - oOO
  if 56 - 56: I1Ii1I1 - IiIIii11Ii - Ii - oOo0O00
  if 28 - 28: I1I % i1I / I1I / I11iiIi11i1I * ooOOO
  if 4 - 4: Oo % ooo000 / i1i1i1111I % ooo000 - ooOOO
  if 74 - 74: iI1iII1I1I1i + oOo0O00 - iI1iII1I1I1i / i1iiIII111 / i1I
  if 71 - 71: iI1iII1I1I1i . i1iiIII111 . oOo0O00
  if 60 - 60: IiI11Ii111 . OooOoo
  if 56 - 56: i1iiIII111 - i1I / Ooo0Ooo
  if 59 - 59: ooOOO % Oo - IiI11Ii111 % Ooo0Ooo . oOO - Ii
  if 63 - 63: Oo * Ii
  Config = 0
  if 4 - 4: iI1iII1I1I1i
  if 73 - 73: ooo000 - Ii - I1Ii1I1 . I1Ii1I1
  Classifier = 1
  if 2 - 2: i1
  if 89 - 89: oOo0O00 - I1I / I1Ii1I1 % i1 / i1iiIII111 + I1Ii1I1
  Regressor = 2
  if 19 - 19: IiI11Ii111
  if 40 - 40: I1Ii1I1
  Task = 3
  if 34 - 34: ooo000 * Oo / OooOoo
 Config = IIi11Iii
 Classifier = ii1II
 Regressor = IiIi
 Task = iIi11I1i
 if 95 - 95: I1Ii1I1
class Oo0Oooo0OOOO ( oO00ooO00oOO0 ) :
 if 21 - 21: i1iiIII111 * iI1iII1I1I1i . ooo000
 if 41 - 41: IiI11Ii111 * i1 % oOo0O00 - IiI11Ii111
 if 42 - 42: IiI11Ii111
 if 84 - 84: OooOoo - I11iiIi11i1I
 if 79 - 79: IIiIIiIi11I1 + Ii / I1I * Oo
 if 37 - 37: Iii1i / Oo - i1 + I11iiIi11i1I / IiIIii11Ii % I11iiIi11i1I
 if 74 - 74: iI1iII1I1I1i + IiI11Ii111 . i1I * Ooo0Ooo . IiI11Ii111
 class PaddingTypes ( II1i1I ) :
  if 74 - 74: oOO * oOO . OooOoo % IIiIIiIi11I1 / Ii . ooOOO
  if 39 - 39: IIiIIiIi11I1 . Oo . Ooo0Ooo / Ooo0Ooo + oOO
  if 79 - 79: ooo000
  if 91 - 91: iI1iII1I1I1i % i1iiIII111 % Iii1i % IiI11Ii111 / Oo
  if 19 - 19: IIiIIiIi11I1 - Ii % I1I + oOO * IIiIIiIi11I1 * i1iiIII111
  if 10 - 10: I11iiIi11i1I * IiI11Ii111 * I1I + ooOOO * i1I / iI1iII1I1I1i
  if 83 - 83: i1
  if 73 - 73: IIiIIiIi11I1 - i1 / Iii1i % ooOOO . ooOOO . I1I
  Zeros = 0
  if 22 - 22: Ooo0Ooo * IiI11Ii111 * oOo0O00 + Iii1i . OooOoo + I1I
  if 19 - 19: Ii
  Stretch = 1
  if 90 - 90: ooo000 % oOO + I1Ii1I1 - I1I * ooOOO / oOO
 class UpscaleTypes ( II1i1I ) :
  if 63 - 63: IiI11Ii111 . oOo0O00 / i1i1i1111I / oOo0O00 . iI1iII1I1I1i
  if 83 - 83: iI1iII1I1I1i - IIiIIiIi11I1 + i1
  if 22 - 22: i1i1i1111I + ooOOO * i1iiIII111 . i1i1i1111I - I1I - i1i1i1111I
  if 23 - 23: OooOoo / i1I . iI1iII1I1I1i
  if 74 - 74: IIiIIiIi11I1 + ooo000
  if 15 - 15: Ii + i1iiIII111 / I1I * Ii
  if 6 - 6: I11iiIi11i1I - Oo + iI1iII1I1I1i
  if 20 - 20: ooOOO / ooo000 . IIiIIiIi11I1 % i1iiIII111
  Bicubic = 0
  if 34 - 34: i1
  if 100 - 100: I1I - Iii1i
  Bilinear = 1
  if 86 - 86: i1iiIII111
  if 8 - 8: i1I * OooOoo / I11iiIi11i1I % Ii / i1I
  NearestNeighbor = 2
  if 20 - 20: i1 . I1I
  if 60 - 60: ooOOO
  PadZeros = 3
  if 86 - 86: Ii * I11iiIi11i1I / Ooo0Ooo
  if 3 - 3: IiI11Ii111 / I1I + Ooo0Ooo . OooOoo
  InsertZeros = 4
  if 65 - 65: ooOOO / Oo + i1I / IiIIii11Ii
 class AlgorithmTypes ( II1i1I ) :
  if 15 - 15: OooOoo - i1iiIII111 % oOO + IIiIIiIi11I1 - IiI11Ii111
  if 93 - 93: ooo000 . Ii
  if 83 - 83: I11iiIi11i1I - Ooo0Ooo
  if 26 - 26: oOo0O00 * iI1iII1I1I1i % IiIIii11Ii - ooo000 * Oo * OooOoo
  if 68 - 68: Ooo0Ooo
  if 78 - 78: I1Ii1I1 + Oo . Ii
  if 90 - 90: I1I + ooo000 . i1iiIII111 . ooo000 - IIiIIiIi11I1
  if 92 - 92: i1iiIII111 * iI1iII1I1I1i % I1I . i1i1i1111I + Oo
  Conv2DTranspose = 0
  if 17 - 17: oOO / I11iiIi11i1I * Iii1i . I1Ii1I1 + I1I
  if 71 - 71: i1iiIII111 * I1Ii1I1 * iI1iII1I1I1i + ooo000 % IiIIii11Ii + oOo0O00
  ScaleThenConv2D = 1
  if 46 - 46: I11iiIi11i1I
 def __init__ ( self , name : str = None , layerUnits : int = 30 , convFilterWidth : int = 3 , convPadding : bool = True , convStride : Tuple [ int , int ] = [ 1 , 1 ] , convDilation : int = 1 ,
 dconvPadding : 'ModelNode.Layer.Deconvolution.PaddingTypes' = PaddingTypes . Stretch , dconvUpscale : 'ModelNode.Layer.Deconvolution.UpscaleTypes' = UpscaleTypes . Bicubic ,
 dconvAlgorithm : 'ModelNode.Layer.Deconvolution.AlgorithmTypes' = AlgorithmTypes . Conv2DTranspose , refLayerName : str = None , refLayerTranspose : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 5e-2 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0 , biasInitial = 0.001 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict = { } ,
 batchNorm : bool = True , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 reshape = None , buildNo = 0 , weightDecayRate = 0 , weightStdDev = 5e-2 , biasInitial = 0.001 , weightL2Loss = True , weightAvg = 0 , weightL1Loss = False ) :
  if 42 - 42: oOO + i1iiIII111 % IiI11Ii111
  if 66 - 66: Ii * i1I - oOo0O00 . i1I / IIiIIiIi11I1 % I11iiIi11i1I
  if 68 - 68: i1I % oOo0O00 % oOO % ooOOO + Iii1i
  if 51 - 51: OooOoo
  if 50 - 50: i1I . IiIIii11Ii * oOo0O00 % IiIIii11Ii . OooOoo
  if 14 - 14: i1I % Iii1i % Iii1i / iI1iII1I1I1i - IIiIIiIi11I1
  if 25 - 25: oOO
  if 65 - 65: i1iiIII111
  if 30 - 30: I1Ii1I1
  if 75 - 75: I1I / ooo000
  if 60 - 60: IiIIii11Ii . i1I / i1I - OooOoo
  if 46 - 46: oOo0O00 % Oo
  if 91 - 91: iI1iII1I1I1i * i1I
  if 81 - 81: i1
  if 19 - 19: i1 / IiIIii11Ii / I11iiIi11i1I
  if 97 - 97: ooOOO % Iii1i * i1i1i1111I + I1Ii1I1 - IIiIIiIi11I1
  if 36 - 36: Oo / OooOoo
  if 86 - 86: i1i1i1111I
  if 96 - 96: ooOOO + I11iiIi11i1I + IiIIii11Ii
  if 2 - 2: oOo0O00 * Ooo0Ooo
  if 90 - 90: Iii1i
  if 87 - 87: ooo000 . i1i1i1111I % IIiIIiIi11I1 . i1 . IIiIIiIi11I1 - i1I
  if 96 - 96: Iii1i / i1iiIII111 % oOo0O00 . ooo000
  if 2 - 2: IIiIIiIi11I1 / Ii / Ii + i1
  if 82 - 82: oOo0O00 * Iii1i
  if 37 - 37: Oo . i1i1i1111I / iI1iII1I1I1i
  if 72 - 72: I1I - oOo0O00 * I1I
  if 52 - 52: ooOOO
  if 44 - 44: i1i1i1111I . IiI11Ii111 / Iii1i
  if 33 - 33: I1Ii1I1 . I11iiIi11i1I
  if 56 - 56: Ooo0Ooo - iI1iII1I1I1i - ooo000 + ooo000 + IiI11Ii111
  if 65 - 65: ooo000 / I1I / Ii / oOo0O00 % Oo % Ooo0Ooo
  if 65 - 65: i1i1i1111I / i1I % IiI11Ii111
  if 1 - 1: IIiIIiIi11I1 % i1i1i1111I . ooo000 + I11iiIi11i1I . Ii - I1Ii1I1
  if 61 - 61: IiI11Ii111 / ooOOO / iI1iII1I1I1i - i1 % oOo0O00 . ooo000
  if linearTransform is None and any ( [ param is not None for param in [ weightAvg , weightStdDev , weightL1Loss , weightL2Loss , weightDecayRate , biasInitial ] ] ) :
   linearTransform = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = weightAvg , weightStdDev = weightStdDev ,
 weightL1Loss = weightL1Loss , weightL2Loss = weightL2Loss , weightL2Decay = weightDecayRate , biasInitial = biasInitial )
  super ( ) . __init__ ( o00OoOo0O0O00 . Deconvolution , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig ,
 activation = activation , activationParams = activationParams , linearTransform = linearTransform ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , outputConfig = outputConfig )
  if 36 - 36: Iii1i + I11iiIi11i1I
  if 67 - 67: i1 / ooOOO / I1I * Ooo0Ooo % Ooo0Ooo % oOo0O00
  self . convFilterWidth = convFilterWidth
  if 92 - 92: IIiIIiIi11I1 - OooOoo / IIiIIiIi11I1 / ooOOO / I1Ii1I1 % IiI11Ii111
  if 22 - 22: i1 . OooOoo / Iii1i + i1i1i1111I - ooo000 % IiI11Ii111
  self . convPadding = convPadding
  if 83 - 83: Iii1i - ooo000 + i1I
  if 20 - 20: IiIIii11Ii + IiIIii11Ii . Ooo0Ooo * IiI11Ii111
  self . convStride = convStride
  if 46 - 46: I1Ii1I1 % i1i1i1111I - i1I - I1I . i1 + I11iiIi11i1I
  if 87 - 87: OooOoo
  self . convDilation = convDilation
  if 98 - 98: Ii % i1iiIII111 / ooo000
  if 22 - 22: IiI11Ii111
  self . dconvPadding = dconvPadding
  if 57 - 57: Ooo0Ooo - oOo0O00 . oOo0O00
  if 8 - 8: ooOOO / oOo0O00 . OooOoo
  self . dconvUpscale = dconvUpscale
  if 89 - 89: i1iiIII111 - OooOoo - i1i1i1111I - Ii - ooo000 + oOo0O00
  if 32 - 32: Iii1i
  self . dconvAlgorithm = dconvAlgorithm
  if 57 - 57: iI1iII1I1I1i + ooo000
  if 50 - 50: IiIIii11Ii . I1I * I1I . IIiIIiIi11I1 % I1I % iI1iII1I1I1i
  self . refLayerName = refLayerName
  if 37 - 37: ooo000 - IiI11Ii111 * IIiIIiIi11I1 / IIiIIiIi11I1
  if 94 - 94: oOo0O00 / I1Ii1I1 * I1Ii1I1 + IIiIIiIi11I1
  self . refLayerTranspose = refLayerTranspose
  if 66 - 66: i1i1i1111I * oOO / IIiIIiIi11I1
  if 82 - 82: OooOoo . I11iiIi11i1I * Ooo0Ooo / Oo
  self . reshape = reshape
  if 21 - 21: i1I * oOO % iI1iII1I1I1i
 def enumParser ( self , k : str , v : Any ) -> Any :
  if 58 - 58: IiI11Ii111 % I11iiIi11i1I + i1I . Ii + Ooo0Ooo
  if 91 - 91: I1Ii1I1 . IiIIii11Ii - i1i1i1111I - Iii1i * oOo0O00
  if 5 - 5: IIiIIiIi11I1 - OooOoo / I11iiIi11i1I + I11iiIi11i1I - ooOOO
  if 67 - 67: Iii1i
  if 49 - 49: iI1iII1I1I1i + i1i1i1111I
  if 50 - 50: IiI11Ii111 - oOO / Ooo0Ooo
  if 41 - 41: I1Ii1I1
  if 4 - 4: Oo + OooOoo + I11iiIi11i1I
  if 4 - 4: I11iiIi11i1I - oOo0O00 - IIiIIiIi11I1 - Oo . i1I - ooo000
  if 18 - 18: OooOoo
  if 85 - 85: ooo000 / OooOoo
  if 63 - 63: ooo000
  if 48 - 48: oOO * i1i1i1111I
  if 27 - 27: i1I % ooo000 + OooOoo * I1I
  if k == "dconvPadding" :
   if isinstance ( v , str ) :
    return getattr ( Oo0Oooo0OOOO . PaddingTypes , v )
   else :
    return getattr ( Oo0Oooo0OOOO . PaddingTypes , Oo0Oooo0OOOO . PaddingTypes . getName ( v ) )
  elif k == "dconvUpscale" :
   if isinstance ( v , str ) :
    return getattr ( Oo0Oooo0OOOO . UpscaleTypes , v )
   else :
    return getattr ( Oo0Oooo0OOOO . UpscaleTypes , Oo0Oooo0OOOO . UpscaleTypes . getName ( v ) )
  elif k == "dconvAlgorithm" :
   if isinstance ( v , str ) :
    return getattr ( Oo0Oooo0OOOO . AlgorithmTypes , v )
   else :
    return getattr ( Oo0Oooo0OOOO . AlgorithmTypes , Oo0Oooo0OOOO . AlgorithmTypes . getName ( v ) )
  else :
   return v
   if 42 - 42: IiIIii11Ii / i1i1i1111I * I1Ii1I1
 def _copySymmetricLayerConfig ( self , useSymmetricWeights = True , buildNo : int = 0 ) -> 'ModelNode.Layer.Convolution' :
  if 76 - 76: oOo0O00
  if 47 - 47: Ooo0Ooo % oOO / IiI11Ii111 + OooOoo + oOo0O00
  if 7 - 7: Ii . i1iiIII111 + i1i1i1111I
  if 96 - 96: ooo000
  if 83 - 83: Iii1i - oOO + Ii % i1I
  if 41 - 41: ooOOO / i1I / I11iiIi11i1I * i1iiIII111 . I11iiIi11i1I
  if 81 - 81: I1Ii1I1 / IiIIii11Ii / Ii - Oo / Oo
  if 53 - 53: ooo000 * Ii - oOO / I1Ii1I1 % I11iiIi11i1I
  if 12 - 12: I11iiIi11i1I % ooo000 % IiIIii11Ii
  if 56 - 56: Oo % IIiIIiIi11I1 * Oo % ooOOO + oOO * I1I
  if 50 - 50: i1i1i1111I
  if 41 - 41: i1 % i1
  if 49 - 49: oOo0O00 * i1I + oOo0O00 / iI1iII1I1I1i
  if 90 - 90: Ii / oOo0O00 / OooOoo
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 56 - 56: ooOOO % ooo000 + i1i1i1111I - Oo
  return O00oOo0O . Layer . Convolution ( name = ( self . name + "_Sym" ) , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride , convDilation = self . convDilation ,
 refLayerName = self . name if useSymmetricWeights else None , refLayerTranspose = True ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 40 - 40: IiIIii11Ii . I11iiIi11i1I - Ooo0Ooo - Iii1i - i1i1i1111I * IIiIIiIi11I1
 def copy ( self , name : str ) -> 'ModelNode.Layer.Deconvolution' :
  if 70 - 70: IiI11Ii111 * ooo000
  if 13 - 13: IIiIIiIi11I1 * Iii1i / iI1iII1I1I1i
  if 38 - 38: Iii1i * iI1iII1I1I1i / IIiIIiIi11I1 % OooOoo * IIiIIiIi11I1
  if 26 - 26: Oo
  if 76 - 76: IiI11Ii111 - oOo0O00 % IiIIii11Ii - Oo / IIiIIiIi11I1
  if 38 - 38: ooo000 * oOO + i1I
  if 89 - 89: ooOOO % oOO / oOO - oOo0O00 + i1
  if 89 - 89: ooo000 . ooOOO % oOo0O00 . iI1iII1I1I1i + i1I
  if 46 - 46: iI1iII1I1I1i * oOO / i1i1i1111I
  if 44 - 44: iI1iII1I1I1i - IiI11Ii111 % OooOoo - i1i1i1111I % Ooo0Ooo + i1i1i1111I
  if 25 - 25: OooOoo . i1 * IIiIIiIi11I1 / I1I - i1i1i1111I % ooo000
  if 92 - 92: oOo0O00 % IIiIIiIi11I1 % i1I / ooo000 - iI1iII1I1I1i % ooo000
  if 47 - 47: oOo0O00 - Oo - i1i1i1111I % IIiIIiIi11I1 * IiIIii11Ii
  if 30 - 30: i1I . Oo - i1I
  if not isinstance ( self , Oo0Oooo0OOOO ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 82 - 82: IiIIii11Ii - i1i1i1111I . i1iiIII111 - I1I - oOo0O00
   if 36 - 36: Ooo0Ooo
  return Oo0Oooo0OOOO ( name = name , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride ,
 convDilation = self . convDilation , dconvPadding = self . dconvPadding , dconvUpscale = self . dconvUpscale , dconvAlgorithm = self . dconvAlgorithm , refLayerName = self . refLayerName , refLayerTranspose = self . refLayerTranspose ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 7 - 7: Ii . i1I
 def _build ( self , buildNo : int ) :
  if 13 - 13: Ooo0Ooo / Ooo0Ooo % Ooo0Ooo % IIiIIiIi11I1
  if 21 - 21: i1 % I1Ii1I1 / ooo000 / I1I
  if 63 - 63: i1I . Ooo0Ooo
  if 67 - 67: I1I + Ooo0Ooo
  if 75 - 75: OooOoo . Ii . IIiIIiIi11I1 - IiI11Ii111 % iI1iII1I1I1i
  if 21 - 21: Oo - Ooo0Ooo + i1i1i1111I % oOo0O00
  if 93 - 93: Iii1i - I1Ii1I1 . oOO % i1I / ooOOO * IiIIii11Ii
  if 38 - 38: ooo000
  if 36 - 36: IIiIIiIi11I1 . Oo * Ii + Iii1i
  if 56 - 56: ooo000 * I1Ii1I1 + i1iiIII111 % Ii / ooOOO . i1iiIII111
  self . _clearTempTensors ( )
  if 48 - 48: I11iiIi11i1I * oOO - IiI11Ii111 + I1Ii1I1
  if 20 - 20: Ii / Iii1i
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 99 - 99: IiI11Ii111 + iI1iII1I1I1i - Oo + oOo0O00
   if self . refLayerName is not None :
    ooo00ooOoo0O = self . train . modelNodes [ self . refLayerName ]
    with tf . compat . v1 . variable_scope ( self . refLayerName , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     oOoO0O0o000 = i11i111iI . getFromGraph ( "weight" )
     if 72 - 72: IIiIIiIi11I1
    if self . refLayerTranspose :
     with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
      oOoO0O0o000 = tf . transpose ( oOoO0O0o000 , [ 0 , 1 , 3 , 2 ] )
      if 79 - 79: Oo / Ooo0Ooo . Oo - OooOoo
      if 31 - 31: ooOOO
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 50 - 50: I11iiIi11i1I + ooo000 / IiI11Ii111 + oOO % Oo . Ooo0Ooo
    O00o = self . _combineIncomingTensors ( buildNo = buildNo )
    II11i11 = [ * O00o . shape ]
    if 86 - 86: oOO + Oo * Ooo0Ooo / Ooo0Ooo
    if 90 - 90: OooOoo / Ii
    if len ( II11i11 ) != 4 :
     if 70 - 70: Iii1i . Oo / Iii1i / IiIIii11Ii
     if len ( II11i11 ) > 4 :
      I11II = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ 3 : ] , 1 )
      O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape [ : 3 ] ) , I11II ] )
      II11i11 = [ * O00o . shape ]
      if 71 - 71: I11iiIi11i1I + oOO
      if 10 - 10: ooo000 + oOO . ooOOO / iI1iII1I1I1i * Iii1i + iI1iII1I1I1i
     elif len ( II11i11 ) == 3 :
      O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape ) , 1 ] )
      II11i11 = [ * O00o . shape ]
      if 73 - 73: I1I + oOo0O00 + Oo + iI1iII1I1I1i * ooo000 + Ooo0Ooo
      if 50 - 50: IiI11Ii111
     else :
      raise ValueError ( "2 or lower dimension is not supported for DCNN Layer." )
      if 51 - 51: i1 . I1Ii1I1
      if 31 - 31: IiI11Ii111 / Iii1i + i1I . ooo000 - i1i1i1111I
    iiII = self . linearTransform
    if self . refLayerName is None :
     oOoO0O0o000 = iiII . weightConfig . create ( "weight" , [ self . convFilterWidth , self . convFilterWidth , II11i11 [ - 1 ] , self . layerUnits ] , dtype = O00o . dtype , defaultDevice = self . train . device )
     if 65 - 65: oOO . OooOoo - IIiIIiIi11I1 - Ii * i1iiIII111 * i1i1i1111I
     if 94 - 94: IiI11Ii111
    ii1iII11iI1I = iiII . biasConfig . create ( "biases" , [ oOoO0O0o000 . shape [ - 1 ] ] , dtype = O00o . dtype , defaultDevice = self . train . device )
    self . _weights . extend ( [ oOoO0O0o000 , ii1iII11iI1I ] )
    if 24 - 24: IiI11Ii111 . Iii1i / OooOoo + i1i1i1111I . oOO
    if 47 - 47: IiIIii11Ii . IIiIIiIi11I1 / Oo / oOO . iI1iII1I1I1i
    OOooOoo0 = 0
    Oo0o0Oooo00O0 = 0
    if self . convPadding :
     OOooOoo0 = II11i11 [ 1 ] * self . convStride [ 0 ]
     Oo0o0Oooo00O0 = II11i11 [ 2 ] * self . convStride [ 1 ]
    else :
     if 78 - 78: I1Ii1I1 * I1Ii1I1 / i1I + ooOOO / ooOOO + Iii1i
     OO0 = max ( [ self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 ) - self . convStride [ 0 ] , 0 ] )
     ii1IOOo0o00oOO = max ( [ self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 ) - self . convStride [ 1 ] , 0 ] )
     OOooOoo0 = II11i11 [ 1 ] * self . convStride [ 0 ] + OO0
     Oo0o0Oooo00O0 = II11i11 [ 2 ] * self . convStride [ 1 ] + ii1IOOo0o00oOO
     if 89 - 89: oOo0O00 . I1Ii1I1 / Oo . IIiIIiIi11I1 * I1Ii1I1
     if 36 - 36: Ii - i1i1i1111I + I11iiIi11i1I
    if self . dconvAlgorithm == Oo0Oooo0OOOO . AlgorithmTypes . Conv2DTranspose :
     if 23 - 23: I11iiIi11i1I
     if self . train . device . startswith ( "/cpu" ) and self . convDilation > 1 :
      raise ValueError ( "Deconvolutional dilation is not supported for CPU processing. --- at Layer: " + self . name )
     elif self . convDilation > 1 and any ( [ s > 1 for s in self . convStride ] ) :
      raise ValueError ( "Deconvolutional layer using convolutional 2D transpose currently does not support dilation > 1 when stride > 1.   --- at Layer: " + self . name )
      if 82 - 82: oOO
     with tf . device ( self . train . device ) :
      O0oO000OOoooo0OO = tf . nn . conv2d_transpose ( O00o , filter = tf . transpose ( oOoO0O0o000 , [ 0 , 1 , 3 , 2 ] ) , output_shape = [ tf . shape ( O00o ) [ 0 ] , OOooOoo0 , Oo0o0Oooo00O0 , oOoO0O0o000 . shape [ - 1 ] ] , strides = [ 1 , * self . convStride , 1 ] , padding = ( 'SAME' if self . convPadding else 'VALID' ) , dilations = [ 1 , self . convDilation , self . convDilation , 1 ] )
      O0oO000OOoooo0OO = tf . nn . bias_add ( O0oO000OOoooo0OO , ii1iII11iI1I )
    else :
     if 53 - 53: iI1iII1I1I1i
     if 66 - 66: I11iiIi11i1I
     oOo00 = self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 )
     OoOoo = ( oOo00 - 1 ) * 2
     if 89 - 89: Ii - i1 * Ooo0Ooo
     if 47 - 47: i1I + i1iiIII111 / Iii1i - I1Ii1I1 - IIiIIiIi11I1
     if self . dconvPadding == Oo0Oooo0OOOO . PaddingTypes . Stretch :
      if 84 - 84: I1Ii1I1 % Iii1i % ooOOO * Ooo0Ooo * i1I * IiI11Ii111
      if self . dconvUpscale in [ Oo0Oooo0OOOO . UpscaleTypes . PadZeros , Oo0Oooo0OOOO . UpscaleTypes . InsertZeros ] :
       raise ValueError ( "Deconvolutional upscale cannot be PadZeros or InsertZeros when it is stretching but not padding." )
       if 69 - 69: i1i1i1111I
       if 94 - 94: i1i1i1111I / i1 * Ii - I1Ii1I1
      oOoO0OoO = Oo0Oooo0OOOO . getTFResizeMethod ( self . dconvUpscale )
      i1Iiiiii1ii1 = tf . image . ResizeMethod . BICUBIC if oOoO0OoO == "BICUBIC" else tf . image . ResizeMethod . BILINEAR if oOoO0OoO == "BILINEAR" else tf . image . ResizeMethod . NEAREST_NEIGHBOR
      O00o = tf . image . resize ( O00o , ( OOooOoo0 + OoOoo , Oo0o0Oooo00O0 + OoOoo ) , i1Iiiiii1ii1 )
      if 27 - 27: i1I . i1i1i1111I
      if 39 - 39: Oo / i1 % ooOOO % i1iiIII111 . i1i1i1111I / i1i1i1111I
     else :
      if 91 - 91: I1Ii1I1 % Ii / i1 - i1 . i1I
      if self . dconvUpscale == Oo0Oooo0OOOO . UpscaleTypes . PadZeros :
       O00o = tf . image . pad_to_bounding_box ( O00o , int ( ( OOooOoo0 + OoOoo - II11i11 [ 1 ] ) / 2 ) , int ( ( Oo0o0Oooo00O0 + OoOoo - II11i11 [ 2 ] ) / 2 ) , OOooOoo0 + OoOoo , Oo0o0Oooo00O0 + OoOoo )
       if 60 - 60: oOO % I11iiIi11i1I
       if 61 - 61: iI1iII1I1I1i % iI1iII1I1I1i
      else :
       if self . dconvUpscale == Oo0Oooo0OOOO . UpscaleTypes . InsertZeros :
        if 10 - 10: Ii * oOo0O00
        if 19 - 19: IIiIIiIi11I1 % ooo000
        if 65 - 65: i1I
        if 1 - 1: IIiIIiIi11I1
        if 87 - 87: IiI11Ii111 - oOo0O00 - iI1iII1I1I1i / Ii - iI1iII1I1I1i % I11iiIi11i1I
        if 48 - 48: i1 + i1I
        if 80 - 80: I1I
        if self . convStride [ 1 ] > 1 :
         OooO000O0 = [ np . zeros ( O00o . shape for x in range ( 0 , self . convStride [ 1 ] - 1 ) ) ]
         O00o = tf . reshape ( tf . concat ( [ O00o , * OooO000O0 ] , axis = - 1 ) , [ O00o . shape [ 0 ] , O00o . shape [ 1 ] , O00o . shape [ 2 ] * self . convStride [ 1 ] , O00o . shape [ 3 ] ] )
        if self . convStride [ 0 ] > 1 :
         IIi1ii = [ np . zeros ( O00o . shape for x in range ( 0 , self . convStride [ 0 ] - 1 ) ) ]
         O00o = tf . reshape ( tf . concat ( [ O00o , * OooO000O0 ] , axis = - 2 ) , [ O00o . shape [ 0 ] , O00o . shape [ 1 ] * self . convStride [ 0 ] , O00o . shape [ 2 ] , O00o . shape [ 3 ] ] )
         if 34 - 34: I1Ii1I1 . oOO + I11iiIi11i1I
       elif ( self . convStride [ 1 ] > 1 ) or ( self . convStride [ 0 ] > 1 ) :
        if 47 - 47: Iii1i . I11iiIi11i1I % IiI11Ii111
        oOoO0OoO = Oo0Oooo0OOOO . getTFResizeMethod ( self . dconvUpscale )
        i1Iiiiii1ii1 = tf . image . ResizeMethod . BICUBIC if oOoO0OoO == "BICUBIC" else tf . image . ResizeMethod . BILINEAR if oOoO0OoO == "BILINEAR" else tf . image . ResizeMethod . NEAREST_NEIGHBOR
        O00o = tf . image . resize ( O00o , ( O00o . shape [ 1 ] * self . convStride [ 0 ] , O00o . shape [ 2 ] * self . convStride [ 1 ] ) , i1Iiiiii1ii1 )
        if 20 - 20: iI1iII1I1I1i . Iii1i . iI1iII1I1I1i % oOO + i1 + i1i1i1111I
        if 44 - 44: IiI11Ii111 * oOo0O00 - ooo000 * Iii1i * oOO
       O00o = tf . image . pad_to_bounding_box ( O00o , int ( ( OOooOoo0 + OoOoo - II11i11 [ 1 ] ) / 2 ) , int ( ( Oo0o0Oooo00O0 + OoOoo - II11i11 [ 2 ] ) / 2 ) , OOooOoo0 + OoOoo , Oo0o0Oooo00O0 + OoOoo )
       if 96 - 96: OooOoo * ooOOO + IIiIIiIi11I1 - IIiIIiIi11I1
     with tf . device ( self . train . device ) :
      if 43 - 43: oOO % Oo
      O0oO000OOoooo0OO = tf . nn . conv2d ( O00o , oOoO0O0o000 , [ 1 , 1 , 1 , 1 ] , padding = 'SAME' , dilations = [ 1 , self . convDilation , self . convDilation , 1 ] )
      O0oO000OOoooo0OO = tf . nn . bias_add ( O0oO000OOoooo0OO , ii1iII11iI1I )
      if 96 - 96: oOO - IiIIii11Ii / OooOoo / ooOOO
      if 61 - 61: Oo . Oo . OooOoo - IiI11Ii111 . I11iiIi11i1I
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 73 - 73: oOo0O00 + i1I - i1i1i1111I / Ooo0Ooo
    if 72 - 72: IiIIii11Ii . i1i1i1111I * oOo0O00 - Oo % IiI11Ii111 * Iii1i
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 64 - 64: ooOOO
   self . _built = True
   if 36 - 36: IiI11Ii111 . ooo000 * oOo0O00
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 74 - 74: Iii1i / ooo000
 @ staticmethod
 def getTFResizeMethod ( upscaleType : 'ModelNode.Layer.Deconvolution.UpscaleTypes' ) -> str :
  if 89 - 89: IiI11Ii111 . Oo . ooOOO - I11iiIi11i1I
  if 38 - 38: I1Ii1I1 + ooOOO
  if 53 - 53: IiI11Ii111 . Ii / oOo0O00 - IIiIIiIi11I1
  if 26 - 26: Iii1i % IIiIIiIi11I1 % I1I + oOO + i1I * oOO
  if 27 - 27: ooOOO * I1I
  if 43 - 43: IiIIii11Ii % i1 . i1 / Ooo0Ooo . IiI11Ii111 * IiIIii11Ii
  if 35 - 35: i1 / I1Ii1I1
  if 36 - 36: i1 % IiIIii11Ii + Ooo0Ooo . IiI11Ii111
  if 64 - 64: I1I % IIiIIiIi11I1 * IIiIIiIi11I1 - Ii / oOo0O00
  if 30 - 30: Oo - I11iiIi11i1I % ooOOO % iI1iII1I1I1i / Oo
  if 95 - 95: IiI11Ii111 * i1iiIII111 - oOo0O00 - IiIIii11Ii
  if 47 - 47: IiI11Ii111 / I11iiIi11i1I / Iii1i + ooOOO / Ooo0Ooo - IiI11Ii111
  if 52 - 52: IiIIii11Ii * ooOOO * oOo0O00
  I1111IiI = { 0 : "BICUBIC" , 1 : "BINEAR" , 2 : "NEAREST_NEIGHBOR" , 3 : "AREA" }
  if upscaleType . value not in I1111IiI :
   raise ValueError ( "Resize method not supported." )
  return I1111IiI [ upscaleType . value ]
  if 28 - 28: I1I % ooo000
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 75 - 75: oOO . Iii1i
  if 10 - 10: oOO
  if 63 - 63: I1I . i1I
  if 70 - 70: Iii1i / Ii / Iii1i * Ooo0Ooo + i1iiIII111 * iI1iII1I1I1i
  if 22 - 22: oOO / Oo - Ii - oOO . i1i1i1111I - i1I
  if 14 - 14: Ooo0Ooo * ooOOO
  if 8 - 8: i1I - oOO + IiIIii11Ii . i1i1i1111I * oOo0O00 % Ii
  if 38 - 38: IIiIIiIi11I1 - IiIIii11Ii / i1 . I11iiIi11i1I . oOo0O00 % i1I
  if 59 - 59: ooo000 . I1Ii1I1 / I1Ii1I1
  if 68 - 68: Ooo0Ooo + i1 / Ooo0Ooo
  if 53 - 53: I1Ii1I1 . i1iiIII111 / i1i1i1111I / i1I - OooOoo * Oo
  if 16 - 16: oOO / i1i1i1111I % Iii1i / i1iiIII111 * i1i1i1111I
  if 3 - 3: i1i1i1111I - IiI11Ii111
  if 3 - 3: I11iiIi11i1I * ooOOO . iI1iII1I1I1i
  if 81 - 81: Ii - i1iiIII111 * OooOoo - I1I / Ii
  if self . convPadding :
   O00OO00O0Oo = inputshape [ 1 ] * self . convStride [ 0 ]
   OO0o0O = inputshape [ 2 ] * self . convStride [ 1 ]
  else :
   if 34 - 34: IIiIIiIi11I1 / i1 / Iii1i / Ii
   OO0 = max ( [ self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 ) - self . convStride [ 0 ] , 0 ] )
   ii1IOOo0o00oOO = max ( [ self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 ) - self . convStride [ 1 ] , 0 ] )
   O00OO00O0Oo = inputshape [ 1 ] * self . convStride [ 0 ] + OO0
   OO0o0O = inputshape [ 2 ] * self . convStride [ 1 ] + ii1IOOo0o00oOO
  II = [ None , O00OO00O0Oo , OO0o0O , self . layerUnits ]
  if 29 - 29: ooOOO . Oo - ooo000 - i1 / I1Ii1I1 + IiIIii11Ii
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  ii1 = ( 'SAME' if self . convPadding else 'VALID' )
  if 68 - 68: i1I . Iii1i + Oo . OooOoo . IiIIii11Ii % OooOoo
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  if 45 - 45: i1 - Ii - Ii - ooOOO
  if 99 - 99: IIiIIiIi11I1 / iI1iII1I1I1i / IiIIii11Ii * ooOOO . IiIIii11Ii / i1
  if 42 - 42: ooOOO * I1Ii1I1 - OooOoo
  if 20 - 20: oOo0O00 % ooo000 - Ii - IiI11Ii111 . oOo0O00 - i1I
  if 1 - 1: OooOoo . Oo - i1 % oOO + Oo
  if 48 - 48: oOo0O00
  if 13 - 13: IiI11Ii111 + Ii + oOo0O00 . IiI11Ii111 % ooo000
  O0OOO0O0OO000 = self . get_initiallizer ( )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  OoOO , OoooOO0 = [ ] , [ ]
  oO00oOooO0O = 'self.%s = tf.keras.layers.Conv2DTranspose(%d,[%d,%d], strides=(%d,%d), dilation_rate=(%d,%d), padding=\'%s\', activation=%s, kernel_initializer=%s, bias_initializer=%s, kernel_regularizer=%s, bias_regularizer=%s)' % ( self . name , self . layerUnits , self . convFilterWidth , self . convFilterWidth ,
  # I11iiIi11i1I . OooOoo
 self . convStride [ 0 ] , self . convStride [ 1 ] , self . convDilation , self . convDilation , ii1 , I11i1I11IiII , O0OOO0O0OO000 , OOOoooO , i1IiiIi1iIiIIi , ooiiii1IiIi )
  OoOO . append ( oO00oOooO0O )
  if self . refLayerName is not None :
   self . refLayerName = self . refLayerName . replace ( ' ' , '' )
   inputshape = [ str ( x ) for x in inputshape ]
   OoOO . append ( 'self.%s.build((' % self . name + ',' . join ( inputshape ) + '))' )
   OoOO . append ( 'self.%s.kernel = None' % self . name )
   if 39 - 39: IiI11Ii111
   if self . refLayerTranspose :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
   else :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 71 - 71: iI1iII1I1I1i + I11iiIi11i1I - I1I - Oo + i1 * iI1iII1I1I1i
  if self . dropout < 100 :
   i1oOo0oO0 = ( 100 - self . dropout ) / 100
   OoOO . append ( 'self.%s_dp = tf.keras.layers.Dropout(%g)' % ( self . name , i1oOo0oO0 ) )
   OoooOO0 . append ( '%s = self.%s_dp(%s)' % ( I1111iiI , self . name , I1111iiI ) )
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   if 9 - 9: iI1iII1I1I1i - i1I + I11iiIi11i1I - IiIIii11Ii % I1I
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 96 - 96: I1Ii1I1 + oOO + i1 + i1iiIII111 + IiI11Ii111 * i1I
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 44 - 44: i1iiIII111
  if 35 - 35: oOo0O00
  if 32 - 32: oOo0O00 . oOO / OooOoo - oOo0O00
  if 31 - 31: oOO
  if 66 - 66: ooo000 % Ii * Ooo0Ooo
  if 34 - 34: oOo0O00 . OooOoo + Ii + ooo000 % I1I % i1
  if 100 - 100: IIiIIiIi11I1 + Ii % i1iiIII111 . IiIIii11Ii
  if 3 - 3: Iii1i % I1I - i1iiIII111 % oOo0O00 % i1iiIII111
  if 35 - 35: i1iiIII111 . I1Ii1I1 * IiI11Ii111
  if 50 - 50: IIiIIiIi11I1 / ooOOO . IIiIIiIi11I1
  if 53 - 53: Ii % oOO % ooo000 + i1 % Ii + IiIIii11Ii
  if 13 - 13: ooOOO / Iii1i + iI1iII1I1I1i / IiIIii11Ii + ooOOO
  if 82 - 82: Ii * ooOOO . i1I / i1iiIII111
  if 3 - 3: I1I * Ooo0Ooo
  if 74 - 74: oOO - i1
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if len ( input_shape ) != 4 :
   if self . reshape == None :
    if len ( input_shape ) > 4 :
     iiI1i11Ii11I1 = 3
     II = input_shape [ 0 : iiI1i11Ii11I1 ]
     II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) == 3 :
     II = input_shape . copy ( )
     II . append ( 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) == 2 :
     oooo = input_shape [ - 1 ]
     O00o00 = 1
     OOo00oo0 = 1
     for IIIi1iii1Ii in range ( 2 , math . floor ( oooo ** .5 ) + 1 ) :
      if oooo % IIIi1iii1Ii == 0 :
       O00o00 = IIIi1iii1Ii
       OOo00oo0 = oooo // IIIi1iii1Ii
     II = [ None , O00o00 , OOo00oo0 , 1 ]
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "One dimension data is not supported." )
   else :
    OoO0oOOo = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ 1 : ] , 1 )
    OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , self . reshape , 1 )
    II = [ input_shape [ 0 ] ]
    II . extend ( self . reshape )
    if OoO0oOOo != OOo00oOOO :
     raise ValueError ( "Unable to reshape to specified shape." )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in list ( self . reshape ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 82 - 82: Ooo0Ooo / i1 / I1I
class i1i ( oO00ooO00oOO0 ) :
 if 88 - 88: Ii
 if 72 - 72: Oo
 if 88 - 88: I1I
 if 70 - 70: I1I - oOO * Ii . iI1iII1I1I1i
 if 95 - 95: IiI11Ii111 % Oo % ooo000 % oOO
 if 100 - 100: Ooo0Ooo . Ooo0Ooo - I11iiIi11i1I % oOo0O00
 if 26 - 26: Ooo0Ooo . i1iiIII111
 def __init__ ( self , name : str = None , layerUnits : int = 30 , convFilterWidth : int = 3 , convPadding : bool = True , convStride : Tuple [ int , int ] = [ 1 , 1 ] , convDilation : int = 1 , reshape : List [ int ] = None , refLayerName : str = None , refLayerTranspose : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 5e-2 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0 , biasInitial = 0.001 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict = { } ,
 batchNorm : bool = True , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 buildNo = 0 , weightDecayRate = 0 , weightStdDev = 5e-2 , biasInitial = 0.001 , weightL2Loss = True , weightAvg = 0 , weightL1Loss = False ) :
  if 5 - 5: I1I % oOO / I1Ii1I1 . OooOoo - oOo0O00
  if 78 - 78: Oo . Ii + oOo0O00 + IiI11Ii111 / ooOOO / ooo000
  if 80 - 80: I11iiIi11i1I % IIiIIiIi11I1 + i1 * oOo0O00 % i1
  if 76 - 76: IIiIIiIi11I1 / IiIIii11Ii / I11iiIi11i1I
  if 2 - 2: i1iiIII111
  if 99 - 99: IiIIii11Ii * I11iiIi11i1I
  if 37 - 37: OooOoo - Ii . I1Ii1I1 / Ii / I1Ii1I1
  if 2 - 2: IiI11Ii111
  if 18 - 18: oOO * Ii - IIiIIiIi11I1 . i1
  if 65 - 65: IiIIii11Ii + IiIIii11Ii + Ii
  if 45 - 45: oOO
  if 12 - 12: ooo000 - oOo0O00 . ooo000 / OooOoo - oOo0O00 + i1
  if 53 - 53: Iii1i - i1i1i1111I + Iii1i . I11iiIi11i1I
  if 6 - 6: I1Ii1I1
  if 83 - 83: IiI11Ii111 + I1I . i1I + IIiIIiIi11I1
  if 34 - 34: IiIIii11Ii % ooOOO - IiIIii11Ii / IIiIIiIi11I1 / i1iiIII111
  if 96 - 96: iI1iII1I1I1i . IIiIIiIi11I1
  if 97 - 97: Iii1i . i1 + I1Ii1I1 - Ooo0Ooo + IiIIii11Ii
  if 50 - 50: IIiIIiIi11I1 / I1I
  if 33 - 33: oOO + oOO
  if 78 - 78: IiI11Ii111
  if 8 - 8: Iii1i
  if 4 - 4: I1Ii1I1 + Iii1i
  if 10 - 10: iI1iII1I1I1i - ooo000
  if 4 - 4: OooOoo - i1I + IIiIIiIi11I1 + oOO
  if 61 - 61: Oo + OooOoo . I11iiIi11i1I
  if 40 - 40: I1Ii1I1 + IIiIIiIi11I1 . I1Ii1I1 * ooOOO - OooOoo
  if 10 - 10: ooOOO % oOo0O00 . oOO - i1I * i1i1i1111I * I1I
  if 56 - 56: Ooo0Ooo . Ooo0Ooo . oOo0O00 % i1I
  if 86 - 86: i1I * i1i1i1111I % OooOoo * i1 - I11iiIi11i1I
  if 89 - 89: IiI11Ii111 - oOo0O00
  if 12 - 12: IiIIii11Ii + i1I . iI1iII1I1I1i
  if linearTransform is None and any ( [ param is not None for param in [ weightAvg , weightStdDev , weightL1Loss , weightL2Loss , weightDecayRate , biasInitial ] ] ) :
   linearTransform = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = weightAvg , weightStdDev = weightStdDev ,
 weightL1Loss = weightL1Loss , weightL2Loss = weightL2Loss , weightL2Decay = weightDecayRate , biasInitial = biasInitial )
  super ( ) . __init__ ( o00OoOo0O0O00 . Convolution , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , outputConfig = outputConfig )
  self . convFilterWidth = convFilterWidth
  self . convPadding = convPadding
  self . convStride = convStride
  self . convDilation = convDilation
  self . reshape = reshape
  self . refLayerName = refLayerName
  self . refLayerTranspose = refLayerTranspose
  if 31 - 31: Ii / IiI11Ii111
 def _copySymmetricLayerConfig ( self , useSymmetricWeights = True , buildNo : int = 0 ) -> 'ModelNode.Layer.Deconvolution' :
  if 67 - 67: i1 . I1Ii1I1 % ooOOO * I1Ii1I1
  if 76 - 76: OooOoo + Ii - IiI11Ii111 + i1 - ooOOO
  if 40 - 40: I1I - oOo0O00 * ooo000
  if 34 - 34: i1I + i1iiIII111 - Oo % i1
  if 13 - 13: Iii1i
  if 10 - 10: I1Ii1I1 / i1i1i1111I * I11iiIi11i1I
  if 12 - 12: IiIIii11Ii % oOO % i1i1i1111I
  if 21 - 21: oOO - I11iiIi11i1I
  if 53 - 53: I11iiIi11i1I . oOO * i1 / OooOoo
  if 31 - 31: i1i1i1111I . i1I / i1iiIII111
  if 91 - 91: i1iiIII111 / ooOOO
  if 74 - 74: IiIIii11Ii + Iii1i - i1i1i1111I / ooo000 - Oo % Ii
  if 12 - 12: I1Ii1I1 / IIiIIiIi11I1 + IIiIIiIi11I1 . Ii / Oo % oOo0O00
  if 11 - 11: i1 / IiIIii11Ii - iI1iII1I1I1i
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 36 - 36: ooOOO + Oo + i1 - I1I * i1i1i1111I . Ooo0Ooo
  return Oo0Oooo0OOOO ( name = ( self . name + "_Sym" ) , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride ,
 convDilation = self . convDilation , refLayerName = self . name if useSymmetricWeights else None , refLayerTranspose = True ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 44 - 44: I11iiIi11i1I + ooo000 - iI1iII1I1I1i + i1i1i1111I % i1I + i1i1i1111I
 def copy ( self , name : str ) -> 'ModelNode.Layer.Convolution' :
  if 54 - 54: i1iiIII111 + i1i1i1111I * OooOoo - oOO
  if 50 - 50: i1i1i1111I / Ooo0Ooo / Ii
  if 15 - 15: oOo0O00 . I1Ii1I1 - OooOoo / IiI11Ii111
  if 89 - 89: I1I + i1I . ooo000
  if 91 - 91: ooo000 . oOo0O00 + Oo
  if 71 - 71: i1iiIII111 . Iii1i + I11iiIi11i1I . i1 + Iii1i % IiI11Ii111
  if 35 - 35: iI1iII1I1I1i . IiI11Ii111
  if 51 - 51: IiI11Ii111 . Ii % IiI11Ii111 * i1I - i1I % Ooo0Ooo
  if 43 - 43: i1i1i1111I % Oo / oOO . Iii1i - I11iiIi11i1I * iI1iII1I1I1i
  if 67 - 67: i1iiIII111 . ooOOO - i1I * Oo * IIiIIiIi11I1 - i1i1i1111I
  if 55 - 55: IIiIIiIi11I1 - i1I . I11iiIi11i1I
  if 56 - 56: oOO - i1iiIII111 % Ooo0Ooo . oOO
  if 23 - 23: I1I
  if 72 - 72: I11iiIi11i1I / iI1iII1I1I1i + IiI11Ii111
  if not isinstance ( self , i1i ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 39 - 39: i1i1i1111I
   if 44 - 44: i1i1i1111I * IiIIii11Ii * Iii1i
  return i1i ( name = name , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride ,
 convDilation = self . convDilation , reshape = self . reshape , refLayerName = self . refLayerName , refLayerTranspose = self . refLayerTranspose ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 52 - 52: oOO % i1i1i1111I + oOO . i1i1i1111I % i1i1i1111I
 def _build ( self , buildNo : int ) :
  if 49 - 49: oOO - I1I - I11iiIi11i1I + oOO . Oo + ooOOO
  if 79 - 79: iI1iII1I1I1i - iI1iII1I1I1i + Oo * ooo000
  if 74 - 74: Iii1i + I1I / Oo
  if 26 - 26: I1Ii1I1 + ooo000 * I1I % ooo000 % IiI11Ii111 % IiIIii11Ii
  if 60 - 60: i1
  if 82 - 82: IiIIii11Ii % Iii1i - Oo . oOO - IiIIii11Ii + i1i1i1111I
  if 81 - 81: ooOOO / Ii
  if 23 - 23: iI1iII1I1I1i % oOO
  if 79 - 79: Ii / oOO / oOo0O00 . iI1iII1I1I1i * Ii - ooOOO
  if 1 - 1: I1Ii1I1 - Ooo0Ooo * i1I / OooOoo / IiIIii11Ii
  self . _clearTempTensors ( )
  if 100 - 100: IiIIii11Ii * iI1iII1I1I1i / I1Ii1I1 - Iii1i . i1I
  if 71 - 71: I1Ii1I1 / iI1iII1I1I1i * OooOoo
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 57 - 57: Ooo0Ooo . ooo000
   if self . refLayerName is not None :
    ooo00ooOoo0O = self . train . modelNodes [ self . refLayerName ]
    with tf . compat . v1 . variable_scope ( self . refLayerName , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     oOoO0O0o000 = i11i111iI . getFromGraph ( "weight" )
     if 60 - 60: i1I + Iii1i * IiIIii11Ii
    if self . refLayerTranspose :
     with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
      oOoO0O0o000 = tf . transpose ( oOoO0O0o000 , [ 0 , 1 , 3 , 2 ] )
      if 74 - 74: Iii1i / iI1iII1I1I1i / i1 + IIiIIiIi11I1
      if 100 - 100: Ii + I11iiIi11i1I % I1I
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 1 - 1: oOO - i1I / I11iiIi11i1I + iI1iII1I1I1i . ooOOO . i1I
    O00o = self . _combineIncomingTensors ( buildNo = buildNo )
    II11i11 = [ * O00o . shape ]
    if 89 - 89: OooOoo - oOo0O00 % iI1iII1I1I1i / IiI11Ii111
    if 98 - 98: i1I
    if len ( II11i11 ) != 4 :
     II111 = self . reshape
     if II111 is None :
      if 100 - 100: Ii
      if len ( II11i11 ) > 4 :
       I11II = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ 3 : ] , 1 )
       O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape [ : 3 ] ) , I11II ] )
       II11i11 = [ * O00o . shape ]
       if 35 - 35: Iii1i / I11iiIi11i1I / oOO % I1Ii1I1
       if 28 - 28: i1I - Iii1i - iI1iII1I1I1i % Ii - i1i1i1111I
      elif len ( II11i11 ) == 3 :
       O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape ) , 1 ] )
       II11i11 = [ * O00o . shape ]
       if 41 - 41: oOo0O00 / I1Ii1I1 * oOo0O00 + i1i1i1111I / OooOoo . IiI11Ii111
       if 74 - 74: Oo / Iii1i
      elif len ( II11i11 ) == 2 :
       oooo = O00o . shape [ - 1 ]
       O00o00 = 1
       OOo00oo0 = 1
       for IIIi1iii1Ii in range ( 2 , math . floor ( oooo ** .5 ) + 1 ) :
        if oooo % IIIi1iii1Ii == 0 :
         O00o00 = IIIi1iii1Ii
         OOo00oo0 = oooo // IIIi1iii1Ii
       if O00o00 > 1 :
        O00o = tf . reshape ( O00o , [ - 1 , O00o00 , OOo00oo0 , 1 ] )
        II11i11 = [ * O00o . shape ]
       else :
        raise ValueError ( "Unable to reshape before Convolutional Layer can be applied." )
        if 28 - 28: ooOOO - Ii . I1Ii1I1 % i1iiIII111
      elif len ( II11i11 ) == 1 :
       raise ValueError ( "One dimension data is not supported for convolutional layers." )
     else :
      if 100 - 100: ooOOO * IIiIIiIi11I1 / i1I . I1I % I11iiIi11i1I . Oo
      OoO0oOOo = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , [ s for s in II11i11 [ 1 : ] ] , 1 )
      OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , II111 , 1 )
      if OoO0oOOo != OOo00oOOO :
       raise ValueError ( "Unable to reshape to specified shape." )
      elif len ( II111 ) != 3 :
       raise ValueError ( "The convolutional shape should be in 3 dimensions." )
       if 70 - 70: i1
       if 100 - 100: Iii1i / Oo - oOo0O00
      O00o = tf . reshape ( O00o , [ - 1 , * II111 ] )
      II11i11 = [ * O00o . shape ]
      if 70 - 70: I1I * i1iiIII111 . oOo0O00 * Iii1i + oOO
      if 17 - 17: IiIIii11Ii * IiI11Ii111 * ooo000 % I11iiIi11i1I
    iiII = self . linearTransform
    if self . refLayerName is None :
     oOoO0O0o000 = iiII . weightConfig . create ( "weight" , [ self . convFilterWidth , self . convFilterWidth , II11i11 [ - 1 ] , self . layerUnits ] , dtype = O00o . dtype , defaultDevice = self . train . device )
    ii1iII11iI1I = iiII . biasConfig . create ( "biases" , [ self . layerUnits ] , dtype = O00o . dtype , defaultDevice = self . train . device )
    self . _weights . extend ( [ oOoO0O0o000 , ii1iII11iI1I ] )
    if 48 - 48: IiI11Ii111 . ooOOO - oOO % oOo0O00 * Ooo0Ooo
    with tf . device ( self . train . device ) :
     O0oO000OOoooo0OO = tf . nn . conv2d ( O00o , oOoO0O0o000 , [ 1 , * self . convStride , 1 ] , padding = ( 'SAME' if self . convPadding else 'VALID' ) , dilations = [ 1 , self . convDilation , self . convDilation , 1 ] )
     O0oO000OOoooo0OO = tf . nn . bias_add ( O0oO000OOoooo0OO , ii1iII11iI1I )
     if 84 - 84: oOO + I1Ii1I1 / I1Ii1I1 / oOO
     if 52 - 52: i1iiIII111 / oOo0O00 . Ooo0Ooo
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 36 - 36: IIiIIiIi11I1 . OooOoo + IiIIii11Ii - oOO
    if 70 - 70: Ooo0Ooo . i1i1i1111I - OooOoo
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 35 - 35: i1i1i1111I . Ooo0Ooo . Ii
   self . _built = True
   if 13 - 13: ooOOO * Oo
   if 71 - 71: Oo
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 89 - 89: iI1iII1I1I1i . I1Ii1I1 - Oo * Iii1i
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 75 - 75: I1Ii1I1 % I1Ii1I1 - ooo000 . oOO
  if 35 - 35: Iii1i / Ii / I1I - i1i1i1111I
  if 40 - 40: Ii
  if 76 - 76: ooOOO + I1I
  if 24 - 24: oOo0O00 + IiIIii11Ii . I11iiIi11i1I - ooo000 * oOo0O00
  if 19 - 19: Oo - IIiIIiIi11I1 * ooOOO / OooOoo - IIiIIiIi11I1
  if 87 - 87: I11iiIi11i1I . oOO
  if 73 - 73: Ooo0Ooo . oOo0O00 . ooo000 + OooOoo
  if 3 - 3: oOo0O00 - oOo0O00
  if 94 - 94: i1i1i1111I - IiI11Ii111 % i1i1i1111I
  if 86 - 86: IIiIIiIi11I1 * oOo0O00 / OooOoo * i1i1i1111I
  if 33 - 33: Oo . ooOOO
  if 4 - 4: oOO * i1 . ooo000 - oOo0O00
  if 77 - 77: Iii1i % IIiIIiIi11I1
  if 8 - 8: i1 % i1I
  def oo0o0OoOO ( L , S , K , P ) :
   return int ( ( ( L - K + 2 * P ) / S + 1 ) )
   if 8 - 8: oOo0O00 * i1I * OooOoo / OooOoo
  if self . convPadding == 'SAME' :
   I11i1I1I11 = ( self . convFilterWidth - 1 ) / 2
  else :
   I11i1I1I11 = 0
  Ii1I = self . convFilterWidth + ( self . convFilterWidth - 1 ) * ( self . convDilation - 1 )
  O00OO00O0Oo = oo0o0OoOO ( inputshape [ 1 ] , self . convStride [ 0 ] , Ii1I , I11i1I1I11 )
  OO0o0O = oo0o0OoOO ( inputshape [ 2 ] , self . convStride [ 1 ] , Ii1I , I11i1I1I11 )
  II = [ None , O00OO00O0Oo , OO0o0O , self . layerUnits ]
  if self . convDilation < 1 :
   self . convDilation = 1
  else :
   self . convDilation = int ( self . convDilation )
   if 41 - 41: Oo - oOo0O00 - Iii1i . I11iiIi11i1I + i1I * IiIIii11Ii
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  ii1 = ( 'SAME' if self . convPadding else 'VALID' )
  if 21 - 21: ooOOO . ooOOO / IiIIii11Ii
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  O0OOO0O0OO000 = self . get_initiallizer ( )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  OoOO , OoooOO0 = [ ] , [ ]
  oO00oOooO0O = 'self.%s = tf.keras.layers.Conv2D(%d,[%d,%d], strides=(%d,%d), dilation_rate=(%d,%d), padding=\'%s\', activation=%s, kernel_initializer=%s, bias_initializer=%s, kernel_regularizer=%s, bias_regularizer=%s)' % ( self . name , self . layerUnits , self . convFilterWidth , self . convFilterWidth ,
  # Ooo0Ooo + I1I - IIiIIiIi11I1 % i1i1i1111I
 self . convStride [ 0 ] , self . convStride [ 1 ] , self . convDilation , self . convDilation , ii1 , I11i1I11IiII , O0OOO0O0OO000 , OOOoooO , i1IiiIi1iIiIIi , ooiiii1IiIi )
  OoOO . append ( oO00oOooO0O )
  if self . refLayerName is not None :
   inputshape = [ str ( x ) for x in inputshape ]
   self . refLayerName = self . refLayerName . replace ( ' ' , '' )
   OoOO . append ( 'self.%s.build((' % self . name + ',' . join ( inputshape ) + '))' )
   OoOO . append ( 'self.%s.kernel = None' % self . name )
   if 65 - 65: i1i1i1111I
   if self . refLayerTranspose :
    OoooOO0 . append ( 'self.%s.kernel = tf.transpose(self.%s.kernel, perm=[0,1,3,2])' % ( self . name , self . refLayerName ) )
   else :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 18 - 18: ooo000 . i1 / IIiIIiIi11I1 + i1I + IIiIIiIi11I1 % IiI11Ii111
  if self . dropout < 100 :
   i1oOo0oO0 = ( 100 - self . dropout ) / 100
   OoOO . append ( 'self.%s_dp = tf.keras.layers.Dropout(%g)' % ( self . name , i1oOo0oO0 ) )
   OoooOO0 . append ( '%s = self.%s_dp(%s)' % ( I1111iiI , self . name , I1111iiI ) )
   if 35 - 35: i1iiIII111 - iI1iII1I1I1i - Ooo0Ooo + ooo000 + Ooo0Ooo
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 64 - 64: iI1iII1I1I1i - i1I + i1i1i1111I * i1
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 39 - 39: Oo % i1I - ooOOO * I1I . oOo0O00 / OooOoo
  if 21 - 21: Ooo0Ooo
  if 90 - 90: IiIIii11Ii * OooOoo / oOo0O00
  if 93 - 93: OooOoo * oOo0O00 . ooo000
  if 13 - 13: Iii1i
  if 37 - 37: I1I % IiI11Ii111 + Ii . I11iiIi11i1I + Oo
  if 98 - 98: I1I % IiIIii11Ii - oOo0O00 . i1I - Ii
  if 42 - 42: i1i1i1111I * i1 % Ooo0Ooo - I1I + IiI11Ii111
  if 59 - 59: Ii . iI1iII1I1I1i + I1I % i1i1i1111I + Iii1i
  if 70 - 70: IIiIIiIi11I1
  if 46 - 46: i1I
  if 43 - 43: I1I
  if 42 - 42: Oo + Ooo0Ooo / ooOOO
  if 5 - 5: IiI11Ii111 * oOo0O00
  if 23 - 23: Ii / oOO * i1I + Iii1i + Oo / OooOoo
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if len ( input_shape ) != 4 :
   if self . reshape == None :
    if len ( input_shape ) > 4 :
     iiI1i11Ii11I1 = 3
     II = input_shape [ 0 : iiI1i11Ii11I1 ]
     II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) == 3 :
     II = input_shape . copy ( )
     II . append ( 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) == 2 :
     oooo = input_shape [ - 1 ]
     O00o00 = 1
     OOo00oo0 = 1
     for IIIi1iii1Ii in range ( 2 , math . floor ( oooo ** .5 ) + 1 ) :
      if oooo % IIIi1iii1Ii == 0 :
       O00o00 = IIIi1iii1Ii
       OOo00oo0 = oooo // IIIi1iii1Ii
     II = [ None , O00o00 , OOo00oo0 , 1 ]
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "One dimension data is not supported." )
   else :
    OoO0oOOo = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ 1 : ] , 1 )
    OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , self . reshape , 1 )
    if OoO0oOOo != OOo00oOOO :
     raise ValueError ( "Unable to reshape to specified shape." )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in list ( self . reshape ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 97 - 97: IiIIii11Ii . i1I + i1I + IiIIii11Ii % I1Ii1I1 % ooOOO
class IIIOOoo0 ( oO00ooO00oOO0 ) :
 if 12 - 12: IIiIIiIi11I1
 if 99 - 99: I1I
 if 17 - 17: i1 . IiIIii11Ii / oOO / ooo000 / i1i1i1111I
 if 37 - 37: IiI11Ii111 * IIiIIiIi11I1 . i1I
 if 20 - 20: Ooo0Ooo
 if 44 - 44: oOo0O00
 if 70 - 70: i1i1i1111I
 def __init__ ( self , name : str = None , layerUnits : int = 30 , convFilterWidth : int = 3 , convPadding : bool = True , convStride : int = 1 , convDilation : int = 1 , reshape : List [ int ] = None , refLayerName : str = None , refLayerTranspose : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 5e-2 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0 , biasInitial = 0.001 ) ,
 activation : str = "relu" , activationParams : Dict = { } ,
 batchNorm : bool = True , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 buildNo = 0 , weightDecayRate = 0 , weightStdDev = 5e-2 , biasInitial = 0.001 , weightL2Loss = True , weightAvg = 0 , weightL1Loss = False ) :
  if 13 - 13: oOO - I1Ii1I1 - ooo000
  if 15 - 15: IIiIIiIi11I1
  if 31 - 31: I1Ii1I1 . IiIIii11Ii . oOO / ooOOO
  if 45 - 45: I1I
  if 47 - 47: i1I * ooo000 % iI1iII1I1I1i
  if 29 - 29: I1I
  if 86 - 86: OooOoo
  if 16 - 16: I1Ii1I1 . oOo0O00
  if 26 - 26: ooo000 * ooo000 - OooOoo
  if 78 - 78: I1I
  if 89 - 89: i1i1i1111I / i1 + ooOOO % ooOOO
  if 2 - 2: i1i1i1111I . Ooo0Ooo + Oo * OooOoo
  if 2 - 2: oOO * IiI11Ii111 + oOO
  if 37 - 37: IiIIii11Ii - IiI11Ii111 / I1I
  if 55 - 55: Iii1i
  if 62 - 62: Oo % I1I / IiIIii11Ii
  if 31 - 31: i1 * Ooo0Ooo
  if 80 - 80: iI1iII1I1I1i . Oo + I11iiIi11i1I
  if 4 - 4: iI1iII1I1I1i . IiIIii11Ii * IiIIii11Ii - OooOoo % i1iiIII111 + ooOOO
  if 66 - 66: I11iiIi11i1I / oOO - ooo000 * OooOoo . i1iiIII111 / I11iiIi11i1I
  if 63 - 63: i1iiIII111 . IIiIIiIi11I1 . Ii / IiI11Ii111 * Ii
  if 62 - 62: ooOOO % I11iiIi11i1I
  if 41 - 41: ooo000 / ooo000 - I1I - Oo
  if 28 - 28: ooo000 * I1Ii1I1 * I11iiIi11i1I * i1 - I1I
  if 70 - 70: i1iiIII111 - IIiIIiIi11I1 + Oo . i1i1i1111I * I1Ii1I1
  if 11 - 11: IiIIii11Ii / I1I % IiI11Ii111
  if 30 - 30: I1Ii1I1 + I1Ii1I1 - OooOoo % I11iiIi11i1I % Oo
  if 99 - 99: IiIIii11Ii - IiI11Ii111 * ooo000
  if 2 - 2: I1Ii1I1 . iI1iII1I1I1i % oOo0O00
  if 40 - 40: Iii1i - ooOOO - i1i1i1111I % I1I
  if 31 - 31: I11iiIi11i1I - IiI11Ii111 / i1I
  if 20 - 20: oOo0O00 * i1 / i1iiIII111
  super ( ) . __init__ ( o00OoOo0O0O00 . Convolution1D , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , outputConfig = outputConfig )
  if 100 - 100: ooo000
  if 70 - 70: I1I + i1 % i1 % IiI11Ii111 * ooo000
  self . convFilterWidth = convFilterWidth
  if 4 - 4: OooOoo * I1I - OooOoo % i1
  if 80 - 80: IiI11Ii111
  self . convPadding = convPadding
  if 18 - 18: IIiIIiIi11I1 + I11iiIi11i1I * IIiIIiIi11I1 * IiIIii11Ii + ooOOO
  if 47 - 47: Iii1i * Oo / oOO * Ooo0Ooo
  self . convStride = convStride
  if 65 - 65: i1I + IIiIIiIi11I1 / IiI11Ii111 % oOo0O00
  if 67 - 67: I1Ii1I1
  self . convDilation = convDilation
  if 78 - 78: oOo0O00 - oOo0O00 + OooOoo % IIiIIiIi11I1 - i1I . IiIIii11Ii
  if 78 - 78: Oo
  self . reshape = reshape
  if 80 - 80: ooOOO % i1 . oOo0O00 - iI1iII1I1I1i + I1Ii1I1 - i1I
  if 13 - 13: oOO
  self . refLayerName = refLayerName
  if 65 - 65: Ii + Oo * ooOOO
  if 58 - 58: oOO . I1I / i1I . Oo - OooOoo - IiIIii11Ii
  self . refLayerTranspose = refLayerTranspose
  if 66 - 66: I11iiIi11i1I / ooOOO + I1Ii1I1 * Oo - I11iiIi11i1I
 def _copySymmetricLayerConfig ( self , useSymmetricWeights = True , buildNo : int = 0 ) :
  if 4 - 4: i1iiIII111 + i1i1i1111I % I1Ii1I1
  if 70 - 70: IiIIii11Ii % I1Ii1I1 . IIiIIiIi11I1 . oOo0O00 + iI1iII1I1I1i
  if 48 - 48: i1 * i1iiIII111 - I11iiIi11i1I . I1I
  if 100 - 100: oOo0O00 . Ii - I1Ii1I1 * I1I
  if 59 - 59: I1Ii1I1
  if 47 - 47: ooo000
  if 66 - 66: OooOoo . Iii1i
  if 29 - 29: Oo % IiI11Ii111 / iI1iII1I1I1i
  if 80 - 80: i1i1i1111I + Ooo0Ooo % I1Ii1I1 * ooOOO * OooOoo + ooOOO
  if 5 - 5: I11iiIi11i1I + iI1iII1I1I1i % I1Ii1I1
  if 30 - 30: i1i1i1111I % IiI11Ii111 % I11iiIi11i1I
  if 67 - 67: I1Ii1I1 + IiI11Ii111 / OooOoo
  if 79 - 79: Ii - IiIIii11Ii / i1I * oOO
  if 37 - 37: i1iiIII111 % oOo0O00 + OooOoo
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 21 - 21: i1iiIII111
  return IIIOOoo0 ( name = ( self . name + "_Sym" ) , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride ,
 convDilation = self . convDilation , refLayerName = self . name if useSymmetricWeights else None , refLayerTranspose = True ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 38 - 38: iI1iII1I1I1i % i1I / I1Ii1I1 . I11iiIi11i1I % i1I * ooo000
 def copy ( self , name : str ) :
  if 58 - 58: IiIIii11Ii / i1
  if 59 - 59: Ooo0Ooo
  if 96 - 96: I1I / Ii
  if 1 - 1: iI1iII1I1I1i . IiI11Ii111 . IiIIii11Ii * IIiIIiIi11I1 + I1I - OooOoo
  if 77 - 77: Oo * Ooo0Ooo - OooOoo
  if 10 - 10: Ooo0Ooo * IIiIIiIi11I1 * ooOOO
  if 72 - 72: I1I - oOo0O00 - Ii - Iii1i / Ooo0Ooo / ooo000
  if 32 - 32: Ii - ooo000 / I11iiIi11i1I * Oo - iI1iII1I1I1i
  if 43 - 43: Iii1i + i1 + oOO . oOO * Ooo0Ooo
  if 43 - 43: I1Ii1I1 + I11iiIi11i1I / IIiIIiIi11I1 % Oo - iI1iII1I1I1i
  if 21 - 21: Ooo0Ooo + Iii1i . oOo0O00 / i1i1i1111I
  if 1 - 1: oOO % I11iiIi11i1I / iI1iII1I1I1i
  if 4 - 4: i1i1i1111I + IIiIIiIi11I1
  if 12 - 12: ooOOO % i1I * ooOOO - Iii1i + Iii1i
  if not isinstance ( self , IIIOOoo0 ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 78 - 78: Ooo0Ooo . ooOOO + IIiIIiIi11I1 . i1i1i1111I
   if 82 - 82: i1iiIII111 * i1
  return IIIOOoo0 ( name = name , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride ,
 convDilation = self . convDilation , reshape = self . reshape , refLayerName = self . refLayerName , refLayerTranspose = self . refLayerTranspose ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 37 - 37: Oo . i1iiIII111 + i1iiIII111 * I1Ii1I1
 def _build ( self , buildNo : int ) :
  if 34 - 34: OooOoo . oOO - I1Ii1I1 * Oo . oOO + i1i1i1111I
  if 15 - 15: I11iiIi11i1I . i1
  if 77 - 77: Oo / Ooo0Ooo . IiI11Ii111
  if 42 - 42: Oo * OooOoo + I1I / i1iiIII111 + oOO . i1I
  if 55 - 55: IIiIIiIi11I1
  if 10 - 10: IIiIIiIi11I1 / ooo000 - Iii1i - oOO * ooo000 . Iii1i
  if 55 - 55: i1iiIII111
  if 92 - 92: Ooo0Ooo
  if 38 - 38: IiIIii11Ii
  if 13 - 13: oOO
  self . _clearTempTensors ( )
  if 30 - 30: ooOOO % Iii1i
  if 90 - 90: oOo0O00 . ooOOO * iI1iII1I1I1i . Iii1i % I1I + I11iiIi11i1I
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 73 - 73: i1 + Oo
   if self . refLayerName is not None :
    ooo00ooOoo0O = self . train . modelNodes [ self . refLayerName ]
    with tf . compat . v1 . variable_scope ( self . refLayerName , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     oOoO0O0o000 = i11i111iI . getFromGraph ( "weight" )
     if 59 - 59: OooOoo * oOo0O00
    if self . refLayerTranspose :
     with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
      oOoO0O0o000 = tf . transpose ( oOoO0O0o000 , [ 0 , 2 , 1 ] )
      if 56 - 56: IiIIii11Ii
      if 86 - 86: OooOoo / i1i1i1111I + i1i1i1111I
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 32 - 32: oOo0O00 . Oo % OooOoo
    O00o = self . _combineIncomingTensors ( buildNo = buildNo )
    II11i11 = [ * O00o . shape ]
    if 54 - 54: i1I % ooo000 / oOO + i1 * I1Ii1I1 + IIiIIiIi11I1
    if 31 - 31: IiI11Ii111 / I11iiIi11i1I - i1iiIII111 % Iii1i - Ooo0Ooo
    if len ( II11i11 ) != 3 :
     II111 = self . reshape
     if II111 is None :
      if 79 - 79: ooo000 + ooOOO % iI1iII1I1I1i
      if len ( II11i11 ) > 3 :
       I11II = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ 2 : ] , 1 )
       O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape [ : 2 ] ) , I11II ] )
       II11i11 = [ * O00o . shape ]
       if 7 - 7: i1i1i1111I / IiIIii11Ii % i1I - i1I * Ooo0Ooo
       if 43 - 43: I1Ii1I1 . i1 * ooOOO % IiI11Ii111 + ooOOO
      elif len ( II11i11 ) == 2 :
       O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape ) , 1 ] )
       II11i11 = [ * O00o . shape ]
       if 79 - 79: iI1iII1I1I1i . oOO
      elif len ( II11i11 ) == 1 :
       raise ValueError ( "One dimension data is not supported for convolutional layers." )
     else :
      if 40 - 40: I11iiIi11i1I - ooOOO + IiI11Ii111
      OoO0oOOo = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , [ s for s in II11i11 [ 1 : ] ] , 1 )
      OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , II111 , 1 )
      if OoO0oOOo != OOo00oOOO :
       raise ValueError ( "Unable to reshape to specified shape." )
      elif len ( II111 ) != 2 :
       raise ValueError ( "The convolutional shape should be in 2 dimensions." )
       if 84 - 84: I1Ii1I1 . Ii / IIiIIiIi11I1 - oOo0O00 . ooo000 * i1iiIII111
       if 88 - 88: OooOoo
      O00o = tf . reshape ( O00o , [ - 1 , * II111 ] )
      II11i11 = [ * O00o . shape ]
      if 72 - 72: i1i1i1111I . I11iiIi11i1I . iI1iII1I1I1i / Ooo0Ooo
      if 79 - 79: Ii
    iiII = self . linearTransform
    if self . refLayerName is None :
     oOoO0O0o000 = iiII . weightConfig . create ( "weight" , [ self . convFilterWidth , II11i11 [ - 1 ] , self . layerUnits ] , dtype = O00o . dtype , defaultDevice = self . train . device )
    ii1iII11iI1I = iiII . biasConfig . create ( "biases" , [ self . layerUnits ] , dtype = O00o . dtype , defaultDevice = self . train . device )
    self . _weights . extend ( [ oOoO0O0o000 , ii1iII11iI1I ] )
    if 66 - 66: oOO
    with tf . device ( self . train . device ) :
     O0oO000OOoooo0OO = tf . nn . conv1d ( O00o , oOoO0O0o000 , [ 1 , self . convStride , 1 ] , padding = ( 'SAME' if self . convPadding else 'VALID' ) , dilations = [ 1 , self . convDilation , 1 ] )
     O0oO000OOoooo0OO = tf . nn . bias_add ( O0oO000OOoooo0OO , ii1iII11iI1I )
     if 92 - 92: Oo % i1 * I11iiIi11i1I - Oo . Oo
     if 6 - 6: Iii1i - ooOOO % ooOOO
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 90 - 90: i1iiIII111 + OooOoo / IiIIii11Ii
    if 52 - 52: i1i1i1111I / i1i1i1111I * i1iiIII111 % i1i1i1111I
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 12 - 12: i1I
   self . _built = True
   if 35 - 35: OooOoo * IiIIii11Ii - I11iiIi11i1I
   if 82 - 82: Ooo0Ooo . i1iiIII111
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 46 - 46: oOo0O00
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 56 - 56: Iii1i * Iii1i
  if 1 - 1: oOO % I11iiIi11i1I * IIiIIiIi11I1 * Ooo0Ooo * oOo0O00
  if 96 - 96: oOo0O00
  if 31 - 31: I1Ii1I1 - I1Ii1I1 / IiIIii11Ii % i1iiIII111
  if 55 - 55: I1I * ooOOO . i1 % oOo0O00 + oOO
  if 72 - 72: Ii
  if 93 - 93: OooOoo / Ooo0Ooo - i1i1i1111I * i1I
  if 87 - 87: Ii * iI1iII1I1I1i / iI1iII1I1I1i - i1i1i1111I / Oo
  if 2 - 2: I1I + iI1iII1I1I1i
  if 85 - 85: i1 % i1iiIII111 / oOO
  if 41 - 41: IiIIii11Ii
  if 86 - 86: oOo0O00
  if 74 - 74: Iii1i . ooOOO - Ooo0Ooo
  if 61 - 61: i1I / iI1iII1I1I1i
  if 99 - 99: oOO % Oo . I11iiIi11i1I % Oo / Ii
  def oo0o0OoOO ( L , S , K , P ) :
   return int ( ( ( L - K + 2 * P ) / S + 1 ) )
  if self . convPadding == 'SAME' :
   I11i1I1I11 = ( self . convFilterWidth - 1 ) / 2
  else :
   I11i1I1I11 = 0
  Ii1I = self . convFilterWidth + ( self . convFilterWidth - 1 ) * ( self . convDilation - 1 )
  OoO00OO00000 = oo0o0OoOO ( inputshape [ 1 ] , self . convStride , Ii1I , I11i1I1I11 )
  II = [ None , OoO00OO00000 , self . layerUnits ]
  if self . convDilation < 1 :
   self . convDilation = 1
  else :
   self . convDilation = int ( self . convDilation )
   if 60 - 60: ooOOO
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  ii1 = ( 'SAME' if self . convPadding else 'VALID' )
  if 19 - 19: iI1iII1I1I1i / Ooo0Ooo - i1I
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  O0OOO0O0OO000 = self . get_initiallizer ( )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  OoOO , OoooOO0 = [ ] , [ ]
  oO00oOooO0O = 'self.%s = tf.keras.layers.Conv1D(%d, %d, strides=%d, dilation_rate=(%d), padding=\'%s\', activation=%s, kernel_initializer=%s, bias_initializer=%s, kernel_regularizer=%s, bias_regularizer=%s)' % ( self . name , self . layerUnits , self . convFilterWidth ,
  # IIiIIiIi11I1 - i1 * IiIIii11Ii / i1I + ooo000 - Iii1i
 self . convStride , self . convDilation , ii1 , I11i1I11IiII , O0OOO0O0OO000 , OOOoooO , i1IiiIi1iIiIIi , ooiiii1IiIi )
  OoOO . append ( oO00oOooO0O )
  if self . refLayerName is not None :
   inputshape = [ str ( x ) for x in inputshape ]
   self . refLayerName = self . refLayerName . replace ( ' ' , '' )
   OoOO . append ( 'self.%s.build((' % self . name + ',' . join ( inputshape ) + '))' )
   OoOO . append ( 'self.%s.kernel = None' % self . name )
   if 63 - 63: I1Ii1I1
   if self . refLayerTranspose :
    OoooOO0 . append ( 'self.%s.kernel = tf.transpose(self.%s.kernel, perm=[0,2,1])' % ( self . name , self . refLayerName ) )
   else :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 71 - 71: I1I - OooOoo - oOO / IiIIii11Ii . Oo - OooOoo
  if self . dropout < 100 :
   i1oOo0oO0 = ( 100 - self . dropout ) / 100
   OoOO . append ( 'self.%s_dp = tf.keras.layers.Dropout(%g)' % ( self . name , i1oOo0oO0 ) )
   OoooOO0 . append ( '%s = self.%s_dp(%s)' % ( I1111iiI , self . name , I1111iiI ) )
   if 15 - 15: Ooo0Ooo * IiI11Ii111 / ooo000 - I11iiIi11i1I
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 81 - 81: IIiIIiIi11I1 / ooOOO / I11iiIi11i1I / Ii % ooOOO * I1Ii1I1
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 51 - 51: oOo0O00 + ooo000 + ooo000 . I11iiIi11i1I % i1I
  if 43 - 43: IiI11Ii111 % OooOoo / IiI11Ii111 . i1 . I1I
  if 94 - 94: ooOOO
  if 39 - 39: IIiIIiIi11I1 . IiI11Ii111
  if 42 - 42: oOO + IiIIii11Ii
  if 54 - 54: Iii1i + oOo0O00 + Ooo0Ooo
  if 22 - 22: oOo0O00 . oOo0O00 * Oo
  if 52 - 52: Ooo0Ooo . ooo000
  if 99 - 99: IIiIIiIi11I1 . Ii . Ii
  if 29 - 29: i1I - Iii1i
  if 33 - 33: OooOoo + OooOoo . Ii * Ooo0Ooo
  if 87 - 87: IiIIii11Ii . I11iiIi11i1I * oOO . i1iiIII111
  if 54 - 54: OooOoo . oOO * i1I * IIiIIiIi11I1 . Ii
  if 65 - 65: Iii1i % OooOoo - OooOoo + IIiIIiIi11I1 . i1iiIII111
  if 31 - 31: oOO
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if len ( input_shape ) != 3 :
   if self . reshape == None :
    if len ( input_shape ) > 3 :
     iiI1i11Ii11I1 = 2
     II = input_shape [ 0 : iiI1i11Ii11I1 ]
     II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) == 2 :
     II = input_shape . copy ( )
     II . append ( 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "One dimension data is not supported." )
   else :
    OoO0oOOo = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ 1 : ] , 1 )
    OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , self . reshape , 1 )
    if OoO0oOOo != OOo00oOOO :
     raise ValueError ( "Unable to reshape to specified shape." )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in list ( self . reshape ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 89 - 89: OooOoo - ooo000 / Ooo0Ooo % ooo000
class o0O00O ( oO00ooO00oOO0 ) :
 if 8 - 8: i1iiIII111
 if 92 - 92: Ii
 if 68 - 68: i1iiIII111 % i1I + i1i1i1111I
 if 92 - 92: ooo000 * i1i1i1111I + Ooo0Ooo
 if 64 - 64: Oo / iI1iII1I1I1i / IiI11Ii111 . OooOoo + ooo000
 if 12 - 12: I11iiIi11i1I . IIiIIiIi11I1 - i1I . Ooo0Ooo
 if 65 - 65: IIiIIiIi11I1 * OooOoo
 def __init__ ( self , name : str = None , layerUnits : int = 30 , convFilterWidth : int = 3 , convPadding : bool = True , convStride : int = 1 , convDilation : int = 1 , refLayerName : str = None , refLayerTranspose : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 5e-2 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0 , biasInitial = 0.001 ) ,
 activation : str = "relu" , activationParams : Dict = { } ,
 batchNorm : bool = True , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 reshape = None , buildNo = 0 , weightDecayRate = 0 , weightStdDev = 5e-2 , biasInitial = 0.001 , weightL2Loss = True , weightAvg = 0 , weightL1Loss = False ) :
  if 4 - 4: Ooo0Ooo
  if 33 - 33: i1iiIII111 * iI1iII1I1I1i + i1 . OooOoo / i1iiIII111
  if 71 - 71: i1I
  if 91 - 91: ooOOO / i1i1i1111I % Iii1i / Ii
  if 39 - 39: ooo000 / IiIIii11Ii / ooo000 * Oo % i1iiIII111 * i1
  if 96 - 96: IiI11Ii111 * i1 * i1iiIII111 . i1i1i1111I % IIiIIiIi11I1 % ooo000
  if 22 - 22: ooOOO . ooo000 - i1i1i1111I
  if 4 - 4: Ii
  if 56 - 56: i1i1i1111I * IiIIii11Ii % I11iiIi11i1I * ooo000 . I11iiIi11i1I . IiI11Ii111
  if 26 - 26: i1I / oOO * i1iiIII111 - Ooo0Ooo / Oo - oOo0O00
  if 46 - 46: i1i1i1111I
  if 71 - 71: oOO
  if 62 - 62: Ii + iI1iII1I1I1i / I1I + i1i1i1111I - I1Ii1I1
  if 44 - 44: oOo0O00
  if 22 - 22: ooo000 * I11iiIi11i1I . i1i1i1111I % oOo0O00 / i1iiIII111 . I1Ii1I1
  if 9 - 9: IiI11Ii111 . i1
  if 28 - 28: I1I - Ii . ooo000 * i1 . I1Ii1I1
  if 65 - 65: IiI11Ii111 - IiIIii11Ii * i1 - iI1iII1I1I1i - IiIIii11Ii
  if 56 - 56: oOo0O00 * Oo * oOO . oOo0O00 % OooOoo + Ii
  if 62 - 62: IiI11Ii111 + ooOOO
  if 96 - 96: I1I
  if 64 - 64: i1I + i1i1i1111I + i1 / Iii1i
  if 76 - 76: i1iiIII111 + OooOoo + OooOoo * i1iiIII111 + oOo0O00
  if 80 - 80: OooOoo + I11iiIi11i1I / i1i1i1111I + i1i1i1111I + ooo000 / I1I
  if 19 - 19: I11iiIi11i1I + Oo - i1
  if 28 - 28: I1I / IiIIii11Ii . Oo - i1 * i1i1i1111I . Oo
  if 86 - 86: i1 * OooOoo - Ooo0Ooo / IiI11Ii111 - I11iiIi11i1I . I1Ii1I1
  if 96 - 96: I1I
  if 95 - 95: I1Ii1I1 * OooOoo * i1i1i1111I
  if 16 - 16: Oo
  if 67 - 67: i1I . I1I % Ii * IIiIIiIi11I1 % i1I
  if 73 - 73: I1I / Ii
  if linearTransform is None and any ( [ param is not None for param in [ weightAvg , weightStdDev , weightL1Loss , weightL2Loss , weightDecayRate , biasInitial ] ] ) :
   linearTransform = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = weightAvg , weightStdDev = weightStdDev ,
 weightL1Loss = weightL1Loss , weightL2Loss = weightL2Loss , weightL2Decay = weightDecayRate , biasInitial = biasInitial )
  super ( ) . __init__ ( o00OoOo0O0O00 . Deconvolution1D , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig ,
 activation = activation , activationParams = activationParams , linearTransform = linearTransform ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , outputConfig = outputConfig )
  if 77 - 77: I1I . IiI11Ii111 % IiI11Ii111 . Ooo0Ooo % I1Ii1I1 . Iii1i
  self . convFilterWidth = convFilterWidth
  if 98 - 98: oOO / Ooo0Ooo % I11iiIi11i1I * Oo * oOO
  self . convPadding = convPadding
  if 16 - 16: I1I / I11iiIi11i1I + Ooo0Ooo
  self . convStride = convStride
  if 23 - 23: IiIIii11Ii / oOO % IiIIii11Ii . I11iiIi11i1I % iI1iII1I1I1i
  self . convDilation = convDilation
  if 63 - 63: Ooo0Ooo % Ii % Ooo0Ooo - IIiIIiIi11I1 % Ii % I1Ii1I1
  self . refLayerName = refLayerName
  if 36 - 36: ooOOO - I1Ii1I1 + I1I
  self . refLayerTranspose = refLayerTranspose
  if 84 - 84: I11iiIi11i1I % ooo000 * ooOOO
 def _copySymmetricLayerConfig ( self , useSymmetricWeights = True , buildNo : int = 0 ) -> 'ModelNode.Layer.Convolution' :
  if 66 - 66: i1I . IIiIIiIi11I1 / Iii1i
  if 19 - 19: IIiIIiIi11I1 . ooOOO + OooOoo / ooOOO * oOO
  if 75 - 75: i1i1i1111I . iI1iII1I1I1i + oOO - oOO % I1I
  if 52 - 52: IiI11Ii111 * Oo
  if 43 - 43: IiIIii11Ii - ooo000 % I11iiIi11i1I - Oo * ooOOO
  if 7 - 7: oOO + ooOOO
  if 44 - 44: i1 + iI1iII1I1I1i - i1I
  if 25 - 25: Ooo0Ooo / I1I / IiIIii11Ii + iI1iII1I1I1i * I11iiIi11i1I . i1i1i1111I
  if 10 - 10: i1I + Ooo0Ooo - oOo0O00 . oOo0O00
  if 85 - 85: IiIIii11Ii - ooOOO % Ii % I11iiIi11i1I
  if 89 - 89: IiIIii11Ii * Oo - IIiIIiIi11I1 . ooo000 . Oo
  if 13 - 13: I1Ii1I1 . I1I / i1iiIII111
  if 76 - 76: ooo000 . I11iiIi11i1I + IiIIii11Ii + I1Ii1I1
  if 23 - 23: Iii1i + oOo0O00 % I1I + Iii1i - ooOOO
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 69 - 69: oOO + ooo000 * i1i1i1111I * Oo % IIiIIiIi11I1
  return IIIOOoo0 ( name = ( self . name + "_Sym" ) , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride , convDilation = self . convDilation ,
 refLayerName = self . name if useSymmetricWeights else None , refLayerTranspose = True ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 37 - 37: i1iiIII111 - ooo000 - I11iiIi11i1I
 def copy ( self , name : str ) -> 'ModelNode.Layer.Deconvolution' :
  if 17 - 17: I1I * IiI11Ii111 - Iii1i * Ii
  if 65 - 65: IIiIIiIi11I1 * Ii / Ooo0Ooo / IiI11Ii111 + Ii
  if 60 - 60: Ooo0Ooo + ooOOO - I1I / oOo0O00
  if 1 - 1: iI1iII1I1I1i * i1iiIII111 . i1iiIII111 + Oo . I1I
  if 27 - 27: i1 + i1i1i1111I
  if 99 - 99: OooOoo * IIiIIiIi11I1 * oOo0O00 * IiI11Ii111
  if 55 - 55: Oo / I11iiIi11i1I % i1 + ooOOO * OooOoo . ooo000
  if 16 - 16: Oo . I11iiIi11i1I + OooOoo + I1I - I1I / i1i1i1111I
  if 6 - 6: I11iiIi11i1I * i1iiIII111 * IIiIIiIi11I1 - I11iiIi11i1I
  if 89 - 89: Ooo0Ooo + Ii / oOo0O00 + Iii1i / i1i1i1111I
  if 12 - 12: ooo000 - I1Ii1I1 % I1Ii1I1 - i1 - oOo0O00
  if 6 - 6: I11iiIi11i1I
  if 70 - 70: oOo0O00
  if 73 - 73: iI1iII1I1I1i * ooOOO * oOO . i1i1i1111I
  if not isinstance ( self , o0O00O ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 65 - 65: iI1iII1I1I1i / IiIIii11Ii . Oo * Oo / ooOOO % I11iiIi11i1I
   if 22 - 22: oOO % iI1iII1I1I1i / i1 - I1I + ooOOO % Ooo0Ooo
  return o0O00O ( name = name , layerUnits = self . layerUnits , convFilterWidth = self . convFilterWidth , convPadding = self . convPadding , convStride = self . convStride ,
 convDilation = self . convDilation , refLayerName = self . refLayerName , refLayerTranspose = self . refLayerTranspose ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 30 - 30: Oo - I11iiIi11i1I % ooo000
 def _build ( self , buildNo : int ) :
  if 82 - 82: i1iiIII111 / IIiIIiIi11I1 + iI1iII1I1I1i / i1iiIII111 + iI1iII1I1I1i
  if 15 - 15: iI1iII1I1I1i * iI1iII1I1I1i / ooOOO
  if 87 - 87: IiI11Ii111 - Oo / IiI11Ii111 * Iii1i % i1i1i1111I - OooOoo
  if 32 - 32: iI1iII1I1I1i - I11iiIi11i1I
  if 14 - 14: Oo / IiIIii11Ii + I1Ii1I1 + iI1iII1I1I1i / i1I / i1I
  if 58 - 58: Iii1i * Oo + i1iiIII111 + oOO
  if 69 - 69: I1I . ooOOO - OooOoo / i1
  if 48 - 48: ooo000 . OooOoo / iI1iII1I1I1i % i1iiIII111 - i1iiIII111
  if 34 - 34: oOo0O00 % Iii1i . OooOoo + Iii1i . IiI11Ii111 * i1I
  if 63 - 63: I11iiIi11i1I * i1iiIII111 % Ooo0Ooo - Iii1i * i1i1i1111I
  self . _clearTempTensors ( )
  if 87 - 87: Ooo0Ooo - ooo000 * iI1iII1I1I1i * I1I % i1I
  if 73 - 73: IIiIIiIi11I1 / I1I % Ii - IIiIIiIi11I1 * I11iiIi11i1I % IiI11Ii111
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 6 - 6: IIiIIiIi11I1 % oOO * I1Ii1I1 % IIiIIiIi11I1 . i1I * I11iiIi11i1I
   if self . refLayerName is not None :
    ooo00ooOoo0O = self . train . modelNodes [ self . refLayerName ]
    with tf . compat . v1 . variable_scope ( self . refLayerName , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     oOoO0O0o000 = i11i111iI . getFromGraph ( "weight" )
     if 31 - 31: I11iiIi11i1I / Iii1i . I1I . OooOoo - Iii1i + I11iiIi11i1I
    if self . refLayerTranspose :
     with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
      oOoO0O0o000 = tf . transpose ( oOoO0O0o000 , [ 0 , 2 , 1 ] )
      if 96 - 96: IiI11Ii111 . i1iiIII111
      if 88 - 88: ooo000 * ooOOO
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 100 - 100: oOo0O00 - i1iiIII111 + I1I - I1Ii1I1
    O00o = self . _combineIncomingTensors ( buildNo = buildNo )
    II11i11 = [ * O00o . shape ]
    if 19 - 19: i1iiIII111 * IiIIii11Ii . ooo000 + I11iiIi11i1I - oOo0O00 % I11iiIi11i1I
    if 72 - 72: IiIIii11Ii
    if len ( II11i11 ) != 3 :
     if 74 - 74: IIiIIiIi11I1 + I1Ii1I1 + Iii1i
     if len ( II11i11 ) > 3 :
      I11II = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ 2 : ] , 1 )
      O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape [ : 2 ] ) , I11II ] )
      II11i11 = [ * O00o . shape ]
      if 4 - 4: i1I % OooOoo
      if 29 - 29: iI1iII1I1I1i / oOo0O00 . I1Ii1I1
     elif len ( II11i11 ) == 2 :
      O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape ) , 1 ] )
      II11i11 = [ * O00o . shape ]
      if 91 - 91: I11iiIi11i1I / I11iiIi11i1I * Ii
      if 16 - 16: iI1iII1I1I1i * I1Ii1I1
     else :
      raise ValueError ( "2 or lower dimension is not supported for DCNN Layer." )
      if 85 - 85: I1Ii1I1 % oOO % oOo0O00
      if 5 - 5: ooo000 % Ooo0Ooo % IIiIIiIi11I1 + I11iiIi11i1I / i1iiIII111 * i1
    iiII = self . linearTransform
    if self . refLayerName is None :
     oOoO0O0o000 = iiII . weightConfig . create ( "weight" , [ self . convFilterWidth , II11i11 [ - 1 ] , self . layerUnits ] , dtype = O00o . dtype , defaultDevice = self . train . device )
     if 81 - 81: Oo + OooOoo / IIiIIiIi11I1 . OooOoo
     if 11 - 11: oOO % Ii * i1iiIII111
    ii1iII11iI1I = iiII . biasConfig . create ( "biases" , [ oOoO0O0o000 . shape [ - 1 ] ] , dtype = O00o . dtype , defaultDevice = self . train . device )
    self . _weights . extend ( [ oOoO0O0o000 , ii1iII11iI1I ] )
    if 50 - 50: I1Ii1I1
    if 24 - 24: IIiIIiIi11I1 + Ii
    Oo0o0Oooo00O0 = 0
    if self . convPadding :
     Oo0o0Oooo00O0 = II11i11 [ 1 ] * self . convStride
    else :
     if 30 - 30: i1i1i1111I * i1
     ii1IOOo0o00oOO = max ( [ self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 ) - self . convStride , 0 ] )
     Oo0o0Oooo00O0 = II11i11 [ 1 ] * self . convStride + ii1IOOo0o00oOO
     if 94 - 94: oOO - Iii1i
     if 8 - 8: oOo0O00 % IiI11Ii111 . Ooo0Ooo * ooOOO
     if 19 - 19: oOO / i1iiIII111 + Ii + i1I - I1I
    if self . train . device . startswith ( "/cpu" ) and self . convDilation > 1 :
     raise ValueError ( "Deconvolutional dilation is not supported for CPU processing. --- at Layer: " + self . name )
    elif self . convDilation > 1 and any ( [ s > 1 for s in self . convStride ] ) :
     raise ValueError ( "Deconvolutional layer using convolutional 2D transpose currently does not support dilation > 1 when stride > 1.   --- at Layer: " + self . name )
     if 23 - 23: Ii
    with tf . device ( self . train . device ) :
     O0oO000OOoooo0OO = tf . nn . conv1d_transpose ( O00o , filter = tf . transpose ( oOoO0O0o000 , [ 0 , 2 , 1 ] ) , output_shape = [ tf . shape ( O00o ) [ 0 ] , Oo0o0Oooo00O0 , oOoO0O0o000 . shape [ - 1 ] ] , strides = [ 1 , self . convStride , 1 ] , padding = ( 'SAME' if self . convPadding else 'VALID' ) , dilations = [ 1 , self . convDilation , 1 ] )
     O0oO000OOoooo0OO = tf . nn . bias_add ( O0oO000OOoooo0OO , ii1iII11iI1I )
     if 89 - 89: I11iiIi11i1I * OooOoo / ooOOO + i1I * i1 . Ii
     if 81 - 81: Iii1i . IiIIii11Ii % IIiIIiIi11I1 + Ii
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 36 - 36: i1I
    if 25 - 25: Iii1i + ooOOO - IiIIii11Ii . Oo
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 16 - 16: I1Ii1I1 / oOo0O00 / i1 . I1Ii1I1 * i1I
   self . _built = True
   if 48 - 48: i1i1i1111I
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 4 - 4: I1Ii1I1 / I1I
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 95 - 95: Oo * I1I
  if 73 - 73: OooOoo * oOO * I11iiIi11i1I + oOo0O00 . I1Ii1I1
  if 64 - 64: Ii + I1Ii1I1
  if 18 - 18: ooOOO
  if 80 - 80: ooo000
  if 12 - 12: i1i1i1111I
  if 77 - 77: i1 + OooOoo * Iii1i . IiI11Ii111 + IIiIIiIi11I1
  if 65 - 65: I1Ii1I1 + oOO * oOo0O00 . i1 * i1iiIII111 * Oo
  if 92 - 92: oOo0O00 % Oo * i1I % IiI11Ii111 - i1i1i1111I % IIiIIiIi11I1
  if 53 - 53: Oo . IiI11Ii111
  if 84 - 84: Oo . ooOOO + Oo / iI1iII1I1I1i - i1i1i1111I . oOo0O00
  if 15 - 15: oOo0O00
  if 87 - 87: OooOoo % Ooo0Ooo . IiIIii11Ii + OooOoo - Iii1i
  if 81 - 81: IiI11Ii111
  if 71 - 71: I1Ii1I1 * IIiIIiIi11I1
  if self . convPadding :
   OoO00OO00000 = inputshape [ 1 ] * self . convStride
  else :
   if 25 - 25: OooOoo + i1I * IiI11Ii111 / iI1iII1I1I1i
   I11ii11IIII1 = max ( [ self . convFilterWidth + ( self . convDilation - 1 ) * ( self . convFilterWidth - 1 ) - self . convStride , 0 ] )
   OoO00OO00000 = inputshape [ 1 ] * self . convStride + I11ii11IIII1
  II = [ None , OoO00OO00000 , self . layerUnits ]
  if 94 - 94: Oo % iI1iII1I1I1i - OooOoo . iI1iII1I1I1i
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  ii1 = ( 'SAME' if self . convPadding else 'VALID' )
  if 79 - 79: Iii1i + i1 . Iii1i
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  if 45 - 45: OooOoo - I1I + I1Ii1I1 / i1I + iI1iII1I1I1i
  if 6 - 6: I1I * ooo000 . Ooo0Ooo % oOO
  if 66 - 66: Ooo0Ooo % i1I . Ii / OooOoo
  if 89 - 89: IiIIii11Ii % oOo0O00
  if 6 - 6: OooOoo . i1i1i1111I - Ooo0Ooo
  if 50 - 50: ooOOO * Ii + i1iiIII111 . OooOoo - I1Ii1I1
  if 44 - 44: I11iiIi11i1I + IiI11Ii111 . Ooo0Ooo . oOo0O00 . i1iiIII111
  O0OOO0O0OO000 = self . get_initiallizer ( )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  OoOO , OoooOO0 = [ ] , [ ]
  IiIIiI11II = 'self.%s_before = tf.keras.layers.Lambda(lambda x: tf.keras.backend.expand_dims(x, axis=2))' % ( self . name , )
  OoOO . append ( IiIIiI11II )
  Ii1I1iIiiiI = '%s = self.%s_before(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 79 - 79: Oo * OooOoo - Oo % I1Ii1I1
  oO00oOooO0O = 'self.%s = tf.keras.layers.Conv2DTranspose(%d,(%d, 1), strides=(%d, 1), dilation_rate=(%d, 1), padding=\'%s\', activation=%s, kernel_initializer=%s, bias_initializer=%s, kernel_regularizer=%s, bias_regularizer=%s)' % ( self . name , self . layerUnits , self . convFilterWidth ,
  # I11iiIi11i1I % i1iiIII111 . i1 / ooOOO
 self . convStride , self . convDilation , ii1 , I11i1I11IiII , O0OOO0O0OO000 , OOOoooO , i1IiiIi1iIiIIi , ooiiii1IiIi )
  OoOO . append ( oO00oOooO0O )
  if 46 - 46: oOO / oOo0O00
  if self . refLayerName is not None :
   self . refLayerName = self . refLayerName . replace ( ' ' , '' )
   inputshape = [ str ( x ) for x in inputshape ]
   OoOO . append ( 'self.%s.build((' % self . name + ',' . join ( inputshape ) + '))' )
   OoOO . append ( 'self.%s.kernel = None' % self . name )
   if 27 - 27: IiI11Ii111
   if self . refLayerTranspose :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
   else :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , I1111iiI )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 82 - 82: IiI11Ii111 - iI1iII1I1I1i
  ii1iI1ii1IIII = 'self.%s_after = tf.keras.layers.Lambda(lambda x: tf.keras.backend.squeeze(x, axis=2))' % ( self . name , )
  OoOO . append ( ii1iI1ii1IIII )
  Ii1I1iIiiiI = '%s = self.%s_after(%s)' % ( I1111iiI , self . name , I1111iiI )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 79 - 79: I1I . ooOOO + i1iiIII111 . IiIIii11Ii % Ooo0Ooo
  if 46 - 46: IiIIii11Ii % i1I . ooOOO - i1 * IiIIii11Ii % Ii
  if self . dropout < 100 :
   i1oOo0oO0 = ( 100 - self . dropout ) / 100
   OoOO . append ( 'self.%s_dp = tf.keras.layers.Dropout(%g)' % ( self . name , i1oOo0oO0 ) )
   OoooOO0 . append ( '%s = self.%s_dp(%s)' % ( I1111iiI , self . name , I1111iiI ) )
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   if 33 - 33: oOo0O00 * i1I * OooOoo
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 97 - 97: i1I . ooOOO + IiIIii11Ii + IiI11Ii111 + I1Ii1I1 . I11iiIi11i1I
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 27 - 27: Oo
  if 58 - 58: oOo0O00 % oOo0O00 % OooOoo + I11iiIi11i1I / OooOoo / IiI11Ii111
  if 82 - 82: I11iiIi11i1I + oOo0O00 - iI1iII1I1I1i / Ooo0Ooo % i1
  if 1 - 1: i1iiIII111 % i1iiIII111 * Iii1i
  if 73 - 73: oOO - ooo000 * oOo0O00
  if 9 - 9: oOO / I1Ii1I1 % i1i1i1111I % Iii1i
  if 93 - 93: i1I * IiIIii11Ii / Oo
  if 22 - 22: Oo
  if 65 - 65: oOo0O00 * I1Ii1I1 - Oo / Ooo0Ooo . ooo000
  if 48 - 48: i1 - Ooo0Ooo * i1
  if 1 - 1: oOo0O00
  if 87 - 87: i1iiIII111 / i1I
  if 6 - 6: IiIIii11Ii
  if 51 - 51: iI1iII1I1I1i . IiIIii11Ii * i1iiIII111
  if 92 - 92: oOo0O00 % ooOOO . iI1iII1I1I1i - I1I
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    iiI1i11Ii11I1 = 2
    II = input_shape [ 0 : iiI1i11Ii11I1 ]
    II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   elif len ( input_shape ) == 2 :
    II = input_shape . copy ( )
    II . append ( 1 )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 44 - 44: I11iiIi11i1I / IiI11Ii111 / OooOoo - IIiIIiIi11I1 + iI1iII1I1I1i
class oOoOOO0OOOOO ( oO00ooO00oOO0 ) :
 if 2 - 2: i1 / IiIIii11Ii - I11iiIi11i1I + ooo000
 if 15 - 15: i1i1i1111I . Ooo0Ooo . Ooo0Ooo % iI1iII1I1I1i
 if 74 - 74: i1 % I1Ii1I1 % i1I + Ooo0Ooo
 if 20 - 20: oOo0O00 + I1I
 if 55 - 55: I11iiIi11i1I / i1i1i1111I + Ooo0Ooo + I11iiIi11i1I / I1I
 if 64 - 64: iI1iII1I1I1i + oOo0O00 - IIiIIiIi11I1 . I1I * i1
 if 90 - 90: Ii - Oo
 def __init__ ( self , name : str = None ,
 activation : 'Train.Activation' = iI11II1 . Linear , activationParams : Dict = { } ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 batchNorm : bool = True , batchNormParams : Dict = { } , dropout : float = 1 ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 7 - 7: Ooo0Ooo % ooo000 - Ii * IiIIii11Ii
  if 28 - 28: i1iiIII111 * I1I . i1iiIII111
  if 71 - 71: Ooo0Ooo . IiIIii11Ii * IiI11Ii111 + oOO * Ii * ooo000
  if 14 - 14: ooo000 + oOO + ooo000 - I11iiIi11i1I . IiIIii11Ii
  if 58 - 58: Ooo0Ooo + I1I . I1I - I1Ii1I1
  if 37 - 37: Ooo0Ooo % ooo000
  if 23 - 23: Oo - IiI11Ii111
  if 81 - 81: iI1iII1I1I1i . i1
  if 53 - 53: i1iiIII111 * Ooo0Ooo - i1 - IiI11Ii111
  if 8 - 8: Ii * I1Ii1I1 - IIiIIiIi11I1 - I1Ii1I1
  if 86 - 86: IiIIii11Ii - iI1iII1I1I1i
  if 53 - 53: ooOOO
  if 59 - 59: Ooo0Ooo - IIiIIiIi11I1 + Oo * ooOOO - I1Ii1I1 . I1Ii1I1
  if 51 - 51: OooOoo
  if 26 - 26: ooOOO % iI1iII1I1I1i + I1Ii1I1
  if 35 - 35: IiI11Ii111 + iI1iII1I1I1i . ooOOO - I1Ii1I1 % Oo - oOo0O00
  if 68 - 68: Iii1i . IiI11Ii111 % IIiIIiIi11I1 + i1i1i1111I % i1 % I1I
  super ( ) . __init__ ( o00OoOo0O0O00 . Collector , name = name , layerUnits = - 1 ,
 activation = activation , activationParams = activationParams , incomingConfig = incomingConfig ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , dropout = dropout , outputConfig = outputConfig )
  if 67 - 67: IIiIIiIi11I1 . i1 . i1 * Oo * ooo000 + Ooo0Ooo
 def _copySymmetricLayerConfig ( self , useSymmetricWeights : bool = True , buildNo : int = 0 ) -> 'ModelNode.Layer.Collector' :
  if 62 - 62: i1iiIII111
  if 25 - 25: Ii * oOO
  if 100 - 100: IiI11Ii111 . I1I % oOO
  if 87 - 87: ooo000 . ooo000 % I1Ii1I1 * oOo0O00
  if 80 - 80: IiIIii11Ii % i1I - i1i1i1111I . I1I . Iii1i
  if 70 - 70: IiIIii11Ii - ooo000 % oOO / Iii1i * ooOOO
  if 8 - 8: Oo + i1i1i1111I - ooo000
  if 52 - 52: Oo * Iii1i / I1I - oOo0O00 + IiIIii11Ii % I1I
  if 74 - 74: Iii1i . I11iiIi11i1I + I11iiIi11i1I . oOO
  if 1 - 1: IIiIIiIi11I1 * i1I + I11iiIi11i1I
  if 91 - 91: IiIIii11Ii - ooOOO % Ii * oOo0O00 / i1 % I11iiIi11i1I
  if 59 - 59: I1I
  if 69 - 69: OooOoo % i1I - i1 * oOo0O00 + ooOOO
  if 88 - 88: oOO + IiI11Ii111 * Iii1i
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 44 - 44: I1I - Ii * i1I . IiI11Ii111 * OooOoo + ooo000
  oO0OOOOOOoo = self . copy ( self . name + "_Sym" )
  if useSymmetricWeights :
   oO0OOOOOOoo . refLayerName = self . name
  return oO0OOOOOOoo
  if 10 - 10: IiIIii11Ii * iI1iII1I1I1i * I11iiIi11i1I
 def copy ( self , name : str ) -> 'ModelNode.Layer.Collector' :
  if 22 - 22: ooo000 + i1 - Ooo0Ooo
  if 28 - 28: IiIIii11Ii
  if 15 - 15: i1i1i1111I % Ooo0Ooo
  if 26 - 26: i1I % i1 - iI1iII1I1I1i . i1
  if 26 - 26: IiIIii11Ii % ooo000
  if 71 - 71: ooo000 / i1iiIII111 % Ii - Ii * i1iiIII111 . Ii
  if 91 - 91: I1I + Oo
  if 55 - 55: I1Ii1I1 % I1I
  if 94 - 94: I1Ii1I1 - i1 . ooOOO
  if 25 - 25: iI1iII1I1I1i + i1i1i1111I
  if 100 - 100: i1iiIII111 . IIiIIiIi11I1
  if 40 - 40: i1i1i1111I / oOO / Iii1i - I11iiIi11i1I - I1Ii1I1
  if 68 - 68: OooOoo - I11iiIi11i1I * Ii - ooOOO / IiIIii11Ii
  if 52 - 52: i1iiIII111 * Oo / Ii
  if not isinstance ( self , oOoOOO0OOOOO ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 61 - 61: i1I * Ii * Iii1i - Iii1i
   if 99 - 99: ooo000 % oOO . Ooo0Ooo % oOo0O00 - i1 + i1iiIII111
  return oOoOOO0OOOOO ( name = name , activation = self . activation , activationParams = self . activationParams , incomingConfig = self . incomingConfig ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams , dropout = self . dropout , outputConfig = self . outputConfig )
  if 76 - 76: IiIIii11Ii + IIiIIiIi11I1
 def _build ( self , buildNo : int ) :
  if 10 - 10: Oo * Ooo0Ooo + i1 / ooo000
  if 3 - 3: i1i1i1111I * i1i1i1111I . I1Ii1I1 / I1I
  if 9 - 9: Iii1i / i1
  if 52 - 52: Ooo0Ooo / oOo0O00 % i1 - Ii
  if 70 - 70: Ooo0Ooo
  if 77 - 77: I1I
  if 44 - 44: I1I
  if 93 - 93: OooOoo + ooo000 . I11iiIi11i1I / IiI11Ii111 * I11iiIi11i1I + Iii1i
  if 36 - 36: oOO + i1iiIII111
  if 13 - 13: Ooo0Ooo . oOO % i1 * I1Ii1I1 % i1i1i1111I . oOo0O00
  self . _clearTempTensors ( )
  if 32 - 32: IIiIIiIi11I1 - IiIIii11Ii % iI1iII1I1I1i % I1I / ooOOO * ooo000
  if 49 - 49: ooo000 - OooOoo % I1I % Ii
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 4 - 4: I1I - Iii1i - I11iiIi11i1I / IIiIIiIi11I1 - Ooo0Ooo + ooOOO
   O0oO000OOoooo0OO = self . _combineIncomingTensors ( buildNo = buildNo )
   if 30 - 30: i1iiIII111 * I11iiIi11i1I . I1Ii1I1 % iI1iII1I1I1i + Iii1i
   if 37 - 37: i1iiIII111 * ooOOO + I1Ii1I1
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 72 - 72: I11iiIi11i1I + oOO
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 62 - 62: I1Ii1I1 + Ii . ooOOO % oOO / IiIIii11Ii . oOo0O00
    if 88 - 88: ooOOO % I11iiIi11i1I * I11iiIi11i1I % i1
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 1 - 1: I11iiIi11i1I
   self . _built = True
   if 98 - 98: oOO . iI1iII1I1I1i . i1 + i1I
   if 30 - 30: i1I * IiIIii11Ii % iI1iII1I1I1i - Iii1i - ooOOO . I1Ii1I1
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 62 - 62: i1I
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 66 - 66: Ooo0Ooo % i1iiIII111
  if 38 - 38: i1I % I1I + I1I * Iii1i % IiIIii11Ii * I1I
  if 53 - 53: iI1iII1I1I1i + i1i1i1111I
  if 89 - 89: I11iiIi11i1I - ooOOO . oOO - Ii
  if 45 - 45: oOo0O00 * IiIIii11Ii + i1I / IiIIii11Ii / I1Ii1I1 % ooOOO
  if 75 - 75: oOo0O00
  if 70 - 70: oOO
  if 58 - 58: i1I + Oo / I11iiIi11i1I
  if 74 - 74: Ii . IiIIii11Ii
  if 67 - 67: I11iiIi11i1I - IiI11Ii111 - ooOOO * ooo000
  if 9 - 9: i1i1i1111I + i1iiIII111 - IIiIIiIi11I1 * ooOOO . Oo
  if 85 - 85: iI1iII1I1I1i % Oo + i1iiIII111 . ooo000
  if 53 - 53: Ooo0Ooo / I1Ii1I1
  if 36 - 36: Ii / i1iiIII111 / IIiIIiIi11I1 * oOO
  if 95 - 95: i1 + IIiIIiIi11I1 + ooo000 % Ooo0Ooo
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = reshape_output_name
  if self . activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'tf.nn.hard_sigmoid'
  else :
   I11i1I11IiII = 'tf.nn.' + self . activation . name . lower ( )
   if 51 - 51: Ooo0Ooo / i1 . Oo / Oo
  OoOO , OoooOO0 = [ ] , [ ]
  if self . activation != iI11II1 . Linear :
   iiII1I1iIi = output_reg
   Ii1I1iIiiiI = '%s = %s(%s)' % ( I1111iiI , I11i1I11IiII , oO )
   OoooOO0 . append ( Ii1I1iIiiiI )
   if 82 - 82: I1Ii1I1 * i1iiIII111 + Ooo0Ooo % IiIIii11Ii . IIiIIiIi11I1 + IiI11Ii111
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , iiII1I1iIi , inputshape
  else :
   return OoOO , OoooOO0 , iiII1I1iIi , inputshape
   if 74 - 74: ooOOO + Oo * IiIIii11Ii % IiI11Ii111 . IiI11Ii111
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 53 - 53: I1Ii1I1 / Ooo0Ooo - oOO / Ii % I11iiIi11i1I
  if 19 - 19: Oo - Iii1i
  if 48 - 48: Iii1i - I1I / IiI11Ii111 / Iii1i % ooOOO
  if 58 - 58: OooOoo / I1Ii1I1 - ooOOO / IIiIIiIi11I1 / oOO + Oo
  if 14 - 14: IiIIii11Ii / ooo000 % IiI11Ii111 * iI1iII1I1I1i
  if 9 - 9: i1i1i1111I + ooOOO . iI1iII1I1I1i * iI1iII1I1I1i - Oo
  if 50 - 50: i1iiIII111 . IiI11Ii111
  if 26 - 26: IiI11Ii111 . OooOoo - iI1iII1I1I1i * ooo000 % Oo
  if 12 - 12: i1I * i1I . oOO / ooOOO / ooOOO
  if 5 - 5: Ii - I11iiIi11i1I
  if 29 - 29: oOO * oOO * i1I
  if 60 - 60: I1I * oOo0O00 + Ii
  if 99 - 99: oOO + I1Ii1I1 + oOo0O00 . IiIIii11Ii % ooOOO
  if 79 - 79: IIiIIiIi11I1 % ooo000
  if 60 - 60: Ooo0Ooo + i1iiIII111 - I11iiIi11i1I / Ooo0Ooo - I11iiIi11i1I % i1i1i1111I
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  return ooo0oOOooO , OooOoO00 , combine_output_name , input_shape
  if 40 - 40: I1I * OooOoo % oOo0O00
class iiIiiiI1Ii1i1 ( oO00ooO00oOO0 ) :
 if 82 - 82: oOo0O00 + i1I % Ii
 if 99 - 99: I11iiIi11i1I . oOo0O00
 if 18 - 18: IiIIii11Ii / i1I % i1I . OooOoo
 if 12 - 12: I11iiIi11i1I - ooOOO - ooOOO
 if 92 - 92: i1I / i1i1i1111I - Iii1i / OooOoo + I11iiIi11i1I
 if 58 - 58: Ii
 if 16 - 16: ooo000 . oOo0O00 / IiIIii11Ii - i1i1i1111I / OooOoo
 def __init__ ( self , name : str = None , layerUnits : int = 150 , flattenToAxis : int = 1 , refLayerName : str = None , refLayerTranspose : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 0.004 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.004 , biasInitial = 0.001 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict = { } ,
 batchNorm : bool = True , batchNormParams : Dict = { } , dropout : float = 1 ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 buildNo = 0 , weightDecayRate = 0.004 , biasInitial = 0.001 , weightAvg = 0 , weightStdDev = 0.04 , weightL1Loss = False , weightL2Loss = True ) :
  if 20 - 20: OooOoo - oOo0O00 + i1
  if 60 - 60: IiI11Ii111 / Ii / Ooo0Ooo - IiIIii11Ii
  if 34 - 34: Ooo0Ooo - Ii - I1I
  if 57 - 57: iI1iII1I1I1i
  if 7 - 7: Ii
  if 73 - 73: IiIIii11Ii * IiIIii11Ii - i1
  if 65 - 65: OooOoo * iI1iII1I1I1i + ooOOO % I1I * iI1iII1I1I1i
  if 12 - 12: IIiIIiIi11I1
  if 83 - 83: oOO
  if 45 - 45: ooo000 * Oo % i1i1i1111I * IIiIIiIi11I1 * i1i1i1111I % I11iiIi11i1I
  if 72 - 72: I11iiIi11i1I + IiIIii11Ii . i1I % Oo
  if 68 - 68: OooOoo - IiI11Ii111 / iI1iII1I1I1i / ooOOO % I11iiIi11i1I . iI1iII1I1I1i
  if 9 - 9: IIiIIiIi11I1 + IiIIii11Ii . I1Ii1I1 - Iii1i . Ii
  if 3 - 3: i1i1i1111I - oOo0O00 % Ii
  if 56 - 56: Ooo0Ooo + i1iiIII111 % Ii % I1I . Iii1i - oOO
  if 54 - 54: oOo0O00
  if 55 - 55: i1i1i1111I % Ii
  if 19 - 19: oOo0O00 * I1I / I11iiIi11i1I - I1I
  if 58 - 58: OooOoo - Oo / ooOOO * Iii1i - OooOoo . ooo000
  if 88 - 88: IiIIii11Ii
  if 53 - 53: I1Ii1I1 * OooOoo % ooo000 - I1Ii1I1 % ooo000 / OooOoo
  if 7 - 7: i1
  if 38 - 38: ooOOO . I11iiIi11i1I
  if 64 - 64: Iii1i / i1I / ooo000 % OooOoo
  if 65 - 65: i1i1i1111I
  if 71 - 71: I1I
  if 16 - 16: I11iiIi11i1I - i1iiIII111 % IiIIii11Ii / i1i1i1111I % I1I
  if 95 - 95: I1Ii1I1 % Ooo0Ooo * i1
  if 64 - 64: iI1iII1I1I1i + I11iiIi11i1I % I11iiIi11i1I * oOo0O00 / IiI11Ii111 + Oo
  if linearTransform is None and any ( [ param is not None for param in [ weightAvg , weightStdDev , weightL1Loss , weightL2Loss , weightDecayRate , biasInitial ] ] ) :
   linearTransform = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = weightAvg , weightStdDev = weightStdDev ,
 weightL1Loss = weightL1Loss , weightL2Loss = weightL2Loss , weightL2Decay = weightDecayRate , biasInitial = biasInitial )
  super ( ) . __init__ ( o00OoOo0O0O00 . FullyConnected , name = name , layerUnits = layerUnits ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = batchNorm , batchNormParams = batchNormParams ,
 dropout = dropout , outputConfig = outputConfig )
  self . flattenToAxis = flattenToAxis
  self . refLayerName = refLayerName
  self . refLayerTranspose = refLayerTranspose
  if 78 - 78: oOO - I1I . i1I / IIiIIiIi11I1 . OooOoo
 def _copySymmetricLayerConfig ( self , useSymmetricWeights : bool = True , buildNo : int = 0 ) -> 'ModelNode.Layer.FullyConnected' :
  if 26 - 26: I11iiIi11i1I % I1Ii1I1
  if 83 - 83: I1Ii1I1 % iI1iII1I1I1i
  if 41 - 41: I1I . IIiIIiIi11I1 % Ii
  if 48 - 48: oOo0O00 + i1iiIII111 . oOo0O00
  if 63 - 63: I1I + oOo0O00 / Oo
  if 26 - 26: Ii % Ii - oOo0O00 / i1I
  if 79 - 79: ooOOO
  if 87 - 87: Iii1i
  if 89 - 89: IIiIIiIi11I1 . iI1iII1I1I1i % i1I % Ooo0Ooo
  if 64 - 64: I1I * ooo000 * Iii1i
  if 1 - 1: oOo0O00 + IIiIIiIi11I1 + IiI11Ii111
  if 37 - 37: IiIIii11Ii - i1
  if 60 - 60: I1I - I1Ii1I1
  if 51 - 51: IiIIii11Ii % iI1iII1I1I1i / ooOOO / ooOOO + IIiIIiIi11I1 % Oo
  if len ( self . fromNode [ buildNo ] ) != 1 :
   raise ValueError ( "Layers not having one and only one layer node inputs are not able to be copied in a symmetric way." )
   if 21 - 21: i1I - i1iiIII111
  oO0OOOOOOoo = self . copy ( self . name + "_Sym" )
  if useSymmetricWeights :
   oO0OOOOOOoo . refLayerName = self . name
   oO0OOOOOOoo . refLayerTranspose = True
  return oO0OOOOOOoo
  if 10 - 10: i1 * IiI11Ii111 - I1Ii1I1
 def copy ( self , name : str ) -> 'ModelNode.Layer.FullyConnected' :
  if 6 - 6: i1I
  if 13 - 13: I11iiIi11i1I + IiIIii11Ii
  if 31 - 31: Ii * IiI11Ii111 / IIiIIiIi11I1
  if 3 - 3: IiIIii11Ii % I11iiIi11i1I / IiI11Ii111 * Iii1i - Ooo0Ooo
  if 85 - 85: i1i1i1111I . IIiIIiIi11I1 / ooOOO
  if 71 - 71: IIiIIiIi11I1 - OooOoo % i1 - ooo000 - IiI11Ii111
  if 17 - 17: i1i1i1111I - i1iiIII111 . i1I
  if 81 - 81: i1 * oOO . oOo0O00 . oOo0O00 * IIiIIiIi11I1
  if 78 - 78: i1iiIII111 . i1iiIII111 . Oo
  if 43 - 43: IiI11Ii111 + Ooo0Ooo . i1 . Ooo0Ooo + I1Ii1I1
  if 60 - 60: ooo000
  if 10 - 10: IiIIii11Ii
  if 6 - 6: IiI11Ii111
  if 13 - 13: IiI11Ii111 . IiIIii11Ii * iI1iII1I1I1i / OooOoo
  if not isinstance ( self , iiIiiiI1Ii1i1 ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 72 - 72: iI1iII1I1I1i
   if 62 - 62: Iii1i + IiI11Ii111 % I11iiIi11i1I % IIiIIiIi11I1 + iI1iII1I1I1i % IiIIii11Ii
  return iiIiiiI1Ii1i1 ( name = name , layerUnits = self . layerUnits , flattenToAxis = self . flattenToAxis , refLayerName = self . refLayerName , refLayerTranspose = self . refLayerTranspose ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 dropout = self . dropout , outputConfig = self . outputConfig )
  if 85 - 85: Oo . IiIIii11Ii
 def _build ( self , buildNo : int ) :
  if 95 - 95: i1i1i1111I + oOo0O00 - I1I
  if 96 - 96: i1I * I11iiIi11i1I
  if 17 - 17: i1 % iI1iII1I1I1i - Ii . iI1iII1I1I1i % ooOOO
  if 14 - 14: Ooo0Ooo % OooOoo % IIiIIiIi11I1 % IiIIii11Ii * IIiIIiIi11I1
  if 13 - 13: oOO * iI1iII1I1I1i % I1I / iI1iII1I1I1i . i1iiIII111
  if 89 - 89: oOO - Oo - ooo000
  if 41 - 41: Oo + I1I * Ii . IiI11Ii111 * I1I
  if 21 - 21: Ooo0Ooo . oOo0O00
  if 52 - 52: Ooo0Ooo . Ooo0Ooo
  if 63 - 63: I11iiIi11i1I % i1
  self . _clearTempTensors ( )
  if 54 - 54: i1I
  if 81 - 81: i1i1i1111I * Iii1i * I1Ii1I1
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 65 - 65: I1Ii1I1 * ooo000 % I11iiIi11i1I / Iii1i * Ooo0Ooo / oOo0O00
   iiI1iI11 = None
   if self . refLayerName is not None :
    ooo00ooOoo0O = self . train . modelNodes [ self . refLayerName ]
    if 97 - 97: OooOoo * Ii % i1i1i1111I / Oo + I1Ii1I1
    with tf . compat . v1 . variable_scope ( self . refLayerName , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
     I11i1II = i11i111iI . getFromGraph ( "weight" )
     if 23 - 23: I1Ii1I1 * iI1iII1I1I1i + I1I % i1 - Ooo0Ooo
    if self . refLayerTranspose :
     with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
      iiI1iI11 = tf . transpose ( I11i1II , [ 1 , 0 ] )
    else :
     iiI1iI11 = I11i1II
     if 68 - 68: OooOoo
     if 29 - 29: i1iiIII111
   O0oO000OOoooo0OO = self . _combineIncomingTensors ( buildNo = buildNo )
   if 89 - 89: i1iiIII111 / OooOoo
   if 55 - 55: Ii
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 9 - 9: oOO . Oo * i1 / IIiIIiIi11I1 . I11iiIi11i1I / I11iiIi11i1I
    III1i = self . linearTransform . buildOn ( O0oO000OOoooo0OO , toUnit = self . layerUnits , axis = self . flattenToAxis , weightSharing = iiI1iI11 , defaultDevice = self . train . device )
    O0oO000OOoooo0OO = III1i . results
    self . _weights . extend ( III1i . weights )
    if 72 - 72: i1i1i1111I . OooOoo * i1i1i1111I / ooOOO / I1I * Ooo0Ooo
    if 45 - 45: Ii . i1i1i1111I
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 5 - 5: ooOOO * I1Ii1I1 + IiIIii11Ii . Ii
    if 5 - 5: i1i1i1111I % IiI11Ii111 . iI1iII1I1I1i * i1iiIII111 . I11iiIi11i1I
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 4 - 4: Oo + i1i1i1111I . Iii1i + oOo0O00 * Oo
   self . _built = True
   if 22 - 22: i1iiIII111 * Ii
   if 10 - 10: I1Ii1I1
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 65 - 65: Ii + I1Ii1I1 % iI1iII1I1I1i - Ii
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 25 - 25: i1I . i1 - Iii1i % IiI11Ii111 - i1I
  if 13 - 13: i1 % Oo - IiI11Ii111
  if 12 - 12: ooOOO
  if 48 - 48: oOo0O00
  if 16 - 16: oOO - Oo % IIiIIiIi11I1
  if 41 - 41: Ii . IiIIii11Ii % i1 % oOo0O00
  if 70 - 70: i1iiIII111 / i1i1i1111I % iI1iII1I1I1i / i1 + I1Ii1I1 - oOo0O00
  if 61 - 61: Ii % I1Ii1I1 + I1I / oOo0O00 * IIiIIiIi11I1
  if 44 - 44: i1I
  if 9 - 9: I1I % Ooo0Ooo + ooo000 / ooOOO
  if 5 - 5: IiIIii11Ii * i1iiIII111 % oOO % Oo . IiIIii11Ii % IiIIii11Ii
  if 58 - 58: IIiIIiIi11I1 . iI1iII1I1I1i . IiIIii11Ii - IIiIIiIi11I1
  if 55 - 55: iI1iII1I1I1i / Ii . ooo000 * Oo
  if 5 - 5: Ii / Iii1i / IIiIIiIi11I1
  if 27 - 27: IiIIii11Ii * oOO / I11iiIi11i1I - I11iiIi11i1I / i1iiIII111 . IiI11Ii111
  II = [ None , self . layerUnits ]
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 60 - 60: Iii1i . iI1iII1I1I1i * oOO * Oo - Ooo0Ooo
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  O0OOO0O0OO000 = self . get_initiallizer ( )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  OoOO , OoooOO0 = [ ] , [ ]
  oO00oOooO0O = 'self.%s = tf.keras.layers.Dense(%d, activation = %s,  kernel_initializer=%s, bias_initializer=%s, kernel_regularizer=%s, bias_regularizer=%s)' % ( self . name , self . layerUnits , I11i1I11IiII , O0OOO0O0OO000 , OOOoooO , i1IiiIi1iIiIIi , ooiiii1IiIi )
  if 78 - 78: Ii
  OoOO . append ( oO00oOooO0O )
  if self . refLayerName is not None :
   self . refLayerName = self . refLayerName . replace ( ' ' , '' )
   inputshape = [ str ( x ) for x in inputshape ]
   OoOO . append ( 'self.%s.build((' % self . name + ',' . join ( inputshape ) + '))' )
   OoOO . append ( 'self.%s.kernel = None' % self . name )
   if self . refLayerTranspose :
    OoooOO0 . append ( 'self.%s.kernel = tf.transpose(self.%s.kernel, perm=[1, 0])' % ( self . name , self . refLayerName ) )
   else :
    OoooOO0 . append ( 'self.%s.kernel = self.%s.kernel' % ( self . name , self . refLayerName ) )
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if self . dropout < 100 :
   i1oOo0oO0 = ( 100 - self . dropout ) / 100
   OoOO . append ( 'self.%s_dp = tf.keras.layers.Dropout(%g)' % ( self . name , i1oOo0oO0 ) )
   OoooOO0 . append ( '%s = self.%s_dp(%s)' % ( I1111iiI , self . name , I1111iiI ) )
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 67 - 67: ooOOO / iI1iII1I1I1i * i1iiIII111
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 41 - 41: iI1iII1I1I1i
  if 39 - 39: ooOOO . oOo0O00 + i1I / ooOOO + Ooo0Ooo
  if 96 - 96: ooo000 / I1Ii1I1 - I1I - IiIIii11Ii % Oo
  if 75 - 75: Oo % i1 * i1 % ooOOO / IiI11Ii111 * oOo0O00
  if 11 - 11: I1Ii1I1 + IiI11Ii111 % I1Ii1I1
  if 60 - 60: iI1iII1I1I1i - I1I . oOO + IiI11Ii111
  if 78 - 78: Oo - Iii1i - i1i1i1111I . Oo / i1 . IIiIIiIi11I1
  if 65 - 65: oOO . IiI11Ii111 - I11iiIi11i1I - i1I
  if 22 - 22: Ii / Ii % IIiIIiIi11I1 - i1iiIII111 / oOO
  if 39 - 39: Ii
  if 78 - 78: Ooo0Ooo . i1iiIII111 / i1I . Ooo0Ooo + ooo000 * ooo000
  if 1 - 1: Ooo0Ooo . i1I % Iii1i
  if 24 - 24: IiIIii11Ii * I1Ii1I1 * I11iiIi11i1I
  if 67 - 67: I1I - oOO - Iii1i + Iii1i - ooOOO
  if 15 - 15: I1Ii1I1 . Oo + Oo - iI1iII1I1I1i - OooOoo
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if self . flattenToAxis < 0 :
   iiI1i11Ii11I1 = len ( input_shape ) + self . flattenToAxis
  else :
   iiI1i11Ii11I1 = self . flattenToAxis
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if iiI1i11Ii11I1 == len ( input_shape ) - 1 :
   II = input_shape
   iiII1I1iIi = combine_output_name
  elif iiI1i11Ii11I1 == 1 :
   II = input_shape [ 0 : iiI1i11Ii11I1 ]
   II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
   string = 'self.%s_auto_reshape = tf.keras.layers.Flatten()' % self . name
   ooo0oOOooO . append ( string )
   string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
   OooOoO00 . append ( string )
  elif iiI1i11Ii11I1 > 1 and iiI1i11Ii11I1 < len ( input_shape ) - 1 :
   II = input_shape [ 0 : iiI1i11Ii11I1 ]
   II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
   string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
   string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
   string += '))'
   ooo0oOOooO . append ( string )
   string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
   OooOoO00 . append ( string )
  else :
   raise ValueError ( "Linear Transformation axis should within the dimension of the incoming tensor." )
   if 25 - 25: iI1iII1I1I1i % Ii / Iii1i % i1iiIII111
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 29 - 29: Oo . i1I
class I1IOO ( oO00ooO00oOO0 ) :
 if 68 - 68: i1iiIII111 * I1Ii1I1 . I1I
 if 11 - 11: oOo0O00 - ooOOO
 if 63 - 63: IiIIii11Ii
 if 49 - 49: I1I . Oo - i1iiIII111
 if 95 - 95: Iii1i . ooOOO - I11iiIi11i1I % I11iiIi11i1I / Ooo0Ooo / oOO
 if 19 - 19: i1i1i1111I
 if 19 - 19: OooOoo
 def __init__ ( self , name : str = None , layerUnits : int = 150 ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 0.004 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0.004 , biasInitial = 0.001 ) ,
 batchNorm : bool = True , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 buildNo = 0 , weightDecayRate = 0.004 , biasInitial = 0.001 , weightAvg = 0 , weightStdDev = 0.04 , weightL1Loss = False , weightL2Loss = True ) :
  if 92 - 92: i1iiIII111
  if 19 - 19: Ii / Ooo0Ooo - IIiIIiIi11I1 * i1I
  if 47 - 47: i1iiIII111 - iI1iII1I1I1i * I11iiIi11i1I . IiI11Ii111 - OooOoo - IiIIii11Ii
  if 3 - 3: Ooo0Ooo
  if 77 - 77: Ooo0Ooo / I11iiIi11i1I + i1I - ooOOO
  if 76 - 76: I1I / IiIIii11Ii . Oo . oOO . IIiIIiIi11I1 . I11iiIi11i1I
  if 26 - 26: i1
  if 43 - 43: IiI11Ii111 . i1I . I1I * Ooo0Ooo
  if 55 - 55: IIiIIiIi11I1 . IiIIii11Ii - I11iiIi11i1I % I11iiIi11i1I . i1 % iI1iII1I1I1i
  if 49 - 49: Ooo0Ooo
  if 9 - 9: iI1iII1I1I1i * OooOoo . i1iiIII111 + Ii * IiIIii11Ii - oOO
  if 34 - 34: IiI11Ii111 / IIiIIiIi11I1 . I1Ii1I1 % ooOOO - Ii
  if 71 - 71: ooOOO + oOo0O00
  if 27 - 27: I1Ii1I1 . I11iiIi11i1I % i1iiIII111
  if 89 - 89: IiI11Ii111 % Ii . I11iiIi11i1I
  if 59 - 59: IIiIIiIi11I1 . Ooo0Ooo + i1 - i1iiIII111
  if 63 - 63: I1I . I11iiIi11i1I * oOO . I11iiIi11i1I - I1I
  if 21 - 21: Iii1i
  if 60 - 60: oOO / ooo000 * oOo0O00 + iI1iII1I1I1i / Oo . Oo
  if 17 - 17: i1I % I11iiIi11i1I / iI1iII1I1I1i % OooOoo
  if 18 - 18: iI1iII1I1I1i % i1i1i1111I - IiI11Ii111
  if 100 - 100: oOo0O00 / IIiIIiIi11I1 % ooo000 - Oo . Oo / Iii1i
  if 92 - 92: Ooo0Ooo % ooOOO / I1I + Oo . i1iiIII111
  if linearTransform is None and any ( [ param is not None for param in [ weightAvg , weightStdDev , weightL1Loss , weightL2Loss , weightDecayRate , biasInitial ] ] ) :
   linearTransform = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = weightAvg , weightStdDev = weightStdDev ,
 weightL1Loss = weightL1Loss , weightL2Loss = weightL2Loss , weightL2Decay = weightDecayRate , biasInitial = biasInitial )
  super ( ) . __init__ ( o00OoOo0O0O00 . FullyConnected , name = name , layerUnits = layerUnits ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , batchNormParams = batchNormParams ,
 outputConfig = outputConfig )
  if 97 - 97: oOO . ooo000 / OooOoo + I1Ii1I1
 def _copySymmetricLayerConfig ( self , useSymmetricWeights : bool = True , buildNo : int = 0 ) -> 'ModelNode.Layer.FullyConnected' :
  if 59 - 59: Iii1i
  if 52 - 52: Ooo0Ooo + Ooo0Ooo - Ooo0Ooo + oOO + ooOOO
  if 5 - 5: i1I / Ii . I1I
  if 57 - 57: iI1iII1I1I1i % Ooo0Ooo / oOo0O00
  if 47 - 47: i1i1i1111I - i1i1i1111I / I1Ii1I1 * oOo0O00
  if 78 - 78: iI1iII1I1I1i * oOo0O00 - i1iiIII111 . IIiIIiIi11I1 + OooOoo
  if 16 - 16: i1i1i1111I / IiI11Ii111 * i1 . ooo000 % i1 % i1I
  if 90 - 90: I1Ii1I1
  if 65 - 65: iI1iII1I1I1i % Ooo0Ooo
  if 63 - 63: I1Ii1I1 / IIiIIiIi11I1 . i1i1i1111I . IiIIii11Ii / i1 . I1I
  if 53 - 53: i1I % IiI11Ii111 + IiI11Ii111 + OooOoo
  if 64 - 64: Ooo0Ooo / IIiIIiIi11I1 - oOo0O00 + I1I - I1Ii1I1
  if 38 - 38: Oo - i1iiIII111 % IiIIii11Ii
  if 35 - 35: oOO - IIiIIiIi11I1 + iI1iII1I1I1i / ooo000 * Ii
  raise ValueError ( "Pool layer is not able to be copied in a symmetric way." )
  if 34 - 34: I1Ii1I1
  if 70 - 70: IIiIIiIi11I1
 def copy ( self , name : str ) -> 'ModelNode.Layer.FullyConnected' :
  if 64 - 64: IIiIIiIi11I1
  if 12 - 12: i1I % ooOOO + I1Ii1I1 + oOO
  if 25 - 25: I1I - ooOOO / Ii - oOo0O00 . I1Ii1I1
  if 75 - 75: IiIIii11Ii * ooOOO + Oo - Ii / iI1iII1I1I1i . i1
  if 12 - 12: Ii % Ii % oOO - I1Ii1I1
  if 35 - 35: IiI11Ii111 / IiI11Ii111
  if 61 - 61: ooo000 - IIiIIiIi11I1 * I1I + IiI11Ii111 / i1I % oOO
  if 29 - 29: oOO . i1iiIII111 - i1I % IiIIii11Ii . I11iiIi11i1I
  if 68 - 68: i1I . oOo0O00 * I11iiIi11i1I
  if 24 - 24: oOo0O00 - Oo * i1i1i1111I
  if 68 - 68: i1 . ooOOO * iI1iII1I1I1i - Iii1i . Ooo0Ooo
  if 14 - 14: I1I % ooOOO % i1 - I11iiIi11i1I
  if 10 - 10: ooo000
  if 32 - 32: iI1iII1I1I1i . i1i1i1111I / IiIIii11Ii % Ii
  if not isinstance ( self , I1IOO ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 72 - 72: ooo000 / i1i1i1111I
   if 52 - 52: Ii + i1iiIII111
  return I1IOO ( name = name , layerUnits = self . layerUnits ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 37 - 37: IiI11Ii111 + i1iiIII111 % Iii1i % Oo
 def _build ( self , buildNo : int ) :
  if 61 - 61: oOo0O00 / Iii1i . i1i1i1111I
  if 59 - 59: Iii1i + i1I + i1
  if 42 - 42: Oo % i1i1i1111I + IIiIIiIi11I1 / IIiIIiIi11I1
  if 4 - 4: IiIIii11Ii
  if 31 - 31: IIiIIiIi11I1 % IiI11Ii111
  if 18 - 18: i1 % I1Ii1I1 % Oo % i1 / Oo % i1i1i1111I
  if 84 - 84: ooOOO - Ii * IIiIIiIi11I1 . i1 + OooOoo
  if 50 - 50: ooOOO % I1I
  if 22 - 22: IIiIIiIi11I1 * ooo000
  if 6 - 6: I1I * ooo000 + OooOoo - ooOOO % OooOoo + oOo0O00
  self . _clearTempTensors ( )
  if 62 - 62: I1Ii1I1 / Ooo0Ooo
  if 37 - 37: I11iiIi11i1I / i1 / oOo0O00 / i1
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 21 - 21: Ii - I1I * OooOoo / iI1iII1I1I1i / ooo000 + Oo
   iiI1iI11 = None
   if 64 - 64: I11iiIi11i1I + oOo0O00 / ooOOO * i1i1i1111I * i1 - Iii1i
   if 80 - 80: i1i1i1111I * I11iiIi11i1I * i1I . OooOoo * oOo0O00
   O0oO000OOoooo0OO = self . _combineIncomingTensors ( buildNo = buildNo )
   if 94 - 94: ooOOO / I1Ii1I1 . Ooo0Ooo % IiIIii11Ii / IIiIIiIi11I1 % IiIIii11Ii
   if 21 - 21: I11iiIi11i1I % i1
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 20 - 20: IiI11Ii111
    if 29 - 29: ooOOO - oOO % Iii1i . I1Ii1I1 % IiI11Ii111
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 30 - 30: iI1iII1I1I1i - IiIIii11Ii % ooOOO . IiIIii11Ii
    if 44 - 44: IiI11Ii111 * oOo0O00 + ooOOO
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 94 - 94: IiI11Ii111 / iI1iII1I1I1i * i1
   self . _built = True
   if 63 - 63: oOO - I1I
   if 21 - 21: ooOOO / oOO
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 28 - 28: IiIIii11Ii - IiIIii11Ii
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 89 - 89: i1 * oOO - i1i1i1111I + i1
  if 77 - 77: Oo . ooo000
  if 43 - 43: OooOoo . Ooo0Ooo
  if 33 - 33: IiI11Ii111 - iI1iII1I1I1i - IiIIii11Ii
  if 57 - 57: IiIIii11Ii
  if 62 - 62: IIiIIiIi11I1
  if 12 - 12: i1i1i1111I % oOO * i1
  if 30 - 30: IiIIii11Ii / ooo000
  if 22 - 22: IiIIii11Ii * Iii1i + I1I . oOO + Oo + Ii
  if 91 - 91: ooOOO / i1i1i1111I . iI1iII1I1I1i / OooOoo / OooOoo . OooOoo
  if 5 - 5: iI1iII1I1I1i
  if 30 - 30: OooOoo / Ooo0Ooo * ooo000 . ooo000 % oOO
  if 90 - 90: Ooo0Ooo * i1 - IIiIIiIi11I1 . IiI11Ii111 . Ooo0Ooo % oOo0O00
  if 70 - 70: i1 - IiI11Ii111 % iI1iII1I1I1i % Ooo0Ooo + oOO
  if 13 - 13: IiI11Ii111 / i1iiIII111 % i1i1i1111I % Iii1i . OooOoo
  ooOo0ooOOo = inputshape [ 1 ]
  II11Ii11ii1 = inputshape [ 2 ]
  II = [ None , ooOo0ooOOo , self . layerUnits ]
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 11 - 11: Iii1i * ooo000
  ooo00o00 = self . get_initiallizer ( )
  O0ooOo = self . get_regularizer ( )
  OoOO , OoooOO0 = [ ] , [ ]
  oO00oOooO0O = 'self.%s = tf.keras.layers.Embedding(input_dim=%d, output_dim=%d, embeddings_initializer=%s, embeddings_regularizer=%s,input_length=%d)' % ( self . name , II11Ii11ii1 , self . layerUnits , ooo00o00 , O0ooOo , ooOo0ooOOo )
  if 96 - 96: ooOOO + i1iiIII111 - OooOoo % I1I
  OoOO . append ( oO00oOooO0O )
  if 80 - 80: IiI11Ii111 + oOO - Ooo0Ooo / i1I
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 3 - 3: I11iiIi11i1I
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 2 - 2: oOo0O00
  if 59 - 59: I1I
  if 24 - 24: Ii - Iii1i
  if 68 - 68: oOo0O00 % I1I * i1i1i1111I % ooOOO / IiI11Ii111
  if 59 - 59: Iii1i . IiIIii11Ii
  if 28 - 28: I11iiIi11i1I % IiI11Ii111 * Oo / IiI11Ii111 / Iii1i
  if 40 - 40: I1Ii1I1 + OooOoo % Ooo0Ooo / Ooo0Ooo . i1i1i1111I . Iii1i
  if 85 - 85: OooOoo - oOO * I1I % oOO * I1Ii1I1
  if 9 - 9: Oo * Ii
  if 13 - 13: Iii1i . Ii - IiI11Ii111
  if 63 - 63: i1I + Iii1i - OooOoo + Ii * i1I
  if 57 - 57: ooo000 - i1 - Ii . IiI11Ii111 . i1iiIII111 + I1I
  if 10 - 10: ooOOO * OooOoo / ooo000 / i1 + I1Ii1I1
  if 61 - 61: ooOOO
  if 62 - 62: IiIIii11Ii / IIiIIiIi11I1 . OooOoo - i1 / iI1iII1I1I1i / IiIIii11Ii
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 6 - 6: ooOOO * ooOOO + i1 % IIiIIiIi11I1 . oOo0O00
  return ooo0oOOooO , OooOoO00 , combine_output_name , input_shape
  if 96 - 96: Ooo0Ooo / i1i1i1111I . i1i1i1111I - I11iiIi11i1I - IIiIIiIi11I1
class ooOoOoo0OOO0O ( oO00ooO00oOO0 ) :
 if 68 - 68: I1I - IiI11Ii111
 if 16 - 16: Oo . I11iiIi11i1I / oOO % oOO
 if 14 - 14: OooOoo
 if 73 - 73: oOO - OooOoo % I1Ii1I1
 if 87 - 87: i1iiIII111 / I11iiIi11i1I
 if 55 - 55: ooOOO / OooOoo
 if 85 - 85: oOo0O00 / OooOoo
 def __init__ ( self , name : str = None , layerUnits : int = 0 , refLayerName : str = None , refLayerTranspose : bool = False ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 5e-2 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0 , biasInitial = 0.001 ) ,
 activation : 'Train.Activation' = iI11II1 . Relu , activationParams : Dict = { } ,
 batchNorm : bool = False , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ,
 buildNo = 0 , weightDecayRate = 0 , weightStdDev = 5e-2 , biasInitial = 0.001 , weightL2Loss = True , weightAvg = 0 , weightL1Loss = False ) :
  if 19 - 19: i1i1i1111I + Oo . ooOOO + OooOoo
  if 25 - 25: IiIIii11Ii
  if 49 - 49: iI1iII1I1I1i + Ooo0Ooo - ooo000 . Oo
  if 81 - 81: IiIIii11Ii / IIiIIiIi11I1 . i1 + I1Ii1I1 + Iii1i . oOO
  if 40 - 40: oOO % I11iiIi11i1I
  if 73 - 73: i1I * Iii1i
  if 32 - 32: Ooo0Ooo . Ooo0Ooo % ooo000 + I11iiIi11i1I - OooOoo . ooo000
  if 86 - 86: IIiIIiIi11I1 % oOO + Oo + Oo * Ooo0Ooo - Ooo0Ooo
  if 15 - 15: IIiIIiIi11I1 + ooo000
  if 83 - 83: i1I + ooo000 - oOo0O00 - i1I - I1Ii1I1
  if 56 - 56: Ii % oOO / I1Ii1I1
  if 61 - 61: oOo0O00 * IiI11Ii111 - oOO + I1Ii1I1
  if 43 - 43: i1iiIII111 + ooo000 - oOo0O00 / iI1iII1I1I1i + oOO * I1Ii1I1
  if 6 - 6: Oo
  if 25 - 25: ooo000 * i1 % I1Ii1I1 + I11iiIi11i1I
  if 10 - 10: OooOoo - ooOOO
  if 23 - 23: oOo0O00
  if 54 - 54: i1 + I1Ii1I1 + IIiIIiIi11I1 . Ii * IIiIIiIi11I1 + OooOoo
  if 49 - 49: i1I - I1I % Ii . OooOoo
  if 93 - 93: I1I . ooOOO . I1I / IIiIIiIi11I1 . i1I - Iii1i
  if 93 - 93: i1i1i1111I
  if 17 - 17: IiIIii11Ii
  if 25 - 25: I11iiIi11i1I / oOO
  if 40 - 40: i1I
  if 79 - 79: i1iiIII111 + Ooo0Ooo . I1Ii1I1
  if 63 - 63: oOO
  if 16 - 16: ooo000
  super ( ) . __init__ ( o00OoOo0O0O00 . Convolution , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = batchNorm , batchNormParams = batchNormParams , outputConfig = outputConfig )
  if 26 - 26: IiI11Ii111
  self . subModelNodes = [ ]
  self . sub_layer_dict = { }
  self . refLayerName = refLayerName
  self . refLayerTranspose = refLayerTranspose
  if 69 - 69: ooOOO + oOO * Ii
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 56 - 56: ooo000 - Ooo0Ooo + IiI11Ii111 / Ii
  if 86 - 86: i1iiIII111 - ooo000 . i1i1i1111I + ooo000 / ooOOO + IIiIIiIi11I1
  if 26 - 26: ooOOO . i1i1i1111I / Oo + IiIIii11Ii
  if 19 - 19: iI1iII1I1I1i % iI1iII1I1I1i
  if 97 - 97: Ii - Iii1i . I11iiIi11i1I % ooOOO + IiIIii11Ii
  if 8 - 8: IiI11Ii111 * i1iiIII111 / IIiIIiIi11I1 * ooo000
  if 31 - 31: I11iiIi11i1I / Oo * I1I / oOo0O00 + I1I * I1I
  if 56 - 56: ooo000
  if 20 - 20: I1I
  if 64 - 64: OooOoo . Ii * IIiIIiIi11I1 * Ii
  if 58 - 58: i1 - ooo000
  if 54 - 54: i1 . Ooo0Ooo . iI1iII1I1I1i % Iii1i - iI1iII1I1I1i
  if 92 - 92: ooOOO . Ooo0Ooo - Ii . i1iiIII111 + i1I
  if 98 - 98: i1i1i1111I * i1I
  if 75 - 75: I1I % ooOOO + IiI11Ii111
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 91 - 91: ooo000 . IiIIii11Ii . Ii % oOO / iI1iII1I1I1i
   if 79 - 79: OooOoo % I1Ii1I1 - i1iiIII111 / i1iiIII111 + oOo0O00 - Oo
  OoOO , OoooOO0 = [ ] , [ ]
  if self . refLayerName is not None :
   oO00oOooO0O = 'self.%s = self.%s' % ( self . name , self . refLayerName )
  else :
   oO00oOooO0O = 'self.%s = %s()' % ( self . name , self . name )
  OoOO . append ( oO00oOooO0O )
  if 80 - 80: IiIIii11Ii * Ii * I11iiIi11i1I
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  II = self . subModelNodes [ - 1 ] . shape
  if 82 - 82: Ooo0Ooo . Iii1i - Ooo0Ooo / ooOOO / Iii1i
  return OoOO , OoooOO0 , output_reg , II
  if 75 - 75: ooo000 . Ooo0Ooo . I1I % i1 . i1 / ooo000
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 26 - 26: I1Ii1I1 + Iii1i % ooOOO
  if 86 - 86: I1Ii1I1 / ooo000
  if 33 - 33: IiIIii11Ii + Oo % ooo000
  if 39 - 39: Ooo0Ooo + i1iiIII111 . I11iiIi11i1I / oOO - Oo
  if 42 - 42: IiIIii11Ii . iI1iII1I1I1i - Iii1i + IIiIIiIi11I1 * i1I
  if 33 - 33: iI1iII1I1I1i . IiI11Ii111 * Iii1i * Iii1i - oOO
  if 13 - 13: iI1iII1I1I1i + Ii
  if 51 - 51: OooOoo
  if 90 - 90: I1Ii1I1 % ooOOO / i1I % iI1iII1I1I1i * i1i1i1111I
  if 40 - 40: Ooo0Ooo . IiIIii11Ii - ooo000 % i1iiIII111
  if 5 - 5: Iii1i
  if 24 - 24: i1I
  if 96 - 96: iI1iII1I1I1i % Ooo0Ooo * iI1iII1I1I1i + Iii1i
  if 84 - 84: oOO * Iii1i - i1i1i1111I
  if 52 - 52: i1i1i1111I - oOo0O00 / Ooo0Ooo
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  II = self . _shape [ 0 ]
  iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 53 - 53: Ooo0Ooo + i1I
 def keras_group ( self , buildNo = 0 , train = None ) :
  if 45 - 45: OooOoo
  if 48 - 48: Ooo0Ooo
  if 18 - 18: Iii1i * ooo000 / ooOOO . OooOoo / I11iiIi11i1I
  if 85 - 85: oOo0O00 - i1I - IIiIIiIi11I1
  if 67 - 67: I1I . I11iiIi11i1I - i1i1i1111I
  if 78 - 78: Iii1i % ooOOO * ooOOO
  if 94 - 94: i1iiIII111 / oOO * Ii . OooOoo
  if 58 - 58: i1i1i1111I % iI1iII1I1I1i
  if 14 - 14: Oo . Oo / I1Ii1I1
  if 79 - 79: IiIIii11Ii
  if 67 - 67: I11iiIi11i1I * i1i1i1111I + I1I % I1Ii1I1 - ooo000
  if 81 - 81: i1i1i1111I / oOo0O00 / ooOOO % Iii1i - I11iiIi11i1I - i1i1i1111I
  if 93 - 93: IiI11Ii111 / OooOoo + i1I . i1 * oOO
  if 44 - 44: I1Ii1I1 / IiI11Ii111
  self . layer_obj = [ ]
  self . call_obj = [ ]
  if self . refLayerName is not None :
   return [ ] , [ ]
  iIiiII = O0oO00000000 ( )
  iiiI1iIi1IIi1 = { }
  I1ii111 = [ ]
  I11IiiiII1iI1 = { }
  for oo00OOOO , O0Oo00o0 in self . sub_layer_dict . items ( ) :
   OoOooo = O0Oo00o0 . toNodes [ buildNo ]
   if 75 - 75: Oo . oOO
   if len ( OoOooo ) == 0 :
    I11IiiiII1iI1 [ oo00OOOO ] = - 1
   else :
    I11IiiiII1iI1 [ oo00OOOO ] = len ( OoOooo )
   try :
    iiiI1iIi1IIi1 [ O0Oo00o0 . _order [ buildNo ] ] . append ( oo00OOOO )
   except :
    iiiI1iIi1IIi1 [ O0Oo00o0 . _order [ buildNo ] ] = [ oo00OOOO ]
    if 72 - 72: Ooo0Ooo . IiI11Ii111 * oOO * I1I
  for oo00OOOO , O0Oo00o0 in iiiI1iIi1IIi1 . items ( ) :
   I1ii111 . append ( oo00OOOO )
  I1ii111 . sort ( )
  print ( 'group connect' )
  if 19 - 19: ooOOO / i1i1i1111I . ooo000 . I11iiIi11i1I / Iii1i
  for IiIii1i1II in I1ii111 :
   for Iii111iII in iiiI1iIi1IIi1 [ IiIii1i1II ] :
    O0Oo00o0 = self . sub_layer_dict [ Iii111iII ]
    if 45 - 45: i1iiIII111 . IiIIii11Ii - i1 + Iii1i + OooOoo . Ooo0Ooo
    ooOoOOOo , O0o00 = [ ] , [ ]
    o0OIi1i1I1i1iiiI , o0OOOoOOoo0OOo0o = [ ] , [ ]
    if 12 - 12: i1I
    if 21 - 21: IIiIIiIi11I1
    for I1IIII1Ii1 in O0Oo00o0 . fromSource [ buildNo ] :
     Oo0ooOo0o = [ x if x != 'None' else None for x in train . dppNodes [ I1IIII1Ii1 ] . getShape ( False ) ]
     ooOoOOOo . append ( Oo0ooOo0o )
     if I1IIII1Ii1 in iIiiII . name_to_reg :
      OOO = iIiiII . get_register ( I1IIII1Ii1 )
     else :
      OOO = iIiiII . get_register ( I1IIII1Ii1 )
      if 64 - 64: i1 * IIiIIiIi11I1 * IIiIIiIi11I1 / IiIIii11Ii / Iii1i % ooo000
      if 25 - 25: i1 % I1Ii1I1 . Oo
      self . call_obj . append ( '%s = x' % OOO )
      if 90 - 90: Ii . IiI11Ii111 . IiI11Ii111
      if 78 - 78: I1Ii1I1
     o0OIi1i1I1i1iiiI . append ( OOO )
     if 80 - 80: I1Ii1I1 % ooOOO * Ooo0Ooo % I1I . i1i1i1111I
    for ooOoOOoo00 in O0Oo00o0 . fromNodes [ buildNo ] :
     ooOoOOoo00 = ooOoOOoo00 . replace ( ' ' , '' )
     try :
      ooOoOOoo00 = self . sub_layer_dict [ ooOoOOoo00 ]
      Oo0ooOo0o = [ x if x != 'None' else None for x in ooOoOOoo00 . _shape [ buildNo ] ]
      O0o00 . append ( Oo0ooOo0o )
      OOO = iIiiII . get_register ( ooOoOOoo00 . name )
      I11IiiiII1iI1 [ ooOoOOoo00 . name ] -= 1
      if I11IiiiII1iI1 [ ooOoOOoo00 . name ] == 0 :
       iIiiII . free_register ( ooOoOOoo00 . name )
      o0OOOoOOoo0OOo0o . append ( OOO )
     except :
      ooOoOOoo00 = train . modelNodes [ ooOoOOoo00 ]
      Oo0ooOo0o = [ x if x != 'None' else None for x in ooOoOOoo00 . _shape [ buildNo ] ]
      O0o00 . append ( Oo0ooOo0o )
      OOO = iIiiII . get_register ( ooOoOOoo00 . name )
      self . call_obj . append ( '%s = x' % OOO )
      if 13 - 13: I1I
      o0OOOoOOoo0OOo0o . append ( OOO )
      if 42 - 42: iI1iII1I1I1i . i1i1i1111I - i1I . I1Ii1I1 . Ii
    iIiiII . get_register ( Iii111iII )
    O0o0O0O0Oo00 = iIiiII . get_register ( Iii111iII )
    if 39 - 39: i1iiIII111 / ooOOO * ooo000
    Oo0ooOo0o , Iii11iii , ooO0OOo0 , I11 = O0Oo00o0 . keras_call_combineIncomingTensors ( ooOoOOOo , O0o00 , o0OIi1i1I1i1iiiI , o0OOOoOOoo0OOo0o , O0o0O0O0Oo00 )
    if 91 - 91: iI1iII1I1I1i
    for string in Iii11iii :
     self . layer_obj . append ( string )
    for string in ooO0OOo0 :
     self . call_obj . append ( string )
     if 64 - 64: I1I / I11iiIi11i1I - Ooo0Ooo / oOo0O00 . oOo0O00
    OOOOooo , iI111IIi , OoO00ooOO , II = O0Oo00o0 . keras_call_auto_reshape_build ( Oo0ooOo0o , I11 , O0o0O0O0Oo00 )
    for string in OOOOooo :
     self . layer_obj . append ( string )
    for string in iI111IIi :
     self . call_obj . append ( string )
     if 17 - 17: ooo000 . I1I + IIiIIiIi11I1 % ooOOO % ooOOO
    oO00oOooO0O , OoO0O0oOoO , O0o0Ii , II = O0Oo00o0 . keras_call_layer_build ( OoO00ooOO , O0o0O0O0Oo00 , II )
    for string in OoO0O0oOoO :
     if string != '' :
      self . call_obj . append ( string )
    for string in oO00oOooO0O :
     self . layer_obj . append ( string )
     if 25 - 25: I11iiIi11i1I
    oO00oOooO0O , OoO0O0oOoO = O0Oo00o0 . keras_call_processOutputTensor ( II , O0o0Ii , O0o0O0O0Oo00 )
    for string in OoO0O0oOoO :
     if string != '' :
      self . call_obj . append ( string )
    for string in oO00oOooO0O :
     self . layer_obj . append ( string )
    if O0Oo00o0 . toNodes [ buildNo ] [ 0 ] . replace ( ' ' , '' ) not in self . sub_layer_dict . keys ( ) :
     self . call_obj . append ( 'return %s' % O0o0O0O0Oo00 )
     if 95 - 95: i1i1i1111I * I1Ii1I1 / i1I * I1I + IiI11Ii111
     if 57 - 57: i1iiIII111
  return self . layer_obj , self . call_obj
  if 5 - 5: Ii
class iIiI1i111ii ( oO00ooO00oOO0 ) :
 if 73 - 73: Oo . IIiIIiIi11I1 - ooOOO
 if 80 - 80: i1I . I11iiIi11i1I / OooOoo / i1I + Oo + Oo
 if 1 - 1: Ooo0Ooo * iI1iII1I1I1i * I1Ii1I1 . IiI11Ii111 + i1i1i1111I
 if 10 - 10: IiI11Ii111 % oOo0O00 / iI1iII1I1I1i * oOO
 if 99 - 99: Ooo0Ooo - IiI11Ii111 / ooOOO - ooo000
 if 57 - 57: Iii1i / iI1iII1I1I1i * Oo / IIiIIiIi11I1 * oOO
 if 23 - 23: i1I
 class Types ( II1i1I ) :
  if 90 - 90: IIiIIiIi11I1 / Iii1i % Ii * I11iiIi11i1I - ooOOO * ooo000
  if 38 - 38: IIiIIiIi11I1 % i1
  if 39 - 39: iI1iII1I1I1i * I1I - IiIIii11Ii
  if 66 - 66: I1I - i1i1i1111I . I1I . oOo0O00 + IiI11Ii111 * I1Ii1I1
  if 41 - 41: IIiIIiIi11I1 - i1iiIII111 + oOo0O00 - i1 + Oo
  if 27 - 27: Oo % IiIIii11Ii
  if 50 - 50: I1I
  if 54 - 54: i1 / OooOoo / Ii % oOo0O00 * Ooo0Ooo
  Max = 1
  if 1 - 1: ooo000 + iI1iII1I1I1i * Ii + OooOoo - oOo0O00
  if 100 - 100: Oo . IIiIIiIi11I1 % IiI11Ii111 % IIiIIiIi11I1 % Oo
  Average = 2
  if 63 - 63: oOO . oOO + i1iiIII111 . I1Ii1I1 * IIiIIiIi11I1
 def __init__ ( self , name : str = None , poolingType : 'ModelNode.Layer.Pool.Types' = Types . Max , sameForAllDimensions : bool = True ,
 windowWidth : Union [ int , List [ int ] ] = 3 , strides : Union [ int , List [ int ] ] = 1 , dilations : Union [ int , List [ int ] ] = 1 , poolPadding : bool = False ,
 reshape : List [ int ] = None ,
 incomingConfig : 'ModelNode.Layer.Incoming.Config' = i1iIi1i1i1I1 . Concat ( ) ,
 linearTransform : 'Train.Variable.LinearTransform' = i11i111iI . LinearTransform . createBasicConfig ( weightAvg = 0 , weightStdDev = 5e-2 , weightL1Loss = False , weightL2Loss = True , weightL2Decay = 0 , biasInitial = 0.001 ) ,
 activation : str = "relu" , activationParams : Dict = { } ,
 batchNorm : bool = True , batchNormParams : Dict = { } ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 58 - 58: i1i1i1111I . I1Ii1I1 + i1iiIII111 - Iii1i * I1I - Ooo0Ooo
  if 11 - 11: Ii / oOo0O00
  if 8 - 8: I1Ii1I1 / I1I / I1Ii1I1 - I11iiIi11i1I
  if 13 - 13: i1I * i1I - i1i1i1111I % i1i1i1111I . Iii1i / IIiIIiIi11I1
  if 30 - 30: i1i1i1111I - ooo000 % Oo - i1I
  if 57 - 57: IiI11Ii111 - I11iiIi11i1I - ooo000 . ooo000 / ooo000
  if 63 - 63: ooOOO
  if 9 - 9: I1Ii1I1 % IiIIii11Ii - IIiIIiIi11I1 % Ii
  if 7 - 7: I1Ii1I1 / OooOoo . i1i1i1111I - OooOoo
  if 11 - 11: IiI11Ii111 . Iii1i - IiI11Ii111
  if 52 - 52: i1 - Oo
  if 55 - 55: ooOOO / IiI11Ii111 % oOO / ooOOO
  if 19 - 19: I11iiIi11i1I - i1i1i1111I - I11iiIi11i1I - ooOOO
  if 2 - 2: oOO + Oo + OooOoo
  if 3 - 3: OooOoo . ooo000 * IIiIIiIi11I1 % i1
  if 61 - 61: Oo
  if 35 - 35: I11iiIi11i1I % IIiIIiIi11I1 - Oo
  if 90 - 90: I11iiIi11i1I + IiI11Ii111 * OooOoo * oOO - OooOoo . IiIIii11Ii
  if 77 - 77: I1I / i1I * i1I * i1I . IIiIIiIi11I1
  if 93 - 93: I1I % I11iiIi11i1I - ooOOO - Oo / i1i1i1111I + i1i1i1111I
  if 94 - 94: ooo000 * i1i1i1111I
  if 1 - 1: i1i1i1111I * OooOoo * OooOoo % IIiIIiIi11I1 - i1iiIII111
  if 49 - 49: I1I + i1I % I1I % Ooo0Ooo - iI1iII1I1I1i * i1
  if 21 - 21: I1Ii1I1 + Ooo0Ooo - iI1iII1I1I1i - I1I
  super ( ) . __init__ ( o00OoOo0O0O00 . Convolution1D , name = name , final = False ,
 incomingConfig = incomingConfig , linearTransform = linearTransform ,
 activation = activation , activationParams = activationParams ,
 batchNorm = batchNorm , batchNormParams = batchNormParams ,
 outputConfig = outputConfig )
  if 4 - 4: ooOOO
  if 18 - 18: OooOoo + IIiIIiIi11I1
  self . poolingType = poolingType
  if 87 - 87: ooOOO * oOo0O00 / iI1iII1I1I1i . ooo000 . OooOoo
  self . sameForAllDimensions = sameForAllDimensions
  if 99 - 99: ooo000 - ooOOO - I11iiIi11i1I - oOo0O00 * Ooo0Ooo % Iii1i
  self . windowWidth = windowWidth
  if 83 - 83: ooOOO - i1 . i1i1i1111I
  self . poolPadding = poolPadding
  if 91 - 91: ooo000
  self . strides = strides
  if 52 - 52: OooOoo . IIiIIiIi11I1 % IiI11Ii111 / oOo0O00
  self . dilations = dilations
  if 43 - 43: I1I
  self . reshape = reshape
  if 94 - 94: Iii1i - i1I % Ii
 def enumParser ( self , k : str , v : Any ) -> Any :
  if 10 - 10: I11iiIi11i1I + ooo000 . i1i1i1111I % Ooo0Ooo . i1iiIII111 * i1I
  if 96 - 96: Iii1i * ooo000 / I1I
  if 88 - 88: I1Ii1I1 - i1
  if 61 - 61: i1iiIII111 . oOo0O00 * I1I
  if 20 - 20: Ooo0Ooo * Iii1i
  if 21 - 21: ooOOO % I1Ii1I1 - Ii + ooo000
  if 89 - 89: iI1iII1I1I1i / IiI11Ii111 + ooOOO * IiIIii11Ii * I11iiIi11i1I
  if 62 - 62: OooOoo . Iii1i / i1i1i1111I - i1iiIII111 . oOo0O00 - Ii
  if 95 - 95: Ooo0Ooo
  if 58 - 58: IiIIii11Ii . ooo000 % IIiIIiIi11I1
  if 79 - 79: OooOoo * Iii1i + oOO
  if 64 - 64: Oo + IiIIii11Ii + iI1iII1I1I1i . IIiIIiIi11I1 + ooOOO - oOo0O00
  if 74 - 74: i1 * I1Ii1I1 % oOo0O00 . oOO
  if 16 - 16: oOo0O00 - ooOOO / Ii * I1I + ooo000
  if k == "poolingType" :
   if isinstance ( v , str ) :
    return getattr ( iIiI1i111ii . Types , v )
   else :
    return getattr ( iIiI1i111ii . Types , iIiI1i111ii . Types . getName ( v ) )
  else :
   return v
   if 47 - 47: i1iiIII111 * i1I . i1i1i1111I
 def _copySymmetricLayerConfig ( self , useSymmetricWeights = True , buildNo : int = 0 ) -> 'ModelNode.Layer.Pool' :
  if 92 - 92: Ii . I1Ii1I1 * OooOoo * OooOoo
  if 55 - 55: Ooo0Ooo + IiI11Ii111 - I1Ii1I1 % ooo000 - oOo0O00 / i1
  if 36 - 36: Oo * oOO - i1i1i1111I * I11iiIi11i1I + Ii * oOO
  if 79 - 79: IiIIii11Ii - oOO * Oo - Ooo0Ooo + OooOoo % Oo
  if 89 - 89: i1I
  if 29 - 29: oOO - IiIIii11Ii - ooOOO - I1Ii1I1 . I11iiIi11i1I / IIiIIiIi11I1
  if 55 - 55: ooOOO . oOo0O00 + i1i1i1111I - oOO
  if 50 - 50: i1i1i1111I + IiI11Ii111 / ooOOO . oOO . Ii
  if 65 - 65: I11iiIi11i1I / i1 * i1iiIII111 + IIiIIiIi11I1
  if 13 - 13: iI1iII1I1I1i / i1I . I1I
  if 11 - 11: I1Ii1I1 . i1i1i1111I * i1iiIII111 / i1I * i1iiIII111
  if 30 - 30: OooOoo / oOo0O00 * Oo
  if 22 - 22: ooo000 - I1Ii1I1 * Ii * Ooo0Ooo
  if 72 - 72: Ooo0Ooo - IiI11Ii111 . Iii1i
  raise ValueError ( "Pool layer is not able to be copied in a symmetric way." )
  if 91 - 91: oOO % i1iiIII111
 def copy ( self , name : str ) -> 'ModelNode.Layer.Pool' :
  if 39 - 39: i1i1i1111I
  if 10 - 10: OooOoo . i1i1i1111I . Ii + ooo000 / i1iiIII111 . IiIIii11Ii
  if 33 - 33: iI1iII1I1I1i / iI1iII1I1I1i * i1i1i1111I * ooOOO * Ii . oOo0O00
  if 46 - 46: oOO % IIiIIiIi11I1
  if 53 - 53: Ooo0Ooo * I11iiIi11i1I % Iii1i
  if 80 - 80: ooOOO
  if 80 - 80: OooOoo + Iii1i - Oo + I11iiIi11i1I * oOo0O00 + ooo000
  if 36 - 36: I1I
  if 63 - 63: Oo % Oo
  if 17 - 17: i1i1i1111I / oOo0O00
  if 34 - 34: ooo000 % Ooo0Ooo / I11iiIi11i1I - I1Ii1I1 . IiI11Ii111
  if not isinstance ( self , iIiI1i111ii ) :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 41 - 41: oOO + i1I + IiI11Ii111
   if 58 - 58: Ooo0Ooo / IIiIIiIi11I1 + Ii
  return iIiI1i111ii ( name = name ,
 poolingType = self . poolingType , sameForAllDimensions = self . sameForAllDimensions , windowWidth = self . windowWidth ,
 poolPadding = self . poolPadding , strides = self . strides , dilations = self . dilations , reshape = self . reshape ,
 incomingConfig = self . incomingConfig , linearTransform = self . linearTransform ,
 activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , batchNormParams = self . batchNormParams ,
 outputConfig = self . outputConfig )
  if 8 - 8: OooOoo - oOo0O00 % oOo0O00
 def _build ( self , buildNo : int ) :
  if 25 - 25: Ii % oOO
  if 12 - 12: Ooo0Ooo . IiI11Ii111 . I1Ii1I1 - i1 % i1iiIII111 % Ooo0Ooo
  if 12 - 12: i1i1i1111I - i1iiIII111
  if 14 - 14: Iii1i
  if 27 - 27: i1I + OooOoo * OooOoo . Iii1i
  if 80 - 80: I11iiIi11i1I % Ii - IIiIIiIi11I1 . iI1iII1I1I1i
  if 88 - 88: i1i1i1111I - IiIIii11Ii + i1iiIII111
  if 50 - 50: I1I * i1I
  if 88 - 88: Ooo0Ooo - Ooo0Ooo + IiI11Ii111
  if 9 - 9: i1iiIII111 + I11iiIi11i1I - IiI11Ii111 + Iii1i * i1iiIII111 % Oo
  self . _clearTempTensors ( )
  if 78 - 78: Iii1i % i1iiIII111 % IiI11Ii111 % IiIIii11Ii . Iii1i - I1I
  if 17 - 17: OooOoo - i1iiIII111 * Oo * Ii
  if all ( [ i11II . _built for i11II in self . fromNode [ buildNo ] ] ) :
   if 30 - 30: IiIIii11Ii
   with tf . compat . v1 . variable_scope ( self . name , reuse = tf . compat . v1 . AUTO_REUSE ) as o0oOOOoO0ooO0o0 :
    if 32 - 32: I11iiIi11i1I
    O00o = self . _combineIncomingTensors ( buildNo = buildNo )
    II11i11 = [ * O00o . shape ]
    if 60 - 60: i1
    if 30 - 30: I1Ii1I1
    if len ( II11i11 ) <= 2 :
     raise ValueError ( "Pooling layer must be taken on input with at least 3 dimensions." )
     if 36 - 36: IIiIIiIi11I1 - IiI11Ii111 - Ooo0Ooo * oOO
     if 84 - 84: Iii1i - oOo0O00 - Ii . Ii % IiI11Ii111
    i1i111IIi = ( len ( II11i11 ) - 2 ) if self . sameForAllDimensions else len ( self . windowWidth )
    if len ( II11i11 ) != i1i111IIi + 2 :
     II111 = self . reshape
     if II111 is None :
      if 23 - 23: i1iiIII111 % Oo + i1iiIII111
      if len ( II11i11 ) > i1i111IIi + 2 :
       if 81 - 81: I1I . I1I + i1I + i1i1i1111I
       I11II = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , II11i11 [ i1i111IIi + 1 : ] , 1 )
       O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape [ : i1i111IIi + 1 ] ) , I11II ] )
       II11i11 = [ * O00o . shape ]
       if 57 - 57: Ii
      elif len ( II11i11 ) == i1i111IIi + 1 :
       if 7 - 7: i1iiIII111 * IIiIIiIi11I1
       O00o = tf . reshape ( O00o , [ * i11i111iI . setAsReshape ( O00o . shape ) , 1 ] )
       II11i11 = [ * O00o . shape ]
       if 81 - 81: i1iiIII111
      elif len ( II11i11 ) <= i1i111IIi :
       raise ValueError ( "The incoming data dimension is not supported for this pooling layer." )
     else :
      if 69 - 69: i1 * oOo0O00
      OoO0oOOo = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , [ s for s in II11i11 [ 1 : ] ] , 1 )
      OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , II111 , 1 )
      if OoO0oOOo != OOo00oOOO :
       raise ValueError ( "Unable to reshape to specified shape." )
      elif len ( II111 ) != i1i111IIi + 1 :
       raise ValueError ( "The pooling reshape should be the same as the target pooling spatial dimension length." )
       if 76 - 76: IIiIIiIi11I1 / IIiIIiIi11I1 + IiIIii11Ii
       if 8 - 8: ooo000 / i1iiIII111 % i1I / IiI11Ii111
      O00o = tf . reshape ( O00o , [ - 1 , * II111 ] )
      II11i11 = [ * O00o . shape ]
      if 89 - 89: ooo000 % I1I
      if 49 - 49: i1 * i1i1i1111I + IiIIii11Ii . IiIIii11Ii / Ooo0Ooo
    oOOoOOo0ooOO = self . windowWidth
    IIIiI1iI1iI = self . strides
    Ii1iii11 = self . dilations
    if 19 - 19: ooOOO / i1i1i1111I . IIiIIiIi11I1 - IiIIii11Ii . I1I + Ooo0Ooo
    if 63 - 63: IIiIIiIi11I1 . oOo0O00
    if self . sameForAllDimensions :
     oOOoOOo0ooOO = [ oOOoOOo0ooOO for i in range ( 0 , len ( II11i11 ) - 2 ) ]
     IIIiI1iI1iI = [ IIIiI1iI1iI for i in range ( 0 , len ( II11i11 ) - 2 ) ]
     Ii1iii11 = [ Ii1iii11 for i in range ( 0 , len ( II11i11 ) - 2 ) ]
     if 21 - 21: Oo
     if 44 - 44: i1I . I1Ii1I1
    with tf . device ( self . train . device ) :
     O0oO000OOoooo0OO = tf . nn . pool ( O00o , oOOoOOo0ooOO , [ "MAX" , "AVG" ] [ self . poolingType . value - 1 ] ,
 strides = IIIiI1iI1iI , padding = ( 'SAME' if self . poolPadding else 'VALID' ) , dilations = Ii1iii11 )
     if 56 - 56: i1 % Iii1i - i1I % Ii - I1I - IiI11Ii111
     if 80 - 80: Oo + i1i1i1111I / Iii1i
    O0oO000OOoooo0OO = self . _commonLayerOps ( O0oO000OOoooo0OO )
    if 31 - 31: oOO % oOO - Ooo0Ooo % i1iiIII111 / oOo0O00 % Oo
    if 19 - 19: IIiIIiIi11I1 . IiIIii11Ii
    self . _outputTensor = self . _processOutputTensor ( O0oO000OOoooo0OO )
    if 49 - 49: i1iiIII111 + iI1iII1I1I1i / IIiIIiIi11I1 * Ii
   self . _built = True
   if 78 - 78: OooOoo + IiIIii11Ii / I1I - I11iiIi11i1I
   if 100 - 100: Ooo0Ooo . I1I . Oo
   for i11II in self . toNode [ buildNo ] :
    i11II . _build ( buildNo )
    if 20 - 20: IiI11Ii111
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 11 - 11: OooOoo + I1I * oOO
  if 11 - 11: ooOOO + i1 . OooOoo
  if 62 - 62: Oo + ooOOO + ooOOO - OooOoo / IiIIii11Ii + i1I
  if 18 - 18: i1i1i1111I - IiI11Ii111
  if 24 - 24: IIiIIiIi11I1 . ooOOO + Oo . I11iiIi11i1I + I1Ii1I1 - IiI11Ii111
  if 86 - 86: I11iiIi11i1I - OooOoo / I11iiIi11i1I * i1iiIII111 + I11iiIi11i1I / Oo
  if 97 - 97: Oo % Ooo0Ooo
  if 56 - 56: ooOOO
  if 90 - 90: Iii1i
  if 95 - 95: i1I % Ooo0Ooo / iI1iII1I1I1i % i1i1i1111I . IIiIIiIi11I1
  if 19 - 19: IiIIii11Ii
  if 89 - 89: oOO
  if 34 - 34: oOo0O00 - Ii + Ii . ooOOO + i1 * i1i1i1111I
  if 86 - 86: I1Ii1I1 / Ooo0Ooo
  if 39 - 39: i1 / iI1iII1I1I1i / oOo0O00 / oOo0O00 * IiIIii11Ii
  if 5 - 5: i1I % I1I
  O0O00Oo0 = self . windowWidth
  IIIiI1iI1iI = self . strides
  Ii1iii11 = self . dilations
  if 25 - 25: I1I + IIiIIiIi11I1
  if 61 - 61: I1Ii1I1 + Ooo0Ooo / i1i1i1111I - oOo0O00 - ooOOO % i1
  if self . sameForAllDimensions :
   O0O00Oo0 = [ O0O00Oo0 for IiIIiiII in range ( 0 , len ( inputshape ) - 2 ) ]
   IIIiI1iI1iI = [ IIIiI1iI1iI for IiIIiiII in range ( 0 , len ( inputshape ) - 2 ) ]
   Ii1iii11 = [ Ii1iii11 for IiIIiiII in range ( 0 , len ( inputshape ) - 2 ) ]
   if 98 - 98: oOo0O00 . oOo0O00 + ooo000
  IIoOOO00O00o = [ "MAX" , "AVG" ] [ self . poolingType . value - 1 ]
  ii1 = 'SAME' if self . poolPadding else 'VALID'
  if 94 - 94: i1I % i1 . IIiIIiIi11I1 + ooOOO - IiI11Ii111 + i1I
  def oo0o0OoOO ( L , S , K , P ) :
   return int ( ( ( L - K + 2 * P ) / S + 1 ) )
   if 45 - 45: I1I + IiI11Ii111 * Oo . i1 . Ii
   if 69 - 69: i1i1i1111I / I1Ii1I1
   if 14 - 14: iI1iII1I1I1i . OooOoo - i1i1i1111I + i1I
   if 59 - 59: Oo * Iii1i
   if 19 - 19: IiI11Ii111 * i1 % Oo / Ooo0Ooo / OooOoo + I11iiIi11i1I
   if 13 - 13: Ii
   if 57 - 57: oOO % oOO % IIiIIiIi11I1
  iI1IiIi = [ ]
  for IiIIiiII , iIIII11iIi in enumerate ( O0O00Oo0 ) :
   if self . poolPadding == 'SAME' :
    I11i1I1I11 = ( O0O00Oo0 [ IiIIiiII ] - 1 ) / 2
   else :
    I11i1I1I11 = 0
   Ii1I = O0O00Oo0 [ IiIIiiII ] + ( O0O00Oo0 [ IiIIiiII ] - 1 ) * ( Ii1iii11 [ IiIIiiII ] - 1 )
   iI1IiIi . append ( oo0o0OoOO ( inputshape [ 1 + IiIIiiII ] , IIIiI1iI1iI [ IiIIiiII ] , Ii1I , I11i1I1I11 ) )
   if 80 - 80: OooOoo - OooOoo
  II = [ None , * iI1IiIi , self . layerUnits ]
  if 31 - 31: I1I % ooo000
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 36 - 36: IiIIii11Ii % i1I + oOo0O00 * Ooo0Ooo
  OoOO , OoooOO0 = [ ] , [ ]
  if 47 - 47: OooOoo % IiIIii11Ii . I11iiIi11i1I + I11iiIi11i1I % Ii + iI1iII1I1I1i
  if 28 - 28: iI1iII1I1I1i + IiI11Ii111
  Ii1I1iIiiiI = '%s = tf.nn.pool(%s, %s, "%s", strides=%s, padding="%s", dilations=%s)' % ( I1111iiI , oO , O0O00Oo0 , IIoOOO00O00o , IIIiI1iI1iI , ii1 , Ii1iii11 )
  if 12 - 12: IiI11Ii111 / Ii * IIiIIiIi11I1 - I1Ii1I1
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 54 - 54: IiIIii11Ii / I1I / Ii / IiI11Ii111 % ooo000
  if 54 - 54: OooOoo - i1iiIII111
  if self . activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'tf.nn.hard_sigmoid'
  else :
   I11i1I11IiII = 'tf.nn.' + self . activation . name . lower ( )
   if 5 - 5: i1i1i1111I . Ii / oOO . oOo0O00
  if self . activation != iI11II1 . Linear :
   iiII1I1iIi = output_reg
   Ii1I1iIiiiI = '%s = %s(%s)' % ( I1111iiI , I11i1I11IiII , I1111iiI )
   OoooOO0 . append ( Ii1I1iIiiiI )
   if 6 - 6: I11iiIi11i1I + I1Ii1I1 % OooOoo / IIiIIiIi11I1
   if 17 - 17: I11iiIi11i1I + i1I + i1 % IIiIIiIi11I1 . i1iiIII111 % I11iiIi11i1I
  if self . dropout < 100 :
   i1oOo0oO0 = ( 100 - self . dropout ) / 100
   OoOO . append ( 'self.%s_dp = tf.keras.layers.Dropout(%g)' % ( self . name , i1oOo0oO0 ) )
   OoooOO0 . append ( '%s = self.%s_dp(%s)' % ( I1111iiI , self . name , I1111iiI ) )
   if 61 - 61: IIiIIiIi11I1 * ooOOO / IiIIii11Ii . oOO / ooo000
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 62 - 62: iI1iII1I1I1i - Iii1i - I1I * I1I - i1I - ooo000
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 61 - 61: Ii % I1I
  if 53 - 53: i1I . i1I % ooo000 + IiIIii11Ii
  if 5 - 5: I1Ii1I1
  if 25 - 25: I11iiIi11i1I - I1Ii1I1 / I1I
  if 82 - 82: IiI11Ii111 + iI1iII1I1I1i * oOO . oOo0O00 / Ii
  if 56 - 56: OooOoo - IiI11Ii111
  if 48 - 48: ooo000 / oOo0O00 + ooOOO . IIiIIiIi11I1 % iI1iII1I1I1i - oOo0O00
  if 44 - 44: i1I * Oo + oOO % ooo000 / I11iiIi11i1I
  if 97 - 97: oOO . I11iiIi11i1I % Ii % I1I % Iii1i / iI1iII1I1I1i
  if 77 - 77: oOo0O00 + I11iiIi11i1I * IIiIIiIi11I1 . IiIIii11Ii
  if 46 - 46: i1 + IiI11Ii111
  if 9 - 9: IiIIii11Ii / OooOoo + Iii1i + I1I . oOO . i1I
  if 89 - 89: IIiIIiIi11I1 / Ii - I1Ii1I1 * IIiIIiIi11I1
  if 67 - 67: I1I . OooOoo / i1iiIII111 . I11iiIi11i1I
  if 99 - 99: ooo000 * I1I
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 6 - 6: IiI11Ii111 * OooOoo
  OOo0OoO00 = ( len ( input_shape ) - 2 ) if self . sameForAllDimensions else len ( self . windowWidth )
  if 80 - 80: i1 % ooo000 / oOO / Oo * iI1iII1I1I1i
  if len ( input_shape ) != OOo0OoO00 + 2 :
   if self . reshape == None :
    if len ( input_shape ) > OOo0OoO00 + 2 :
     iiI1i11Ii11I1 = OOo0OoO00 + 1
     II = input_shape [ 0 : iiI1i11Ii11I1 ]
     II . append ( functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ iiI1i11Ii11I1 : ] , 1 ) )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) == OOo0OoO00 + 1 :
     II = input_shape . copy ( )
     II . append ( 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    elif len ( input_shape ) <= OOo0OoO00 :
     raise ValueError ( "The incoming data dimension is not supported for this pooling layer." )
   else :
    OoO0oOOo = functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O * oOO0OooooooO , input_shape [ 1 : ] , 1 )
    OOo00oOOO = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , self . reshape , 1 )
    if OoO0oOOo != OOo00oOOO :
     raise ValueError ( "Unable to reshape to specified shape." )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ str ( int ( x ) ) for x in list ( self . reshape ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 94 - 94: Ooo0Ooo . i1I . oOo0O00
class o00o00O000 :
 if 89 - 89: i1 . i1I . Oo
 if 99 - 99: i1I / iI1iII1I1I1i - I1I
 if 100 - 100: iI1iII1I1I1i
 if 33 - 33: ooo000 % I1I * ooo000 % oOo0O00
 if 50 - 50: Ii
 if 96 - 96: Oo % iI1iII1I1I1i / IiI11Ii111 - ooOOO
 if 80 - 80: IIiIIiIi11I1
 def __init__ ( self , weightConfigs : 'VarConfig' = i11i111iI . Config ( ) , recurrentWeightConfigs : 'VarConfig' = i11i111iI . Config ( ) ,
 biasConfigs : 'VarConfig' = i11i111iI . Config ( ) ) :
  if 55 - 55: I11iiIi11i1I + oOO % I11iiIi11i1I
  if 17 - 17: i1i1i1111I % Ooo0Ooo
  if 92 - 92: Ii - oOo0O00
  if 80 - 80: oOo0O00
  if 83 - 83: I11iiIi11i1I
  if 98 - 98: OooOoo - i1 / I1I
  if 69 - 69: Oo / IIiIIiIi11I1 - i1I / Ii . iI1iII1I1I1i / OooOoo
  if 88 - 88: IIiIIiIi11I1 * i1I . ooOOO
  if 16 - 16: IiIIii11Ii % I1I . IIiIIiIi11I1 . i1iiIII111 + OooOoo + IiI11Ii111
  if 5 - 5: I1I . IiI11Ii111 + Iii1i / IIiIIiIi11I1 + Ii * oOO
  if 26 - 26: OooOoo * OooOoo * i1 - Iii1i * I1I
  if 7 - 7: i1 % IIiIIiIi11I1 * Ooo0Ooo . ooOOO
  self . weightConfig = weightConfigs
  self . recurrentWeightConfig = recurrentWeightConfigs
  self . biasConfig = biasConfigs
  if 19 - 19: ooOOO % ooo000 * OooOoo . IiIIii11Ii * IIiIIiIi11I1 * IiI11Ii111
 @ staticmethod
 def createBasicConfig ( ) -> 'RNNConfig' :
  if 69 - 69: Oo * I1Ii1I1 * I1I / Ooo0Ooo . I1I . Ii
  if 70 - 70: IiI11Ii111 % IiIIii11Ii / i1 - i1i1i1111I * oOo0O00 . Iii1i
  if 22 - 22: IiIIii11Ii . Ii / Iii1i % Ii + iI1iII1I1I1i / Ooo0Ooo
  if 10 - 10: oOO - I1Ii1I1 . I11iiIi11i1I * i1I
  if 32 - 32: i1 / ooOOO
  if 48 - 48: OooOoo / I1I * i1i1i1111I
  if 96 - 96: IIiIIiIi11I1 * Oo % I1Ii1I1 - Oo
  if 94 - 94: IIiIIiIi11I1 / IiIIii11Ii - Ooo0Ooo
  if 44 - 44: IIiIIiIi11I1 . OooOoo - ooOOO . Oo
  if 53 - 53: Ii + OooOoo
  IiiIiii1II = i11i111iI . Config ( initializer = i11i111iI . Initializer . GlorotUniform ( ) )
  Oooo00Oo0o = i11i111iI . Config ( initializer = i11i111iI . Initializer . Orthogonal ( ) )
  OoOo0OO = i11i111iI . Config ( initializer = i11i111iI . Initializer . Zeros ( ) )
  if 43 - 43: Iii1i - IiI11Ii111
  return o00o00O000 ( weightConfigs = IiiIiii1II , recurrentWeightConfigs = Oooo00Oo0o ,
 biasConfigs = OoOo0OO )
  if 20 - 20: I11iiIi11i1I * IIiIIiIi11I1
class iii1i1IIIi11 :
 if 73 - 73: oOo0O00 / IiIIii11Ii / i1i1i1111I
 if 64 - 64: Oo
 if 25 - 25: I11iiIi11i1I + i1i1i1111I % I1Ii1I1 * IiIIii11Ii . IiIIii11Ii + OooOoo
 if 34 - 34: IiI11Ii111 % Iii1i / IIiIIiIi11I1 % I1I . Iii1i
 if 98 - 98: ooo000
 if 12 - 12: Iii1i % i1i1i1111I + I1Ii1I1 . OooOoo . ooo000
 if 16 - 16: i1I
 class GRUVarConfigs :
  if 86 - 86: Iii1i * Oo - OooOoo . i1I * IIiIIiIi11I1 - ooOOO
  if 54 - 54: IIiIIiIi11I1 % I11iiIi11i1I - I1I . i1I + Oo / Ooo0Ooo
  if 30 - 30: I1I % oOo0O00 * i1 % IiIIii11Ii + oOo0O00 - i1I
  if 4 - 4: iI1iII1I1I1i + IIiIIiIi11I1 + IIiIIiIi11I1 . Oo - i1iiIII111
  if 43 - 43: I11iiIi11i1I + ooo000 % i1 + OooOoo
  if 20 - 20: ooo000 + ooo000 % Oo / Oo % oOO + IiI11Ii111
  if 79 - 79: i1I . I1I % I1Ii1I1 * ooo000
  def __init__ ( self , resetGate : 'VarConfig' = None , updateGate : 'VarConfig' = None , stateCandidate : 'VarConfig' = None ) :
   if 26 - 26: Ii / OooOoo % Ooo0Ooo
   if 21 - 21: oOo0O00
   if 66 - 66: Iii1i + Oo
   if 45 - 45: iI1iII1I1I1i . I1I
   if 70 - 70: Ii
   if 9 - 9: IiI11Ii111 % i1 - I1I * I1Ii1I1 * IIiIIiIi11I1 + Oo
   if 44 - 44: i1iiIII111 / i1I % IiI11Ii111 % ooo000 * i1 - IiI11Ii111
   if 8 - 8: ooo000 . i1I
   if 58 - 58: Oo % oOO
   if 100 - 100: oOO + Ii + i1 - i1 + i1i1i1111I
   if 74 - 74: oOO
   if 46 - 46: I1I - ooo000 + I11iiIi11i1I % Ooo0Ooo * iI1iII1I1I1i * i1iiIII111
   self . resetGate = resetGate
   self . updateGate = updateGate
   self . stateCandidate = stateCandidate
   if 88 - 88: IIiIIiIi11I1 % i1i1i1111I . oOo0O00 + OooOoo / IIiIIiIi11I1
 def __init__ ( self , weightConfigs : 'GRUVarConfigs' = GRUVarConfigs ( ) , recurrentWeightConfigs : 'GRUVarConfigs' = GRUVarConfigs ( ) ,
 biasConfigs : 'GRUVarConfigs' = GRUVarConfigs ( ) ) :
  if 6 - 6: IiIIii11Ii * IIiIIiIi11I1 + I1Ii1I1 - Ii . i1iiIII111
  if 89 - 89: oOO - I11iiIi11i1I
  if 93 - 93: oOO . Ooo0Ooo % i1 + i1 + oOO
  if 23 - 23: Oo
  if 70 - 70: Ooo0Ooo - i1i1i1111I - i1I / ooOOO
  if 84 - 84: i1i1i1111I * IiIIii11Ii . i1
  if 81 - 81: IiI11Ii111
  if 14 - 14: IIiIIiIi11I1 * Ii
  if 57 - 57: ooo000 - I1Ii1I1
  if 7 - 7: OooOoo * OooOoo - ooOOO + iI1iII1I1I1i
  if 2 - 2: Ooo0Ooo % ooOOO - Iii1i + i1i1i1111I - Ooo0Ooo
  if 19 - 19: OooOoo % IiIIii11Ii
  self . resetGateWeightConfig = weightConfigs . resetGate
  self . updateGateWeightConfig = weightConfigs . updateGate
  self . stateCandidateWeightConfig = weightConfigs . stateCandidate
  self . resetGateRecurrentWeightConfig = recurrentWeightConfigs . resetGate
  self . updateGateRecurrentWeightConfig = recurrentWeightConfigs . updateGate
  self . stateCandidateRecurrentWeightConfig = recurrentWeightConfigs . stateCandidate
  self . resetGateBiasConfig = biasConfigs . resetGate
  self . updateGateBiasConfig = biasConfigs . updateGate
  self . stateCandidateBiasConfig = biasConfigs . stateCandidate
  if 18 - 18: IiIIii11Ii * IiIIii11Ii * iI1iII1I1I1i + i1iiIII111
 @ staticmethod
 def createBasicConfig ( ) -> 'GRUConfig' :
  if 57 - 57: I11iiIi11i1I * Oo . Iii1i / Ii
  if 46 - 46: i1iiIII111 + i1 + ooOOO . Iii1i
  if 62 - 62: I1I + IiI11Ii111 * I11iiIi11i1I / I1Ii1I1 - iI1iII1I1I1i * Iii1i
  if 61 - 61: IiI11Ii111 + I1I * IiIIii11Ii / I1Ii1I1 % I1Ii1I1 + I1I
  if 72 - 72: oOO + i1 / OooOoo
  if 70 - 70: Oo . IIiIIiIi11I1 * Ii . I1I - IIiIIiIi11I1
  if 68 - 68: Oo
  if 70 - 70: i1I % oOO / i1I / i1iiIII111
  if 99 - 99: ooOOO / i1iiIII111 * IIiIIiIi11I1
  if 89 - 89: OooOoo . oOo0O00 % I1I . ooOOO % IiIIii11Ii . oOO
  o00o0o = i11i111iI . Config ( initializer = i11i111iI . Initializer . GlorotUniform ( ) )
  Iii1ioOo0OoooOOo = i11i111iI . Config ( initializer = i11i111iI . Initializer . Orthogonal ( ) )
  o000ooooO0 = i11i111iI . Config ( initializer = i11i111iI . Initializer . Zeros ( ) )
  if 67 - 67: i1 / I11iiIi11i1I + i1iiIII111 . oOO
  IiiIiii1II = iii1i1IIIi11 . GRUVarConfigs ( o00o0o , o00o0o , o00o0o )
  Oooo00Oo0o = iii1i1IIIi11 . GRUVarConfigs ( Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo )
  OoOo0OO = iii1i1IIIi11 . GRUVarConfigs ( o000ooooO0 , o000ooooO0 , o000ooooO0 )
  if 21 - 21: i1I * IiI11Ii111 % i1iiIII111 * I11iiIi11i1I % i1i1i1111I
  return iii1i1IIIi11 ( weightConfigs = IiiIiii1II , recurrentWeightConfigs = Oooo00Oo0o , biasConfigs = OoOo0OO )
  if 37 - 37: Iii1i % IiI11Ii111 + i1i1i1111I + i1iiIII111 + Ooo0Ooo
class OOooOooo :
 if 54 - 54: oOo0O00 - iI1iII1I1I1i
 if 5 - 5: IIiIIiIi11I1 % oOo0O00 . OooOoo
 if 68 - 68: ooOOO . oOO * Oo % OooOoo % oOo0O00 % ooOOO
 if 57 - 57: I1I / iI1iII1I1I1i * IiI11Ii111 - i1I
 if 31 - 31: ooOOO . Ii - i1 . I1I . iI1iII1I1I1i
 if 56 - 56: ooOOO
 if 76 - 76: i1I
 class LSTMVarConfigs :
  if 13 - 13: IiI11Ii111 - iI1iII1I1I1i % i1iiIII111 . i1I - iI1iII1I1I1i * I1I
  if 13 - 13: I11iiIi11i1I
  if 7 - 7: IIiIIiIi11I1 / i1i1i1111I * Ooo0Ooo / I1Ii1I1 / IiIIii11Ii + IIiIIiIi11I1
  if 67 - 67: i1I . i1 . OooOoo
  if 17 - 17: Oo . i1
  if 90 - 90: Ooo0Ooo % i1i1i1111I % ooo000 % Iii1i - IIiIIiIi11I1
  if 2 - 2: i1i1i1111I + i1I * IIiIIiIi11I1 + ooOOO / i1i1i1111I
  def __init__ ( self , inputGate : 'VarConfig' = None , forgetGate : 'VarConfig' = None , outputGate : 'VarConfig' = None , memory : 'VarConfig' = None ) :
   if 53 - 53: I11iiIi11i1I + ooOOO * I1I + ooo000 * i1I
   if 66 - 66: Ii . I1I + oOo0O00 * IiIIii11Ii . oOo0O00 / IIiIIiIi11I1
   if 37 - 37: I1I / oOO . Ii . IiI11Ii111 - i1I
   if 30 - 30: ooo000 + i1i1i1111I + i1
   if 76 - 76: IIiIIiIi11I1 . I1Ii1I1 * iI1iII1I1I1i - i1iiIII111 + i1 / IiI11Ii111
   if 49 - 49: i1I + i1I
   if 73 - 73: iI1iII1I1I1i
   if 71 - 71: I1Ii1I1
   if 62 - 62: i1iiIII111
   if 24 - 24: i1 - IIiIIiIi11I1
   if 90 - 90: OooOoo * Ooo0Ooo
   if 26 - 26: Oo - Oo - oOO - I1I . oOO
   if 25 - 25: Oo % I11iiIi11i1I - Oo
   self . inputGate = inputGate
   self . forgetGate = forgetGate
   self . outputGate = outputGate
   self . memory = memory
   if 4 - 4: oOo0O00 / i1iiIII111 * Iii1i
 def __init__ ( self , weightConfigs : 'LSTMVarConfigs' = LSTMVarConfigs ( ) , recurrentWeightConfigs : 'LSTMVarConfigs' = LSTMVarConfigs ( ) ,
 peepholeWeightConfigs : 'LSTMVarConfigs' = LSTMVarConfigs ( ) , biasConfigs : 'LSTMVarConfigs' = LSTMVarConfigs ( ) ) :
  if 25 - 25: oOO - IiIIii11Ii / oOo0O00
  if 23 - 23: Oo
  if 91 - 91: i1iiIII111 * IIiIIiIi11I1
  if 80 - 80: oOo0O00 . oOo0O00 + Ii . i1iiIII111
  if 59 - 59: IIiIIiIi11I1 % oOO % i1 + i1iiIII111 . I1Ii1I1
  if 21 - 21: IiI11Ii111 * Oo . iI1iII1I1I1i . oOo0O00
  if 56 - 56: Ii + IiIIii11Ii - i1
  if 2 - 2: Iii1i * Iii1i
  if 55 - 55: ooo000 * I1Ii1I1 + I1Ii1I1 / oOo0O00 . OooOoo
  if 3 - 3: I1Ii1I1 + ooOOO / Iii1i - I1Ii1I1 + oOo0O00 % I11iiIi11i1I
  if 41 - 41: i1i1i1111I
  if 26 - 26: OooOoo - i1iiIII111 + oOO . IiI11Ii111
  if 31 - 31: Ii * Iii1i
  self . inputGateWeightConfig = weightConfigs . inputGate
  self . forgetGateWeightConfig = weightConfigs . forgetGate
  self . outputGateWeightConfig = weightConfigs . outputGate
  self . memoryWeightConfig = weightConfigs . memory
  self . inputGateRecurrentWeightConfig = recurrentWeightConfigs . inputGate
  self . forgetGateRecurrentWeightConfig = recurrentWeightConfigs . forgetGate
  self . outputGateRecurrentWeightConfig = recurrentWeightConfigs . outputGate
  self . memoryRecurrentWeightConfig = recurrentWeightConfigs . memory
  self . inputGatePeepholeWeightConfig = peepholeWeightConfigs . inputGate
  self . forgetGatePeepholeWeightConfig = peepholeWeightConfigs . forgetGate
  self . outputGatePeepholeWeightConfig = peepholeWeightConfigs
  self . inputGateBiasConfig = biasConfigs . inputGate
  self . forgetGateBiasConfig = biasConfigs . forgetGate
  self . outputGateBiasConfig = biasConfigs . outputGate
  self . memoryBiasConfig = biasConfigs . memory
  if 68 - 68: oOO * iI1iII1I1I1i * i1iiIII111
 @ staticmethod
 def createBasicConfig ( ) -> 'LSTMConfig' :
  if 19 - 19: i1I
  if 29 - 29: IiI11Ii111 - oOo0O00
  if 36 - 36: oOo0O00 - Oo / OooOoo . Oo % OooOoo * Iii1i
  if 73 - 73: i1iiIII111 - I1I % IiIIii11Ii * IIiIIiIi11I1
  if 15 - 15: IIiIIiIi11I1 * Ooo0Ooo % Iii1i / IiI11Ii111 % iI1iII1I1I1i / i1I
  if 74 - 74: I1I % oOO + I1Ii1I1 / i1I
  if 33 - 33: IIiIIiIi11I1 . OooOoo + I11iiIi11i1I - Iii1i % Oo
  if 58 - 58: Oo . IIiIIiIi11I1 - IiIIii11Ii
  if 36 - 36: Ii + i1i1i1111I / I11iiIi11i1I - Oo
  if 46 - 46: Ooo0Ooo / oOo0O00 - Iii1i * IiI11Ii111
  o00o0o = i11i111iI . Config ( initializer = i11i111iI . Initializer . GlorotUniform ( ) )
  Iii1ioOo0OoooOOo = i11i111iI . Config ( initializer = i11i111iI . Initializer . Orthogonal ( ) )
  o000ooooO0 = i11i111iI . Config ( initializer = i11i111iI . Initializer . Zeros ( ) )
  if 95 - 95: Iii1i % I1Ii1I1 . Iii1i . I1I
  IiiIiii1II = OOooOooo . LSTMVarConfigs ( o00o0o , o00o0o , o00o0o , o00o0o )
  Oooo00Oo0o = OOooOooo . LSTMVarConfigs ( Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo )
  i1I1i1IIII1II = OOooOooo . LSTMVarConfigs ( Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo , Iii1ioOo0OoooOOo , None )
  OoOo0OO = OOooOooo . LSTMVarConfigs ( o000ooooO0 , o000ooooO0 , o000ooooO0 , o000ooooO0 )
  if 37 - 37: oOO
  return OOooOooo ( weightConfigs = IiiIiii1II , recurrentWeightConfigs = Oooo00Oo0o ,
 peepholeWeightConfigs = i1I1i1IIII1II , biasConfigs = OoOo0OO )
  if 70 - 70: i1iiIII111 % I1I . I1Ii1I1 - i1I . I1I
class I1ioOo00OOoo0O ( oO00ooO00oOO0 ) :
 if 30 - 30: i1 + I1Ii1I1 / IiIIii11Ii . i1 - oOo0O00
 if 26 - 26: IIiIIiIi11I1 * I11iiIi11i1I - IiIIii11Ii / i1 / I11iiIi11i1I
 if 13 - 13: IIiIIiIi11I1 + I1I + I1Ii1I1
 if 83 - 83: IiIIii11Ii % iI1iII1I1I1i + i1iiIII111 + I11iiIi11i1I / i1
 if 47 - 47: Ooo0Ooo
 if 45 - 45: i1i1i1111I + i1I / IIiIIiIi11I1 . ooOOO * i1 + OooOoo
 if 74 - 74: OooOoo % Iii1i * OooOoo / I1Ii1I1
 def __init__ ( self , name : str = None , layerUnits : int = 150 , incomingConfig : 'IncomingConfig' = i1iIi1i1i1I1 . Concat ( ) ,
 isKerasLayer : bool = False ,
 linearTransform : 'RNNConfig' = o00o00O000 . createBasicConfig ( ) ,
 activation : int = iI11II1 . Tanh , activationParams : Dict = { } ,
 batchNorm : bool = True , useBias : bool = True , dropout : float = 1 , recurrentDropout : float = 1 ,
 stateClip : float = None , statefull : bool = False , goBackwards : bool = False , returnSequenceLen : int = None ,
 returnSequences : bool = False , returnState : bool = False , outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 16 - 16: iI1iII1I1I1i / Iii1i
  if 85 - 85: OooOoo / I11iiIi11i1I
  if 65 - 65: IIiIIiIi11I1 % I1Ii1I1 . Ooo0Ooo * Ii . IiIIii11Ii
  if 18 - 18: Ooo0Ooo
  if 98 - 98: Iii1i
  if 97 - 97: Oo + ooo000 . IIiIIiIi11I1 % iI1iII1I1I1i - i1iiIII111
  if 25 - 25: oOO / ooo000
  if 25 - 25: IIiIIiIi11I1 * I1I - oOo0O00 - Oo / oOO - i1iiIII111
  if 92 - 92: I1Ii1I1 - I11iiIi11i1I / Iii1i * ooOOO * i1 * ooo000
  if 78 - 78: iI1iII1I1I1i
  if 95 - 95: I1I / Ii % oOO
  if 56 - 56: i1I . I11iiIi11i1I . i1I . Oo % IIiIIiIi11I1
  if 39 - 39: OooOoo + iI1iII1I1I1i * i1iiIII111
  if 82 - 82: Iii1i - Iii1i
  if 33 - 33: Ii
  if 23 - 23: i1 / I1Ii1I1 - ooo000 % i1i1i1111I + ooo000 . IiI11Ii111
  if 17 - 17: Ii - oOO / i1 % i1i1i1111I
  if 86 - 86: Ooo0Ooo * ooOOO
  if 75 - 75: i1
  if 56 - 56: iI1iII1I1I1i + Ooo0Ooo . I11iiIi11i1I % IIiIIiIi11I1 % i1I / i1
  if 10 - 10: i1i1i1111I . i1i1i1111I . IiIIii11Ii % ooOOO + Iii1i
  if 48 - 48: oOo0O00 + IIiIIiIi11I1 % i1 . oOO
  if 11 - 11: Oo - ooOOO - oOo0O00 - Iii1i % IiI11Ii111 - I1Ii1I1
  if 32 - 32: IiIIii11Ii % I1I
  if 31 - 31: ooo000 / I1I / i1iiIII111 . iI1iII1I1I1i
  if 52 - 52: Ii * iI1iII1I1I1i
  if 22 - 22: IiI11Ii111 - Oo / IiIIii11Ii % I11iiIi11i1I
  if linearTransform is None :
   linearTransform = o00o00O000 . createBasicConfig ( )
  super ( ) . __init__ ( o00OoOo0O0O00 . RNN , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , outputConfig = outputConfig )
  self . isKerasLayer = isKerasLayer
  self . activation = activation
  self . activationParams = activationParams
  self . useBias = useBias
  self . dropout = dropout
  self . recurrentDropout = recurrentDropout
  self . stateClip = stateClip
  self . statefull = statefull
  self . goBackwards = goBackwards
  self . returnSequenceLen = returnSequenceLen
  self . returnSequences = returnSequences
  self . returnState = returnState
  if 100 - 100: Oo / Ooo0Ooo % OooOoo
 def copy ( self , name ) :
  if 48 - 48: IiIIii11Ii % ooo000
  if 28 - 28: oOO + oOo0O00 - OooOoo / I1I + oOo0O00
  if 75 - 75: i1I
  if 26 - 26: ooo000 / I1Ii1I1 % Ooo0Ooo
  if 29 - 29: oOo0O00 + I1I % Iii1i
  if 33 - 33: Iii1i
  if 48 - 48: I11iiIi11i1I + ooo000 % Iii1i
  if 9 - 9: iI1iII1I1I1i / I1Ii1I1 - ooo000 % i1iiIII111 - Ooo0Ooo
  if 52 - 52: Iii1i % I1I - i1iiIII111 + iI1iII1I1I1i * Iii1i . iI1iII1I1I1i
  if 14 - 14: Iii1i % IiIIii11Ii - Ii + I1Ii1I1
  if 55 - 55: OooOoo - I1I / i1i1i1111I
  if self . __class__ . __name__ != "RNNLayer" :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 34 - 34: oOo0O00 * Ii / Iii1i / iI1iII1I1I1i
   if 51 - 51: i1I - ooo000 - iI1iII1I1I1i
  return I1ioOo00OOoo0O ( o00OoOo0O0O00 . RNN , name = name , layerUnits = self . layerUnits , incomingConfig = self . incomingConfig ,
 isKerasLayer = self . isKerasLayer , linearTransform = self . linearTransform , activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , useBias = self . useBias , dropout = self . dropout , recurrentDropout = self . recurrentDropout ,
 stateClip = self . stateClip , statefull = self . statefull , goBackwards = self . goBackwards ,
 returnSequenceLen = self . returnSequenceLen , returnSequences = self . returnSequences , returnState = self . returnState , outputConfig = self . outputConfig )
  if 45 - 45: I1I . i1 + ooOOO + iI1iII1I1I1i - ooo000
 def keras_layer_build ( self ) :
  if 96 - 96: ooo000 / i1I
  if 50 - 50: i1 * oOO - Oo - I1Ii1I1
  if 1 - 1: IiI11Ii111 + IIiIIiIi11I1 - Ooo0Ooo
  if 62 - 62: ooOOO * ooOOO . IiIIii11Ii % ooo000 . IiI11Ii111 * I1Ii1I1
  if 45 - 45: IiI11Ii111
  if 86 - 86: i1i1i1111I
  if 45 - 45: Ooo0Ooo + I1Ii1I1 + OooOoo % oOO - I1I . ooo000
  if 19 - 19: oOO * ooOOO . Ooo0Ooo
  if 62 - 62: i1 % oOO / i1I / i1iiIII111
  if 94 - 94: OooOoo
  if self . isKerasLayer :
   return 'self.%s = tf.keras.layers.SimpleRNN(%d)' % ( self . name , self . layerUnits )
  else :
   return 'self.%s = RNN(%d)' % ( self . name , self . layerUnits )
   if 81 - 81: ooo000 % I1Ii1I1 * ooo000 * I1I
 def _activationToKerasName ( self , activation ) :
  if 87 - 87: ooOOO
  if 12 - 12: Ii + I1I
  if 89 - 89: I11iiIi11i1I - i1i1i1111I + i1i1i1111I + Iii1i / i1i1i1111I
  if 10 - 10: ooo000 . IIiIIiIi11I1 - Ooo0Ooo / i1iiIII111 % I1Ii1I1
  if 87 - 87: oOo0O00 - iI1iII1I1I1i
  if 54 - 54: Oo
  if 43 - 43: oOo0O00 % IIiIIiIi11I1 % I1I
  if 65 - 65: Iii1i . Oo % i1i1i1111I
  if 8 - 8: i1i1i1111I / ooOOO / Iii1i
  if 86 - 86: Ooo0Ooo - I11iiIi11i1I - Oo - IiI11Ii111
  if activation == iI11II1 . Relu6 or activation == iI11II1 . Crelu :
   I11i1I11IiII = 'relu'
  elif activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'hard_sigmoid'
  else :
   I11i1I11IiII = ( iI11II1 . getName ( activation ) ) . split ( '.' ) [ - 1 ] . lower ( )
  return I11i1I11IiII
  if 69 - 69: oOo0O00 - I1I + I11iiIi11i1I / I1I
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 59 - 59: Oo / Ii
  if 57 - 57: iI1iII1I1I1i + Iii1i - i1i1i1111I / IIiIIiIi11I1 . iI1iII1I1I1i - I1I
  if 83 - 83: i1 / Ooo0Ooo % ooOOO
  if 11 - 11: i1i1i1111I + IIiIIiIi11I1 / IiIIii11Ii
  if 62 - 62: oOO % I1Ii1I1 . OooOoo - IiI11Ii111 . IiI11Ii111
  if 88 - 88: I1Ii1I1 + IiIIii11Ii
  if 10 - 10: IiI11Ii111 . I11iiIi11i1I
  if 59 - 59: oOo0O00 + ooo000 * IIiIIiIi11I1
  if 92 - 92: Iii1i
  if 37 - 37: oOO + Ii - OooOoo . I11iiIi11i1I
  if 3 - 3: Ii - ooOOO / Oo . I1I - oOO
  if 54 - 54: Ii
  if 12 - 12: I11iiIi11i1I
  if 26 - 26: Oo
  if 48 - 48: OooOoo + iI1iII1I1I1i
  II = [ None , self . returnSequenceLen , self . layerUnits ]
  if 72 - 72: Ii
  if 94 - 94: Ii - oOO % Ooo0Ooo
  self . dropout = 1 - self . dropout / 100.
  self . recurrentDropout = 1 - self . recurrentDropout / 100.
  if 25 - 25: oOo0O00 * IiI11Ii111 . OooOoo - oOo0O00 % Oo
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 77 - 77: iI1iII1I1I1i + ooo000 + IiI11Ii111
  OoOO , OoooOO0 = [ ] , [ ]
  if 4 - 4: IIiIIiIi11I1 + I1Ii1I1 % I1Ii1I1 / i1i1i1111I * I1I % i1I
  if 42 - 42: oOO - I1I + IiI11Ii111 % i1
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  Ii1Ii1Ii = 'True' if self . useBias else 'False'
  O0OOO0O0OO000 = self . get_initiallizer ( key = 'weightConfig' )
  Oo000 = self . get_initiallizer ( key = 'recurrentWeightConfig' )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( key = 'weightConfig' )
  II111II1I1 = self . get_regularizer ( key = 'recurrentWeightConfig' )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  IIIi1iii1Ii = self . dropout
  OoO0000OO00o0 = self . recurrentDropout
  OOooOo00 = 'True' if self . returnState else 'False'
  OO0O0oooOo = 'True' if self . goBackwards else 'False'
  I11I = 'True' if self . statefull else 'False'
  if 39 - 39: Iii1i
  if self . isKerasLayer :
   iIII1I11i11iI = 'True' if self . returnSequences else 'False'
   if 18 - 18: iI1iII1I1I1i / oOO / iI1iII1I1I1i / ooo000
   oO00oOooO0O = 'self.%s = tf.keras.layers.SimpleRNN(%d, activation = %s, use_bias=%s,  kernel_initializer=%s, recurrent_initializer=%s, bias_initializer=%s,' 'kernel_regularizer=%s, recurrent_regularizer=%s, bias_regularizer=%s, dropout=%f, recurrent_dropout=%f, return_sequences=%s, return_state=%s,' 'go_backwards=%s, stateful=%s )' % ( self . name , self . layerUnits , I11i1I11IiII , Ii1Ii1Ii , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , IIIi1iii1Ii , OoO0000OO00o0 , iIII1I11i11iI , OOooOo00 , OO0O0oooOo , I11I )
   if 3 - 3: iI1iII1I1I1i * ooo000 . IiIIii11Ii / Iii1i
   if 80 - 80: IIiIIiIi11I1
  else :
   Ii1 = 'None' if self . stateClip is None else str ( self . stateClip )
   I1iI111i = 'None' if self . returnSequenceLen is None else str ( self . returnSequenceLen )
   if 93 - 93: OooOoo / I1I
   oO00oOooO0O = 'self.%s = RNN(%d, activation = %s,kernelInitializer = %s,recurrentInitializer = %s,biasInitializer = %s,' 'kernelRegularizer = %s,recurrentRegularizer = %s,biasRegularizer = %s,useBias = %s,dropout =%f,recurrentDropout =%f,' 'stateClip = %s, statefull = %s, goBackwards = %s, returnSequenceLen = %s, returnState = %s)' % ( self . name , self . layerUnits , I11i1I11IiII , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , Ii1Ii1Ii , IIIi1iii1Ii , OoO0000OO00o0 , Ii1 , I11I , OO0O0oooOo , I1iI111i , OOooOo00 )
   if 56 - 56: i1 * i1iiIII111 - ooOOO * Ii
   if 11 - 11: IIiIIiIi11I1 * Oo / i1i1i1111I . Iii1i / OooOoo
   if 60 - 60: Oo / ooo000
   if 31 - 31: IIiIIiIi11I1
  OoOO . append ( oO00oOooO0O )
  if 38 - 38: Oo * IiI11Ii111 % oOO / OooOoo % iI1iII1I1I1i * i1
  if 29 - 29: IiI11Ii111 . i1iiIII111 * oOO
  if 51 - 51: oOo0O00 + Ooo0Ooo
  if 75 - 75: OooOoo / ooo000
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 100 - 100: ooOOO / i1I / i1I * Ooo0Ooo
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 49 - 49: Iii1i % iI1iII1I1I1i
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 36 - 36: ooo000 * Ooo0Ooo
  if 27 - 27: IiI11Ii111 % i1i1i1111I
  if 23 - 23: Iii1i % Iii1i
  if 24 - 24: IIiIIiIi11I1 * Ii
  if 81 - 81: Ooo0Ooo * IiI11Ii111 . I1I * oOo0O00 . iI1iII1I1I1i . i1
  if 89 - 89: Oo - I1Ii1I1
  if 30 - 30: I1I / i1i1i1111I % i1I % i1iiIII111 + ooOOO
  if 86 - 86: iI1iII1I1I1i % i1i1i1111I + i1iiIII111 * i1 / i1iiIII111 % oOO
  if 74 - 74: IiIIii11Ii / ooo000 . i1i1i1111I - i1
  if 19 - 19: i1 * iI1iII1I1I1i
  if 91 - 91: i1I . i1 . i1 . ooo000 + oOo0O00 + i1
  if 78 - 78: i1i1i1111I
  if 43 - 43: i1 / i1iiIII111 % i1 % OooOoo / Ooo0Ooo * IiIIii11Ii
  if 6 - 6: Oo . I11iiIi11i1I / I11iiIi11i1I . oOO + IiI11Ii111
  if 29 - 29: oOo0O00 - IiI11Ii111 + i1 . Ii * ooo000 . iI1iII1I1I1i
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 74 - 74: I1I . Ooo0Ooo + Ii % Iii1i - ooo000
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 45 - 45: OooOoo . IIiIIiIi11I1 . IIiIIiIi11I1 + OooOoo
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    if len ( input_shape ) < 5 :
     II = input_shape [ 0 : 2 ]
     II . append ( - 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "When dimension of data is more than 4, it is not supported." )
   elif len ( input_shape ) == 2 :
    OoOo = input_shape [ - 1 ]
    II = input_shape [ 0 : 1 ]
    II . append ( 1 )
    II . append ( OoOo )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ '1' , str ( int ( OoOo ) ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 56 - 56: iI1iII1I1I1i % OooOoo - i1iiIII111 - I1I * oOO
class O00O0oOo0O ( oO00ooO00oOO0 ) :
 if 83 - 83: oOO . Iii1i
 if 94 - 94: I1I % ooo000 . I11iiIi11i1I % I1I / IIiIIiIi11I1
 if 74 - 74: IiIIii11Ii * oOo0O00 / Iii1i / Ooo0Ooo + ooo000
 if 65 - 65: iI1iII1I1I1i
 if 29 - 29: ooo000 / i1iiIII111 - ooo000
 if 46 - 46: oOO % Iii1i
 if 48 - 48: Ii * I1I
 def __init__ ( self , name : str = None , layerUnits : int = 150 , incomingConfig : 'IncomingConfig' = i1iIi1i1i1I1 . Concat ( ) ,
 isKerasLayer : bool = False ,
 linearTransform : 'GRUConfig' = iii1i1IIIi11 . createBasicConfig ( ) ,
 resetGateActivation : int = iI11II1 . Sigmoid , updateGateActivation : int = iI11II1 . Sigmoid , stateCandidateActivation : int = iI11II1 . Tanh ,
 batchNorm : bool = True , useBias : bool = True , dropout : float = 1 , recurrentDropout : float = 1 ,
 stateClip : float = None , statefull : bool = False , goBackwards : bool = False , returnSequenceLen : int = None ,
 returnSequences : bool = False , returnState : bool = False , outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 51 - 51: Iii1i
  if 3 - 3: Ooo0Ooo * Iii1i * i1iiIII111
  if 14 - 14: Iii1i
  if 13 - 13: IiI11Ii111 * Iii1i + IiI11Ii111 . IIiIIiIi11I1 % I1Ii1I1
  if 51 - 51: OooOoo - Oo - Ooo0Ooo
  if 59 - 59: Iii1i / i1I + i1
  if 98 - 98: ooOOO + IiIIii11Ii . I1Ii1I1 - i1I / ooOOO - I1Ii1I1
  if 33 - 33: OooOoo + i1iiIII111 * i1I % Oo
  if 80 - 80: i1iiIII111 * IIiIIiIi11I1 % Ooo0Ooo + i1i1i1111I + i1I
  if 69 - 69: IiIIii11Ii - I1I - Oo
  if 51 - 51: I1I
  if 24 - 24: oOO % i1I % oOO + IIiIIiIi11I1 % IiI11Ii111 % oOo0O00
  if 14 - 14: OooOoo - i1 - IiIIii11Ii * I11iiIi11i1I / OooOoo % I11iiIi11i1I
  if 2 - 2: I11iiIi11i1I * I1I / oOo0O00 . Ii / OooOoo * IiIIii11Ii
  if 20 - 20: Iii1i
  if 84 - 84: I11iiIi11i1I % IiI11Ii111
  if 4 - 4: Ooo0Ooo / oOO % Ii
  if 70 - 70: I1Ii1I1 % i1 + ooo000 + IIiIIiIi11I1
  if 85 - 85: i1I
  if 75 - 75: I11iiIi11i1I * i1iiIII111 * Ii * Ooo0Ooo
  if 10 - 10: i1 . OooOoo . iI1iII1I1I1i . I11iiIi11i1I
  if 69 - 69: oOO * I11iiIi11i1I * i1i1i1111I * I1Ii1I1 - Ooo0Ooo - ooo000
  if 79 - 79: ooOOO - I1Ii1I1 / i1 / oOo0O00 % oOo0O00
  if 40 - 40: i1i1i1111I . i1I - i1iiIII111 * oOo0O00
  if 77 - 77: iI1iII1I1I1i + i1i1i1111I . Iii1i - IiI11Ii111 + oOo0O00 + i1i1i1111I
  if 47 - 47: Oo - ooOOO
  if 43 - 43: oOO
  if 97 - 97: i1 . OooOoo
  if linearTransform is None :
   linearTransform = iii1i1IIIi11 . createBasicConfig ( )
  super ( ) . __init__ ( o00OoOo0O0O00 . GRU , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , outputConfig = outputConfig )
  self . isKerasLayer = isKerasLayer
  if self . isKerasLayer :
   if resetGateActivation != updateGateActivation :
    raise ValueError ( 'The recurrent_activation of keras GRU layer is wrong' )
    if 13 - 13: Oo % ooo000 * Ii - i1I + IiIIii11Ii . ooo000
  self . resetGateActivation = resetGateActivation
  self . updateGateActivation = updateGateActivation
  self . stateCandidateActivation = stateCandidateActivation
  self . useBias = useBias
  self . dropout = dropout
  self . recurrentDropout = recurrentDropout
  self . stateClip = stateClip
  self . statefull = statefull
  self . goBackwards = goBackwards
  self . returnSequenceLen = returnSequenceLen
  self . returnSequences = returnSequences
  self . returnState = returnState
  if 14 - 14: Ii
 def copy ( self , name ) :
  if 63 - 63: Ii - iI1iII1I1I1i
  if 49 - 49: IiIIii11Ii * Ooo0Ooo . Ii + Ooo0Ooo * oOo0O00
  if 5 - 5: i1iiIII111
  if 71 - 71: oOo0O00 * IiIIii11Ii + OooOoo . I1Ii1I1 % OooOoo - IiI11Ii111
  if 34 - 34: IiI11Ii111 % oOO
  if 10 - 10: Ooo0Ooo
  if 56 - 56: IIiIIiIi11I1 % ooOOO / I11iiIi11i1I
  if 96 - 96: i1iiIII111 / IiI11Ii111
  if 42 - 42: oOO + IiI11Ii111 + i1 . I1I
  if 64 - 64: i1I % i1 / ooOOO
  if 47 - 47: I1I / oOO % I11iiIi11i1I . Oo - ooo000
  if self . __class__ . __name__ != "GRULayer" :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 76 - 76: iI1iII1I1I1i - Ooo0Ooo + oOO
   if 100 - 100: OooOoo * I1Ii1I1 % iI1iII1I1I1i + I11iiIi11i1I - Ii
  return O00O0oOo0O ( name = name , layerUnits = self . layerUnits , incomingConfig = self . incomingConfig ,
 isKerasLayer = self . isKerasLayer , linearTransform = self . linearTransform , resetGateActivation = self . resetGateActivation ,
 updateGateActivation = self . updateGateActivation , stateCandidateActivation = self . stateCandidateActivation ,
 batchNorm = self . batchNorm , useBias = self . useBias , dropout = self . dropout , recurrentDropout = self . recurrentDropout ,
 stateClip = self . stateClip , statefull = self . statefull , goBackwards = self . goBackwards , returnSequenceLen = self . returnSequenceLen ,
 returnSequences = self . returnSequences , returnState = self . returnState , outputConfig = self . outputConfig )
  if 61 - 61: IIiIIiIi11I1 + i1I
 def keras_layer_build ( self ) :
  if 57 - 57: i1i1i1111I * i1i1i1111I / i1iiIII111
  if 96 - 96: I1I - IIiIIiIi11I1 - Ooo0Ooo
  if 20 - 20: I1I
  if 88 - 88: Ooo0Ooo . IiI11Ii111 / i1I + ooOOO
  if 35 - 35: I1Ii1I1 * OooOoo - IiIIii11Ii + i1iiIII111
  if 86 - 86: IiI11Ii111 - i1I % IIiIIiIi11I1 % i1iiIII111
  if 9 - 9: IiI11Ii111
  if 37 - 37: i1 % I1I * i1 * I1I - IiI11Ii111
  if 73 - 73: i1i1i1111I . ooOOO + Oo - IiIIii11Ii
  if 88 - 88: i1I % iI1iII1I1I1i * i1i1i1111I - ooOOO % ooOOO * i1iiIII111
  if self . isKerasLayer :
   return 'self.%s = tf.keras.layers.GRU(%d)' % ( self . name , self . layerUnits )
  else :
   return 'self.%s = GRU(%d)' % ( self . name , self . layerUnits )
   if 80 - 80: IiI11Ii111 * i1i1i1111I - ooOOO
 def _activationToKerasName ( self , activation ) :
  if 5 - 5: iI1iII1I1I1i - i1i1i1111I + oOo0O00 % OooOoo . ooo000
  if 33 - 33: i1iiIII111
  if 32 - 32: IiI11Ii111 / I1Ii1I1 / OooOoo
  if 60 - 60: IIiIIiIi11I1 % Ii / iI1iII1I1I1i + I1Ii1I1
  if 16 - 16: ooOOO - i1 + Ooo0Ooo / ooo000 . IiI11Ii111
  if 10 - 10: i1I + i1 % IiI11Ii111 * ooOOO
  if 45 - 45: I1Ii1I1 / i1I - I11iiIi11i1I . IiIIii11Ii . ooOOO + IIiIIiIi11I1
  if 7 - 7: Ooo0Ooo
  if 97 - 97: IIiIIiIi11I1 % Iii1i / OooOoo * Ooo0Ooo % OooOoo
  if 4 - 4: Ooo0Ooo * i1 * i1
  if activation == iI11II1 . Relu6 or activation == iI11II1 . Crelu :
   I11i1I11IiII = 'relu'
  elif activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'hard_sigmoid'
  else :
   I11i1I11IiII = ( iI11II1 . getName ( activation ) ) . split ( '.' ) [ - 1 ] . lower ( )
  return I11i1I11IiII
  if 51 - 51: i1I . Ooo0Ooo - OooOoo
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 97 - 97: iI1iII1I1I1i / I1Ii1I1 . oOO * I1Ii1I1 % Ooo0Ooo
  if 32 - 32: Iii1i
  if 94 - 94: oOO - I1Ii1I1 - oOo0O00 + iI1iII1I1I1i . IIiIIiIi11I1
  if 99 - 99: oOO + i1i1i1111I % I11iiIi11i1I - Iii1i / I1I + I1Ii1I1
  if 67 - 67: OooOoo
  if 60 - 60: Oo / iI1iII1I1I1i - I1Ii1I1 + IIiIIiIi11I1
  if 69 - 69: ooOOO * IIiIIiIi11I1 / oOO % I1Ii1I1 - ooOOO
  if 18 - 18: I11iiIi11i1I + ooOOO . ooo000 . i1iiIII111
  if 8 - 8: oOO + i1I . IiIIii11Ii * Oo / oOo0O00 - iI1iII1I1I1i
  if 7 - 7: ooOOO % oOO % iI1iII1I1I1i
  if 44 - 44: ooOOO * Ii
  if 62 - 62: I1I * oOO / oOo0O00 * ooo000 + I11iiIi11i1I % i1I
  if 31 - 31: I11iiIi11i1I / i1i1i1111I
  if 82 - 82: Ii . I1Ii1I1 % oOO / Oo
  if 73 - 73: I1I . ooOOO / i1I
  II = [ None , self . returnSequenceLen , self . layerUnits ]
  self . dropout = 1 - self . dropout / 100.
  self . recurrentDropout = 1 - self . recurrentDropout / 100.
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 90 - 90: IiIIii11Ii - IiI11Ii111 * I1I / ooo000
  OoOO , OoooOO0 = [ ] , [ ]
  if 57 - 57: IiIIii11Ii / oOO % i1iiIII111 + i1I + Ii
  Ii1Ii1Ii = 'True' if self . useBias else 'False'
  IIIi1iii1Ii = self . dropout
  OoO0000OO00o0 = self . recurrentDropout
  OOooOo00 = 'True' if self . returnState else 'False'
  OO0O0oooOo = 'True' if self . goBackwards else 'False'
  I11I = 'True' if self . statefull else 'False'
  if 87 - 87: IIiIIiIi11I1 - I11iiIi11i1I * I1I . OooOoo % i1
  if self . isKerasLayer :
   I11i1I11IiII = self . act_dict [ int ( self . stateCandidateActivation ) ]
   iI1I1I1III1 = self . act_dict [ int ( self . resetGateActivation ) ]
   O0OOO0O0OO000 = self . get_initiallizer ( key = 'resetGateWeightConfig' )
   Oo000 = self . get_initiallizer ( key = 'resetGateRecurrentWeightConfig' )
   OOOoooO = self . get_initiallizer ( key = 'resetGateBiasConfig' )
   i1IiiIi1iIiIIi = self . get_regularizer ( key = 'resetGateWeightConfig' )
   II111II1I1 = self . get_regularizer ( key = 'resetGateRecurrentWeightConfig' )
   ooiiii1IiIi = self . get_regularizer ( key = 'resetGateBiasConfig' )
   iIII1I11i11iI = 'True' if self . returnSequences else 'False'
   oO00oOooO0O = 'self.%s = tf.keras.layers.GRU(%d, activation = %s,recurrent_activation = %s, use_bias=%s,  kernel_initializer=%s, recurrent_initializer=%s, bias_initializer=%s,' 'kernel_regularizer=%s, recurrent_regularizer=%s, bias_regularizer=%s, dropout=%f, recurrent_dropout=%f, return_sequences=%s, return_state=%s,' 'go_backwards=%s, stateful=%s )' % ( self . name , self . layerUnits , I11i1I11IiII , iI1I1I1III1 , Ii1Ii1Ii , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , IIIi1iii1Ii , OoO0000OO00o0 , iIII1I11i11iI , OOooOo00 , OO0O0oooOo , I11I )
   if 67 - 67: i1 / ooo000 + i1 - I11iiIi11i1I % I1Ii1I1 * I11iiIi11i1I
   if 22 - 22: Iii1i - ooo000
   if 87 - 87: IIiIIiIi11I1 % iI1iII1I1I1i - i1 - oOO . I1Ii1I1 + i1I
  else :
   if 65 - 65: iI1iII1I1I1i . Ii - OooOoo
   Ii1i11IIiI = self . act_dict [ int ( self . resetGateActivation ) ]
   if 86 - 86: Iii1i / i1i1i1111I
   OoooO00o = self . act_dict [ int ( self . updateGateActivation ) ]
   if 94 - 94: I1Ii1I1 * oOO
   Oo00O = self . act_dict [ int ( self . stateCandidateActivation ) ]
   Ii1I11I1ii1 = self . get_initiallizer ( key = 'resetGateWeightConfig' )
   ooo0i11ii11 = self . get_initiallizer ( key = 'updateGateWeightConfig' )
   IiIi11 = self . get_initiallizer ( key = 'stateCandidateWeightConfig' )
   o000Ooo = self . get_initiallizer ( key = 'resetGateRecurrentWeightConfig' )
   IIiIi1i = self . get_initiallizer ( key = 'updateGateRecurrentWeightConfig' )
   II1IIIii1III1 = self . get_initiallizer ( key = 'stateCandidateRecurrentWeightConfig' )
   IIiII = self . get_initiallizer ( key = 'resetGateBiasConfig' )
   oO0o00O = self . get_initiallizer ( key = 'updateGateBiasConfig' )
   i1Ii11Iii = self . get_initiallizer ( key = 'stateCandidateBiasConfig' )
   i1I1IIi1IIIi1 = self . get_regularizer ( key = 'resetGateWeightConfig' )
   oOOo = self . get_regularizer ( key = 'updateGateWeightConfig' )
   I11111II = self . get_regularizer ( key = 'stateCandidateWeightConfig' )
   ooO0OO000OoO0O = self . get_regularizer ( key = 'resetGateRecurrentWeightConfig' )
   IiIIIII1ii1IIii = self . get_regularizer ( key = 'updateGateRecurrentWeightConfig' )
   O0oiI1iIiiI1I11 = self . get_regularizer ( key = 'stateCandidateRecurrentWeightConfig' )
   I1o0 = self . get_regularizer ( key = 'resetGateBiasConfig' )
   OOOooO = self . get_regularizer ( key = 'updateGateBiasConfig' )
   IIII1i11 = self . get_regularizer ( key = 'stateCandidateBiasConfig' )
   i1iIi11I1IiIi = 'None' if self . stateClip is None else str ( self . stateClip )
   I1iI111i = 'None' if self . returnSequenceLen is None else str ( self . returnSequenceLen )
   oO00oOooO0O = 'self.%s = GRU(%d, activation = GRU.Activation(%s,%s,%s),kernelInitializer = GRU.Initializer(%s,%s,%s),' 'recurrentInitializer = GRU.Initializer(%s,%s,%s),biasInitializer = GRU.Initializer(%s,%s,%s),' 'kernelRegularizer = GRU.Regularizer(%s,%s,%s),recurrentRegularizer = GRU.Regularizer(%s,%s,%s),' 'biasRegularizer = GRU.Regularizer(%s,%s,%s),useBias = %s,dropout =%f,recurrentDropout =%f,' 'stateClip = %s, statefull = %s, goBackwards = %s, returnSequenceLen = %s, returnState = %s)' % ( self . name , self . layerUnits , Ii1i11IIiI , OoooO00o , Oo00O , Ii1I11I1ii1 , ooo0i11ii11 , IiIi11 ,
   # i1i1i1111I - oOO
   # i1 . i1iiIII111 + Ooo0Ooo % iI1iII1I1I1i + I1Ii1I1
   # oOO / oOO - I11iiIi11i1I . ooOOO
   # oOo0O00 . ooo000 - i1 / Ii % ooo000 / IIiIIiIi11I1
   # IiI11Ii111
 o000Ooo , IIiIi1i , II1IIIii1III1 ,
 IIiII , oO0o00O , i1Ii11Iii , i1I1IIi1IIIi1 , oOOo , I11111II ,
 ooO0OO000OoO0O , IiIIIII1ii1IIii , O0oiI1iIiiI1I11 ,
 I1o0 , OOOooO , IIII1i11 , Ii1Ii1Ii , IIIi1iii1Ii , OoO0000OO00o0 , i1iIi11I1IiIi , I11I , OO0O0oooOo , I1iI111i , OOooOo00 )
  OoOO . append ( oO00oOooO0O )
  if 38 - 38: oOO . iI1iII1I1I1i - IIiIIiIi11I1 * i1i1i1111I
  if 96 - 96: i1i1i1111I + Oo % Ooo0Ooo + Ii
  if 33 - 33: i1I * i1i1i1111I % i1I / i1 * I1I - OooOoo
  if 19 - 19: I1Ii1I1 . iI1iII1I1I1i % I11iiIi11i1I % i1i1i1111I . I1I
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 98 - 98: OooOoo - Ii * i1I
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 56 - 56: oOO / Ooo0Ooo * IIiIIiIi11I1 - IiIIii11Ii
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 9 - 9: IiIIii11Ii - iI1iII1I1I1i / iI1iII1I1I1i - i1 . IiI11Ii111
  if 93 - 93: oOo0O00 - IiI11Ii111
  if 77 - 77: oOo0O00
  if 30 - 30: IiI11Ii111 / i1iiIII111 - i1iiIII111 . Iii1i / oOO
  if 81 - 81: ooo000 / Ii
  if 14 - 14: IIiIIiIi11I1 - IiIIii11Ii . i1i1i1111I
  if 11 - 11: oOO % oOO % I1Ii1I1 * Ii - I1Ii1I1 / I1Ii1I1
  if 38 - 38: IiI11Ii111 % i1 . Ii - I1I + ooOOO - IiIIii11Ii
  if 48 - 48: ooo000 * i1 - oOo0O00 % Iii1i
  if 69 - 69: i1I
  if 17 - 17: I11iiIi11i1I + I11iiIi11i1I + IIiIIiIi11I1 / iI1iII1I1I1i
  if 48 - 48: iI1iII1I1I1i + I1Ii1I1 % iI1iII1I1I1i / Ii * i1i1i1111I
  if 76 - 76: ooo000 + iI1iII1I1I1i
  if 46 - 46: IIiIIiIi11I1 + ooo000 % i1 / Oo - i1i1i1111I
  if 77 - 77: Oo + iI1iII1I1I1i
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 4 - 4: Oo - i1iiIII111 - I11iiIi11i1I . iI1iII1I1I1i . Ii
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 27 - 27: ooo000 - I1I . I1Ii1I1 + OooOoo + Oo % Ooo0Ooo
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    if len ( input_shape ) < 5 :
     II = input_shape [ 0 : 2 ]
     II . append ( - 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "When dimension of data is more than 4, it is not supported." )
   elif len ( input_shape ) == 2 :
    OoOo = input_shape [ - 1 ]
    II = input_shape [ 0 : 1 ]
    II . append ( 1 )
    II . append ( OoOo )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ '1' , str ( int ( OoOo ) ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 75 - 75: i1 + oOO * ooOOO
class Oo000O ( oO00ooO00oOO0 ) :
 if 18 - 18: iI1iII1I1I1i + I1I + IiI11Ii111
 if 81 - 81: i1I - OooOoo * Ii * oOo0O00 . I11iiIi11i1I
 if 19 - 19: I1I / IiI11Ii111 - IiIIii11Ii / i1I * IiI11Ii111
 if 49 - 49: i1iiIII111 - ooo000 . Iii1i - i1i1i1111I . ooo000
 if 45 - 45: ooo000 % Oo + i1i1i1111I
 if 45 - 45: i1
 if 42 - 42: oOO + oOO . Ii
 def __init__ ( self , name : str = None , layerUnits : int = 150 , incomingConfig : 'IncomingConfig' = i1iIi1i1i1I1 . Concat ( ) ,
 isKerasLayer : bool = False ,
 linearTransform : 'LSTMConfig' = OOooOooo . createBasicConfig ( ) ,
 inputGateActivation : int = iI11II1 . Sigmoid , forgetGateActivation : int = iI11II1 . Sigmoid , outputGateActivation : int = iI11II1 . Sigmoid ,
 memoryActivation : int = iI11II1 . Tanh , shadowGateActivation : int = iI11II1 . Tanh ,
 batchNorm : bool = True , useBias : bool = True , usePeephole : bool = False , dropout : float = 1 , recurrentDropout : float = 1 ,
 memoryCellClip : float = None , shadowStateClip : float = None , statefull : bool = False , goBackwards : bool = False , returnSequenceLen : int = None ,
 returnSequences : bool = False , returnState : bool = False , outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 87 - 87: Ii * ooo000 - Iii1i * Ooo0Ooo + IIiIIiIi11I1 * IIiIIiIi11I1
  if 85 - 85: Oo * I1I
  if 56 - 56: Ii
  if 69 - 69: I1I * Ii % Iii1i
  if 94 - 94: IiI11Ii111 / i1 % I11iiIi11i1I - OooOoo
  if 100 - 100: i1I - Oo
  if 2 - 2: IiI11Ii111 * IIiIIiIi11I1 * I11iiIi11i1I * I1Ii1I1 - i1i1i1111I
  if 74 - 74: ooo000
  if 26 - 26: IiI11Ii111 . Ooo0Ooo . i1i1i1111I + oOO - Iii1i . ooOOO
  if 62 - 62: i1iiIII111 . I1I
  if 43 - 43: Ii * IiI11Ii111 . i1iiIII111 / I11iiIi11i1I
  if 58 - 58: IIiIIiIi11I1
  if 8 - 8: Ii . IiIIii11Ii
  if 42 - 42: Iii1i + Oo * oOO * I11iiIi11i1I - Iii1i % Ii
  if 84 - 84: i1I / ooOOO % OooOoo
  if 29 - 29: IiIIii11Ii + ooOOO
  if 26 - 26: ooOOO / I1Ii1I1 % I1I * i1i1i1111I / oOo0O00 / I1I
  if 1 - 1: I11iiIi11i1I + I1I
  if 32 - 32: I1I . i1i1i1111I - OooOoo / IIiIIiIi11I1 / i1I - Iii1i
  if 33 - 33: IIiIIiIi11I1 * ooOOO * IIiIIiIi11I1 + i1 * IiI11Ii111 . I11iiIi11i1I
  if 14 - 14: Iii1i
  if 95 - 95: oOO * oOO . Ooo0Ooo - ooo000
  if 62 - 62: i1iiIII111 + I1I / I1I + i1 * IiIIii11Ii
  if 87 - 87: oOo0O00 % iI1iII1I1I1i / i1i1i1111I . i1i1i1111I
  if 65 - 65: I1I . ooo000 / I1I . I1I - i1iiIII111 - Iii1i
  if 54 - 54: i1iiIII111
  if 8 - 8: IiIIii11Ii / Oo
  if 15 - 15: IIiIIiIi11I1 / oOo0O00 % iI1iII1I1I1i + i1
  if 53 - 53: i1 + Iii1i
  if 32 - 32: OooOoo * Iii1i - I1Ii1I1
  if 57 - 57: OooOoo / ooo000
  if 79 - 79: iI1iII1I1I1i / I11iiIi11i1I / Iii1i - I1Ii1I1 / IiI11Ii111
  if linearTransform is None :
   linearTransform = OOooOooo . createBasicConfig ( )
  super ( ) . __init__ ( o00OoOo0O0O00 . LSTM , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , outputConfig = outputConfig )
  self . isKerasLayer = isKerasLayer
  if self . isKerasLayer :
   if ( inputGateActivation != forgetGateActivation ) or ( inputGateActivation != outputGateActivation ) or ( forgetGateActivation != outputGateActivation ) :
    raise ValueError ( 'The recurrent_activation of keras LSTM layer is wrong' )
   if memoryActivation != shadowGateActivation :
    raise ValueError ( 'The activation of keras LSTM layer is wrong' )
    if 39 - 39: Iii1i . IIiIIiIi11I1 % i1i1i1111I + Iii1i . i1I / i1
  self . inputGateActivation = inputGateActivation
  self . forgetGateActivation = forgetGateActivation
  self . outputGateActivation = outputGateActivation
  self . memoryActivation = memoryActivation
  self . shadowGateActivation = shadowGateActivation
  self . useBias = useBias
  self . usePeephole = usePeephole
  self . dropout = dropout
  self . recurrentDropout = recurrentDropout
  self . memoryCellClip = memoryCellClip
  self . shadowStateClip = shadowStateClip
  self . statefull = statefull
  self . goBackwards = goBackwards
  self . returnSequenceLen = returnSequenceLen
  self . returnSequences = returnSequences
  self . returnState = returnState
  if 78 - 78: ooOOO * i1I . Ooo0Ooo % Ooo0Ooo + oOO - i1I
 def copy ( self , name ) :
  if 46 - 46: ooOOO - IiIIii11Ii * I11iiIi11i1I % i1i1i1111I * i1i1i1111I - I1I
  if 5 - 5: i1I / OooOoo
  if 72 - 72: I1Ii1I1 + I1Ii1I1 * Oo
  if 28 - 28: I1I + OooOoo / i1 . Ii / Ii
  if 83 - 83: oOo0O00
  if 94 - 94: i1iiIII111 % ooo000
  if 1 - 1: OooOoo . IiI11Ii111
  if 26 - 26: i1I . I11iiIi11i1I + I1Ii1I1 - I1Ii1I1 . iI1iII1I1I1i . IiIIii11Ii
  if 20 - 20: Iii1i
  if 89 - 89: IiIIii11Ii + ooo000
  if 77 - 77: I11iiIi11i1I . Ooo0Ooo
  if self . __class__ . __name__ != "LSTMLayer" :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 1 - 1: I1Ii1I1 * Oo / i1 + I11iiIi11i1I
   if 62 - 62: i1 + i1 - Iii1i
  return Oo000O ( name = name , layerUnits = self . layerUnits , incomingConfig = self . incomingConfig ,
 isKerasLayer = self . isKerasLayer , linearTransform = self . linearTransform , inputGateActivation = self . inputGateActivation ,
 forgetGateActivation = self . forgetGateActivation , outputGateActivation = self . outputGateActivation ,
 memoryActivation = self . memoryActivation , shadowGateActivation = self . shadowGateActivation , batchNorm = self . batchNorm ,
 useBias = self . useBias , usePeephole = self . usePeephole , dropout = self . dropout , recurrentDropout = self . recurrentDropout ,
 memoryCellClip = self . memoryCellClip , shadowStateClip = self . shadowStateClip , statefull = self . statefull , goBackwards = self . goBackwards ,
 returnSequenceLen = self . returnSequenceLen , returnSequences = self . returnSequences , returnState = self . returnState , outputConfig = self . outputConfig )
  if 45 - 45: IiI11Ii111 + Ooo0Ooo
 def keras_layer_build ( self ) :
  if 17 - 17: i1 - Ii . i1I * IIiIIiIi11I1
  if 49 - 49: I1Ii1I1 * i1iiIII111
  if 18 - 18: i1 * iI1iII1I1I1i % IIiIIiIi11I1 - ooOOO
  if 71 - 71: i1 . Oo % OooOoo + i1 . IIiIIiIi11I1
  if 47 - 47: oOo0O00 % oOo0O00 . i1i1i1111I / oOo0O00
  if 4 - 4: i1
  if 76 - 76: IIiIIiIi11I1 % oOO * I1Ii1I1 + IiIIii11Ii % i1
  if 91 - 91: iI1iII1I1I1i * Oo
  if 66 - 66: I1Ii1I1 + oOo0O00 % oOO . oOO * I11iiIi11i1I
  if 47 - 47: i1 * Iii1i % oOO / i1iiIII111
  if self . isKerasLayer :
   return 'self.%s = tf.keras.layers.LSTM(%d)' % ( self . name , self . layerUnits )
  else :
   return 'self.%s = LSTM(%d)' % ( self . name , self . layerUnits )
   if 20 - 20: OooOoo
 def _activationToKerasName ( self , activation ) :
  if 98 - 98: Ii
  if 37 - 37: ooo000 . oOO + IiIIii11Ii * i1i1i1111I * IiIIii11Ii + i1I
  if 52 - 52: IIiIIiIi11I1 % I1I . OooOoo
  if 16 - 16: Iii1i - IiI11Ii111 / Ii + oOO * oOO
  if 71 - 71: I1Ii1I1 + IiIIii11Ii / ooOOO % OooOoo . i1i1i1111I
  if 53 - 53: Ii % oOO - i1 . ooo000 + I1I
  if 88 - 88: OooOoo - ooOOO / oOo0O00 * I1Ii1I1 - i1iiIII111 - IiIIii11Ii
  if 53 - 53: IiIIii11Ii
  if 86 - 86: iI1iII1I1I1i * i1 / IiIIii11Ii + i1i1i1111I
  if 62 - 62: ooOOO - oOO
  if activation == iI11II1 . Relu6 or activation == iI11II1 . Crelu :
   I11i1I11IiII = 'relu'
  elif activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'hard_sigmoid'
  else :
   I11i1I11IiII = ( iI11II1 . getName ( activation ) ) . split ( '.' ) [ - 1 ] . lower ( )
  return I11i1I11IiII
  if 38 - 38: I1Ii1I1 % Ii - i1I + IiI11Ii111
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 34 - 34: Oo - i1 - i1iiIII111
  if 29 - 29: Ooo0Ooo . I11iiIi11i1I * oOo0O00 + IIiIIiIi11I1
  if 94 - 94: Ooo0Ooo . IIiIIiIi11I1 * Iii1i + i1i1i1111I % I1Ii1I1 * ooo000
  if 4 - 4: I11iiIi11i1I * iI1iII1I1I1i
  if 82 - 82: Iii1i
  if 93 - 93: Oo . Ooo0Ooo . I11iiIi11i1I + Ii
  if 98 - 98: OooOoo / IiIIii11Ii
  if 87 - 87: i1I - I11iiIi11i1I % Ii . oOO % Oo
  if 37 - 37: oOO + IiI11Ii111 * ooo000 + i1iiIII111 * ooOOO
  if 10 - 10: I1Ii1I1 . I1Ii1I1 + IiI11Ii111 / Ii - IiI11Ii111 - i1i1i1111I
  if 32 - 32: Oo / I1Ii1I1 - IiI11Ii111 * OooOoo + i1i1i1111I
  if 72 - 72: iI1iII1I1I1i - OooOoo % i1I / Ooo0Ooo
  if 62 - 62: iI1iII1I1I1i - IiIIii11Ii - i1I
  if 38 - 38: ooo000 % iI1iII1I1I1i / IIiIIiIi11I1 % I11iiIi11i1I * i1iiIII111 + i1I
  if 93 - 93: i1i1i1111I . IiI11Ii111 % OooOoo - oOo0O00
  II = [ None , self . returnSequenceLen , self . layerUnits ]
  self . dropout = 1 - self . dropout / 100.
  self . recurrentDropout = 1 - self . recurrentDropout / 100.
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 92 - 92: I11iiIi11i1I . iI1iII1I1I1i * Ooo0Ooo . I1I / IIiIIiIi11I1
  OoOO , OoooOO0 = [ ] , [ ]
  if 81 - 81: ooOOO - OooOoo - Ooo0Ooo * I1I - I1Ii1I1
  Ii1Ii1Ii = 'True' if self . useBias else 'False'
  IIIi1iii1Ii = self . dropout
  OoO0000OO00o0 = self . recurrentDropout
  OOooOo00 = 'True' if self . returnState else 'False'
  OO0O0oooOo = 'True' if self . goBackwards else 'False'
  I11I = 'True' if self . statefull else 'False'
  if 50 - 50: Oo % Ooo0Ooo / i1iiIII111 . IiI11Ii111 * ooo000 / oOo0O00
  if self . isKerasLayer :
   if 7 - 7: ooo000 * Ii / I1Ii1I1 * oOO
   I11i1I11IiII = self . act_dict [ int ( self . inputGateActivation . value ) ]
   if 20 - 20: IIiIIiIi11I1 . i1I + IiI11Ii111 + I1Ii1I1 - ooOOO * i1i1i1111I
   iI1I1I1III1 = self . act_dict [ int ( self . memoryActivation . value ) ]
   O0OOO0O0OO000 = self . get_initiallizer ( key = 'inputGateWeightConfig' )
   Oo000 = self . get_initiallizer ( key = 'inputGateRecurrentWeightConfig' )
   OOOoooO = self . get_initiallizer ( key = 'inputGateBiasConfig' )
   i1IiiIi1iIiIIi = self . get_regularizer ( key = 'inputGateWeightConfig' )
   II111II1I1 = self . get_regularizer ( key = 'inputGateRecurrentWeightConfig' )
   ooiiii1IiIi = self . get_regularizer ( key = 'inputGateBiasConfig' )
   iIII1I11i11iI = 'True' if self . returnSequences else 'False'
   oO00oOooO0O = 'self.%s = tf.keras.layers.LSTM(%d, activation = %s,recurrent_activation = %s, use_bias=%s,  kernel_initializer=%s, recurrent_initializer=%s, bias_initializer=%s,' 'kernel_regularizer=%s, recurrent_regularizer=%s, bias_regularizer=%s, dropout=%f, recurrent_dropout=%f, return_sequences=%s, return_state=%s,' 'go_backwards=%s, stateful=%s )' % ( self . name , self . layerUnits , I11i1I11IiII , iI1I1I1III1 , Ii1Ii1Ii , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , IIIi1iii1Ii , OoO0000OO00o0 , iIII1I11i11iI , OOooOo00 , OO0O0oooOo , I11I )
   if 83 - 83: ooOOO / i1iiIII111
   if 77 - 77: OooOoo . i1i1i1111I / i1i1i1111I + I1Ii1I1 + IiIIii11Ii . I11iiIi11i1I
   if 19 - 19: i1iiIII111 + Oo * ooOOO
  else :
   if 29 - 29: oOO / IiIIii11Ii / Ii
   I11iiIiiiI1i = self . act_dict [ int ( self . inputGateActivation . value ) ]
   if 47 - 47: IiI11Ii111 + OooOoo * oOO * oOo0O00 / i1I
   ooOoOoOoOO = self . act_dict [ int ( self . forgetGateActivation . value ) ]
   if 83 - 83: i1i1i1111I * IiI11Ii111 + ooo000 - OooOoo + ooo000 / IiI11Ii111
   IiiiIiiiIiI1 = self . act_dict [ int ( self . outputGateActivation . value ) ]
   if 59 - 59: OooOoo * i1i1i1111I * Oo * Ii - Ii
   oO0Oo0 = self . act_dict [ int ( self . memoryActivation . value ) ]
   if 4 - 4: I1Ii1I1
   ooo000Ooo = I11i1I11IiII = self . act_dict [ int ( self . shadowGateActivation . value ) ]
   o0OooOooo00O = self . get_initiallizer ( key = 'inputGateWeightConfig' )
   II1iI1I1iI = self . get_initiallizer ( key = 'forgetGateWeightConfig' )
   o00OO0O0 = self . get_initiallizer ( key = 'outputGateWeightConfig' )
   oOO0Oo = self . get_initiallizer ( key = 'memoryWeightConfig' )
   oOoO000OO0 = self . get_initiallizer ( key = 'inputGateRecurrentWeightConfig' )
   iIii1i1IiI = self . get_initiallizer ( key = 'forgetGateRecurrentWeightConfig' )
   oooii1I1iI1IIII1 = self . get_initiallizer ( key = 'outputGateRecurrentWeightConfig' )
   i1I11i = self . get_initiallizer ( key = 'memoryRecurrentWeightConfig' )
   i1i11iIi1I1 = self . get_initiallizer ( key = 'inputGatePeepholeWeightConfig' )
   iIIIiIIIi1i = self . get_initiallizer ( key = 'forgetGatePeepholeWeightConfig' )
   III11iIiI = self . get_initiallizer ( key = 'outputGatePeepholeWeightConfig' )
   IiO0Oo = self . get_initiallizer ( key = 'inputGateBiasConfig' )
   Oo000OIIIIii = self . get_initiallizer ( key = 'forgetGateBiasConfig' )
   I1i1i1IIiI = self . get_initiallizer ( key = 'outputGateBiasConfig' )
   Ii1iI = self . get_initiallizer ( key = 'memoryBiasConfig' )
   I1111iIi1 = self . get_regularizer ( key = 'inputGateWeightConfig' )
   iIiIoOoOo0O0O = self . get_regularizer ( key = 'forgetGateWeightConfig' )
   oO0oOoo0ooo0 = self . get_regularizer ( key = 'outputGateWeightConfig' )
   i1i1111i = self . get_regularizer ( key = 'memoryWeightConfig' )
   IIi111II1i = self . get_regularizer ( key = 'inputGateRecurrentWeightConfig' )
   II1i1IiIiii11ii1i = self . get_regularizer ( key = 'forgetGateRecurrentWeightConfig' )
   iIiII = self . get_regularizer ( key = 'outputGateRecurrentWeightConfig' )
   OO0ooOo0o000OooO = self . get_regularizer ( key = 'memoryRecurrentWeightConfig' )
   OOOO0O00O = self . get_regularizer ( key = 'inputGatePeepholeWeightConfig' )
   i1oOoooO0Ooo0 = self . get_regularizer ( key = 'forgetGatePeepholeWeightConfig' )
   O00OOOO00o = self . get_regularizer ( key = 'outputGatePeepholeWeightConfig' )
   OoO0o000OOoo = self . get_regularizer ( key = 'inputGateBiasConfig' )
   iI1iIi11iiIii = self . get_regularizer ( key = 'forgetGateBiasConfig' )
   oOIiI11I11IiII = self . get_regularizer ( key = 'outputGateBiasConfig' )
   oo0O0O = self . get_regularizer ( key = 'memoryBiasConfig' )
   Iii11iiI = 'True' if self . usePeephole else 'False'
   oO0O00o0OoO00 = 'None' if self . memoryCellClip is None else str ( self . memoryCellClip )
   oOoO0oO00oO0 = 'None' if self . shadowStateClip is None else str ( self . shadowStateClip )
   I1iI111i = 'None' if self . returnSequenceLen is None else str ( self . returnSequenceLen )
   oO00oOooO0O = 'self.%s = LSTM(%d, activation = LSTM.Activation(%s,%s,%s,%s,%s),kernelInitializer = LSTM.Initializer(%s,%s,%s,%s),' 'recurrentInitializer = LSTM.Initializer(%s,%s,%s,%s),peepholeInitializer = LSTM.Initializer(%s,%s,%s,None),biasInitializer = LSTM.Initializer(%s,%s,%s,%s),' 'kernelRegularizer = LSTM.Regularizer(%s,%s,%s,%s),recurrentRegularizer = LSTM.Regularizer(%s,%s,%s,%s),peepholeRegularizer = LSTM.Regularizer(%s,%s,%s,None),' 'biasRegularizer = LSTM.Regularizer(%s,%s,%s,%s),useBias = %s,usePeephole = %s,dropout =%f,recurrentDropout =%f,' 'memoryCellClip = %s, shadowStateClip = %s, statefull = %s, goBackwards = %s, returnSequenceLen = %s, returnState = %s)' % ( self . name , self . layerUnits , I11iiIiiiI1i , ooOoOoOoOO , IiiiIiiiIiI1 , oO0Oo0 , ooo000Ooo , o0OooOooo00O , II1iI1I1iI , o00OO0O0 , oOO0Oo ,
   # Iii1i * IiI11Ii111 . i1I / oOO + I11iiIi11i1I % i1i1i1111I
   # I11iiIi11i1I * oOo0O00 * I1Ii1I1 / oOo0O00 + IIiIIiIi11I1 + oOo0O00
   # I1Ii1I1 + i1iiIII111
   # i1i1i1111I + OooOoo / ooo000 % i1iiIII111 % OooOoo
   # i1 * I11iiIi11i1I * Oo / Ooo0Ooo . OooOoo
 oOoO000OO0 , iIii1i1IiI , oooii1I1iI1IIII1 , i1I11i , i1i11iIi1I1 , iIIIiIIIi1i , III11iIiI ,
 IiO0Oo , Oo000OIIIIii , I1i1i1IIiI , Ii1iI , I1111iIi1 , iIiIoOoOo0O0O , oO0oOoo0ooo0 , i1i1111i ,
 IIi111II1i , II1i1IiIiii11ii1i , iIiII , OO0ooOo0o000OooO , OOOO0O00O , i1oOoooO0Ooo0 , O00OOOO00o ,
 OoO0o000OOoo , iI1iIi11iiIii , oOIiI11I11IiII , oo0O0O , Ii1Ii1Ii , Iii11iiI , IIIi1iii1Ii , OoO0000OO00o0 , oO0O00o0OoO00 , oOoO0oO00oO0 , I11I , OO0O0oooOo , I1iI111i , OOooOo00 )
  OoOO . append ( oO00oOooO0O )
  if 69 - 69: IiIIii11Ii % Oo / Ii * Ii
  if 91 - 91: i1iiIII111 / Ii % I1I . I1Ii1I1
  if 94 - 94: iI1iII1I1I1i + oOo0O00 . i1i1i1111I + I11iiIi11i1I + OooOoo / ooOOO
  if 97 - 97: I1Ii1I1 . i1iiIII111
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 79 - 79: I11iiIi11i1I % IiIIii11Ii % i1iiIII111
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 57 - 57: i1 % IiI11Ii111
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 63 - 63: ooo000 / oOO . IiIIii11Ii
  if 46 - 46: OooOoo
  if 85 - 85: IiIIii11Ii / IiI11Ii111 % ooOOO . i1
  if 99 - 99: i1I / IiI11Ii111 + i1iiIII111
  if 53 - 53: iI1iII1I1I1i . Iii1i / Ii - Ooo0Ooo / IIiIIiIi11I1
  if 80 - 80: IiI11Ii111 % IIiIIiIi11I1 / ooo000 / Ii / Oo
  if 45 - 45: IIiIIiIi11I1 / I1I - oOo0O00 - oOO * Oo . oOO
  if 39 - 39: IIiIIiIi11I1 % i1I % Iii1i
  if 46 - 46: Oo % oOO
  if 37 - 37: i1I . Ii . I1Ii1I1
  if 44 - 44: iI1iII1I1I1i % OooOoo % i1iiIII111
  if 60 - 60: I1I . Iii1i
  if 23 - 23: i1 . iI1iII1I1I1i
  if 98 - 98: IiIIii11Ii * oOo0O00
  if 6 - 6: i1 * ooOOO / Iii1i
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 13 - 13: iI1iII1I1I1i + IiIIii11Ii % Ii * Ooo0Ooo
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 5 - 5: i1 * IIiIIiIi11I1 / IiI11Ii111 . ooo000 % IiIIii11Ii
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    if len ( input_shape ) < 5 :
     II = input_shape [ 0 : 2 ]
     II . append ( - 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "When dimension of data is more than 4, it is not supported." )
   elif len ( input_shape ) == 2 :
    OoOo = input_shape [ - 1 ]
    II = input_shape [ 0 : 1 ]
    II . append ( 1 )
    II . append ( OoOo )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ '1' , str ( int ( OoOo ) ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 65 - 65: Iii1i . i1i1i1111I / oOo0O00
class O0o00o ( oO00ooO00oOO0 ) :
 if 23 - 23: ooo000 . i1i1i1111I
 if 46 - 46: i1iiIII111 * Iii1i
 if 11 - 11: iI1iII1I1I1i . IiI11Ii111 - iI1iII1I1I1i % i1iiIII111 % Iii1i
 if 39 - 39: Ii * ooo000 . OooOoo / i1iiIII111
 if 6 - 6: iI1iII1I1I1i
 if 64 - 64: i1i1i1111I % oOo0O00 - oOO
 if 83 - 83: IiI11Ii111 . I1I / i1 % Iii1i - oOo0O00
 def __init__ ( self , name : str = None , layerUnits : int = 150 , incomingConfig : 'IncomingConfig' = i1iIi1i1i1I1 . Concat ( ) ,
 isKerasLayer : bool = False ,
 linearTransform : 'RNNConfig' = o00o00O000 . createBasicConfig ( ) ,
 activation : int = iI11II1 . Tanh , activationParams : Dict = { } ,
 batchNorm : bool = True , useBias : bool = True , dropout : float = 1 , recurrentDropout : float = 1 ,
 stateClip : float = None , statefull : bool = False , mergeMode : str = 'concat' ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 83 - 83: Iii1i - Iii1i - Ooo0Ooo
  if 56 - 56: IiIIii11Ii
  if 64 - 64: i1iiIII111 - IIiIIiIi11I1 / i1I / i1 % i1i1i1111I
  if 94 - 94: I1Ii1I1
  if 94 - 94: I11iiIi11i1I % OooOoo / i1i1i1111I
  if 66 - 66: oOO % Iii1i - Ooo0Ooo . oOo0O00 / ooOOO * ooOOO
  if 45 - 45: ooo000
  if 78 - 78: I1I . Iii1i - ooOOO / Iii1i
  if 70 - 70: IiI11Ii111 + I11iiIi11i1I - i1 + i1iiIII111 . Ii * OooOoo
  if 81 - 81: oOo0O00 * i1I / IiI11Ii111 / Oo
  if 73 - 73: ooo000
  if 46 - 46: i1I + oOO + Iii1i
  if 53 - 53: i1I . i1iiIII111
  if 17 - 17: IiI11Ii111 - I11iiIi11i1I + ooo000 * iI1iII1I1I1i . IiIIii11Ii / Ii
  if 77 - 77: i1 / Iii1i
  if 19 - 19: Ooo0Ooo
  if 99 - 99: OooOoo / i1iiIII111 . I11iiIi11i1I / i1iiIII111 + I1Ii1I1
  if 72 - 72: I1I
  if 33 - 33: I11iiIi11i1I - iI1iII1I1I1i + OooOoo + OooOoo / ooo000
  if 49 - 49: Ii
  if 27 - 27: Oo / I11iiIi11i1I . I1Ii1I1 - i1iiIII111 . Ii
  if 87 - 87: i1iiIII111 + i1i1i1111I
  if 32 - 32: i1I
  if 97 - 97: IiI11Ii111 % I1Ii1I1 - oOo0O00 % Ooo0Ooo / IiI11Ii111 + IIiIIiIi11I1
  if linearTransform is None :
   linearTransform = o00o00O000 . createBasicConfig ( )
  super ( ) . __init__ ( o00OoOo0O0O00 . BiRNN , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , outputConfig = outputConfig )
  self . isKerasLayer = isKerasLayer
  self . activation = activation
  self . activationParams = activationParams
  self . useBias = useBias
  self . dropout = dropout
  self . recurrentDropout = recurrentDropout
  self . stateClip = stateClip
  self . statefull = statefull
  self . mergeMode = mergeMode
  if 98 - 98: IIiIIiIi11I1 . I1I . i1iiIII111 + ooo000
 def copy ( self , name ) :
  if 23 - 23: IiIIii11Ii
  if 46 - 46: IIiIIiIi11I1 / OooOoo + Oo
  if 52 - 52: i1I . IIiIIiIi11I1 + i1I + Oo + i1I
  if 94 - 94: ooOOO
  if 42 - 42: Ii % i1iiIII111 - oOo0O00
  if 93 - 93: OooOoo % OooOoo % Ii + IiI11Ii111
  if 65 - 65: Ooo0Ooo - i1i1i1111I - Oo * iI1iII1I1I1i % Ii
  if 2 - 2: IiI11Ii111 + IiI11Ii111 % Iii1i . Ooo0Ooo
  if 12 - 12: OooOoo . I1I . IiIIii11Ii . Ooo0Ooo + iI1iII1I1I1i
  if 60 - 60: Oo / I1I - IiIIii11Ii
  if 80 - 80: ooOOO * ooOOO
  if self . __class__ . __name__ != "BiRNNLayer" :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 39 - 39: iI1iII1I1I1i . i1iiIII111 - oOo0O00
   if 59 - 59: i1I % i1iiIII111 . IiI11Ii111 + IiI11Ii111 / oOO
  return O0o00o ( name = name , layerUnits = self . layerUnits , incomingConfig = self . incomingConfig ,
 isKerasLayer = self . isKerasLayer , linearTransform = self . linearTransform , activation = self . activation , activationParams = self . activationParams ,
 batchNorm = self . batchNorm , useBias = self . useBias , dropout = self . dropout , recurrentDropout = self . recurrentDropout ,
 stateClip = self . stateClip , statefull = self . statefull , mergeMode = self . mergeMode , outputConfig = self . outputConfig )
  if 75 - 75: IiIIii11Ii - Oo * OooOoo + i1iiIII111
 def keras_layer_build ( self ) :
  if 92 - 92: IIiIIiIi11I1 . oOo0O00 * I1Ii1I1 / I1Ii1I1 . Iii1i
  if 100 - 100: I1I - Ooo0Ooo
  if 2 - 2: Oo
  if 39 - 39: i1 / i1 / OooOoo
  if 98 - 98: oOo0O00 . Ii / Oo + i1I - I1I
  if 92 - 92: i1 + oOo0O00 % Iii1i / i1i1i1111I - I11iiIi11i1I
  if 39 - 39: Iii1i - Iii1i % i1iiIII111 / Oo
  if 84 - 84: Ii % I1I * I1I
  if 30 - 30: i1
  if 73 - 73: Ii - IiIIii11Ii
  if self . isKerasLayer :
   return 'self.%s = tf.keras.layers.Bidirectional(tf.keras.layers.SimpleRNN(%d, return_sequences=True))' % ( self . name , self . layerUnits )
  else :
   return 'self.%s = BiRNN(%d)' % ( self . name , self . layerUnits )
   if 90 - 90: Ii / iI1iII1I1I1i * i1i1i1111I / i1i1i1111I
 def _activationToKerasName ( self , activation ) :
  if 47 - 47: Ooo0Ooo * Ooo0Ooo - I1Ii1I1 * I11iiIi11i1I / IiIIii11Ii - oOO
  if 17 - 17: Iii1i / ooo000 . I11iiIi11i1I . Ii
  if 25 - 25: I1I
  if 68 - 68: ooOOO % ooo000 / oOo0O00 / Iii1i
  if 94 - 94: IIiIIiIi11I1 + IiIIii11Ii + i1i1i1111I
  if 43 - 43: IiI11Ii111 - i1 % I1Ii1I1 / i1I % oOO . i1i1i1111I
  if 21 - 21: Iii1i * i1i1i1111I % i1i1i1111I % IIiIIiIi11I1 - Iii1i
  if 11 - 11: I11iiIi11i1I * IIiIIiIi11I1 / Oo - i1I - i1iiIII111
  if 52 - 52: i1iiIII111 % oOO * ooo000 - Ooo0Ooo
  if 16 - 16: iI1iII1I1I1i . IIiIIiIi11I1
  if activation == iI11II1 . Relu6 or activation == iI11II1 . Crelu :
   I11i1I11IiII = 'relu'
  elif activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'hard_sigmoid'
  else :
   I11i1I11IiII = ( iI11II1 . getName ( activation ) ) . split ( '.' ) [ - 1 ] . lower ( )
  return I11i1I11IiII
  if 92 - 92: oOo0O00 * ooOOO * Oo + ooo000 + iI1iII1I1I1i + oOo0O00
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 28 - 28: IiI11Ii111 + I1Ii1I1 % oOO + i1i1i1111I
  if 28 - 28: Oo % I11iiIi11i1I
  if 2 - 2: I1Ii1I1
  if 79 - 79: IiIIii11Ii + ooOOO % ooOOO * iI1iII1I1I1i + i1iiIII111 / I1Ii1I1
  if 50 - 50: iI1iII1I1I1i . oOo0O00 . i1I
  if 11 - 11: Ii . ooOOO
  if 56 - 56: OooOoo + oOo0O00 - ooOOO . Ooo0Ooo + i1iiIII111 + ooOOO
  if 28 - 28: I1Ii1I1
  if 74 - 74: i1
  if 68 - 68: i1iiIII111 - Oo
  if 20 - 20: iI1iII1I1I1i + i1I / OooOoo % i1 - I1I
  if 58 - 58: Ii
  if 77 - 77: i1i1i1111I . IiI11Ii111 / i1i1i1111I
  if 87 - 87: OooOoo / iI1iII1I1I1i
  if 93 - 93: IiIIii11Ii . ooOOO % IiIIii11Ii / i1i1i1111I
  if self . mergeMode == 'concat' :
   II = [ None , inputshape [ 1 ] , self . layerUnits * 2 ]
  else :
   II = [ None , inputshape [ 1 ] , self . layerUnits ]
   if 12 - 12: oOo0O00 - I1Ii1I1 / Oo / i1iiIII111 % I11iiIi11i1I
  self . dropout = 1 - self . dropout / 100.
  self . recurrentDropout = 1 - self . recurrentDropout / 100.
  if 28 - 28: I1I
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 22 - 22: IiIIii11Ii - Iii1i - oOo0O00 / IiI11Ii111 . iI1iII1I1I1i
  OoOO , OoooOO0 = [ ] , [ ]
  if 16 - 16: i1i1i1111I % oOO + oOo0O00 + ooo000 / iI1iII1I1I1i / ooOOO
  if 67 - 67: oOO . I1I - IIiIIiIi11I1 . oOO * OooOoo + i1I
  I11i1I11IiII = self . act_dict [ self . activation . value ]
  Ii1Ii1Ii = 'True' if self . useBias else 'False'
  O0OOO0O0OO000 = self . get_initiallizer ( key = 'weightConfig' )
  Oo000 = self . get_initiallizer ( key = 'recurrentWeightConfig' )
  OOOoooO = self . get_initiallizer ( key = 'biasConfig' )
  i1IiiIi1iIiIIi = self . get_regularizer ( key = 'weightConfig' )
  II111II1I1 = self . get_regularizer ( key = 'recurrentWeightConfig' )
  ooiiii1IiIi = self . get_regularizer ( key = 'biasConfig' )
  IIIi1iii1Ii = self . dropout
  OoO0000OO00o0 = self . recurrentDropout
  I11I = 'True' if self . statefull else 'False'
  Oo0O0O = self . mergeMode
  if 71 - 71: i1I . ooo000 / i1i1i1111I
  if self . isKerasLayer :
   iIII1I11i11iI = 'True'
   if 63 - 63: IiIIii11Ii * oOO * IiI11Ii111 - iI1iII1I1I1i / oOo0O00 * I1Ii1I1
   oO00oOooO0O = 'self.%s =  tf.keras.layers.Bidirectional(tf.keras.layers.SimpleRNN(%d, activation = %s, use_bias=%s,  kernel_initializer=%s, recurrent_initializer=%s, bias_initializer=%s,' 'kernel_regularizer=%s, recurrent_regularizer=%s, bias_regularizer=%s, dropout=%f, recurrent_dropout=%f, return_sequences=%s, return_state=%s,' 'stateful=%s ),merge_mode=\'%s\')' % ( self . name , self . layerUnits , I11i1I11IiII , Ii1Ii1Ii , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , IIIi1iii1Ii , OoO0000OO00o0 , I11I , Oo0O0O )
   if 85 - 85: Ii . IiI11Ii111 / ooo000 . Ii . OooOoo
   if 66 - 66: Oo
  else :
   Ii1 = 'None' if self . stateClip is None else str ( self . stateClip )
   if 14 - 14: IIiIIiIi11I1
   oO00oOooO0O = 'self.%s = BiRNN(%d, activation = %s,kernelInitializer = %s,recurrentInitializer = %s,biasInitializer = %s,' 'kernelRegularizer = %s,recurrentRegularizer = %s,biasRegularizer = %s,useBias = %s,dropout =%f,recurrentDropout =%f,' 'stateClip = %s, statefull = %s, mergeMode = \'%s\')' % ( self . name , self . layerUnits , I11i1I11IiII , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , Ii1Ii1Ii , IIIi1iii1Ii , OoO0000OO00o0 , Ii1 , I11I , Oo0O0O )
   if 5 - 5: oOo0O00 . IIiIIiIi11I1 * oOO
   if 84 - 84: i1 - oOo0O00 - Ii % OooOoo + iI1iII1I1I1i . Iii1i
   if 17 - 17: IIiIIiIi11I1
   if 31 - 31: Ii - i1i1i1111I * i1 - Ooo0Ooo . OooOoo
  OoOO . append ( oO00oOooO0O )
  if 75 - 75: i1i1i1111I % iI1iII1I1I1i . IIiIIiIi11I1
  if 15 - 15: IIiIIiIi11I1 - IIiIIiIi11I1 - ooOOO * ooo000 . ooo000
  if 7 - 7: oOO + oOO + I11iiIi11i1I * oOO
  if 84 - 84: oOo0O00 * OooOoo + oOo0O00
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 44 - 44: ooOOO
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 94 - 94: I11iiIi11i1I * ooo000 % IiIIii11Ii + I11iiIi11i1I / Ooo0Ooo
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 72 - 72: i1iiIII111 + I1Ii1I1 . i1iiIII111 - IIiIIiIi11I1 / Ooo0Ooo - iI1iII1I1I1i
  if 31 - 31: i1iiIII111
  if 48 - 48: ooOOO + i1i1i1111I
  if 89 - 89: I1I % i1i1i1111I / OooOoo . ooo000
  if 69 - 69: oOO
  if 53 - 53: Iii1i + I1I - i1iiIII111 + i1iiIII111 % Ooo0Ooo
  if 96 - 96: IIiIIiIi11I1 % i1i1i1111I - oOo0O00 . ooo000 + oOO % I1Ii1I1
  if 56 - 56: oOo0O00 / oOo0O00 / I1I / IiI11Ii111 + I11iiIi11i1I / I11iiIi11i1I
  if 82 - 82: Iii1i . OooOoo + i1i1i1111I + I1I
  if 51 - 51: I1Ii1I1 - i1iiIII111
  if 69 - 69: I11iiIi11i1I . Oo / ooOOO . Iii1i
  if 91 - 91: I11iiIi11i1I + ooOOO - Ooo0Ooo / IiIIii11Ii . oOo0O00
  if 60 - 60: I1Ii1I1
  if 9 - 9: OooOoo - IiIIii11Ii - I1I - I1Ii1I1 / Iii1i . Ooo0Ooo
  if 13 - 13: IiI11Ii111
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 29 - 29: IiI11Ii111 % OooOoo + IIiIIiIi11I1 % oOo0O00
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 100 - 100: I1Ii1I1 . I1I * IiIIii11Ii / i1 / i1iiIII111
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    if len ( input_shape ) < 5 :
     II = input_shape [ 0 : 2 ]
     II . append ( - 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "When dimension of data is more than 4, it is not supported." )
   elif len ( input_shape ) == 2 :
    OoOo = input_shape [ - 1 ]
    II = input_shape [ 0 : 1 ]
    II . append ( 1 )
    II . append ( OoOo )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ '1' , str ( int ( OoOo ) ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 67 - 67: IiIIii11Ii + Ooo0Ooo % oOO / I11iiIi11i1I / ooo000 + Ii
class OoO000oOOOO ( oO00ooO00oOO0 ) :
 if 14 - 14: Ooo0Ooo % Ii
 if 86 - 86: i1iiIII111 - Iii1i . oOo0O00
 if 24 - 24: i1iiIII111 / ooOOO % ooo000
 if 48 - 48: i1I % I1I / i1iiIII111 / i1i1i1111I - iI1iII1I1I1i
 if 56 - 56: IiIIii11Ii * I11iiIi11i1I / i1I + ooOOO % Iii1i
 if 67 - 67: iI1iII1I1I1i + OooOoo - IiI11Ii111 - OooOoo - Iii1i % IiI11Ii111
 if 18 - 18: i1i1i1111I - Iii1i + oOo0O00 . ooo000
 def __init__ ( self , name : str = None , layerUnits : int = 150 , incomingConfig : 'IncomingConfig' = i1iIi1i1i1I1 . Concat ( ) ,
 isKerasLayer : bool = False ,
 linearTransform : 'GRUConfig' = iii1i1IIIi11 . createBasicConfig ( ) ,
 resetGateActivation : int = iI11II1 . Sigmoid , updateGateActivation : int = iI11II1 . Sigmoid , stateCandidateActivation : int = iI11II1 . Tanh ,
 batchNorm : bool = True , useBias : bool = True , dropout : float = 1 , recurrentDropout : float = 1 ,
 stateClip : float = None , statefull : bool = False , mergeMode : str = 'concat' , outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 33 - 33: I11iiIi11i1I
  if 64 - 64: Oo % i1 - Oo - I11iiIi11i1I % i1iiIII111
  if 58 - 58: OooOoo + IiIIii11Ii + Oo / oOo0O00 - Ii / i1i1i1111I
  if 15 - 15: Ii % I1Ii1I1 % IiI11Ii111 * ooOOO + oOO * i1iiIII111
  if 18 - 18: i1i1i1111I
  if 84 - 84: IiIIii11Ii . i1I
  if 40 - 40: I1I / oOO / IIiIIiIi11I1 . i1I
  if 86 - 86: OooOoo + Ooo0Ooo - Ii % iI1iII1I1I1i . iI1iII1I1I1i
  if 4 - 4: Ii % i1iiIII111 * I1I / iI1iII1I1I1i
  if 8 - 8: IiI11Ii111 . i1 * i1 - IiI11Ii111 % Ooo0Ooo % i1iiIII111
  if 9 - 9: I1I * ooOOO - Ooo0Ooo
  if 24 - 24: i1I - IiIIii11Ii . i1iiIII111 + i1i1i1111I / i1I
  if 6 - 6: ooo000 / Oo - i1iiIII111 / ooOOO % Iii1i
  if 38 - 38: Ii - i1 % Iii1i * iI1iII1I1I1i
  if 32 - 32: Ooo0Ooo + Iii1i . IIiIIiIi11I1
  if 75 - 75: ooOOO * IIiIIiIi11I1 . I11iiIi11i1I - IiIIii11Ii
  if 98 - 98: ooOOO + OooOoo % i1iiIII111 + i1I
  if 30 - 30: oOO + I11iiIi11i1I
  if 49 - 49: oOo0O00 + oOO - Iii1i . I1Ii1I1 / Iii1i
  if 86 - 86: Ooo0Ooo - ooo000 + I1I + IIiIIiIi11I1 . IiIIii11Ii
  if 89 - 89: i1I + OooOoo - IIiIIiIi11I1 * OooOoo + I1I
  if 30 - 30: Oo * oOO / i1
  if 37 - 37: IIiIIiIi11I1 * Iii1i
  if 31 - 31: I1Ii1I1 + IiI11Ii111 - I11iiIi11i1I - IiIIii11Ii
  if 62 - 62: IiI11Ii111 / ooo000 . IiI11Ii111
  if linearTransform is None :
   linearTransform = iii1i1IIIi11 . createBasicConfig ( )
  super ( ) . __init__ ( o00OoOo0O0O00 . BiGRU , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , outputConfig = outputConfig )
  self . isKerasLayer = isKerasLayer
  if self . isKerasLayer :
   if resetGateActivation != updateGateActivation :
    raise ValueError ( 'The recurrent_activation of keras GRU layer is wrong' )
    if 14 - 14: ooOOO % ooo000
  self . resetGateActivation = resetGateActivation
  self . updateGateActivation = updateGateActivation
  self . stateCandidateActivation = stateCandidateActivation
  self . useBias = useBias
  self . dropout = dropout
  self . recurrentDropout = recurrentDropout
  self . stateClip = stateClip
  self . statefull = statefull
  self . mergeMode = mergeMode
  if 71 - 71: i1 / IIiIIiIi11I1 / ooo000 - ooo000 . I1I
 def copy ( self , name ) :
  if 80 - 80: I11iiIi11i1I + Oo . OooOoo - i1iiIII111 / Oo
  if 23 - 23: oOo0O00 - Oo % IiIIii11Ii
  if 27 - 27: Ooo0Ooo + Ii
  if 82 - 82: IiI11Ii111 / Oo % I11iiIi11i1I * Iii1i
  if 68 - 68: ooOOO + Ii / ooo000
  if 1 - 1: IiI11Ii111 * i1 * ooo000 % Ii . IIiIIiIi11I1
  if 71 - 71: ooOOO * I1I % Iii1i + Oo - IIiIIiIi11I1
  if 59 - 59: I11iiIi11i1I / OooOoo
  if 5 - 5: i1i1i1111I + i1 . oOO + Ooo0Ooo
  if 44 - 44: Ooo0Ooo % oOO * Iii1i . i1
  if 24 - 24: OooOoo
  if self . __class__ . __name__ != "BiGRULayer" :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 21 - 21: Oo . i1 - I1Ii1I1
   if 72 - 72: i1iiIII111
  return OoO000oOOOO ( name = name , layerUnits = self . layerUnits , incomingConfig = self . incomingConfig ,
 isKerasLayer = self . isKerasLayer , linearTransform = self . linearTransform , resetGateActivation = self . resetGateActivation ,
 updateGateActivation = self . updateGateActivation , stateCandidateActivation = self . stateCandidateActivation ,
 batchNorm = self . batchNorm , useBias = self . useBias , dropout = self . dropout , recurrentDropout = self . recurrentDropout ,
 stateClip = self . stateClip , statefull = self . statefull , mergeMode = self . mergeMode , outputConfig = self . outputConfig )
  if 79 - 79: i1iiIII111 * oOo0O00 * i1i1i1111I / ooOOO / Ooo0Ooo * IIiIIiIi11I1
 def keras_layer_build ( self ) :
  if 33 - 33: Iii1i
  if 80 - 80: oOo0O00 . iI1iII1I1I1i / oOO
  if 13 - 13: Oo . IiIIii11Ii % I11iiIi11i1I
  if 60 - 60: Ooo0Ooo / Ooo0Ooo . i1 * Ii + i1i1i1111I + I1I
  if 5 - 5: IiIIii11Ii
  if 60 - 60: i1I / IiIIii11Ii
  if 27 - 27: i1I - Oo
  if 65 - 65: i1 / Oo
  if 53 - 53: Ooo0Ooo . IiI11Ii111 / Ooo0Ooo % oOO
  if 9 - 9: i1iiIII111 - oOO + oOo0O00 . OooOoo + i1 * i1
  if self . isKerasLayer :
   return 'self.%s = tf.keras.layers.Bidirectional(tf.keras.layers.GRU(%d, return_sequences=True))' % ( self . name , self . layerUnits )
  else :
   return 'self.%s = BiGRU(%d)' % ( self . name , self . layerUnits )
   if 45 - 45: Oo * i1iiIII111
 def _activationToKerasName ( self , activation ) :
  if 52 - 52: OooOoo
  if 28 - 28: I1Ii1I1 * IIiIIiIi11I1 + ooo000 + IIiIIiIi11I1 % OooOoo % IIiIIiIi11I1
  if 11 - 11: IiIIii11Ii + i1i1i1111I * iI1iII1I1I1i / I1I . IiIIii11Ii
  if 91 - 91: iI1iII1I1I1i % iI1iII1I1I1i % Iii1i % IIiIIiIi11I1 % oOo0O00 % Oo
  if 59 - 59: IIiIIiIi11I1 - i1 % I1I % IiI11Ii111 - i1
  if 74 - 74: IiI11Ii111 * i1iiIII111 % IIiIIiIi11I1
  if 24 - 24: OooOoo
  if 7 - 7: I1Ii1I1 + Oo
  if 8 - 8: Oo % ooOOO . Ooo0Ooo
  if 68 - 68: i1 . i1I % i1 * i1i1i1111I / I11iiIi11i1I / Ooo0Ooo
  if activation == iI11II1 . Relu6 or activation == iI11II1 . Crelu :
   I11i1I11IiII = 'relu'
  elif activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'hard_sigmoid'
  else :
   I11i1I11IiII = ( iI11II1 . getName ( activation ) ) . split ( '.' ) [ - 1 ] . lower ( )
  return I11i1I11IiII
  if 26 - 26: oOo0O00 * OooOoo % i1iiIII111 / OooOoo * ooOOO * IiI11Ii111
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 26 - 26: Oo * ooOOO . iI1iII1I1I1i . ooo000
  if 24 - 24: Oo + i1 . Iii1i * Ooo0Ooo . ooOOO
  if 6 - 6: Iii1i + IiI11Ii111 / iI1iII1I1I1i * ooo000 * Oo / Oo
  if 68 - 68: Ooo0Ooo . Ii % i1 + i1I % i1i1i1111I
  if 14 - 14: I11iiIi11i1I * i1i1i1111I / IiI11Ii111
  if 74 - 74: I1Ii1I1
  if 1 - 1: ooOOO / i1i1i1111I + i1iiIII111 % Iii1i
  if 9 - 9: Ooo0Ooo - oOo0O00 * i1i1i1111I * Iii1i + IiI11Ii111 % IiIIii11Ii
  if 64 - 64: ooo000 + i1i1i1111I % i1 . i1 + i1iiIII111 . i1
  if 24 - 24: Oo / i1I + IiI11Ii111 / I11iiIi11i1I / OooOoo
  if 100 - 100: IiIIii11Ii / IiI11Ii111
  if 52 - 52: IIiIIiIi11I1 + I1Ii1I1
  if 99 - 99: ooOOO / Oo - i1 % i1I
  if 13 - 13: I1Ii1I1 + iI1iII1I1I1i - I1I * Iii1i
  if 70 - 70: OooOoo * ooOOO * i1 . ooo000
  if self . mergeMode == 'concat' :
   II = [ None , inputshape [ 1 ] , self . layerUnits * 2 ]
  else :
   II = [ None , inputshape [ 1 ] , self . layerUnits ]
  self . dropout = 1 - self . dropout / 100.
  self . recurrentDropout = 1 - self . recurrentDropout / 100.
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 37 - 37: Iii1i . I1Ii1I1 * IiIIii11Ii * oOo0O00 * Iii1i
  OoOO , OoooOO0 = [ ] , [ ]
  if 56 - 56: ooo000 + iI1iII1I1I1i * IiIIii11Ii - IIiIIiIi11I1 . IIiIIiIi11I1 / IIiIIiIi11I1
  Ii1Ii1Ii = 'True' if self . useBias else 'False'
  IIIi1iii1Ii = self . dropout
  OoO0000OO00o0 = self . recurrentDropout
  I11I = 'True' if self . statefull else 'False'
  Oo0O0O = self . mergeMode
  if 91 - 91: I1Ii1I1 / Oo % OooOoo
  if self . isKerasLayer :
   I11i1I11IiII = self . act_dict [ int ( self . stateCandidateActivation . value ) ]
   iI1I1I1III1 = self . act_dict [ int ( self . resetGateActivation . value ) ]
   O0OOO0O0OO000 = self . get_initiallizer ( key = 'resetGateWeightConfig' )
   Oo000 = self . get_initiallizer ( key = 'resetGateRecurrentWeightConfig' )
   OOOoooO = self . get_initiallizer ( key = 'resetGateBiasConfig' )
   i1IiiIi1iIiIIi = self . get_regularizer ( key = 'resetGateWeightConfig' )
   II111II1I1 = self . get_regularizer ( key = 'resetGateRecurrentWeightConfig' )
   ooiiii1IiIi = self . get_regularizer ( key = 'resetGateBiasConfig' )
   iIII1I11i11iI = 'True'
   oO00oOooO0O = 'self.%s = tf.keras.layers.Bidirectional(tf.keras.layers.GRU(%d, activation = %s,recurrent_activation = %s, use_bias=%s,  kernel_initializer=%s, recurrent_initializer=%s, bias_initializer=%s,' 'kernel_regularizer=%s, recurrent_regularizer=%s, bias_regularizer=%s, dropout=%f, recurrent_dropout=%f, return_sequences=%s,' 'stateful=%s ),merge_mode=\'%s\')' % ( self . name , self . layerUnits , I11i1I11IiII , iI1I1I1III1 , Ii1Ii1Ii , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , IIIi1iii1Ii , OoO0000OO00o0 , iIII1I11i11iI , I11I , Oo0O0O )
   if 27 - 27: i1iiIII111 - i1iiIII111 * oOo0O00 - Oo + i1I + I1I
   if 1 - 1: i1i1i1111I
   if 95 - 95: Iii1i % oOO / I1Ii1I1
  else :
   if 33 - 33: i1
   Ii1i11IIiI = self . act_dict [ int ( self . resetGateActivation . value ) ]
   if 7 - 7: OooOoo / I11iiIi11i1I * oOo0O00 / ooo000 / ooOOO
   OoooO00o = self . act_dict [ int ( self . updateGateActivation . value ) ]
   if 39 - 39: Ooo0Ooo - Iii1i / i1I
   Oo00O = self . act_dict [ int ( self . stateCandidateActivation . value ) ]
   Ii1I11I1ii1 = self . get_initiallizer ( key = 'resetGateWeightConfig' )
   ooo0i11ii11 = self . get_initiallizer ( key = 'updateGateWeightConfig' )
   IiIi11 = self . get_initiallizer ( key = 'stateCandidateWeightConfig' )
   o000Ooo = self . get_initiallizer ( key = 'resetGateRecurrentWeightConfig' )
   IIiIi1i = self . get_initiallizer ( key = 'updateGateRecurrentWeightConfig' )
   II1IIIii1III1 = self . get_initiallizer ( key = 'stateCandidateRecurrentWeightConfig' )
   IIiII = self . get_initiallizer ( key = 'resetGateBiasConfig' )
   oO0o00O = self . get_initiallizer ( key = 'updateGateBiasConfig' )
   i1Ii11Iii = self . get_initiallizer ( key = 'stateCandidateBiasConfig' )
   i1I1IIi1IIIi1 = self . get_regularizer ( key = 'resetGateWeightConfig' )
   oOOo = self . get_regularizer ( key = 'updateGateWeightConfig' )
   I11111II = self . get_regularizer ( key = 'stateCandidateWeightConfig' )
   ooO0OO000OoO0O = self . get_regularizer ( key = 'resetGateRecurrentWeightConfig' )
   IiIIIII1ii1IIii = self . get_regularizer ( key = 'updateGateRecurrentWeightConfig' )
   O0oiI1iIiiI1I11 = self . get_regularizer ( key = 'stateCandidateRecurrentWeightConfig' )
   I1o0 = self . get_regularizer ( key = 'resetGateBiasConfig' )
   OOOooO = self . get_regularizer ( key = 'updateGateBiasConfig' )
   IIII1i11 = self . get_regularizer ( key = 'stateCandidateBiasConfig' )
   i1iIi11I1IiIi = 'None' if self . stateClip is None else str ( self . stateClip )
   oO00oOooO0O = 'self.%s = BiGRU(%d, activation = BiGRU.Activation(%s,%s,%s),kernelInitializer = BiGRU.Initializer(%s,%s,%s),' 'recurrentInitializer = BiGRU.Initializer(%s,%s,%s),biasInitializer = BiGRU.Initializer(%s,%s,%s),' 'kernelRegularizer = BiGRU.Regularizer(%s,%s,%s),recurrentRegularizer = BiGRU.Regularizer(%s,%s,%s),' 'biasRegularizer = BiGRU.Regularizer(%s,%s,%s),useBias = %s,dropout =%f,recurrentDropout =%f,' 'stateClip = %s, statefull = %s, mergeMode = \'%s\')' % ( self . name , self . layerUnits , Ii1i11IIiI , OoooO00o , Oo00O , Ii1I11I1ii1 , ooo0i11ii11 , IiIi11 ,
   # ooo000 . i1I - oOO + oOo0O00 . ooOOO % Iii1i
   # oOo0O00 - Ooo0Ooo + i1i1i1111I + i1iiIII111
   # IIiIIiIi11I1 . i1I * i1 / Ii
   # OooOoo
   # I1I % i1I + OooOoo * ooOOO % oOo0O00
 o000Ooo , IIiIi1i , II1IIIii1III1 ,
 IIiII , oO0o00O , i1Ii11Iii , i1I1IIi1IIIi1 , oOOo , I11111II ,
 ooO0OO000OoO0O , IiIIIII1ii1IIii , O0oiI1iIiiI1I11 ,
 I1o0 , OOOooO , IIII1i11 , Ii1Ii1Ii , IIIi1iii1Ii , OoO0000OO00o0 , i1iIi11I1IiIi , I11I , Oo0O0O )
  OoOO . append ( oO00oOooO0O )
  if 43 - 43: IIiIIiIi11I1 . I1Ii1I1 + IiI11Ii111
  if 87 - 87: oOO / I1I . IIiIIiIi11I1 * ooOOO % ooOOO
  if 4 - 4: Iii1i
  if 9 - 9: i1iiIII111
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 56 - 56: IIiIIiIi11I1 % IiI11Ii111 - i1 . Ooo0Ooo * ooOOO
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 78 - 78: oOo0O00 + OooOoo / ooo000 . i1I
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 53 - 53: IiI11Ii111 % I11iiIi11i1I / i1I - i1I - i1I - i1
  if 38 - 38: IiI11Ii111 + I1I - IIiIIiIi11I1 + OooOoo / I1I
  if 93 - 93: i1iiIII111
  if 17 - 17: Ii - iI1iII1I1I1i + oOo0O00 % i1i1i1111I % iI1iII1I1I1i + i1iiIII111
  if 68 - 68: Iii1i
  if 5 - 5: IiIIii11Ii
  if 40 - 40: IiIIii11Ii - I1Ii1I1 . ooOOO
  if 48 - 48: IIiIIiIi11I1 / i1I * oOO * ooOOO
  if 66 - 66: Ii
  if 19 - 19: i1
  if 22 - 22: Ii - I11iiIi11i1I - ooo000 % i1i1i1111I * IIiIIiIi11I1
  if 68 - 68: OooOoo / OooOoo * Ii + Oo % IiIIii11Ii + iI1iII1I1I1i
  if 30 - 30: OooOoo / I1Ii1I1
  if 32 - 32: ooo000 / i1i1i1111I . IiIIii11Ii - OooOoo + IiI11Ii111 - I11iiIi11i1I
  if 67 - 67: Ii / IiI11Ii111
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 74 - 74: OooOoo . OooOoo + oOo0O00 / I1I % IiI11Ii111 * Ii
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 93 - 93: I11iiIi11i1I . i1iiIII111 + IIiIIiIi11I1 - OooOoo
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    if len ( input_shape ) < 5 :
     II = input_shape [ 0 : 2 ]
     II . append ( - 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "When dimension of data is more than 4, it is not supported." )
   elif len ( input_shape ) == 2 :
    OoOo = input_shape [ - 1 ]
    II = input_shape [ 0 : 1 ]
    II . append ( 1 )
    II . append ( OoOo )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ '1' , str ( int ( OoOo ) ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 57 - 57: IIiIIiIi11I1 + Iii1i / I1I / i1I * oOo0O00
class OOoOOOoo0000o ( oO00ooO00oOO0 ) :
 if 80 - 80: i1 . iI1iII1I1I1i
 if 6 - 6: I11iiIi11i1I
 if 28 - 28: ooOOO - Iii1i
 if 25 - 25: Ooo0Ooo
 if 76 - 76: IIiIIiIi11I1 * i1 + ooOOO
 if 11 - 11: Oo % iI1iII1I1I1i + Ooo0Ooo * IiIIii11Ii * i1i1i1111I
 if 48 - 48: OooOoo
 def __init__ ( self , name : str = None , layerUnits : int = 150 , incomingConfig : 'IncomingConfig' = i1iIi1i1i1I1 . Concat ( ) ,
 isKerasLayer : bool = False ,
 linearTransform : 'LSTMConfig' = OOooOooo . createBasicConfig ( ) ,
 inputGateActivation : int = iI11II1 . Sigmoid , forgetGateActivation : int = iI11II1 . Sigmoid , outputGateActivation : int = iI11II1 . Sigmoid ,
 memoryActivation : int = iI11II1 . Tanh , shadowGateActivation : int = iI11II1 . Tanh ,
 batchNorm : bool = True , useBias : bool = True , usePeephole : bool = False , dropout : float = 1 , recurrentDropout : float = 1 ,
 memoryCellClip : float = None , shadowStateClip : float = None , statefull : bool = False , mergeMode : str = 'concat' ,
 outputConfig : 'ModelNode.Layer.Output.Config' = I1Iiii1I1 . Default ( ) ) :
  if 13 - 13: ooOOO - IiI11Ii111 + OooOoo % i1I . oOo0O00
  if 15 - 15: IIiIIiIi11I1 . i1 - I11iiIi11i1I
  if 53 - 53: oOO
  if 84 - 84: oOO . oOo0O00 + i1 . I1I . OooOoo
  if 46 - 46: i1iiIII111 + i1iiIII111
  if 76 - 76: IiIIii11Ii * IiI11Ii111 / I1Ii1I1 - i1iiIII111 . Ooo0Ooo
  if 3 - 3: Ooo0Ooo
  if 91 - 91: Iii1i / I1Ii1I1 % OooOoo
  if 47 - 47: i1 - Ooo0Ooo % Ii - i1i1i1111I - Ii
  if 50 - 50: Oo . i1i1i1111I * i1 * Iii1i * OooOoo / I1Ii1I1
  if 28 - 28: i1 / oOo0O00 + I1I / IIiIIiIi11I1 * ooOOO * i1iiIII111
  if 27 - 27: i1iiIII111 * Ii - ooo000 / IIiIIiIi11I1
  if 91 - 91: I1Ii1I1 . ooo000 . i1
  if 66 - 66: i1iiIII111 + i1I
  if 49 - 49: i1 / IiI11Ii111
  if 82 - 82: ooOOO / oOO * I1I + i1I
  if 55 - 55: Ii * i1I % Ii - i1I - i1I / i1i1i1111I
  if 1 - 1: IiIIii11Ii . Iii1i * iI1iII1I1I1i
  if 9 - 9: I11iiIi11i1I . Ooo0Ooo . I1I + i1iiIII111 * oOO % IiIIii11Ii
  if 94 - 94: IiIIii11Ii . I1I * OooOoo * IiI11Ii111 . oOO / i1
  if 84 - 84: ooOOO / ooOOO / IiI11Ii111
  if 43 - 43: i1i1i1111I
  if 41 - 41: oOO * Iii1i
  if 7 - 7: ooOOO - Ooo0Ooo % i1iiIII111 . iI1iII1I1I1i - i1I % I1I
  if 87 - 87: ooo000 + IiI11Ii111
  if 84 - 84: ooOOO * I1Ii1I1 % i1I % Ooo0Ooo
  if 26 - 26: i1I % Ooo0Ooo % Iii1i % I1Ii1I1 . Ooo0Ooo
  if 49 - 49: IiI11Ii111 * Ii / i1iiIII111 . iI1iII1I1I1i + ooo000
  if 36 - 36: oOo0O00 * IiI11Ii111
  if linearTransform is None :
   linearTransform = OOooOooo . createBasicConfig ( )
  super ( ) . __init__ ( o00OoOo0O0O00 . BiLSTM , name = name , layerUnits = layerUnits , incomingConfig = incomingConfig , linearTransform = linearTransform ,
 batchNorm = batchNorm , outputConfig = outputConfig )
  self . isKerasLayer = isKerasLayer
  if self . isKerasLayer :
   if ( inputGateActivation != forgetGateActivation ) or ( inputGateActivation != outputGateActivation ) or ( forgetGateActivation != outputGateActivation ) :
    raise ValueError ( 'The recurrent_activation of keras LSTM layer is wrong' )
   if memoryActivation != shadowGateActivation :
    raise ValueError ( 'The activation of keras LSTM layer is wrong' )
    if 35 - 35: oOO / oOO / i1i1i1111I
  self . inputGateActivation = inputGateActivation
  self . forgetGateActivation = forgetGateActivation
  self . outputGateActivation = outputGateActivation
  self . memoryActivation = memoryActivation
  self . shadowGateActivation = shadowGateActivation
  self . useBias = useBias
  self . usePeephole = usePeephole
  self . dropout = dropout
  self . recurrentDropout = recurrentDropout
  self . memoryCellClip = memoryCellClip
  self . shadowStateClip = shadowStateClip
  self . statefull = statefull
  self . mergeMode = mergeMode
  if 66 - 66: i1iiIII111 / IiIIii11Ii
 def copy ( self , name ) :
  if 11 - 11: ooo000 - IiI11Ii111
  if 9 - 9: oOO * iI1iII1I1I1i / IiI11Ii111 / iI1iII1I1I1i
  if 24 - 24: i1
  if 56 - 56: Iii1i * ooo000 % Iii1i - OooOoo / i1I
  if 52 - 52: Ooo0Ooo . IiIIii11Ii
  if 7 - 7: I1Ii1I1
  if 36 - 36: oOo0O00
  if 86 - 86: I1I
  if 40 - 40: IIiIIiIi11I1
  if 54 - 54: IiI11Ii111
  if 63 - 63: I1I
  if self . __class__ . __name__ != "BiLSTMLayer" :
   raise ValueError ( "This layer class (" + self . __class__ . __name__ + ") has not supported for copying." )
   if 64 - 64: IiI11Ii111 - I11iiIi11i1I / oOo0O00 - Iii1i
   if 34 - 34: ooOOO . Ii / oOO * Ooo0Ooo
  return OOoOOOoo0000o ( name = name , layerUnits = self . layerUnits , incomingConfig = self . incomingConfig ,
 isKerasLayer = self . isKerasLayer , linearTransform = self . linearTransform , inputGateActivation = self . inputGateActivation ,
 forgetGateActivation = self . forgetGateActivation , outputGateActivation = self . outputGateActivation ,
 memoryActivation = self . memoryActivation , shadowGateActivation = self . shadowGateActivation , batchNorm = self . batchNorm ,
 useBias = self . useBias , usePeephole = self . usePeephole , dropout = self . dropout , recurrentDropout = self . recurrentDropout ,
 memoryCellClip = self . memoryCellClip , shadowStateClip = self . shadowStateClip , statefull = self . statefull , mergeMode = self . mergeMode , outputConfig = self . outputConfig )
  if 52 - 52: IIiIIiIi11I1 + I11iiIi11i1I * I1I - i1I + ooOOO * i1
 def keras_layer_build ( self ) :
  if self . isKerasLayer :
   return 'self.%s = tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(%d, return_sequences=True))' % ( self . name , self . layerUnits )
  else :
   return 'self.%s = BiLSTM(%d)' % ( self . name , self . layerUnits )
   if 2 - 2: i1i1i1111I * OooOoo / IiI11Ii111 - Oo + i1 + i1iiIII111
 def _activationToKerasName ( self , activation ) :
  if 33 - 33: I11iiIi11i1I . IIiIIiIi11I1
  if 2 - 2: IiIIii11Ii * IiI11Ii111 . I1Ii1I1 % i1i1i1111I / OooOoo - IiIIii11Ii
  if 80 - 80: I1Ii1I1 / ooOOO
  if 2 - 2: oOo0O00 % Iii1i * IIiIIiIi11I1 * i1I + I11iiIi11i1I / i1
  if 34 - 34: Ooo0Ooo
  if 18 - 18: i1iiIII111 / OooOoo
  if 66 - 66: oOo0O00 + OooOoo . Oo % I1I
  if 27 - 27: IIiIIiIi11I1 / Ooo0Ooo
  if 3 - 3: I1Ii1I1 % Oo
  if 73 - 73: Ooo0Ooo
  if activation == iI11II1 . Relu6 or activation == iI11II1 . Crelu :
   I11i1I11IiII = 'relu'
  elif activation == iI11II1 . HardSigmoid :
   I11i1I11IiII = 'hard_sigmoid'
  else :
   I11i1I11IiII = ( iI11II1 . getName ( activation ) ) . split ( '.' ) [ - 1 ] . lower ( )
  return I11i1I11IiII
  if 42 - 42: ooo000 . I1I + I11iiIi11i1I * i1iiIII111 + i1i1i1111I
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 18 - 18: I11iiIi11i1I % ooo000 - i1 * I11iiIi11i1I . Iii1i
  if 42 - 42: Iii1i / iI1iII1I1I1i % i1I - oOo0O00 . ooo000
  if 26 - 26: IIiIIiIi11I1 . i1 - Oo
  if 71 - 71: IiI11Ii111 + iI1iII1I1I1i / IiIIii11Ii - I1I / IiIIii11Ii
  if 77 - 77: ooOOO * Ii * i1iiIII111 % i1 * I1Ii1I1 / ooOOO
  if 87 - 87: i1 * i1iiIII111 / ooo000 . I11iiIi11i1I % oOo0O00 + i1
  if 28 - 28: IiI11Ii111 % I1Ii1I1 . ooOOO + i1i1i1111I - I1Ii1I1 * IIiIIiIi11I1
  if 70 - 70: ooo000
  if 49 - 49: oOO + Ooo0Ooo + IIiIIiIi11I1
  if 71 - 71: I11iiIi11i1I - I1Ii1I1 % I11iiIi11i1I - i1iiIII111 + OooOoo . IIiIIiIi11I1
  if 99 - 99: Oo
  if 14 - 14: I1I * Ii - i1 - IIiIIiIi11I1 * Iii1i
  if 90 - 90: i1iiIII111 * oOo0O00 + Ooo0Ooo + i1iiIII111 * i1iiIII111 . ooOOO
  if 81 - 81: ooOOO
  if 23 - 23: oOO * Ooo0Ooo
  if self . mergeMode == 'concat' :
   II = [ None , inputshape [ 1 ] , self . layerUnits * 2 ]
  else :
   II = [ None , inputshape [ 1 ] , self . layerUnits ]
  self . dropout = 1 - self . dropout / 100.
  self . recurrentDropout = 1 - self . recurrentDropout / 100.
  if reshape_output_name != output_reg :
   I1111iiI = output_reg
   oO = reshape_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
   if 10 - 10: Iii1i + oOo0O00 % Oo
  OoOO , OoooOO0 = [ ] , [ ]
  if 29 - 29: oOO * OooOoo / I11iiIi11i1I + ooOOO . Ii * i1i1i1111I
  Ii1Ii1Ii = 'True' if self . useBias else 'False'
  IIIi1iii1Ii = self . dropout
  OoO0000OO00o0 = self . recurrentDropout
  I11I = 'True' if self . statefull else 'False'
  Oo0O0O = self . mergeMode
  if 82 - 82: Oo
  if self . isKerasLayer :
   if 86 - 86: i1I
   I11i1I11IiII = self . act_dict [ int ( self . inputGateActivation . value ) ]
   if 4 - 4: oOo0O00 . oOo0O00 * I1Ii1I1
   iI1I1I1III1 = self . act_dict [ int ( self . memoryActivation . value ) ]
   O0OOO0O0OO000 = self . get_initiallizer ( key = 'inputGateWeightConfig' )
   Oo000 = self . get_initiallizer ( key = 'inputGateRecurrentWeightConfig' )
   OOOoooO = self . get_initiallizer ( key = 'inputGateBiasConfig' )
   i1IiiIi1iIiIIi = self . get_regularizer ( key = 'inputGateWeightConfig' )
   II111II1I1 = self . get_regularizer ( key = 'inputGateRecurrentWeightConfig' )
   ooiiii1IiIi = self . get_regularizer ( key = 'inputGateBiasConfig' )
   iIII1I11i11iI = 'True'
   oO00oOooO0O = 'self.%s = tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(%d, activation = %s,recurrent_activation = %s, use_bias=%s,  kernel_initializer=%s, recurrent_initializer=%s, bias_initializer=%s,' 'kernel_regularizer=%s, recurrent_regularizer=%s, bias_regularizer=%s, dropout=%f, recurrent_dropout=%f, return_sequences=%s,  stateful=%s ),merge_mode=\'%s\')' % ( self . name , self . layerUnits , I11i1I11IiII , iI1I1I1III1 , Ii1Ii1Ii , O0OOO0O0OO000 , Oo000 , OOOoooO , i1IiiIi1iIiIIi , II111II1I1 , ooiiii1IiIi , IIIi1iii1Ii , OoO0000OO00o0 , iIII1I11i11iI , I11I , Oo0O0O )
   if 86 - 86: Ooo0Ooo . i1iiIII111 + Ii % I11iiIi11i1I * Oo
   if 5 - 5: ooo000 * i1 * IiIIii11Ii + i1I . OooOoo - ooo000
  else :
   if 25 - 25: ooOOO * i1iiIII111 + Ooo0Ooo
   I11iiIiiiI1i = self . act_dict [ int ( self . inputGateActivation . value ) ]
   if 48 - 48: oOo0O00 / Ooo0Ooo - OooOoo % i1iiIII111 * oOO
   ooOoOoOoOO = self . act_dict [ int ( self . forgetGateActivation . value ) ]
   if 33 - 33: IIiIIiIi11I1 % OooOoo / Ii
   IiiiIiiiIiI1 = self . act_dict [ int ( self . outputGateActivation . value ) ]
   if 48 - 48: Oo
   oO0Oo0 = self . act_dict [ int ( self . memoryActivation . value ) ]
   if 88 - 88: ooo000
   ooo000Ooo = I11i1I11IiII = self . act_dict [ int ( self . shadowGateActivation . value ) ]
   o0OooOooo00O = self . get_initiallizer ( key = 'inputGateWeightConfig' )
   II1iI1I1iI = self . get_initiallizer ( key = 'forgetGateWeightConfig' )
   o00OO0O0 = self . get_initiallizer ( key = 'outputGateWeightConfig' )
   oOO0Oo = self . get_initiallizer ( key = 'memoryWeightConfig' )
   oOoO000OO0 = self . get_initiallizer ( key = 'inputGateRecurrentWeightConfig' )
   iIii1i1IiI = self . get_initiallizer ( key = 'forgetGateRecurrentWeightConfig' )
   oooii1I1iI1IIII1 = self . get_initiallizer ( key = 'outputGateRecurrentWeightConfig' )
   i1I11i = self . get_initiallizer ( key = 'memoryRecurrentWeightConfig' )
   i1i11iIi1I1 = self . get_initiallizer ( key = 'inputGatePeepholeWeightConfig' )
   iIIIiIIIi1i = self . get_initiallizer ( key = 'forgetGatePeepholeWeightConfig' )
   III11iIiI = self . get_initiallizer ( key = 'outputGatePeepholeWeightConfig' )
   IiO0Oo = self . get_initiallizer ( key = 'inputGateBiasConfig' )
   Oo000OIIIIii = self . get_initiallizer ( key = 'forgetGateBiasConfig' )
   I1i1i1IIiI = self . get_initiallizer ( key = 'outputGateBiasConfig' )
   Ii1iI = self . get_initiallizer ( key = 'memoryBiasConfig' )
   I1111iIi1 = self . get_regularizer ( key = 'inputGateWeightConfig' )
   iIiIoOoOo0O0O = self . get_regularizer ( key = 'forgetGateWeightConfig' )
   oO0oOoo0ooo0 = self . get_regularizer ( key = 'outputGateWeightConfig' )
   i1i1111i = self . get_regularizer ( key = 'memoryWeightConfig' )
   IIi111II1i = self . get_regularizer ( key = 'inputGateRecurrentWeightConfig' )
   II1i1IiIiii11ii1i = self . get_regularizer ( key = 'forgetGateRecurrentWeightConfig' )
   iIiII = self . get_regularizer ( key = 'outputGateRecurrentWeightConfig' )
   OO0ooOo0o000OooO = self . get_regularizer ( key = 'memoryRecurrentWeightConfig' )
   OOOO0O00O = self . get_regularizer ( key = 'inputGatePeepholeWeightConfig' )
   i1oOoooO0Ooo0 = self . get_regularizer ( key = 'forgetGatePeepholeWeightConfig' )
   O00OOOO00o = self . get_regularizer ( key = 'outputGatePeepholeWeightConfig' )
   OoO0o000OOoo = self . get_regularizer ( key = 'inputGateBiasConfig' )
   iI1iIi11iiIii = self . get_regularizer ( key = 'forgetGateBiasConfig' )
   oOIiI11I11IiII = self . get_regularizer ( key = 'outputGateBiasConfig' )
   oo0O0O = self . get_regularizer ( key = 'memoryBiasConfig' )
   Iii11iiI = 'True' if self . usePeephole else 'False'
   oO0O00o0OoO00 = 'None' if self . memoryCellClip is None else str ( self . memoryCellClip )
   oOoO0oO00oO0 = 'None' if self . shadowStateClip is None else str ( self . shadowStateClip )
   oO00oOooO0O = 'self.%s = BiLSTM(%d, activation = BiLSTM.Activation(%s,%s,%s,%s,%s),kernelInitializer = BiLSTM.Initializer(%s,%s,%s,%s),' 'recurrentInitializer = BiLSTM.Initializer(%s,%s,%s,%s),peepholeInitializer = BiLSTM.Initializer(%s,%s,%s,None),biasInitializer = BiLSTM.Initializer(%s,%s,%s,%s),' 'kernelRegularizer = BiLSTM.Regularizer(%s,%s,%s,%s),recurrentRegularizer = BiLSTM.Regularizer(%s,%s,%s,%s),peepholeRegularizer = BiLSTM.Regularizer(%s,%s,%s,None),' 'biasRegularizer = BiLSTM.Regularizer(%s,%s,%s,%s),useBias = %s,usePeephole = %s,dropout =%f,recurrentDropout =%f,' 'memoryCellClip = %s, shadowStateClip = %s, statefull = %s, mergeMode = \'%s\')' % ( self . name , self . layerUnits , I11iiIiiiI1i , ooOoOoOoOO , IiiiIiiiIiI1 , oO0Oo0 , ooo000Ooo , o0OooOooo00O , II1iI1I1iI , o00OO0O0 , oOO0Oo ,
   # Iii1i
   # I11iiIi11i1I - oOo0O00
   # Ooo0Ooo % iI1iII1I1I1i - Ooo0Ooo - Oo * I1Ii1I1 % Ii
   # iI1iII1I1I1i % ooo000
   # iI1iII1I1I1i - i1iiIII111
 oOoO000OO0 , iIii1i1IiI , oooii1I1iI1IIII1 , i1I11i , i1i11iIi1I1 , iIIIiIIIi1i , III11iIiI ,
 IiO0Oo , Oo000OIIIIii , I1i1i1IIiI , Ii1iI , I1111iIi1 , iIiIoOoOo0O0O , oO0oOoo0ooo0 , i1i1111i ,
 IIi111II1i , II1i1IiIiii11ii1i , iIiII , OO0ooOo0o000OooO , OOOO0O00O , i1oOoooO0Ooo0 , O00OOOO00o ,
 OoO0o000OOoo , iI1iIi11iiIii , oOIiI11I11IiII , oo0O0O , Ii1Ii1Ii , Iii11iiI , IIIi1iii1Ii , OoO0000OO00o0 , oO0O00o0OoO00 , oOoO0oO00oO0 , I11I , Oo0O0O )
  OoOO . append ( oO00oOooO0O )
  if 45 - 45: iI1iII1I1I1i * oOo0O00 % i1
  Ii1I1iIiiiI = '%s = self.%s(%s)' % ( I1111iiI , self . name , oO )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 14 - 14: IiI11Ii111 * ooo000 / iI1iII1I1I1i - i1i1i1111I . I1Ii1I1 - IiIIii11Ii
  if self . batchNorm :
   OoOO . append ( 'self.%s_bn = BatchNormalization()' % self . name )
   OoooOO0 . append ( '%s = self.%s_bn(%s, training=training)' % ( I1111iiI , self . name , I1111iiI ) )
   return OoOO , OoooOO0 , output_reg , II
  else :
   return OoOO , OoooOO0 , output_reg , II
   if 26 - 26: OooOoo / i1 % oOO
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 51 - 51: i1i1i1111I % oOO
  if 61 - 61: I1I % iI1iII1I1I1i * IiI11Ii111 + iI1iII1I1I1i / OooOoo * IIiIIiIi11I1
  if 46 - 46: I1I
  if 10 - 10: ooo000 % Iii1i / IIiIIiIi11I1
  if 10 - 10: i1I % ooOOO
  if 61 - 61: oOO - oOo0O00 + Ii * i1I - IiIIii11Ii + i1
  if 79 - 79: i1i1i1111I + Oo
  if 24 - 24: oOo0O00 - Ooo0Ooo
  if 89 - 89: oOO * i1iiIII111
  if 7 - 7: ooo000 % OooOoo - Iii1i * ooo000
  if 98 - 98: oOo0O00 - i1iiIII111 . IiIIii11Ii
  if 91 - 91: i1
  if 61 - 61: Oo . Ooo0Ooo * Iii1i
  if 42 - 42: Ii - IIiIIiIi11I1 + I11iiIi11i1I
  if 58 - 58: OooOoo . IIiIIiIi11I1 / I1Ii1I1 * IIiIIiIi11I1 % i1 * IiIIii11Ii
  ooo0oOOooO = [ ]
  OooOoO00 = [ ]
  if 63 - 63: IiIIii11Ii % ooOOO - IiI11Ii111 / Ooo0Ooo
  if combine_output_name != output_reg :
   I1111iiI = output_reg
   oO = combine_output_name
  else :
   I1111iiI = output_reg
   oO = output_reg
  iiII1I1iIi = output_reg
  if 45 - 45: i1I % i1I
  if len ( input_shape ) != 3 :
   if len ( input_shape ) > 3 :
    if len ( input_shape ) < 5 :
     II = input_shape [ 0 : 2 ]
     II . append ( - 1 )
     string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
     string += ',' . join ( [ str ( int ( x ) ) for x in II [ 1 : ] ] )
     string += '))'
     ooo0oOOooO . append ( string )
     string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
     OooOoO00 . append ( string )
    else :
     raise ValueError ( "When dimension of data is more than 4, it is not supported." )
   elif len ( input_shape ) == 2 :
    OoOo = input_shape [ - 1 ]
    II = input_shape [ 0 : 1 ]
    II . append ( 1 )
    II . append ( OoOo )
    string = 'self.%s_auto_reshape = tf.keras.layers.Reshape((' % self . name
    string += ',' . join ( [ '1' , str ( int ( OoOo ) ) ] )
    string += '))'
    ooo0oOOooO . append ( string )
    string = '%s = self.%s_auto_reshape(%s)' % ( I1111iiI , self . name , oO )
    OooOoO00 . append ( string )
   else :
    raise ValueError ( "One dimension data is not supported." )
  else :
   II = input_shape
   iiII1I1iIi = combine_output_name
  return ooo0oOOooO , OooOoO00 , iiII1I1iIi , II
  if 8 - 8: oOo0O00 + i1i1i1111I - iI1iII1I1I1i - Oo + Ooo0Ooo
class o00OoOo0O0O00 ( II1i1I ) :
 if 68 - 68: oOo0O00 - ooOOO * i1I % IiI11Ii111
 if 51 - 51: i1iiIII111
 if 14 - 14: Ooo0Ooo * Iii1i . Iii1i % oOo0O00 + IiIIii11Ii / oOO
 if 30 - 30: Oo * Ii . Ooo0Ooo
 if 86 - 86: iI1iII1I1I1i . Ooo0Ooo * i1 . ooOOO
 if 98 - 98: Iii1i / iI1iII1I1I1i . I1I
 if 36 - 36: IiIIii11Ii
 if 20 - 20: OooOoo + i1i1i1111I * oOO / Oo
 Config = 0
 if 32 - 32: IiI11Ii111 . oOo0O00
 if 31 - 31: Oo . Ii % IIiIIiIi11I1 % IiIIii11Ii * I1I
 Collector = 1
 if 59 - 59: I1Ii1I1 . Ooo0Ooo * Iii1i
 if 4 - 4: iI1iII1I1I1i - ooOOO
 FullyConnected = 2
 if 44 - 44: ooo000 % I11iiIi11i1I . ooOOO % Iii1i / OooOoo - oOo0O00
 if 69 - 69: I11iiIi11i1I - Iii1i / oOO / IiIIii11Ii / I1I
 Convolution = 3
 if 100 - 100: i1iiIII111 + OooOoo / i1iiIII111 . I1I
 if 69 - 69: Ii % Iii1i / I1Ii1I1
 Deconvolution = 4
 if 46 - 46: IiIIii11Ii
 if 60 - 60: ooo000
 Convolution1D = 6
 if 9 - 9: oOo0O00 + iI1iII1I1I1i - I1I / Iii1i % oOo0O00
 if 39 - 39: oOO
 Deconvolution1D = 7
 if 47 - 47: iI1iII1I1I1i . i1i1i1111I . I11iiIi11i1I / IiIIii11Ii / ooOOO . Ooo0Ooo
 if 32 - 32: iI1iII1I1I1i + IiIIii11Ii - oOO
 RNN = 101
 if 36 - 36: oOO * oOo0O00 + iI1iII1I1I1i * I1Ii1I1 - Iii1i
 if 55 - 55: oOo0O00 / ooo000 % I1I - Iii1i - I1Ii1I1
 GRU = 102
 if 14 - 14: IIiIIiIi11I1 % Oo - ooOOO - OooOoo / oOo0O00 - i1i1i1111I
 if 62 - 62: I1Ii1I1 * IiIIii11Ii
 LSTM = 103
 if 47 - 47: oOo0O00
 if 45 - 45: i1iiIII111 % Oo . I1Ii1I1 % i1I % i1I
 BiRNN = 104
 if 2 - 2: Iii1i . Ii . ooo000 / i1I / Ii
 if 2 - 2: IiI11Ii111 . Iii1i % i1 - ooOOO % oOO % i1
 BiGRU = 105
 if 40 - 40: I1I
 if 77 - 77: Ooo0Ooo
 BiLSTM = 106
 if 87 - 87: iI1iII1I1I1i
 if 85 - 85: oOO . I1Ii1I1 - IIiIIiIi11I1 % Ii
 Task = 5
 if 25 - 25: Ii + IiIIii11Ii * oOO
 if 98 - 98: I1Ii1I1 % Ii * ooOOO / ooo000 + i1I * oOo0O00
 Pool = 8
 if 81 - 81: IIiIIiIi11I1 % oOo0O00
 if 24 - 24: IIiIIiIi11I1 + IIiIIiIi11I1
 ConvolutionFlex = 9
 if 76 - 76: i1 % oOo0O00 . OooOoo * ooOOO . I1I + I11iiIi11i1I
 if 21 - 21: I1Ii1I1 / i1i1i1111I
 TextEmbedding = 107
 if 28 - 28: i1i1i1111I . I1I % ooo000 % I11iiIi11i1I * OooOoo / ooo000
class oOOoo :
 if 77 - 77: Ooo0Ooo / oOo0O00 . IIiIIiIi11I1
 if 42 - 42: i1I / oOO - OooOoo % i1
 if 46 - 46: i1i1i1111I / ooOOO % oOo0O00
 if 40 - 40: IiI11Ii111 - oOo0O00 . I11iiIi11i1I % i1iiIII111 / I1I - oOo0O00
 if 63 - 63: Ooo0Ooo
 if 71 - 71: Ii % IIiIIiIi11I1 . i1i1i1111I - oOO . Ooo0Ooo * IiI11Ii111
 if 51 - 51: Ii + IiIIii11Ii - Iii1i
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] , train : 'Train' ) -> 'ModelNode.Layer.Config' :
  if 7 - 7: IiIIii11Ii / ooo000
  if 93 - 93: oOo0O00 . IIiIIiIi11I1 . iI1iII1I1I1i
  if 15 - 15: i1i1i1111I / Iii1i * i1iiIII111
  if 40 - 40: i1i1i1111I + I1I
  if 57 - 57: I11iiIi11i1I
  if 30 - 30: i1I + IIiIIiIi11I1 * i1I * OooOoo % IiI11Ii111 / Oo
  if 8 - 8: Ii % iI1iII1I1I1i - IiIIii11Ii % I11iiIi11i1I * IiI11Ii111 + IiI11Ii111
  if 11 - 11: I1Ii1I1 % i1I % OooOoo * iI1iII1I1I1i . i1I - Ooo0Ooo
  if 8 - 8: i1 % ooOOO
  if 63 - 63: OooOoo - ooOOO - i1i1i1111I - ooo000 * Oo
  if 43 - 43: Ii * oOO . Iii1i - Iii1i + i1iiIII111 / Ii
  if 94 - 94: IIiIIiIi11I1 . ooo000 % Oo . ooOOO * Iii1i
  if 88 - 88: iI1iII1I1I1i - i1 . iI1iII1I1I1i + Iii1i
  if 5 - 5: ooo000 / IIiIIiIi11I1 / Ooo0Ooo + ooo000 + OooOoo
  if "_layerType" in obj :
   if 18 - 18: Ii + iI1iII1I1I1i * iI1iII1I1I1i + I1Ii1I1 - i1I . oOO
   if obj [ "_layerType" ] == o00OoOo0O0O00 . Task . value :
    o0OoOOOOO00O = getattr ( oOOoo . Task , oOOoo . Task . Types . getName ( obj [ "_taskType" ] ) ) ( )
   else :
    o0OoOOOOO00O = getattr ( oOOoo , o00OoOo0O0O00 . getName ( obj [ "_layerType" ] ) ) ( )
  else :
   if 74 - 74: oOO / I1I * i1iiIII111 * i1 % i1i1i1111I . ooo000
   OOiIIiiIi = obj [ "layerUnits" ] if "layerUnits" in obj else None
   if obj [ "_type" ] == "Collector" :
    o0OoOOOOO00O = oOOoo . Collector ( )
   elif obj [ "_type" ] == "BasicLayer" :
    o0OoOOOOO00O = oOOoo . FullyConnected ( layerUnits = OOiIIiiIi )
   elif obj [ "_type" ] == "CNNLayer" :
    o0OoOOOOO00O = oOOoo . Convolution ( layerUnits = OOiIIiiIi )
   elif obj [ "_type" ] == "DCNNLayer" :
    o0OoOOOOO00O = oOOoo . Deconvolution ( layerUnits = OOiIIiiIi )
   elif obj [ "_type" ] == "Classifier" :
    o0OoOOOOO00O = oOOoo . Task . Classifier ( )
   elif obj [ "_type" ] == "Group" :
    o0OoOOOOO00O = oOOoo . Group ( )
   elif obj [ "_type" ] == "Task" :
    o0OoOOOOO00O = oOOoo . Task . Task ( )
   elif obj [ "_type" ] == "Regressor" :
    o0OoOOOOO00O = oOOoo . Task . Regressor ( )
   elif obj [ "_type" ] == "EmbeddingLayer" :
    o0OoOOOOO00O = oOOoo . TextEmbedding ( )
   else :
    raise ValueError ( "Layer type not supported." )
    if 33 - 33: Iii1i * oOo0O00 / I1Ii1I1
    if 69 - 69: ooo000 + I1I - Oo * Oo
  o0OoOOOOO00O . parseJSON ( obj , train )
  return o0OoOOOOO00O
  if 99 - 99: Oo
 Types = o00OoOo0O0O00
 Incoming = i1iIi1i1i1I1
 Output = I1Iiii1I1
 Config = oO00ooO00oOO0
 FullyConnected = iiIiiiI1Ii1i1
 Convolution = i1i
 Deconvolution = Oo0Oooo0OOOO
 Convolution1D = IIIOOoo0
 Deconvolution1D = o0O00O
 Collector = oOoOOO0OOOOO
 Group = ooOoOoo0OOO0O
 Task = I1iiiiIi1iIi
 Pool = iIiI1i111ii
 TextEmbedding = I1IOO
 if 60 - 60: Iii1i - iI1iII1I1I1i / i1i1i1111I % OooOoo
 RNN = I1ioOo00OOoo0O
 GRU = O00O0oOo0O
 LSTM = Oo000O
 BiRNN = O0o00o
 BiGRU = OoO000oOOOO
 BiLSTM = OOoOOOoo0000o
 if 54 - 54: IiIIii11Ii
class o00OO0ooo0o :
 if 39 - 39: Ii . i1 . oOo0O00 / i1iiIII111 * I1I
 if 99 - 99: Oo / IIiIIiIi11I1 * OooOoo + i1i1i1111I / Ooo0Ooo
 if 47 - 47: Oo % IiIIii11Ii . IIiIIiIi11I1 * i1i1i1111I % I1I
 if 50 - 50: I11iiIi11i1I - IiI11Ii111 * i1 + IiI11Ii111 - oOO / Ii
 if 50 - 50: ooo000 % oOO
 if 18 - 18: i1i1i1111I % I1Ii1I1 - IiI11Ii111
 if 64 - 64: I1I
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] , train ) -> 'Config' :
  IIii1I1ii1IIi = iI11iIi1IiI1 ( )
  if 24 - 24: Oo
  if 21 - 21: oOO
  if 94 - 94: I11iiIi11i1I % I1Ii1I1
  if 76 - 76: ooOOO
  if 45 - 45: Ii - i1iiIII111 * oOo0O00
  if 32 - 32: i1i1i1111I / OooOoo
  if 42 - 42: IiIIii11Ii * oOo0O00 * OooOoo / ooOOO * oOo0O00
  if 91 - 91: IiI11Ii111 * I1Ii1I1
  if 23 - 23: iI1iII1I1I1i
  if 66 - 66: Oo * i1iiIII111 . Iii1i * i1I % IiI11Ii111 % ooOOO
  if 94 - 94: oOO . i1i1i1111I * iI1iII1I1I1i - i1 / ooo000 / i1I
  if 32 - 32: Ii . I1I - I11iiIi11i1I
  if 48 - 48: i1iiIII111
  IIii1I1ii1IIi . parseJSON ( obj , train )
  return IIii1I1ii1IIi
  if 28 - 28: I1I * Ooo0Ooo + IIiIIiIi11I1
class iI11iIi1IiI1 ( II1iII1I11I ) :
 if 76 - 76: IiIIii11Ii . Iii1i + IiI11Ii111
 if 39 - 39: iI1iII1I1I1i . IiIIii11Ii + Ooo0Ooo + I1I
 if 63 - 63: Oo . IIiIIiIi11I1 % i1iiIII111 . i1 . Iii1i
 if 1 - 1: oOo0O00 / i1I . Oo - I1Ii1I1
 if 83 - 83: I1Ii1I1 % OooOoo - i1 * Oo - oOO
 if 99 - 99: IiIIii11Ii
 if 57 - 57: iI1iII1I1I1i - oOo0O00 - I1I / I11iiIi11i1I - I11iiIi11i1I
 def __init__ ( self , name : str = None , model_namespace : str = None ) :
  if 41 - 41: iI1iII1I1I1i
  if 73 - 73: oOo0O00 . IiIIii11Ii - I1Ii1I1 + Iii1i / I1I / i1iiIII111
  if 81 - 81: Oo
  if 23 - 23: i1I / Iii1i
  if 7 - 7: Oo
  if 91 - 91: IiI11Ii111 + i1
  if 36 - 36: IiIIii11Ii
  if 88 - 88: OooOoo / I1Ii1I1 . IiIIii11Ii . Oo . Ii
  if 71 - 71: IiI11Ii111 . i1I % Ii + Ooo0Ooo - IiIIii11Ii
  if 77 - 77: i1iiIII111 / Oo - ooOOO * Iii1i . Oo % oOo0O00
  if 87 - 87: oOO / Iii1i - ooo000
  super ( ) . __init__ ( name = name , nodeType = o0OOo000o00 . NOMModel )
  self . _model_namespace = model_namespace
  self . model_params = { }
  self . insideBlockInfo = { }
  self . model_name = ""
  if 69 - 69: i1i1i1111I / oOo0O00 - IIiIIiIi11I1 + Iii1i * IIiIIiIi11I1
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 33 - 33: i1iiIII111 * OooOoo / IiI11Ii111 + ooOOO % IiI11Ii111
  if 83 - 83: iI1iII1I1I1i % i1 - Oo % Iii1i - Ii
  if 58 - 58: oOo0O00 % Ooo0Ooo . oOO + iI1iII1I1I1i
  if 4 - 4: IiIIii11Ii . IiI11Ii111 / Ii + i1 - oOo0O00 + Oo
  if 82 - 82: iI1iII1I1I1i - i1iiIII111 % Iii1i / oOo0O00 + ooo000 + iI1iII1I1I1i
  if 100 - 100: i1I * i1i1i1111I % oOO
  if 81 - 81: OooOoo / oOo0O00 * I1I * I1I
  if 41 - 41: oOO
  if 84 - 84: Oo . iI1iII1I1I1i / ooOOO
  if 66 - 66: Oo * OooOoo - IiI11Ii111 - IiIIii11Ii % Iii1i / i1iiIII111
  if 55 - 55: Iii1i - i1I + i1I % I1I * i1i1i1111I / i1I
  for ( oo00OOOO , O0Oo00o0 ) in obj . items ( ) :
   if oo00OOOO == "name" :
    setattr ( self , oo00OOOO , self . updateNodeName ( O0Oo00o0 ) . replace ( ' ' , '' ) )
   elif oo00OOOO == "shape" :
    if isinstance ( O0Oo00o0 , list ) and len ( O0Oo00o0 ) > 0 :
     setattr ( self , oo00OOOO , O0Oo00o0 )
    else :
     setattr ( self , oo00OOOO , [ O0Oo00o0 ] )
   elif oo00OOOO == "_order" :
    if isinstance ( O0Oo00o0 , list ) and len ( O0Oo00o0 ) :
     if len ( np . array ( O0Oo00o0 ) ) == 2 :
      setattr ( self , oo00OOOO , [ s [ 0 ] for s in O0Oo00o0 ] )
     else :
      setattr ( self , oo00OOOO , O0Oo00o0 )
    else :
     setattr ( self , oo00OOOO , [ O0Oo00o0 ] )
   elif oo00OOOO == "model_params" :
    for OoOO0oO , O0OOO0O000OO0 in O0Oo00o0 . items ( ) :
     self . model_params [ OoOO0oO ] = O0OOO0O000OO0
   elif oo00OOOO == "insideBlockInfo" :
    for OoOO0oO , O0OOO0O000OO0 in O0Oo00o0 . items ( ) :
     self . insideBlockInfo [ OoOO0oO ] = { }
     self . insideBlockInfo [ OoOO0oO ] [ "inChannel" ] = O0OOO0O000OO0 [ "inChannel" ]
     self . insideBlockInfo [ OoOO0oO ] [ "outChannel" ] = O0OOO0O000OO0 [ "outChannel" ]
     self . insideBlockInfo [ OoOO0oO ] [ "kernelSize" ] = O0OOO0O000OO0 [ "kernelSize" ]
     self . insideBlockInfo [ OoOO0oO ] [ "stride" ] = O0OOO0O000OO0 [ "stride" ]
     self . insideBlockInfo [ OoOO0oO ] [ "padding" ] = O0OOO0O000OO0 [ "padding" ]
     self . insideBlockInfo [ OoOO0oO ] [ "dilation" ] = O0OOO0O000OO0 [ "dilation" ]
     self . insideBlockInfo [ OoOO0oO ] [ "bias" ] = O0OOO0O000OO0 [ "bias" ]
   elif oo00OOOO in [ "fromNode" , "toNode" ] :
    setattr ( self , oo00OOOO , [ [ s . replace ( ' ' , '' ) for s in O0Oo00o0 [ 0 ] ] ] )
   elif oo00OOOO not in [ "_train" , "_nodeType" ] :
    setattr ( self , oo00OOOO , O0Oo00o0 )
    if 60 - 60: IiIIii11Ii - I1I - I11iiIi11i1I
    if 19 - 19: IiI11Ii111 - I1Ii1I1 . I11iiIi11i1I
  self . train = train
  if 57 - 57: i1i1i1111I - IiI11Ii111 * Ooo0Ooo - i1i1i1111I % I11iiIi11i1I / i1I
 @ property
 def modelNamespace ( self ) -> 'str' :
  return self . _model_namespace
  if 15 - 15: OooOoo
  if 83 - 83: oOO
  if 64 - 64: Ii + oOO / i1I % Ooo0Ooo / Iii1i + Ii
  if 95 - 95: i1i1i1111I / Iii1i % i1iiIII111 % oOO - I1Ii1I1 % i1iiIII111
  if 68 - 68: I1Ii1I1 / I11iiIi11i1I . ooo000
  if 46 - 46: iI1iII1I1I1i . IIiIIiIi11I1
  if 38 - 38: Ii - IiIIii11Ii / i1 - I11iiIi11i1I - i1i1i1111I
  if 12 - 12: ooo000 * Ii % IiI11Ii111 * OooOoo - i1 - I1Ii1I1
  if 84 - 84: IiIIii11Ii + iI1iII1I1I1i - IIiIIiIi11I1 % oOO + ooOOO
  if 96 - 96: I11iiIi11i1I
 def keras_call_combineIncomingTensors ( self , input_sources , input_tensors , input_sources_name , input_tensors_name , output_reg , buildNo = 0 ) :
  if 47 - 47: I11iiIi11i1I / Ooo0Ooo
  if 12 - 12: OooOoo % OooOoo - Iii1i - i1iiIII111 - IIiIIiIi11I1
  if 56 - 56: IiI11Ii111 / Ooo0Ooo % OooOoo - I1Ii1I1 % oOo0O00
  if 14 - 14: IiI11Ii111 * I11iiIi11i1I - ooo000 * Ii % I1Ii1I1 + I11iiIi11i1I
  if 69 - 69: IiI11Ii111 % i1iiIII111 / I11iiIi11i1I % ooo000
  if 57 - 57: oOo0O00 / IiI11Ii111 . oOo0O00 + IiIIii11Ii . i1i1i1111I - IIiIIiIi11I1
  if 56 - 56: i1I - ooo000
  if 60 - 60: i1I % OooOoo
  if 47 - 47: IiIIii11Ii - i1iiIII111 + ooOOO . Ooo0Ooo
  if 47 - 47: I11iiIi11i1I % i1i1i1111I / I1I + IiI11Ii111 . IiI11Ii111
  if 45 - 45: Oo / oOO
  if 74 - 74: IiIIii11Ii . i1
  if 6 - 6: I11iiIi11i1I * ooo000 * IiIIii11Ii
  if 34 - 34: i1 / I11iiIi11i1I * Ii % IIiIIiIi11I1 - Oo
  if 78 - 78: IIiIIiIi11I1
  if 37 - 37: i1i1i1111I + I11iiIi11i1I
  if 85 - 85: iI1iII1I1I1i % i1iiIII111 * Ooo0Ooo * ooo000
  if 86 - 86: iI1iII1I1I1i . IiIIii11Ii * OooOoo * oOo0O00
  iiIII1Ii1 = [ ]
  iiIII1Ii1 . extend ( input_sources_name )
  iiIII1Ii1 . extend ( input_tensors_name )
  ooo0o = [ ]
  ooo0o . extend ( input_sources )
  ooo0o . extend ( input_tensors )
  return ooo0o , [ ] , [ ] , iiIII1Ii1
  if 87 - 87: IiI11Ii111
 def keras_call_processOutputTensor ( self , input_shape , layer_output_name , output_reg , buildNo = 0 ) :
  if 59 - 59: I11iiIi11i1I + Oo - i1I / ooOOO / ooOOO - i1I
  if 47 - 47: Ii
  if 39 - 39: oOO . Ii + Iii1i
  if 95 - 95: I1I . IIiIIiIi11I1 . IiI11Ii111 * I11iiIi11i1I
  if 40 - 40: i1 - ooOOO
  if 68 - 68: i1iiIII111 . Ooo0Ooo * oOO + I11iiIi11i1I
  if 61 - 61: oOo0O00 / ooOOO . ooo000 % i1 % oOO
  if 91 - 91: I1I . Iii1i - iI1iII1I1I1i
  if 67 - 67: i1 . I1I * i1i1i1111I . ooOOO
  if 9 - 9: I11iiIi11i1I
  if 20 - 20: Ii * Ii - I11iiIi11i1I - I1Ii1I1
  if 92 - 92: IIiIIiIi11I1 . iI1iII1I1I1i % ooOOO - ooo000 * Iii1i - i1iiIII111
  if 64 - 64: Iii1i / Ii + Ii
  if 69 - 69: Iii1i
  if 5 - 5: I11iiIi11i1I
  if 84 - 84: Iii1i - ooo000
  return [ ] , [ ]
  if 24 - 24: Oo
 def keras_call_auto_reshape_build ( self , input_shape , combine_output_name , output_reg ) :
  if 16 - 16: Iii1i % oOO - IIiIIiIi11I1 % IiI11Ii111 . Ii
  if 75 - 75: oOo0O00
  if 21 - 21: Ooo0Ooo / Ooo0Ooo
  if 29 - 29: IiIIii11Ii + oOo0O00 - Ii + ooOOO * IIiIIiIi11I1 . i1I
  if 88 - 88: IiIIii11Ii / OooOoo % OooOoo
  if 2 - 2: i1 . IiI11Ii111
  if 83 - 83: Iii1i / Ooo0Ooo - ooOOO
  if 88 - 88: i1I + I1I
  if 20 - 20: Oo - I11iiIi11i1I * I1I
  if 89 - 89: Oo . iI1iII1I1I1i + oOo0O00 - oOo0O00
  if 11 - 11: Ooo0Ooo - Oo / i1iiIII111 + i1I * oOo0O00 % I11iiIi11i1I
  if 90 - 90: IIiIIiIi11I1 + i1i1i1111I * i1I - i1 * Oo - IIiIIiIi11I1
  if 87 - 87: oOO - ooo000 / oOO
  if 99 - 99: ooOOO
  if 86 - 86: IiIIii11Ii
  return [ ] , [ ] , combine_output_name , input_shape
  if 43 - 43: i1i1i1111I . oOo0O00 * iI1iII1I1I1i + Iii1i . Iii1i + Oo
 def keras_call_layer_build ( self , reshape_output_name , output_reg , input_shape = None ) :
  if 63 - 63: i1 * iI1iII1I1I1i
  if 43 - 43: Oo . I1Ii1I1 * Ooo0Ooo % i1i1i1111I * i1
  if 16 - 16: I1I % i1iiIII111 % iI1iII1I1I1i + i1i1i1111I . Ooo0Ooo
  if 4 - 4: Ooo0Ooo
  if 12 - 12: IiI11Ii111 % IiIIii11Ii * oOo0O00 % IiIIii11Ii / i1 * i1iiIII111
  if 97 - 97: i1 + iI1iII1I1I1i
  if 2 - 2: OooOoo + ooo000 . IiI11Ii111 + i1I % i1iiIII111
  if 84 - 84: ooOOO + oOO . i1I . i1iiIII111 % IiI11Ii111 % OooOoo
  if 84 - 84: OooOoo % i1iiIII111 . i1I + Ooo0Ooo * Iii1i / I11iiIi11i1I
  if 31 - 31: IIiIIiIi11I1 * OooOoo - i1iiIII111 * oOO . I11iiIi11i1I
  if 30 - 30: i1I % i1iiIII111
  if 32 - 32: i1i1i1111I % I1Ii1I1 . ooo000
  if 29 - 29: Ooo0Ooo % i1I + IiIIii11Ii / ooOOO + i1I
  if 80 - 80: Iii1i - i1iiIII111 - oOo0O00 + I1I + oOO % I1Ii1I1
  if 20 - 20: ooOOO * Iii1i
  OoOO = [ ]
  OoooOO0 = [ ]
  if 73 - 73: iI1iII1I1I1i
  O00O = [ ]
  for oo00OOOO , O0Oo00o0 in self . model_params . items ( ) :
   if oo00OOOO == "name" :
    self . model_name = O0Oo00o0
   else :
    O00O . append ( oo00OOOO + "=" + str ( O0Oo00o0 ) )
  if self . model_name == "AttentionNet" :
   O00O . append ( str ( self . insideBlockInfo ) )
   if 5 - 5: i1I * IIiIIiIi11I1 + I1I + OooOoo % Ooo0Ooo
   if 64 - 64: oOO / iI1iII1I1I1i / i1I + iI1iII1I1I1i % ooo000
  O00O . append ( "input_shape=(%s, %s, %s)" % ( input_shape [ 0 ] [ 1 ] , input_shape [ 0 ] [ 2 ] , input_shape [ 0 ] [ 3 ] ) )
  if 68 - 68: iI1iII1I1I1i
  O0iiIIi1iI1iiIi = "self.%s = NOMModel.%s(" % ( self . name , self . model_name )
  O0iiIIi1iI1iiIi += ', ' . join ( O00O )
  O0iiIIi1iI1iiIi += ")"
  if 74 - 74: Ii . Oo + i1 * oOo0O00 . Ooo0Ooo
  OoOO . append ( O0iiIIi1iI1iiIi )
  if 75 - 75: IiI11Ii111 % i1
  if len ( reshape_output_name ) > 1 :
   I1I111i1IiI1 = "%s = self.%s([" % ( output_reg , self . name )
   I1I111i1IiI1 += ',' . join ( reshape_output_name )
   I1I111i1IiI1 += "])"
   OoooOO0 . append ( I1I111i1IiI1 )
  elif len ( reshape_output_name ) == 1 :
   I1I111i1IiI1 = "%s = self.%s(" % ( output_reg , self . name )
   I1I111i1IiI1 += ',' . join ( reshape_output_name )
   I1I111i1IiI1 += ")"
   OoooOO0 . append ( I1I111i1IiI1 )
   if 27 - 27: ooo000 % I1I * IiIIii11Ii + IIiIIiIi11I1 % i1 / ooo000
  return OoOO , OoooOO0 , output_reg , input_shape [ 0 ]
  if 32 - 32: OooOoo - i1iiIII111 % I11iiIi11i1I * i1I + i1i1i1111I % Oo
class OO00Oo0O0 :
 if 68 - 68: IiIIii11Ii
 if 7 - 7: oOo0O00 - Oo + i1iiIII111 . oOo0O00 / i1i1i1111I - I11iiIi11i1I
 if 95 - 95: i1i1i1111I * Ii . I1I . Iii1i
 if 7 - 7: OooOoo + IIiIIiIi11I1
 if 42 - 42: iI1iII1I1I1i
 if 82 - 82: ooo000 % i1
 if 17 - 17: oOo0O00 % IIiIIiIi11I1 % I11iiIi11i1I
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] , train : 'Train' ) -> 'Config' :
  if 31 - 31: Ii . IiI11Ii111 / oOo0O00 % IiIIii11Ii
  if 83 - 83: oOO * I11iiIi11i1I / i1i1i1111I
  if 38 - 38: Oo * I1Ii1I1 - Iii1i - i1i1i1111I
  if 72 - 72: I1I . oOO % OooOoo - IIiIIiIi11I1 . OooOoo
  if 88 - 88: ooo000 / Ooo0Ooo . ooo000 % oOO - I11iiIi11i1I
  if 97 - 97: oOO + i1I - oOo0O00
  if 79 - 79: iI1iII1I1I1i . I1I
  if 26 - 26: Iii1i / Ooo0Ooo
  if 23 - 23: oOO * iI1iII1I1I1i . I1Ii1I1
  if 59 - 59: i1iiIII111 / IiIIii11Ii % ooo000
  if 74 - 74: I11iiIi11i1I / IIiIIiIi11I1
  if 96 - 96: i1 * OooOoo + Ii
  if 43 - 43: I1Ii1I1
  if 37 - 37: i1I
  IIii1I1ii1IIi = I1IiiIiIi ( )
  if 78 - 78: ooo000 * i1I
  if 23 - 23: I1Ii1I1 * i1i1i1111I - IIiIIiIi11I1
  IIii1I1ii1IIi . parseJSON ( obj , train )
  if 48 - 48: IiIIii11Ii
  return IIii1I1ii1IIi
  if 33 - 33: I11iiIi11i1I
class I1IiiIiIi ( II1iII1I11I ) :
 def __init__ ( self , name : str = None , unitNamespace : str = None , trainable : bool = True , url : str = "https://tfhub.dev/google/imagenet/resnet_v2_50/feature_vector/4" ) :
  if 70 - 70: I1Ii1I1 / I11iiIi11i1I * Ii - OooOoo . I1I . Ooo0Ooo
  if 97 - 97: I1I . i1I % I1Ii1I1 % OooOoo / i1I / I11iiIi11i1I
  if 92 - 92: ooOOO * oOo0O00 * Oo + I1Ii1I1
  if 19 - 19: Iii1i - oOO - Ooo0Ooo - Iii1i
  if 58 - 58: oOo0O00 - OooOoo + iI1iII1I1I1i . IIiIIiIi11I1 . Oo - i1
  if 83 - 83: i1I * OooOoo % i1
  if 32 - 32: I1Ii1I1
  if 71 - 71: I11iiIi11i1I % Oo + I11iiIi11i1I . Ooo0Ooo * Iii1i
  if 45 - 45: I1I / Oo . I1Ii1I1
  if 49 - 49: iI1iII1I1I1i + ooOOO
  if 66 - 66: ooo000 + IIiIIiIi11I1 - ooo000 + i1iiIII111 * i1iiIII111
  if 4 - 4: i1iiIII111 - i1i1i1111I * i1I
  if 35 - 35: OooOoo + i1iiIII111
  if 36 - 36: i1iiIII111 / Iii1i * IiIIii11Ii % i1i1i1111I * i1i1i1111I
  if 47 - 47: ooOOO % IiIIii11Ii - Iii1i
  if 88 - 88: IiIIii11Ii - ooOOO / I1Ii1I1
  if 44 - 44: OooOoo * I11iiIi11i1I / oOO
  if 3 - 3: OooOoo / Iii1i - i1I / oOo0O00 - Iii1i % i1iiIII111
  if 59 - 59: oOO - I1I - IiIIii11Ii / Ii / Oo
  super ( ) . __init__ ( nodeType = o0OOo000o00 . TFHub , name = name )
  if 67 - 67: iI1iII1I1I1i % i1i1i1111I - Ii . IiI11Ii111 * iI1iII1I1I1i
  if 56 - 56: I1Ii1I1 . I11iiIi11i1I
  self . trainable = trainable
  if 55 - 55: IiIIii11Ii * IiIIii11Ii / oOO * i1i1i1111I
  if 71 - 71: IiIIii11Ii % IiI11Ii111 - iI1iII1I1I1i . i1i1i1111I / ooOOO
  self . url = url
  if 67 - 67: oOO % i1 / IiIIii11Ii % IiIIii11Ii
  if 16 - 16: Oo + i1I . ooOOO / Ooo0Ooo - i1 - Ii
  self . outputShape = [ [ ] ]
  if 65 - 65: ooOOO . Iii1i % i1i1i1111I % IIiIIiIi11I1 / OooOoo
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 64 - 64: Ooo0Ooo + Ii . Oo . IiIIii11Ii . Ooo0Ooo - i1
  if 81 - 81: i1i1i1111I
  if 4 - 4: ooOOO % IiIIii11Ii % iI1iII1I1I1i + IiI11Ii111 * I1I * IiI11Ii111
  if 88 - 88: Oo % OooOoo
  if 33 - 33: Oo
  if 37 - 37: ooo000 - ooo000 % oOO + ooOOO
  if 56 - 56: i1iiIII111
  if 79 - 79: Iii1i
  if 15 - 15: I1Ii1I1 + iI1iII1I1I1i % Oo
  if 59 - 59: Iii1i / I1I + Oo * I1I . iI1iII1I1I1i % i1iiIII111
  if 1 - 1: i1i1i1111I / Iii1i * Ooo0Ooo * Oo * IIiIIiIi11I1
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if Ii1I == "name" :
    setattr ( self , Ii1I , self . updateNodeName ( iiiiIi1IiiIi ) . replace ( ' ' , '' ) )
   elif Ii1I in [ "shape" , "outputShape" ] :
    if 29 - 29: IiIIii11Ii * IiI11Ii111 * IiI11Ii111
    if isinstance ( iiiiIi1IiiIi , list ) and len ( iiiiIi1IiiIi ) > 0 :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
    else :
     setattr ( self , Ii1I , [ iiiiIi1IiiIi ] )
   elif Ii1I == "_order" :
    if 63 - 63: IIiIIiIi11I1
    if isinstance ( iiiiIi1IiiIi , list ) and len ( iiiiIi1IiiIi ) :
     if len ( np . array ( iiiiIi1IiiIi ) ) == 2 :
      setattr ( self , Ii1I , [ s [ 0 ] for s in iiiiIi1IiiIi ] )
     else :
      setattr ( self , Ii1I , iiiiIi1IiiIi )
    else :
     setattr ( self , Ii1I , [ iiiiIi1IiiIi ] )
   elif Ii1I in [ "fromNode" , "toNode" ] :
    setattr ( self , Ii1I , [ [ s . replace ( ' ' , '' ) for s in iiiiIi1IiiIi [ 0 ] ] ] )
   elif Ii1I not in [ "_train" , "_nodeType" ] :
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 62 - 62: Oo / ooo000 - Ii + i1i1i1111I
    if 50 - 50: i1I + i1iiIII111
  self . train = train
  if 26 - 26: ooOOO + IiI11Ii111 - IIiIIiIi11I1
 @ staticmethod
 def keras_call_combineIncomingTensors ( input_sources , input_tensors , input_sources_name , input_tensors_name , output_reg , buildNo = 0 ) :
  if 18 - 18: Iii1i * IiI11Ii111 % IIiIIiIi11I1 / i1iiIII111 / i1I
  if 45 - 45: ooo000 . oOO * oOO % I1I
  if 64 - 64: Iii1i + oOo0O00 . Oo % Ii * IIiIIiIi11I1 / Iii1i
  if 97 - 97: ooo000 / ooo000 + IIiIIiIi11I1 + i1i1i1111I - Ii * IiIIii11Ii
  if 18 - 18: I1I / IIiIIiIi11I1 * oOo0O00 + I1I
  if 42 - 42: IIiIIiIi11I1 - Ii % Oo
  if 41 - 41: Iii1i - IIiIIiIi11I1
  if 38 - 38: i1I - IiI11Ii111 * i1iiIII111 / I11iiIi11i1I % I1I
  if 74 - 74: oOO * iI1iII1I1I1i + Oo % ooo000
  if 52 - 52: i1i1i1111I % oOo0O00 + ooOOO
  if 46 - 46: i1
  if 23 - 23: Oo / ooOOO / I11iiIi11i1I * i1I * ooOOO . I1Ii1I1
  if 63 - 63: i1iiIII111 / i1I % Oo
  if 47 - 47: i1iiIII111 - i1iiIII111 + oOO * IIiIIiIi11I1 / I1I
  if 59 - 59: Iii1i / Oo + I11iiIi11i1I - I1I % ooOOO % I1Ii1I1
  if 35 - 35: I11iiIi11i1I
  if 41 - 41: oOo0O00
  if 68 - 68: Iii1i . Iii1i - IIiIIiIi11I1 - I11iiIi11i1I . IIiIIiIi11I1
  iiIII1Ii1 = [ ]
  iiIII1Ii1 . extend ( input_sources_name )
  iiIII1Ii1 . extend ( input_tensors_name )
  ooo0o = [ ]
  ooo0o . extend ( input_sources )
  ooo0o . extend ( input_tensors )
  return ooo0o , [ ] , [ ] , iiIII1Ii1
  if 52 - 52: Iii1i + I11iiIi11i1I
 @ staticmethod
 def keras_call_auto_reshape_build ( input_shape , combine_output_name , output_reg ) :
  if 17 - 17: I1I / Ii * i1I . IIiIIiIi11I1 / I1I
  if 30 - 30: OooOoo + IiI11Ii111 % i1iiIII111 / Iii1i - OooOoo
  if 92 - 92: IIiIIiIi11I1 * i1i1i1111I / I1Ii1I1 % IiIIii11Ii
  if 63 - 63: IiIIii11Ii
  if 58 - 58: Oo / i1iiIII111 - ooo000 / i1
  if 78 - 78: ooo000 % IiI11Ii111 * i1 . ooo000
  if 15 - 15: i1 + Ooo0Ooo % I1Ii1I1 % i1I / I11iiIi11i1I
  if 84 - 84: Ooo0Ooo / i1I
  if 10 - 10: iI1iII1I1I1i + IIiIIiIi11I1 . I1I % Ii . I1I
  if 4 - 4: ooo000 + ooOOO + i1iiIII111 . IiI11Ii111 % oOO - i1I
  if 88 - 88: I11iiIi11i1I + oOO / i1iiIII111 - oOO
  if 95 - 95: I1I * Oo
  if 70 - 70: IiI11Ii111 / OooOoo . i1iiIII111 . IIiIIiIi11I1 * OooOoo / Iii1i
  if 69 - 69: Ooo0Ooo * Oo
  if 93 - 93: I1Ii1I1 * I11iiIi11i1I / i1I - oOo0O00
  return [ ] , [ ] , combine_output_name , input_shape
  if 61 - 61: i1i1i1111I . Iii1i
 def keras_call_layer_build ( self , reshape_output_name , output_reg , inputshape = None ) :
  if 76 - 76: Ii / I11iiIi11i1I + Ooo0Ooo . i1i1i1111I . I1I
  if 32 - 32: oOO / IiIIii11Ii % Ii - Oo
  if 48 - 48: IiI11Ii111 * IIiIIiIi11I1 - i1I . IiIIii11Ii - I1Ii1I1
  if 83 - 83: i1 * Iii1i * Ooo0Ooo / Ooo0Ooo
  if 79 - 79: I1I . iI1iII1I1I1i / I1I * i1I % Ooo0Ooo
  if 56 - 56: i1I / i1I . I1I . iI1iII1I1I1i
  if 37 - 37: I1Ii1I1
  if 70 - 70: i1I * i1i1i1111I
  if 85 - 85: ooo000 + I1I - Ii + oOO
  if 23 - 23: Iii1i * ooOOO
  if 64 - 64: i1 * Oo . OooOoo % i1I + Iii1i * iI1iII1I1I1i
  if 36 - 36: I1Ii1I1 % Oo + I1I % I1I * IiIIii11Ii
  if 54 - 54: Iii1i / i1i1i1111I - i1I * Iii1i
  if 14 - 14: IIiIIiIi11I1 * ooOOO / OooOoo
  if 60 - 60: Ii / I11iiIi11i1I
  OoOO = [ ]
  OoooOO0 = [ ]
  if self . url == '' :
   self . url = None
  oO00oOooO0O = 'self.%s = hub.KerasLayer("%s", trainable=%s)' % ( self . name , self . url , str ( self . trainable ) )
  OoOO . append ( oO00oOooO0O )
  if 74 - 74: Iii1i % Iii1i % Oo
  if self . _type == "BERT" :
   Ii1I1iIiiiI = '%s, _ = self.%s(' % ( output_reg , self . name )
  else :
   Ii1I1iIiiiI = '%s = self.%s(' % ( output_reg , self . name )
  if len ( reshape_output_name ) > 1 :
   Ii1I1iIiiiI += '['
   Ii1I1iIiiiI += ',' . join ( reshape_output_name )
   Ii1I1iIiiiI += '], training=training)'
  else :
   Ii1I1iIiiiI += '%s, training=training)' % ( reshape_output_name [ 0 ] )
  OoooOO0 . append ( Ii1I1iIiiiI )
  if 47 - 47: iI1iII1I1I1i
  return OoOO , OoooOO0 , output_reg , inputshape
  if 37 - 37: i1I % Ooo0Ooo % OooOoo / Ooo0Ooo . Ooo0Ooo % IIiIIiIi11I1
 @ staticmethod
 def keras_call_processOutputTensor ( self , input_shape , layer_output_name , output_reg , buildNo = 0 ) :
  if 32 - 32: i1 + oOO * ooOOO % i1i1i1111I
  if 99 - 99: i1 / i1I + I11iiIi11i1I
  if 99 - 99: Ii * OooOoo
  if 74 - 74: i1i1i1111I . ooo000 - Oo + i1i1i1111I + ooOOO - IIiIIiIi11I1
  if 57 - 57: oOo0O00 / I1I
  if 88 - 88: Ooo0Ooo - iI1iII1I1I1i + I11iiIi11i1I % oOo0O00
  if 81 - 81: Iii1i + i1 / Iii1i + ooOOO
  if 50 - 50: Ii * Oo * OooOoo + ooo000 - IiIIii11Ii
  if 5 - 5: Ii - Ii / IiIIii11Ii - I11iiIi11i1I * i1iiIII111
  if 53 - 53: I1I * IiI11Ii111 * Ooo0Ooo * OooOoo / I1Ii1I1
  if 76 - 76: IiI11Ii111 . i1iiIII111 + IIiIIiIi11I1 * i1 - ooOOO
  if 28 - 28: i1I % IIiIIiIi11I1
  if 9 - 9: Ooo0Ooo / i1
  if 5 - 5: IiI11Ii111 . iI1iII1I1I1i / iI1iII1I1I1i * Ii
  if 51 - 51: IiI11Ii111
  if 65 - 65: Ii % i1i1i1111I * iI1iII1I1I1i % i1i1i1111I
  return [ ] , [ ]
  if 53 - 53: i1I * I1I % i1i1i1111I + Ii
 @ staticmethod
 def updateNodeName ( nodeNameOrKey : str ) -> str :
  if 43 - 43: IIiIIiIi11I1 - I1Ii1I1 * ooOOO
  if 17 - 17: OooOoo + iI1iII1I1I1i . oOo0O00 % I1Ii1I1
  if 82 - 82: iI1iII1I1I1i . i1i1i1111I * iI1iII1I1I1i / i1iiIII111
  if 52 - 52: Ooo0Ooo % Oo - ooOOO
  if 29 - 29: oOO + i1 % i1i1i1111I - iI1iII1I1I1i
  if 41 - 41: I11iiIi11i1I . IIiIIiIi11I1 % Iii1i * OooOoo . IiIIii11Ii
  if 14 - 14: I1Ii1I1 % Oo % Ii - i1iiIII111 / i1
  if 31 - 31: i1i1i1111I + Iii1i . I1Ii1I1
  if 23 - 23: i1i1i1111I
  if 29 - 29: i1i1i1111I / Iii1i - i1I * OooOoo / I11iiIi11i1I
  if 79 - 79: Iii1i - IiI11Ii111
  if 94 - 94: I1Ii1I1 - i1 - OooOoo / I1I % i1
  if 86 - 86: Iii1i
  return re . sub ( r"\s" , "" , nodeNameOrKey )
  if 20 - 20: oOO / i1iiIII111
class O00oOo0O :
 if 21 - 21: OooOoo
 if 35 - 35: Ii
 if 50 - 50: ooOOO / Oo
 if 62 - 62: I11iiIi11i1I * Ii - Iii1i
 if 52 - 52: I11iiIi11i1I % I1Ii1I1 % ooOOO
 if 59 - 59: IiI11Ii111 - I1Ii1I1 . Iii1i % I1Ii1I1 * ooo000 - i1I
 if 91 - 91: Iii1i % i1iiIII111 + oOO . Iii1i / I1Ii1I1
 @ staticmethod
 def createFromJSON ( key : str , obj : Dict [ str , Any ] , train : 'Train' ) -> 'ModelNode.Config' :
  if 100 - 100: IiI11Ii111 * iI1iII1I1I1i / I1Ii1I1 % IiI11Ii111
  if 63 - 63: i1iiIII111 * I1I
  if 74 - 74: IIiIIiIi11I1 / i1iiIII111 + iI1iII1I1I1i / Ii + i1i1i1111I
  if 96 - 96: oOO - ooOOO
  if 97 - 97: oOO . Ooo0Ooo + I1I + Iii1i / Ooo0Ooo
  if 43 - 43: Oo / ooOOO / i1 % I1Ii1I1 % iI1iII1I1I1i
  if 78 - 78: ooo000
  if 81 - 81: i1iiIII111 + i1 - ooOOO
  if 86 - 86: i1iiIII111 * Oo + OooOoo / Ooo0Ooo / ooo000
  if 10 - 10: IiIIii11Ii / i1 / oOO . i1i1i1111I
  if 77 - 77: I1I - I1I * ooOOO * oOo0O00 % OooOoo + Iii1i
  if 33 - 33: ooOOO / Ii / IiIIii11Ii
  if 22 - 22: IIiIIiIi11I1 * I11iiIi11i1I / I11iiIi11i1I * IiI11Ii111
  if 2 - 2: ooo000 - Oo * Oo / oOO * ooo000 - i1
  if 85 - 85: i1iiIII111 % Ii + I1Ii1I1 . Iii1i / I1Ii1I1 * Ooo0Ooo
  if 99 - 99: oOO % i1I - Oo + I1Ii1I1
  oO00oOooO0O = getattr ( O00oOo0O , o0OOo000o00 . getName ( obj [ "_nodeType" ] ) if obj [ "_nodeType" ] else "Layer" ) . createFromJSON ( obj , train )
  if 62 - 62: i1iiIII111 . Iii1i - I1Ii1I1 * I1I - Iii1i * i1
  if 67 - 67: Ii . Iii1i
  train . modelNodes [ key ] = oO00oOooO0O
  return oO00oOooO0O
  if 86 - 86: I1I
 @ staticmethod
 def returnLayer ( key : str , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 76 - 76: i1i1i1111I
  oO00oOooO0O = getattr ( O00oOo0O , o0OOo000o00 . getName ( obj [ "_nodeType" ] ) if obj [ "_nodeType" ] else "Layer" ) . createFromJSON ( obj , train )
  if 15 - 15: oOO
  if 7 - 7: i1I
  if 23 - 23: Oo / I1I . I11iiIi11i1I % I11iiIi11i1I - Oo
  if 43 - 43: oOo0O00
  if 14 - 14: i1I % Ooo0Ooo / oOo0O00 + Ii
  if 11 - 11: oOo0O00 / IiI11Ii111 / IiIIii11Ii + IiIIii11Ii
  if 29 - 29: Ii - IIiIIiIi11I1 % i1i1i1111I % oOo0O00 + I1Ii1I1
  if 23 - 23: Ii * oOO + I1I * I11iiIi11i1I / IIiIIiIi11I1 / i1i1i1111I
  if 90 - 90: IIiIIiIi11I1 % oOo0O00 + ooOOO
  if 79 - 79: I1Ii1I1 / OooOoo + ooo000 + ooo000
  if 8 - 8: I1Ii1I1 - ooOOO % I11iiIi11i1I
  if 35 - 35: Iii1i / IiI11Ii111
  return oO00oOooO0O
  if 3 - 3: Oo
 @ staticmethod
 def updateNodeName ( nodeNameOrKey : str ) -> str :
  if 96 - 96: Oo / i1i1i1111I . Ooo0Ooo
  if 83 - 83: IiI11Ii111
  if 57 - 57: Ooo0Ooo . Ii - i1 + I1Ii1I1 . Oo + IiI11Ii111
  if 28 - 28: I11iiIi11i1I . Iii1i * IiIIii11Ii
  if 35 - 35: i1 / IiIIii11Ii
  if 64 - 64: IiIIii11Ii . oOO . Oo
  if 97 - 97: I1Ii1I1 + oOO
  if 82 - 82: IiIIii11Ii . ooOOO . i1 - i1I % Iii1i
  if 42 - 42: i1I - i1I
  if 73 - 73: IiIIii11Ii
  if 85 - 85: OooOoo - IIiIIiIi11I1 % ooo000
  if 71 - 71: Oo * Oo % Ooo0Ooo
  if 17 - 17: I1Ii1I1 % Oo - I1I * OooOoo - i1 + oOo0O00
  return re . sub ( r"\s" , "" , nodeNameOrKey )
  if 85 - 85: i1I
 Types = o0OOo000o00
 Layer = oOOoo
 Config = II1iII1I11I
 ComputationalUnit = I1I11ii
 TFHub = OO00Oo0O0
 NOMModel = o00OO0ooo0o
 if 11 - 11: I1I * i1I * i1I + i1
class II11iI :
 if 94 - 94: ooo000 + OooOoo / i1i1i1111I
 if 71 - 71: Iii1i - Iii1i
 if 98 - 98: OooOoo * oOO - Oo - Ii
 if 72 - 72: IIiIIiIi11I1 + Ii - IIiIIiIi11I1
 if 64 - 64: i1I % i1I % I1Ii1I1 - Ooo0Ooo % IIiIIiIi11I1
 if 38 - 38: I1I / IiI11Ii111
 if 83 - 83: IiI11Ii111 * i1iiIII111 % i1iiIII111 / I11iiIi11i1I % Ii
 def __init__ ( self ) :
  if 40 - 40: ooo000 * I1Ii1I1 * I1Ii1I1 + i1iiIII111 + oOO
  if 4 - 4: Oo * i1iiIII111
  if 29 - 29: i1iiIII111 * i1i1i1111I / I1I * I1I . IiIIii11Ii
  if 17 - 17: oOo0O00
  if 93 - 93: IIiIIiIi11I1 + i1i1i1111I + ooOOO - i1i1i1111I / IiI11Ii111
  if 24 - 24: OooOoo - i1I . i1 - oOo0O00 . iI1iII1I1I1i + I1Ii1I1
  if 55 - 55: oOo0O00 + i1iiIII111 / Ooo0Ooo % ooo000 * Oo . i1I
  self . builds = { }
  if 88 - 88: ooo000 + Oo * Ooo0Ooo . oOO . Iii1i . IIiIIiIi11I1
 def __getitem__ ( self , buildNo : int ) -> Any :
  if 39 - 39: I1Ii1I1 + oOo0O00 + oOO * Oo - i1iiIII111 * Ii
  if 68 - 68: Oo + Ii . oOO
  if 3 - 3: ooo000 . Oo
  if 45 - 45: i1i1i1111I - i1iiIII111 . iI1iII1I1I1i
  if 69 - 69: i1 . iI1iII1I1I1i * I1I . Oo
  if 12 - 12: OooOoo + iI1iII1I1I1i * Ii . I1I . Ooo0Ooo
  if 50 - 50: Ooo0Ooo . OooOoo / IIiIIiIi11I1 % IiI11Ii111
  if 68 - 68: IiIIii11Ii . ooOOO % i1iiIII111 * Ii - ooo000
  if 74 - 74: i1iiIII111 + i1I * Oo % I1Ii1I1 + I1Ii1I1 + IIiIIiIi11I1
  if 89 - 89: Ii * Iii1i % Oo
  if 49 - 49: i1iiIII111 . ooo000 / ooOOO + i1i1i1111I / I1Ii1I1 - i1
  if 2 - 2: i1
  if 1 - 1: oOo0O00
  if buildNo not in self . builds :
   self . builds [ buildNo ] = [ ]
  return self . builds [ buildNo ]
  if 87 - 87: I1Ii1I1 * I11iiIi11i1I . I1Ii1I1
 def __setitem__ ( self , buildNo : int , item : Any ) -> Any :
  if 26 - 26: IiI11Ii111 . I11iiIi11i1I - oOO
  if 96 - 96: oOO * i1 * i1i1i1111I . i1I + ooo000
  if 26 - 26: Ooo0Ooo % Ooo0Ooo - ooOOO % ooOOO + OooOoo . Oo
  if 77 - 77: IIiIIiIi11I1
  if 98 - 98: ooo000
  if 19 - 19: Oo * IIiIIiIi11I1
  if 70 - 70: OooOoo + Iii1i - OooOoo / Iii1i . I1I
  if 85 - 85: I1Ii1I1 . Oo % oOo0O00 + IiIIii11Ii / IiI11Ii111
  if 40 - 40: I11iiIi11i1I / i1I / oOO * Oo . Oo / Ii
  if 43 - 43: Iii1i - I1Ii1I1 . ooOOO * ooOOO * OooOoo
  if 90 - 90: Iii1i - OooOoo
  if 41 - 41: i1 - I1Ii1I1 / Oo % iI1iII1I1I1i
  if 14 - 14: I1Ii1I1 / Ii
  if 77 - 77: i1iiIII111 + Iii1i + I1I % i1 + I11iiIi11i1I - oOO
  self . builds [ buildNo ] = item
  return self . builds [ buildNo ]
  if 54 - 54: ooOOO . Ii % Iii1i / Ooo0Ooo - IiIIii11Ii
class i1i1iiIi1I ( II11iI ) :
 if 51 - 51: I1I % Iii1i . IiI11Ii111 * i1 . IIiIIiIi11I1 % i1iiIII111
 if 83 - 83: iI1iII1I1I1i - i1i1i1111I - i1
 if 35 - 35: OooOoo % i1
 if 25 - 25: i1 + ooOOO . IIiIIiIi11I1
 if 12 - 12: IIiIIiIi11I1 / Iii1i / IiIIii11Ii
 if 11 - 11: IiI11Ii111 / oOo0O00 + oOo0O00 . Oo % Oo - i1i1i1111I
 if 11 - 11: ooOOO % OooOoo
 def __setitem__ ( self , buildNo : int , sources : List [ Tuple [ int , str ] ] ) -> List [ Tuple [ int , str ] ] :
  if 41 - 41: i1i1i1111I * ooo000 % i1 / OooOoo
  if 82 - 82: oOO * OooOoo - i1i1i1111I + I1I
  if 60 - 60: IIiIIiIi11I1 / IiI11Ii111 - IiIIii11Ii . IiIIii11Ii
  if 46 - 46: I11iiIi11i1I . I11iiIi11i1I + Oo / I1I . ooOOO
  if 40 - 40: ooOOO % Ii / oOo0O00 - IiI11Ii111
  if 65 - 65: I1Ii1I1 * IiI11Ii111 . ooo000 - i1i1i1111I % iI1iII1I1I1i / I11iiIi11i1I
  if 65 - 65: IiI11Ii111 * i1i1i1111I . I1Ii1I1 * ooo000 / IiI11Ii111
  if 73 - 73: IiI11Ii111 . Ooo0Ooo . I1Ii1I1
  if 78 - 78: OooOoo + IiIIii11Ii . I1Ii1I1
  if 3 - 3: Ooo0Ooo . i1iiIII111
  if 63 - 63: OooOoo
  if 72 - 72: I1I + oOo0O00 / Iii1i % oOO
  if 99 - 99: i1i1i1111I
  if 26 - 26: oOo0O00 . oOo0O00 % ooOOO - OooOoo
  if not all ( [ ( isinstance ( st [ 0 ] , int ) and isinstance ( st [ 1 ] , str ) ) for st in sources ] ) :
   raise ValueError ( "BuildSourceList should append a tuple of source information." )
   if 16 - 16: i1iiIII111 / oOO + I1Ii1I1
  return super ( ) . __setitem__ ( buildNo , sources )
  if 59 - 59: oOO
class OO0OOoO0 ( II11iI ) :
 if 76 - 76: oOo0O00 . iI1iII1I1I1i + i1I - I1Ii1I1 / i1I
 if 55 - 55: oOO + oOo0O00
 if 98 - 98: Iii1i * OooOoo - IIiIIiIi11I1 . Ooo0Ooo
 if 77 - 77: i1I * i1I * IiI11Ii111 + IiIIii11Ii . Ii / ooOOO
 if 35 - 35: IiI11Ii111 . iI1iII1I1I1i
 if 39 - 39: ooo000
 if 32 - 32: IiIIii11Ii % Ii % Iii1i - IiI11Ii111 . oOo0O00 - Ii
 def __setitem__ ( self , buildNo : int , layerProfiles : List [ 'ModelNode.Layer.Config' ] ) -> List [ 'ModelNode.Layer.Config' ] :
  if 60 - 60: i1I / IIiIIiIi11I1
  if 28 - 28: Iii1i . Iii1i % i1I
  if 26 - 26: i1i1i1111I / Ooo0Ooo % I11iiIi11i1I * i1I / i1iiIII111 % i1I
  if 9 - 9: ooo000 * i1 % ooo000
  if 49 - 49: ooo000 * i1I / oOO . Ii % i1I . Oo
  if 65 - 65: IIiIIiIi11I1 . I1Ii1I1 / I11iiIi11i1I . IiIIii11Ii % ooOOO . i1i1i1111I
  if 79 - 79: I1I * I11iiIi11i1I + Ii - iI1iII1I1I1i
  if 88 - 88: iI1iII1I1I1i
  if 97 - 97: i1iiIII111 - IiIIii11Ii + IIiIIiIi11I1 . IiIIii11Ii * ooo000 * I11iiIi11i1I
  if 85 - 85: Iii1i % IIiIIiIi11I1 + i1I - Ii
  if 100 - 100: i1i1i1111I . I1I * oOO % i1I + oOO - iI1iII1I1I1i
  if 10 - 10: i1 . I1Ii1I1 % Oo . Ii - i1iiIII111
  if 75 - 75: ooo000 - ooo000 % Oo
  if 34 - 34: i1I - i1I - I11iiIi11i1I / OooOoo % IiI11Ii111 - ooOOO
  if not all ( [ isinstance ( lp , O00oOo0O . Layer . Config ) for lp in layerProfiles ] ) :
   raise ValueError ( "LayerNodeList should append ModelNode.Layer.Config objects." )
   if 68 - 68: i1
  return super ( ) . __setitem__ ( buildNo , layerProfiles )
  if 86 - 86: IiIIii11Ii * OooOoo
class oo0OOOOOOo0oO0 ( II11iI ) :
 if 76 - 76: ooOOO + Ii * Iii1i * oOo0O00 + i1 + Iii1i
 if 40 - 40: oOo0O00 . i1
 if 11 - 11: Ooo0Ooo - Oo + i1I % IiI11Ii111 % Iii1i + I1I
 if 51 - 51: ooOOO * OooOoo . oOO % Ooo0Ooo . IIiIIiIi11I1 % oOO
 if 82 - 82: I1Ii1I1 / ooo000
 if 21 - 21: Iii1i
 if 3 - 3: oOO * i1iiIII111
 def __setitem__ ( self , buildNo : int , order : int ) -> int :
  if 66 - 66: IIiIIiIi11I1 + i1I / i1iiIII111 . Oo + i1iiIII111
  if 86 - 86: i1I . I11iiIi11i1I
  if 98 - 98: OooOoo - I1I
  if 91 - 91: oOO
  if 11 - 11: OooOoo - ooo000 * IIiIIiIi11I1 . i1i1i1111I - ooOOO / OooOoo
  if 7 - 7: i1i1i1111I + ooo000 + oOO
  if 88 - 88: Ii * IIiIIiIi11I1
  if 20 - 20: IiI11Ii111 * IiI11Ii111 % i1I * oOo0O00
  if 74 - 74: ooOOO % Ii * I11iiIi11i1I . I11iiIi11i1I % I1Ii1I1 % ooo000
  if 55 - 55: i1 % ooo000
  if 58 - 58: I11iiIi11i1I . Ooo0Ooo * IiIIii11Ii
  if 53 - 53: Iii1i . I1Ii1I1 / i1iiIII111 % IIiIIiIi11I1 * i1 . oOo0O00
  if 76 - 76: IiIIii11Ii + I1I
  if 35 - 35: IIiIIiIi11I1
  if not isinstance ( order , int ) :
   raise ValueError ( "Order should be an integer." )
   if 50 - 50: IIiIIiIi11I1
  return super ( ) . __setitem__ ( buildNo , order )
  if 77 - 77: IIiIIiIi11I1 % IIiIIiIi11I1 - IiI11Ii111 % Ooo0Ooo / oOO * IiI11Ii111
def Ii11 ( insideBlockInfo , input_shape = ( 224 , 224 , 3 ) , ** kwargs ) :
 if 40 - 40: i1 * IIiIIiIi11I1 + iI1iII1I1I1i - ooOOO
 if 14 - 14: Ooo0Ooo + I1I / oOo0O00
 if 88 - 88: Oo * Ii % i1i1i1111I
 if 23 - 23: I1Ii1I1 . i1i1i1111I % I1I + ooOOO % OooOoo
 if 99 - 99: iI1iII1I1I1i
 if 34 - 34: i1i1i1111I . IiIIii11Ii + iI1iII1I1I1i % Ii / IiIIii11Ii
 if 50 - 50: I1Ii1I1 / i1i1i1111I - IiI11Ii111
 if 18 - 18: oOO - iI1iII1I1I1i . Ii + Ii * ooo000 % iI1iII1I1I1i
 if 1 - 1: I1I / I11iiIi11i1I % I11iiIi11i1I * Ooo0Ooo . i1I
 if 59 - 59: I11iiIi11i1I / OooOoo
 if 65 - 65: IiI11Ii111 % IiI11Ii111 * i1i1i1111I * iI1iII1I1I1i
 if 20 - 20: I1Ii1I1 + oOO
 if 96 - 96: IiIIii11Ii . I1I . IiI11Ii111 - I1Ii1I1 % I11iiIi11i1I
 if 64 - 64: Iii1i
 i1IIi = list ( insideBlockInfo . values ( ) )
 ooO = layers . Input ( shape = input_shape )
 OOoo00ooOo00O = OOoi11I11iiII ( ooO , i1IIi [ 0 ] )
 for O00ooo0o00oOO in range ( 1 , len ( i1IIi ) , 1 ) :
  OOoo00ooOo00O = iii1iIIiIi11I ( OOoo00ooOo00O , i1IIi [ O00ooo0o00oOO ] , O00ooo0o00oOO )
 OOoo00ooOo00O = layers . Conv2D ( i1IIi [ - 1 ] [ "outChannel" ] , i1IIi [ - 1 ] [ "kernelSize" ] , padding = 'same' ,
 dilation_rate = i1IIi [ - 1 ] [ "dilation" ] , activation = tf . nn . sigmoid ,
 use_bias = i1IIi [ - 1 ] [ "bias" ] , strides = i1IIi [ - 1 ] [ "stride" ] , name = 'conv_final' ) ( OOoo00ooOo00O )
 if 5 - 5: i1i1i1111I
 O0i1I1iiI = models . Model ( ooO , OOoo00ooOo00O , name = 'attentionnet' )
 return O0i1I1iiI
 if 6 - 6: I1I + IiI11Ii111 . Ooo0Ooo
def OOoi11I11iiII ( inputs , block_info ) :
 if 18 - 18: iI1iII1I1I1i - oOO . i1I - Ooo0Ooo % I1I % Ii
 if 15 - 15: Ooo0Ooo - ooo000 / IiI11Ii111 . ooOOO
 if 94 - 94: IIiIIiIi11I1 / oOo0O00 * i1 + IiI11Ii111 - IiIIii11Ii
 if 97 - 97: IiI11Ii111 - oOO - ooo000 / Ii * ooo000 * IiI11Ii111
 if 19 - 19: oOo0O00 . iI1iII1I1I1i . IiIIii11Ii % oOO % I1I
 if 6 - 6: i1iiIII111 / Ii
 if 4 - 4: ooo000 - ooo000
 if 6 - 6: I1Ii1I1
 if 67 - 67: Ii + oOO / ooOOO
 if 87 - 87: Iii1i . I11iiIi11i1I - IiI11Ii111 * IIiIIiIi11I1
 if 25 - 25: iI1iII1I1I1i
 if 32 - 32: OooOoo - i1i1i1111I / Oo . Iii1i
 if 80 - 80: i1I + IiIIii11Ii - Oo
 if 32 - 32: Oo
 OOoo00ooOo00O = layers . Conv2D ( block_info [ "outChannel" ] , block_info [ "kernelSize" ] , padding = 'same' ,
 dilation_rate = block_info [ "dilation" ] ,
 use_bias = block_info [ "bias" ] , strides = block_info [ "stride" ] , name = 'conv1' ) ( inputs )
 OOoo00ooOo00O = layers . BatchNormalization ( name = 'conv1_bn' ) ( OOoo00ooOo00O )
 return layers . ReLU ( 6. , name = 'conv1_relu' ) ( OOoo00ooOo00O )
 if 22 - 22: IIiIIiIi11I1
def iii1iIIiIi11I ( inputs , block_info , block_index ) :
 if 29 - 29: oOO
 if 10 - 10: oOo0O00 / Oo % Iii1i . i1iiIII111
 if 3 - 3: I1Ii1I1 - i1iiIII111
 if 83 - 83: I1Ii1I1 - i1i1i1111I - i1iiIII111 % oOO
 if 92 - 92: ooo000 / I1Ii1I1 . IIiIIiIi11I1
 if 25 - 25: IiIIii11Ii % OooOoo % oOo0O00
 if 25 - 25: OooOoo % I11iiIi11i1I / Iii1i
 if 66 - 66: ooo000 - I1I / ooo000
 if 22 - 22: i1i1i1111I % Ooo0Ooo
 if 92 - 92: i1
 if 96 - 96: OooOoo . oOO + i1iiIII111
 if 41 - 41: ooo000 + I11iiIi11i1I
 if 58 - 58: Ii * oOO % ooo000 . I1I * IIiIIiIi11I1 + OooOoo
 if 75 - 75: IiI11Ii111 * OooOoo % IiIIii11Ii . i1i1i1111I + i1
 if 60 - 60: oOO / IiI11Ii111 / I1Ii1I1 . i1i1i1111I - oOo0O00 - i1
 OOoo00ooOo00O = layers . Conv2D ( block_info [ "outChannel" ] , block_info [ "kernelSize" ] , padding = 'same' ,
 dilation_rate = block_info [ "dilation" ] ,
 use_bias = block_info [ "bias" ] , strides = block_info [ "stride" ] ,
 name = 'conv_pw_%d_0' % block_index ) ( inputs )
 OOoo00ooOo00O = layers . BatchNormalization ( name = 'conv_dw_%d_bn' % block_index ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . ReLU ( 6. , name = 'conv_dw_%d_relu' % block_index ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Conv2D ( block_info [ "outChannel" ] , block_info [ "kernelSize" ] , padding = 'same' ,
 dilation_rate = block_info [ "dilation" ] ,
 use_bias = block_info [ "bias" ] , strides = block_info [ "stride" ] ,
 name = 'conv_pw_%d_1' % block_index ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( name = 'conv_pw_%d_bn' % block_index ) ( OOoo00ooOo00O )
 return layers . ReLU ( 6. , name = 'conv_pw_%d_relu' % block_index ) ( OOoo00ooOo00O + inputs )
 if 15 - 15: IiI11Ii111 - oOO + Ii . I11iiIi11i1I - i1i1i1111I + i1i1i1111I
def o0o0 ( input_shape = ( 224 , 224 , 3 ) ,
 width_multiplier = 1.0 ,
 resolution_multiplier = 1 ,
 dropout = 1e-3 ,
 classes = 10 ,
 ** kwargs ) :
 ooO = layers . Input ( shape = input_shape )
 if 9 - 9: Oo / OooOoo
 if 46 - 46: IIiIIiIi11I1 + i1 / iI1iII1I1I1i % I11iiIi11i1I + oOo0O00
 if 65 - 65: i1 * Ooo0Ooo * I11iiIi11i1I % OooOoo . I1Ii1I1
 if 44 - 44: i1I
 if 14 - 14: iI1iII1I1I1i + oOO
 if 100 - 100: I1I
 if 61 - 61: I1Ii1I1 + oOo0O00 . i1iiIII111 . Iii1i - IiI11Ii111 % IiIIii11Ii
 if 17 - 17: Ii
 if 97 - 97: Iii1i - IiI11Ii111 + oOO
 if 76 - 76: ooo000 / Oo . oOo0O00 . IIiIIiIi11I1 + Ooo0Ooo
 if 86 - 86: oOo0O00 . ooOOO % oOo0O00 / IiIIii11Ii . i1i1i1111I . i1
 if 99 - 99: Oo % oOo0O00 % IiIIii11Ii * iI1iII1I1I1i
 if 41 - 41: IiIIii11Ii * i1 / i1iiIII111
 if 48 - 48: iI1iII1I1I1i % i1I / IiIIii11Ii + IiIIii11Ii . IiIIii11Ii
 if 19 - 19: Oo . I11iiIi11i1I . IIiIIiIi11I1
 if 83 - 83: i1iiIII111
 OOoo00ooOo00O = o0oo000oOOO ( ooO , 32 , width_multiplier , strides = ( 2 , 2 ) )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 64 , width_multiplier , resolution_multiplier , block_id = 1 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 128 , width_multiplier , resolution_multiplier , strides = ( 2 , 2 ) , block_id = 2 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 128 , width_multiplier , resolution_multiplier , block_id = 3 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 256 , width_multiplier , resolution_multiplier , strides = ( 2 , 2 ) , block_id = 4 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 256 , width_multiplier , resolution_multiplier , block_id = 5 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 512 , width_multiplier , resolution_multiplier , strides = ( 2 , 2 ) , block_id = 6 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 512 , width_multiplier , resolution_multiplier , block_id = 7 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 512 , width_multiplier , resolution_multiplier , block_id = 8 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 512 , width_multiplier , resolution_multiplier , block_id = 9 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 512 , width_multiplier , resolution_multiplier , block_id = 10 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 512 , width_multiplier , resolution_multiplier , block_id = 11 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 1024 , width_multiplier , resolution_multiplier , strides = ( 2 , 2 ) , block_id = 12 )
 OOoo00ooOo00O = II1III111I ( OOoo00ooOo00O , 1024 , width_multiplier , resolution_multiplier , block_id = 13 )
 if 59 - 59: I1I - oOo0O00
 OOo00oOoOo = ( 1 , 1 , int ( 1024 * width_multiplier ) )
 OOoo00ooOo00O = layers . GlobalAveragePooling2D ( ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Reshape ( OOo00oOoOo , name = 'reshape_1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Dropout ( dropout , name = 'dropout' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Conv2D ( classes , ( 1 , 1 ) , padding = 'same' , name = 'conv_pred' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Reshape ( ( classes , ) , name = 'reshape_2' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Activation ( 'softmax' , name = 'act_softmax' ) ( OOoo00ooOo00O )
 if 67 - 67: i1iiIII111 + Iii1i * OooOoo . Iii1i / iI1iII1I1I1i % I1Ii1I1
 O0i1I1iiI = models . Model ( ooO , OOoo00ooOo00O , name = 'mobilenet_%0.2f_%s' % ( width_multiplier , input_shape [ 0 ] ) )
 return O0i1I1iiI
 if 77 - 77: iI1iII1I1I1i * I1Ii1I1 % ooo000 % ooo000
def o0oo000oOOO ( inputs , filters , width_multiplier , kernel = ( 3 , 3 ) , strides = ( 1 , 1 ) ) :
 filters = int ( filters * width_multiplier )
 if 11 - 11: OooOoo % i1iiIII111 % Iii1i % Ii + Ooo0Ooo
 if 17 - 17: i1I
 if 82 - 82: oOo0O00 / Iii1i . OooOoo
 if 30 - 30: Oo . I1I * Oo . i1 . ooo000 / i1
 if 32 - 32: oOO % I11iiIi11i1I - i1I + Ooo0Ooo - Ooo0Ooo
 if 68 - 68: I1I - I11iiIi11i1I + IiIIii11Ii . i1
 if 74 - 74: I1Ii1I1
 if 22 - 22: IiI11Ii111
 if 2 - 2: ooo000 / i1iiIII111 . Ooo0Ooo
 if 74 - 74: ooOOO
 if 98 - 98: oOo0O00 - ooOOO
 if 33 - 33: ooo000 * ooOOO % OooOoo + i1i1i1111I * i1i1i1111I * Iii1i
 if 53 - 53: IiI11Ii111 . Ii % I1I + Ii
 if 30 - 30: i1i1i1111I - i1iiIII111
 if 13 - 13: iI1iII1I1I1i % Ii . Iii1i + oOo0O00 * Ooo0Ooo + ooOOO
 if 98 - 98: oOO / oOO % OooOoo % OooOoo
 OOoo00ooOo00O = layers . ZeroPadding2D ( padding = ( ( 0 , 1 ) , ( 0 , 1 ) ) , name = 'conv1_pad' ) ( inputs )
 OOoo00ooOo00O = layers . Conv2D ( filters , kernel , padding = 'valid' , use_bias = False , strides = strides , name = 'conv1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( name = 'conv1_bn' ) ( OOoo00ooOo00O )
 return layers . ReLU ( 6. , name = 'conv1_relu' ) ( OOoo00ooOo00O )
 if 67 - 67: i1i1i1111I . ooOOO + IiI11Ii111
def II1III111I ( inputs , pointwise_conv_filters , width_multiplier , resolution_multiplier = 1 , strides = ( 1 , 1 ) , block_id = 1 ) :
 if 63 - 63: i1iiIII111 . IIiIIiIi11I1 * i1 * I11iiIi11i1I + Ii
 if 43 - 43: Ooo0Ooo . Oo / I11iiIi11i1I
 if 78 - 78: iI1iII1I1I1i / Ii + Ooo0Ooo . i1I * Oo / i1iiIII111
 if 25 - 25: Iii1i * Iii1i * Iii1i + Ooo0Ooo * IIiIIiIi11I1
 if 92 - 92: I11iiIi11i1I + Oo * IiI11Ii111 - i1I % I1I . i1
 if 5 - 5: i1 % IIiIIiIi11I1
 if 46 - 46: I11iiIi11i1I * I1I . Iii1i * Oo * i1i1i1111I / iI1iII1I1I1i
 if 3 - 3: oOo0O00 % i1I + iI1iII1I1I1i + oOO . i1i1i1111I
 if 27 - 27: Ii . IiI11Ii111 / Iii1i
 if 56 - 56: ooo000
 if 73 - 73: oOO
 if 98 - 98: Ooo0Ooo / Ii . Ooo0Ooo
 if 64 - 64: iI1iII1I1I1i
 if 51 - 51: IIiIIiIi11I1 - I1Ii1I1 . I11iiIi11i1I + Oo % OooOoo
 if 61 - 61: IIiIIiIi11I1
 if 62 - 62: ooo000 / oOO
 if 84 - 84: IIiIIiIi11I1 * i1i1i1111I % Ii
 pointwise_conv_filters = int ( pointwise_conv_filters * width_multiplier )
 if 45 - 45: I11iiIi11i1I / oOo0O00 % Ooo0Ooo . oOO * i1 - i1i1i1111I
 if strides == ( 1 , 1 ) :
  OOoo00ooOo00O = inputs
 else :
  OOoo00ooOo00O = layers . ZeroPadding2D ( ( ( 0 , 1 ) , ( 0 , 1 ) ) , name = 'conv_pad_%d' % block_id ) ( inputs )
  if 65 - 65: OooOoo + i1iiIII111 * Ooo0Ooo
 OOoo00ooOo00O = layers . DepthwiseConv2D ( ( 3 , 3 ) ,
 padding = 'same' if strides == ( 1 , 1 ) else 'valid' ,
 depth_multiplier = resolution_multiplier ,
 strides = strides ,
 use_bias = False ,
 name = 'conv_dw_%d' % block_id ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( name = 'conv_dw_%d_bn' % block_id ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . ReLU ( 6. , name = 'conv_dw_%d_relu' % block_id ) ( OOoo00ooOo00O )
 if 59 - 59: IIiIIiIi11I1 * iI1iII1I1I1i % Iii1i % i1iiIII111
 OOoo00ooOo00O = layers . Conv2D ( pointwise_conv_filters , ( 1 , 1 ) ,
 padding = 'same' ,
 use_bias = False ,
 strides = ( 1 , 1 ) ,
 name = 'conv_pw_%d' % block_id ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( name = 'conv_pw_%d_bn' % block_id ) ( OOoo00ooOo00O )
 return layers . ReLU ( 6. , name = 'conv_pw_%d_relu' % block_id ) ( OOoo00ooOo00O )
 if 95 - 95: i1i1i1111I . ooo000 - IiI11Ii111
def iiIi1Ii ( input_shape = ( 224 , 224 , 3 ) ,
 width_multiplier = 1.0 ,
 classes = 10 ,
 ** kwargs ) :
 if 99 - 99: Ooo0Ooo / IiI11Ii111 % Ooo0Ooo
 if 85 - 85: i1I - Ooo0Ooo - Ooo0Ooo % i1I % Iii1i
 if 7 - 7: I1Ii1I1 % Oo % Iii1i - ooOOO
 if 15 - 15: i1I - Ooo0Ooo
 if 35 - 35: oOo0O00 . IIiIIiIi11I1 % I1I . i1 % Oo + Iii1i
 if 31 - 31: Oo
 if 10 - 10: IIiIIiIi11I1 + IIiIIiIi11I1 * Ii
 if 9 - 9: Iii1i / IIiIIiIi11I1 * oOo0O00 % Iii1i % I11iiIi11i1I
 if 24 - 24: ooo000 + IiI11Ii111 . oOo0O00
 if 30 - 30: Oo . I1I
 if 6 - 6: I1I / i1I
 if 99 - 99: IiIIii11Ii / Ii + IiIIii11Ii / i1i1i1111I - I1I / oOO
 if 34 - 34: I1Ii1I1 - iI1iII1I1I1i * oOO
 if 10 - 10: IiI11Ii111 . ooo000
 if 84 - 84: IIiIIiIi11I1 + IiIIii11Ii / i1iiIII111 . oOo0O00 * ooo000 % Ii
 OOOOooOo = O0oO0OO0OOo0 ( 32 * width_multiplier , 8 )
 if 43 - 43: I11iiIi11i1I % Iii1i . I11iiIi11i1I + i1
 ooO = layers . Input ( shape = input_shape )
 OOoo00ooOo00O = layers . ZeroPadding2D ( padding = I1I1iIiIi1ii ( backend , ooO , 3 ) , name = 'Conv1_pad' ) ( ooO )
 OOoo00ooOo00O = layers . Conv2D ( OOOOooOo , kernel_size = 3 , strides = ( 2 , 2 ) , padding = 'valid' , use_bias = False , name = 'Conv1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = 'bn_Conv1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . ReLU ( 6. , name = 'Conv1_relu' ) ( OOoo00ooOo00O )
 if 57 - 57: OooOoo % i1i1i1111I * Ii * i1iiIII111 % IiI11Ii111
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 16 , alpha = width_multiplier , stride = 1 , expansion = 1 , block_id = 0 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 24 , alpha = width_multiplier , stride = 2 , expansion = 6 , block_id = 1 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 24 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 2 )
 if 90 - 90: i1 % i1iiIII111 + i1i1i1111I . Ooo0Ooo
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 32 , alpha = width_multiplier , stride = 2 , expansion = 6 , block_id = 3 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 32 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 4 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 32 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 5 )
 if 90 - 90: Ii
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 64 , alpha = width_multiplier , stride = 2 , expansion = 6 , block_id = 6 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 64 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 7 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 64 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 8 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 64 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 9 )
 if 50 - 50: i1iiIII111 . Oo * I1I
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 96 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 10 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 96 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 11 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 96 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 12 )
 if 66 - 66: I1Ii1I1 / Ooo0Ooo
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 160 , alpha = width_multiplier , stride = 2 , expansion = 6 , block_id = 13 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 160 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 14 )
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 160 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 15 )
 if 20 - 20: ooo000 / I11iiIi11i1I + i1 % IiI11Ii111 + IiI11Ii111
 OOoo00ooOo00O = Ii11ii1I11 ( OOoo00ooOo00O , filters = 320 , alpha = width_multiplier , stride = 1 , expansion = 6 , block_id = 16 )
 if 50 - 50: i1iiIII111
 if width_multiplier > 1.0 :
  iI11iIiI1I11i = O0oO0OO0OOo0 ( 1280 * width_multiplier , 8 )
 else :
  iI11iIiI1I11i = 1280
  if 95 - 95: I11iiIi11i1I % IiIIii11Ii
 OOoo00ooOo00O = layers . Conv2D ( iI11iIiI1I11i , kernel_size = 1 , use_bias = False , name = 'Conv_1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = 'Conv_1_bn' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . ReLU ( 6. , name = 'out_relu' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . GlobalAveragePooling2D ( ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Dense ( classes , activation = 'softmax' , use_bias = True , name = 'Logits' ) ( OOoo00ooOo00O )
 if 12 - 12: ooo000 % oOo0O00 % Ii
 O0i1I1iiI = models . Model ( ooO , OOoo00ooOo00O , name = 'mobilenet_v2_%0.2f_%s' % ( width_multiplier , input_shape [ 0 ] ) )
 return O0i1I1iiI
 if 79 - 79: iI1iII1I1I1i % I11iiIi11i1I . I11iiIi11i1I
def O0oO0OO0OOo0 ( v , divisor , min_value = None ) :
 if min_value is None :
  if 18 - 18: i1i1i1111I % iI1iII1I1I1i * Iii1i % ooo000 - Ooo0Ooo
  if 13 - 13: IiIIii11Ii + I11iiIi11i1I * Iii1i
  if 85 - 85: Oo - iI1iII1I1I1i % Iii1i . I1I . i1iiIII111 - i1i1i1111I
  if 19 - 19: i1i1i1111I . Ooo0Ooo
  if 26 - 26: ooo000 - Oo % i1
  if 52 - 52: iI1iII1I1I1i * i1iiIII111 / i1I
  if 71 - 71: oOO - I1Ii1I1 + Oo
  if 92 - 92: I11iiIi11i1I / IiI11Ii111
  if 68 - 68: i1iiIII111 / Oo + ooOOO
  if 32 - 32: Oo
  if 82 - 82: I1Ii1I1 + iI1iII1I1I1i - ooo000 / OooOoo / i1iiIII111
  if 14 - 14: i1i1i1111I / ooOOO . i1
  if 3 - 3: oOo0O00 . i1 + Ii . I1Ii1I1 . i1iiIII111
  if 79 - 79: oOo0O00
  min_value = divisor
 O0OO0o = max ( min_value , int ( v + divisor / 2 ) // divisor * divisor )
 if 60 - 60: i1
 if O0OO0o < 0.9 * v :
  O0OO0o += divisor
 return O0OO0o
 if 45 - 45: i1i1i1111I + I11iiIi11i1I * Ooo0Ooo + Oo % IIiIIiIi11I1
def Ii11ii1I11 ( inputs , expansion , stride , alpha , filters , block_id ) :
 in_channels = backend . int_shape ( inputs ) [ - 1 ]
 if 20 - 20: IIiIIiIi11I1 + OooOoo . Oo - IiI11Ii111 % OooOoo
 if 63 - 63: i1i1i1111I + IiI11Ii111
 if 70 - 70: oOO - i1 / I1I / Ooo0Ooo . IiIIii11Ii + IiI11Ii111
 if 58 - 58: i1 . i1iiIII111 + OooOoo / Iii1i
 if 90 - 90: iI1iII1I1I1i / IiI11Ii111
 if 56 - 56: IIiIIiIi11I1
 if 59 - 59: Ii . I1Ii1I1 . Ii % IiIIii11Ii % i1iiIII111 * i1i1i1111I
 if 58 - 58: i1I * ooOOO
 if 70 - 70: IiI11Ii111 * i1 % Oo / i1I . I11iiIi11i1I
 if 74 - 74: i1 % oOo0O00 + IiIIii11Ii . OooOoo
 if 87 - 87: ooo000 * Iii1i + ooo000
 if 4 - 4: ooo000 + I1I + IiI11Ii111 / Ii . oOO % IiI11Ii111
 if 44 - 44: i1I
 if 9 - 9: I1Ii1I1 - i1iiIII111 - Iii1i
 pointwise_conv_filters = int ( filters * alpha )
 pointwise_filters = O0oO0OO0OOo0 ( pointwise_conv_filters , 8 )
 if 98 - 98: i1 * Ooo0Ooo * OooOoo / IiI11Ii111
 x = inputs
 iiIi1II = 'block_{}_' . format ( block_id )
 if 25 - 25: OooOoo
 if block_id :
  if 26 - 26: ooOOO % ooOOO % OooOoo
  x = layers . Conv2D ( expansion * in_channels ,
 kernel_size = 1 ,
 padding = 'same' ,
 use_bias = False ,
 activation = None ,
 name = iiIi1II + 'expand' ) ( x )
  x = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = iiIi1II + 'expand_BN' ) ( x )
  x = layers . ReLU ( 6. , name = iiIi1II + 'expand_relu' ) ( x )
 else :
  iiIi1II = 'expanded_conv_'
  if 8 - 8: i1i1i1111I + ooOOO % ooOOO + I1Ii1I1 - Ii
  if 35 - 35: i1iiIII111 + IIiIIiIi11I1
 if stride == 2 :
  x = layers . ZeroPadding2D ( padding = I1I1iIiIi1ii ( backend , x , 3 ) , name = iiIi1II + 'pad' ) ( x )
  if 82 - 82: I1Ii1I1 - I1I - i1 . IiI11Ii111 * I1Ii1I1
 x = layers . DepthwiseConv2D ( kernel_size = 3 ,
 strides = stride ,
 activation = None ,
 use_bias = False ,
 padding = 'same' if stride == 1 else 'valid' ,
 name = iiIi1II + 'depthwise' ) ( x )
 x = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = iiIi1II + 'depthwise_BN' ) ( x )
 x = layers . ReLU ( 6. , name = iiIi1II + 'depthwise_relu' ) ( x )
 if 91 - 91: Oo
 if 83 - 83: I11iiIi11i1I . I1Ii1I1 * i1I * oOO / Ii
 x = layers . Conv2D ( pointwise_filters , kernel_size = 1 , padding = 'same' , use_bias = False , activation = None , name = iiIi1II + 'project' ) ( x )
 x = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = iiIi1II + 'project_BN' ) ( x )
 if 59 - 59: I11iiIi11i1I / iI1iII1I1I1i + I1Ii1I1
 if in_channels == pointwise_filters and stride == 1 :
  return layers . Add ( name = iiIi1II + 'add' ) ( [ inputs , x ] )
 return x
 if 78 - 78: i1
def iIIiIII1Ii1i ( input_shape = ( 224 , 224 , 3 ) ,
 depth_multiplier = 1.0 ,
 minimalistic = False ,
 classes = 10 ,
 dropout_rate = 0.2 ,
 ** kwargs ) :
 if 57 - 57: Ii . OooOoo - iI1iII1I1I1i - oOO
 if 92 - 92: Ooo0Ooo - i1iiIII111 * IiI11Ii111 * i1 - oOo0O00 / Ooo0Ooo
 if 4 - 4: IIiIIiIi11I1 * IiIIii11Ii . Iii1i
 if 18 - 18: Oo . OooOoo % Iii1i + IiIIii11Ii * I1I % ooo000
 if 92 - 92: i1iiIII111 / iI1iII1I1I1i . OooOoo . IiIIii11Ii + IiIIii11Ii
 if 84 - 84: iI1iII1I1I1i - ooOOO
 if 56 - 56: i1 * oOo0O00 + I1Ii1I1 / I1Ii1I1 / oOO
 if 25 - 25: i1i1i1111I / Iii1i / IIiIIiIi11I1 / I1I
 if 24 - 24: oOo0O00 . oOo0O00
 if 71 - 71: Iii1i . ooOOO . IiIIii11Ii
 if 28 - 28: ooOOO + I1Ii1I1 - I1Ii1I1
 if 64 - 64: OooOoo % i1i1i1111I % OooOoo - I1Ii1I1 - i1 + I1I
 if 34 - 34: I1Ii1I1 - Iii1i * oOO + ooOOO
 if 37 - 37: ooo000 - OooOoo
 if 82 - 82: i1iiIII111 / IiIIii11Ii * IiI11Ii111 % oOO + oOo0O00
 if 72 - 72: IIiIIiIi11I1 * IiIIii11Ii
 if 74 - 74: IiIIii11Ii + oOO % Ooo0Ooo - i1I
 def ooo00oO ( x , kernel , activation , se_ratio ) :
  if 19 - 19: IiI11Ii111 + Oo
  if 51 - 51: Oo / I1Ii1I1 % ooOOO * ooOOO * ooo000
  if 87 - 87: i1iiIII111 % ooo000 - i1iiIII111
  if 52 - 52: Iii1i - Iii1i / Ooo0Ooo - OooOoo * i1iiIII111 + i1i1i1111I
  if 31 - 31: i1I . Oo - iI1iII1I1I1i / i1 * I11iiIi11i1I + i1iiIII111
  if 62 - 62: oOo0O00 * oOo0O00 % oOO . oOo0O00 + I1Ii1I1
  if 56 - 56: ooOOO * i1iiIII111 % i1
  if 57 - 57: IiIIii11Ii
  if 61 - 61: IiI11Ii111 + i1i1i1111I + i1iiIII111
  if 66 - 66: ooOOO + Oo % Iii1i + I1Ii1I1
  if 19 - 19: IiI11Ii111 * i1iiIII111
  if 9 - 9: IiIIii11Ii % oOO * iI1iII1I1I1i % I11iiIi11i1I - i1i1i1111I . ooo000
  if 90 - 90: Iii1i + I11iiIi11i1I * IiI11Ii111
  if 15 - 15: Ii % iI1iII1I1I1i % Ooo0Ooo
  if 78 - 78: IiIIii11Ii . ooOOO - Iii1i % oOo0O00 . I11iiIi11i1I
  if 86 - 86: Ii % Iii1i % OooOoo * ooo000
  def oO0oIII1 ( d ) :
   if 58 - 58: iI1iII1I1I1i + I1Ii1I1 + I11iiIi11i1I / IiIIii11Ii . i1iiIII111
   if 10 - 10: I1Ii1I1 - oOo0O00 * IiI11Ii111
   if 79 - 79: IIiIIiIi11I1 * OooOoo
   if 76 - 76: OooOoo + ooOOO . Ii / ooo000 . Ii
   if 37 - 37: i1 - IIiIIiIi11I1
   if 48 - 48: IIiIIiIi11I1 % I1Ii1I1 * I11iiIi11i1I % ooo000 + I11iiIi11i1I
   if 47 - 47: iI1iII1I1I1i + Iii1i - Iii1i + i1iiIII111 * IIiIIiIi11I1
   if 47 - 47: IIiIIiIi11I1 % I1I + IiI11Ii111 * i1I / i1i1i1111I
   if 69 - 69: Oo * ooOOO % IiIIii11Ii . I11iiIi11i1I + ooOOO
   if 53 - 53: I1Ii1I1 + i1i1i1111I % oOO * I1I % I11iiIi11i1I + Ii
   if 47 - 47: Ii / ooo000 - OooOoo % Iii1i * i1iiIII111
   if 33 - 33: Iii1i - OooOoo
   if 97 - 97: OooOoo + Oo * i1i1i1111I
   return oO0Oo0OOo0 ( d * depth_multiplier )
   if 89 - 89: oOo0O00 % IiIIii11Ii % iI1iII1I1I1i . Iii1i
  x = Ii11ii1I11 ( x , 1 , oO0oIII1 ( 16 ) , 3 , 2 , se_ratio , iIiiiI1I1iII1 , 0 )
  x = Ii11ii1I11 ( x , 72. / 16 , oO0oIII1 ( 24 ) , 3 , 2 , None , iIiiiI1I1iII1 , 1 )
  x = Ii11ii1I11 ( x , 88. / 24 , oO0oIII1 ( 24 ) , 3 , 1 , None , iIiiiI1I1iII1 , 2 )
  x = Ii11ii1I11 ( x , 4 , oO0oIII1 ( 40 ) , kernel , 2 , se_ratio , activation , 3 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 40 ) , kernel , 1 , se_ratio , activation , 4 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 40 ) , kernel , 1 , se_ratio , activation , 5 )
  x = Ii11ii1I11 ( x , 3 , oO0oIII1 ( 48 ) , kernel , 1 , se_ratio , activation , 6 )
  x = Ii11ii1I11 ( x , 3 , oO0oIII1 ( 48 ) , kernel , 1 , se_ratio , activation , 7 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 96 ) , kernel , 2 , se_ratio , activation , 8 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 96 ) , kernel , 1 , se_ratio , activation , 9 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 96 ) , kernel , 1 , se_ratio , activation , 10 )
  return x
  if 95 - 95: IiIIii11Ii
 return o0o0ii ( ooo00oO , 1024 , input_shape = input_shape , depth_multiplier = depth_multiplier , model_type = 'small' , minimalistic = minimalistic , classes = classes , dropout_rate = dropout_rate )
 if 84 - 84: Ii
def oO00 ( input_shape = ( 224 , 224 , 3 ) ,
 depth_multiplier = 1.0 ,
 minimalistic = False ,
 classes = 10 ,
 dropout_rate = 0.2 ,
 ** kwargs ) :
 if 53 - 53: oOo0O00 . ooo000 % OooOoo . I1Ii1I1 * Ii + IiI11Ii111
 if 22 - 22: Oo . IiI11Ii111 . I11iiIi11i1I % i1iiIII111 + ooo000 / i1i1i1111I
 if 63 - 63: OooOoo % IIiIIiIi11I1
 if 6 - 6: ooo000 * Oo
 if 17 - 17: OooOoo % i1I - IIiIIiIi11I1
 if 52 - 52: ooOOO
 if 6 - 6: Oo - oOO
 if 89 - 89: Oo . Iii1i
 if 7 - 7: ooOOO * IiIIii11Ii % i1iiIII111 / Ii + Iii1i
 if 96 - 96: IiIIii11Ii / Oo * oOO * IiI11Ii111 % ooOOO / i1iiIII111
 if 64 - 64: i1I + iI1iII1I1I1i + i1I % iI1iII1I1I1i
 if 80 - 80: i1I - i1i1i1111I
 if 11 - 11: i1i1i1111I * ooOOO - ooo000 - ooo000
 if 86 - 86: I1Ii1I1 / Ooo0Ooo - i1i1i1111I / oOO % IiI11Ii111 / iI1iII1I1I1i
 if 65 - 65: ooo000 - OooOoo % IiIIii11Ii + oOo0O00 % i1iiIII111 % i1i1i1111I
 if 51 - 51: Ooo0Ooo / i1iiIII111 / i1iiIII111 - oOo0O00
 if 89 - 89: i1iiIII111 + oOo0O00 / IiIIii11Ii . Oo + Ooo0Ooo
 def ooo00oO ( x , kernel , activation , se_ratio ) :
  if 69 - 69: Oo / ooOOO
  if 23 - 23: oOo0O00
  if 60 - 60: i1 * I11iiIi11i1I
  if 5 - 5: iI1iII1I1I1i / Ii
  if 42 - 42: ooOOO + I1Ii1I1 . IIiIIiIi11I1
  if 38 - 38: I1Ii1I1
  if 33 - 33: Iii1i / i1iiIII111
  if 68 - 68: I1Ii1I1 * IIiIIiIi11I1 . Iii1i % ooOOO * OooOoo
  if 50 - 50: Oo - i1 * iI1iII1I1I1i - I1I - I11iiIi11i1I + IiIIii11Ii
  if 17 - 17: OooOoo + i1iiIII111 % Iii1i % Oo / OooOoo
  if 4 - 4: i1
  if 95 - 95: IIiIIiIi11I1 * IiI11Ii111
  if 51 - 51: IiIIii11Ii + ooo000 % I1Ii1I1 + i1i1i1111I . IIiIIiIi11I1
  if 63 - 63: Iii1i % I1Ii1I1 . Oo % i1iiIII111 . I1I % IiI11Ii111
  if 3 - 3: ooo000 . oOo0O00
  if 92 - 92: ooo000
  def oO0oIII1 ( d ) :
   if 64 - 64: I1Ii1I1 . i1i1i1111I * i1I + IiI11Ii111 / iI1iII1I1I1i . I11iiIi11i1I
   if 25 - 25: Oo . iI1iII1I1I1i . iI1iII1I1I1i
   if 86 - 86: Iii1i + OooOoo
   if 16 - 16: i1I
   if 70 - 70: I1I % Ooo0Ooo . Iii1i
   if 66 - 66: I11iiIi11i1I / OooOoo * IiI11Ii111
   if 12 - 12: I1I + i1I
   if 100 - 100: Oo . IIiIIiIi11I1 % OooOoo
   if 60 - 60: IiI11Ii111 / i1 / i1i1i1111I
   if 60 - 60: i1i1i1111I - Ooo0Ooo / I1I
   if 15 - 15: IiIIii11Ii
   if 76 - 76: IiI11Ii111 * IiIIii11Ii + IiI11Ii111 + i1i1i1111I
   if 95 - 95: Ii % oOO % i1iiIII111 + IIiIIiIi11I1
   return oO0Oo0OOo0 ( d * depth_multiplier )
   if 51 - 51: Oo + Ooo0Ooo
  x = Ii11ii1I11 ( x , 1 , oO0oIII1 ( 16 ) , 3 , 1 , None , iIiiiI1I1iII1 , 0 )
  x = Ii11ii1I11 ( x , 4 , oO0oIII1 ( 24 ) , 3 , 2 , None , iIiiiI1I1iII1 , 1 )
  x = Ii11ii1I11 ( x , 3 , oO0oIII1 ( 24 ) , 3 , 1 , None , iIiiiI1I1iII1 , 2 )
  x = Ii11ii1I11 ( x , 3 , oO0oIII1 ( 40 ) , kernel , 2 , se_ratio , iIiiiI1I1iII1 , 3 )
  x = Ii11ii1I11 ( x , 3 , oO0oIII1 ( 40 ) , kernel , 1 , se_ratio , iIiiiI1I1iII1 , 4 )
  x = Ii11ii1I11 ( x , 3 , oO0oIII1 ( 40 ) , kernel , 1 , se_ratio , iIiiiI1I1iII1 , 5 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 80 ) , 3 , 2 , None , activation , 6 )
  x = Ii11ii1I11 ( x , 2.5 , oO0oIII1 ( 80 ) , 3 , 1 , None , activation , 7 )
  x = Ii11ii1I11 ( x , 2.3 , oO0oIII1 ( 80 ) , 3 , 1 , None , activation , 8 )
  x = Ii11ii1I11 ( x , 2.3 , oO0oIII1 ( 80 ) , 3 , 1 , None , activation , 9 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 112 ) , 3 , 1 , se_ratio , activation , 10 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 112 ) , 3 , 1 , se_ratio , activation , 11 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 160 ) , kernel , 2 , se_ratio , activation , 12 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 160 ) , kernel , 1 , se_ratio , activation , 13 )
  x = Ii11ii1I11 ( x , 6 , oO0oIII1 ( 160 ) , kernel , 1 , se_ratio , activation , 14 )
  return x
  if 24 - 24: Oo / ooOOO - Iii1i
 return o0o0ii ( ooo00oO , 1280 , input_shape = input_shape , depth_multiplier = depth_multiplier , model_type = 'large' , minimalistic = minimalistic , classes = classes , dropout_rate = dropout_rate )
 if 83 - 83: I1I * iI1iII1I1I1i
def o0o0ii ( stack_fn ,
 last_point_ch ,
 input_shape = None ,
 depth_multiplier = 1.0 ,
 model_type = "large" ,
 minimalistic = False ,
 classes = 10 ,
 dropout_rate = 0.2 ) :
 if 30 - 30: Ii / ooOOO * iI1iII1I1I1i + Oo + OooOoo
 if 79 - 79: Iii1i - i1 * IIiIIiIi11I1 - Iii1i % i1iiIII111
 if 34 - 34: i1 + i1i1i1111I
 if 61 - 61: OooOoo . iI1iII1I1I1i - I1Ii1I1 - iI1iII1I1I1i . I11iiIi11i1I * oOO
 if 84 - 84: OooOoo * iI1iII1I1I1i % OooOoo % ooo000
 if 44 - 44: Ii
 if 81 - 81: I1Ii1I1 . I1I
 if 48 - 48: i1 % Ooo0Ooo - I1Ii1I1
 if 41 - 41: ooo000 % IIiIIiIi11I1
 if 15 - 15: OooOoo / i1I / I1I + OooOoo . i1i1i1111I
 if 44 - 44: IiIIii11Ii % OooOoo / I1I
 if 76 - 76: Oo / IiI11Ii111 + i1i1i1111I * IiIIii11Ii . i1i1i1111I * oOO
 if 94 - 94: IIiIIiIi11I1 . IIiIIiIi11I1 % OooOoo
 if 21 - 21: Ii . oOO * Oo % I11iiIi11i1I % iI1iII1I1I1i
 if 2 - 2: oOO % Ii + Ii . I11iiIi11i1I / oOO
 if 81 - 81: Oo . i1 * Ii / ooo000 / Iii1i
 if 73 - 73: I1I . IIiIIiIi11I1 / i1I + ooo000
 if 10 - 10: i1I - Iii1i
 if 58 - 58: I11iiIi11i1I * Ii
 if 61 - 61: oOo0O00 / Ooo0Ooo + ooo000 % Iii1i % i1I
 if minimalistic :
  iii1 = 3
  I111111iIII = iIiiiI1I1iII1
  i1i1I1iiI = None
 else :
  iii1 = 5
  I111111iIII = iIi1
  i1i1I1iiI = 0.25
  if 7 - 7: i1I % I11iiIi11i1I - Ii
 ooO = layers . Input ( shape = input_shape )
 if 43 - 43: Oo . ooOOO + i1
 OOoo00ooOo00O = layers . ZeroPadding2D ( padding = I1I1iIiIi1ii ( backend , ooO , 3 ) , name = 'Conv_pad' ) ( ooO )
 OOoo00ooOo00O = layers . Conv2D ( 16 , kernel_size = 3 , strides = ( 2 , 2 ) , padding = 'valid' , use_bias = False , name = 'Conv' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = 'Conv/BatchNorm' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Activation ( I111111iIII ) ( OOoo00ooOo00O )
 if 1 - 1: Oo
 OOoo00ooOo00O = stack_fn ( OOoo00ooOo00O , iii1 , I111111iIII , i1i1I1iiI )
 if 9 - 9: IIiIIiIi11I1 - IiIIii11Ii . OooOoo . i1i1i1111I * IIiIIiIi11I1 . i1iiIII111
 II1I1 = oO0Oo0OOo0 ( backend . int_shape ( OOoo00ooOo00O ) [ - 1 ] * 6 )
 if 22 - 22: Ooo0Ooo / I1I + IiIIii11Ii - oOO + IiI11Ii111 + Oo
 if depth_multiplier > 1.0 :
  last_point_ch = oO0Oo0OOo0 ( last_point_ch * depth_multiplier )
  if 17 - 17: I1Ii1I1 % oOo0O00 - oOo0O00 / i1i1i1111I % I11iiIi11i1I + i1iiIII111
 OOoo00ooOo00O = layers . Conv2D ( II1I1 , kernel_size = 1 , padding = 'same' , use_bias = False , name = 'Conv_1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = 'Conv_1/BatchNorm' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Activation ( I111111iIII ) ( OOoo00ooOo00O )
 if 80 - 80: I11iiIi11i1I . oOo0O00 % i1iiIII111 - oOO
 OOoo00ooOo00O = layers . GlobalAveragePooling2D ( ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Reshape ( ( 1 , 1 , II1I1 ) ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Conv2D ( last_point_ch , kernel_size = 1 , padding = 'same' , name = 'Conv_2' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Activation ( I111111iIII ) ( OOoo00ooOo00O )
 if 44 - 44: iI1iII1I1I1i * IiI11Ii111 / oOO
 if dropout_rate > 0 :
  OOoo00ooOo00O = layers . Dropout ( dropout_rate ) ( OOoo00ooOo00O )
  if 73 - 73: Iii1i * i1i1i1111I
 OOoo00ooOo00O = layers . Conv2D ( classes , kernel_size = 1 , padding = 'same' , name = 'Logits' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Flatten ( ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Softmax ( name = 'Predictions/Softmax' ) ( OOoo00ooOo00O )
 if 55 - 55: I1Ii1I1
 O0i1I1iiI = models . Model ( ooO , OOoo00ooOo00O , name = "MobilenetV3" + model_type )
 return O0i1I1iiI
 if 61 - 61: oOo0O00 / ooo000 / I11iiIi11i1I / i1i1i1111I . i1iiIII111
def iIiiiI1I1iII1 ( x ) :
 if 3 - 3: Ooo0Ooo . i1I % I1I / OooOoo
 if 100 - 100: IIiIIiIi11I1
 if 15 - 15: ooOOO
 if 49 - 49: I1I + i1i1i1111I . IIiIIiIi11I1 + Ii
 if 43 - 43: Ii - ooOOO . i1
 if 85 - 85: OooOoo
 if 99 - 99: ooo000 * IiI11Ii111 - i1I * Oo
 if 86 - 86: ooOOO / Iii1i + OooOoo + oOO * i1
 if 17 - 17: Iii1i / IiI11Ii111 . i1iiIII111
 if 35 - 35: Ii
 if 66 - 66: IiI11Ii111 / IiI11Ii111 - Ooo0Ooo
 if 61 - 61: OooOoo + i1 - i1 * I1I
 if 16 - 16: IiIIii11Ii / Ooo0Ooo
 return layers . ReLU ( ) ( x )
 if 24 - 24: I1Ii1I1
def O00 ( x ) :
 if 40 - 40: i1iiIII111
 if 48 - 48: Ooo0Ooo
 if 86 - 86: IiI11Ii111 * iI1iII1I1I1i
 if 60 - 60: i1i1i1111I % ooo000
 if 16 - 16: i1I - ooOOO / Ooo0Ooo % iI1iII1I1I1i . ooo000 + ooOOO
 if 71 - 71: I11iiIi11i1I * Ii / i1I - i1iiIII111
 if 94 - 94: Ii / i1iiIII111 - Iii1i - ooo000 + oOO + I1I
 if 86 - 86: i1iiIII111 . Ii / IIiIIiIi11I1 / Ooo0Ooo
 if 25 - 25: IIiIIiIi11I1 . I11iiIi11i1I + Ooo0Ooo . ooOOO - Oo / OooOoo
 if 16 - 16: I1Ii1I1 % OooOoo - i1I + iI1iII1I1I1i - oOo0O00 / IIiIIiIi11I1
 if 41 - 41: Oo * IIiIIiIi11I1
 if 72 - 72: i1i1i1111I * ooOOO - iI1iII1I1I1i
 if 94 - 94: ooo000 * IiI11Ii111 . Oo
 return layers . ReLU ( 6. ) ( x + 3. ) * ( 1. / 6. )
 if 43 - 43: IiIIii11Ii * Oo + iI1iII1I1I1i + IiI11Ii111
def iIi1 ( x ) :
 if 55 - 55: ooOOO
 if 97 - 97: I1Ii1I1 % i1
 if 36 - 36: oOO * I1Ii1I1
 if 8 - 8: I11iiIi11i1I - Ooo0Ooo % OooOoo / i1iiIII111 / i1
 if 36 - 36: OooOoo / i1 . OooOoo * oOO * oOO - IIiIIiIi11I1
 if 89 - 89: IIiIIiIi11I1 * I1Ii1I1 / i1I + i1I % ooo000
 if 7 - 7: i1 % oOo0O00 % IiIIii11Ii - IiIIii11Ii % IiI11Ii111
 if 65 - 65: oOo0O00 / i1 + I11iiIi11i1I / Oo . IiI11Ii111
 if 33 - 33: IiI11Ii111 . IiIIii11Ii + iI1iII1I1I1i . i1I - Oo . IIiIIiIi11I1
 if 10 - 10: I11iiIi11i1I + ooOOO % i1I
 if 94 - 94: IiIIii11Ii . ooo000 / OooOoo
 if 31 - 31: Iii1i * Ooo0Ooo - I1Ii1I1 % Ooo0Ooo
 if 30 - 30: Iii1i + I11iiIi11i1I - i1iiIII111 * i1I
 return layers . Multiply ( ) ( [ layers . Activation ( O00 ) ( x ) , x ] )
 if 56 - 56: IiIIii11Ii - i1i1i1111I / i1iiIII111
def oO0Oo0OOo0 ( v , divisor = 8 , min_value = None ) :
 if 62 - 62: oOO + IiI11Ii111
 if 43 - 43: ooo000 * ooOOO + oOo0O00 - I1I
 if 77 - 77: i1I % IiI11Ii111 - Iii1i / iI1iII1I1I1i * Iii1i
 if 1 - 1: Ooo0Ooo - Ii - IiIIii11Ii
 if 88 - 88: Ooo0Ooo / Oo
 if 18 - 18: Oo - Iii1i / i1iiIII111
 if 21 - 21: ooo000
 if 35 - 35: i1I . IiI11Ii111 . i1i1i1111I * iI1iII1I1I1i * Iii1i * ooo000
 if 56 - 56: i1iiIII111 / I11iiIi11i1I + Oo % Iii1i * I1Ii1I1
 if 92 - 92: Oo
 if 34 - 34: i1I . i1iiIII111 . oOO + ooo000 . I1I - I11iiIi11i1I
 if 28 - 28: i1I % iI1iII1I1I1i
 if 1 - 1: I11iiIi11i1I % i1iiIII111 / Ooo0Ooo
 if 31 - 31: IIiIIiIi11I1 - Ii
 if 28 - 28: i1I . OooOoo / I11iiIi11i1I % IIiIIiIi11I1
 if min_value is None :
  min_value = divisor
 O0OO0o = max ( min_value , int ( v + divisor / 2 ) // divisor * divisor )
 if 44 - 44: iI1iII1I1I1i + Ooo0Ooo
 if O0OO0o < 0.9 * v :
  O0OO0o += divisor
 return O0OO0o
 if 70 - 70: I1Ii1I1 + ooOOO - iI1iII1I1I1i / IiI11Ii111
def OOoOOooOo0oO0 ( inputs , filters , se_ratio , prefix ) :
 if 35 - 35: i1iiIII111 % oOO % ooo000 / oOo0O00 / i1I * oOo0O00
 if 84 - 84: Ii % I1I + iI1iII1I1I1i
 if 47 - 47: ooOOO * IiI11Ii111 % ooOOO . i1iiIII111 % Oo * i1i1i1111I
 if 91 - 91: Iii1i . Iii1i . oOO
 if 79 - 79: iI1iII1I1I1i % I1Ii1I1 * i1I - Iii1i * IiI11Ii111 + oOo0O00
 if 58 - 58: I1I
 if 64 - 64: OooOoo % ooo000
 if 89 - 89: i1I - IiI11Ii111 + i1i1i1111I % I11iiIi11i1I
 if 26 - 26: Iii1i * i1I / IIiIIiIi11I1 + i1
 if 91 - 91: I1Ii1I1
 if 97 - 97: ooOOO + IIiIIiIi11I1 % IIiIIiIi11I1 . Oo + i1I + IIiIIiIi11I1
 if 54 - 54: Ii + OooOoo . ooo000 % IIiIIiIi11I1
 if 33 - 33: Ooo0Ooo . iI1iII1I1I1i . i1i1i1111I / I11iiIi11i1I % Ii + ooOOO
 OOoo00ooOo00O = layers . GlobalAveragePooling2D ( name = prefix + 'squeeze_excite/AvgPool' ) ( inputs )
 OOoo00ooOo00O = layers . Reshape ( ( 1 , 1 , filters ) ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Conv2D ( oO0Oo0OOo0 ( filters * se_ratio ) , kernel_size = 1 , padding = 'same' , name = prefix + 'squeeze_excite/Conv' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . ReLU ( name = prefix + 'squeeze_excite/Relu' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Conv2D ( filters , kernel_size = 1 , padding = 'same' , name = prefix + 'squeeze_excite/Conv_1' ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Activation ( O00 ) ( OOoo00ooOo00O )
 OOoo00ooOo00O = layers . Multiply ( name = prefix + 'squeeze_excite/Mul' ) ( [ inputs , OOoo00ooOo00O ] )
 return OOoo00ooOo00O
 if 61 - 61: OooOoo % IiIIii11Ii + Ooo0Ooo - I1Ii1I1 . oOO
def Ii11ii1I11 ( x , expansion , filters , kernel_size , stride , se_ratio , activation , block_id ) :
 if 81 - 81: Ii + I11iiIi11i1I
 if 20 - 20: iI1iII1I1I1i * OooOoo * oOo0O00 - ooo000 . oOo0O00
 if 64 - 64: oOO
 if 68 - 68: ooOOO . i1I + Ooo0Ooo . Iii1i
 if 62 - 62: Iii1i / IIiIIiIi11I1 / IiIIii11Ii * oOO * i1I - ooOOO
 if 25 - 25: Iii1i * IiIIii11Ii
 if 6 - 6: Ii
 if 100 - 100: ooOOO * I1I * i1iiIII111 - Ooo0Ooo % Iii1i
 if 63 - 63: IiIIii11Ii + I1Ii1I1 + I1Ii1I1
 if 28 - 28: Iii1i - Ooo0Ooo
 if 99 - 99: ooOOO % oOo0O00 / OooOoo - Ooo0Ooo % i1 % I1Ii1I1
 if 14 - 14: i1I / i1I * IiIIii11Ii
 if 74 - 74: iI1iII1I1I1i . Ii * I11iiIi11i1I % IiIIii11Ii
 if 35 - 35: Oo * I11iiIi11i1I % Ooo0Ooo / IiI11Ii111 + Iii1i
 if 87 - 87: i1i1i1111I + I1Ii1I1 * oOo0O00 + OooOoo - oOo0O00
 if 55 - 55: Ii / I1I
 if 39 - 39: oOo0O00 % i1I . ooOOO
 i1Ii11III1 = x
 iiIi1II = 'expanded_conv/'
 OoOO0Oo00Ooo = backend . int_shape ( x ) [ - 1 ]
 if 97 - 97: Ii * IiI11Ii111 - IIiIIiIi11I1 + Ii * Oo - i1
 if block_id :
  if 3 - 3: Iii1i % I11iiIi11i1I / I11iiIi11i1I - I1Ii1I1 + OooOoo - ooOOO
  iiIi1II = 'expanded_conv_{}/' . format ( block_id )
  x = layers . Conv2D ( oO0Oo0OOo0 ( OoOO0Oo00Ooo * expansion ) , kernel_size = 1 , padding = 'same' , use_bias = False , name = iiIi1II + 'expand' ) ( x )
  x = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = iiIi1II + 'expand/BatchNorm' ) ( x )
  x = layers . Activation ( activation ) ( x )
  if 40 - 40: Ooo0Ooo
 if stride == 2 :
  x = layers . ZeroPadding2D ( padding = I1I1iIiIi1ii ( backend , x , kernel_size ) , name = iiIi1II + 'depthwise/pad' ) ( x )
  if 73 - 73: IiIIii11Ii / i1i1i1111I * IIiIIiIi11I1
 x = layers . DepthwiseConv2D ( kernel_size , strides = stride , padding = 'same' if stride == 1 else 'valid' , use_bias = False , name = iiIi1II + 'depthwise' ) ( x )
 x = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = iiIi1II + 'depthwise/BatchNorm' ) ( x )
 x = layers . Activation ( activation ) ( x )
 if 11 - 11: Oo . I11iiIi11i1I % OooOoo / i1i1i1111I
 if se_ratio :
  x = OOoOOooOo0oO0 ( x , oO0Oo0OOo0 ( OoOO0Oo00Ooo * expansion ) , se_ratio , iiIi1II )
  if 32 - 32: iI1iII1I1I1i
 x = layers . Conv2D ( filters , kernel_size = 1 , padding = 'same' , use_bias = False , name = iiIi1II + 'project' ) ( x )
 x = layers . BatchNormalization ( epsilon = 1e-3 , momentum = 0.999 , name = iiIi1II + 'project/BatchNorm' ) ( x )
 if 19 - 19: i1i1i1111I - I1I
 if stride == 1 and OoOO0Oo00Ooo == filters :
  x = layers . Add ( name = iiIi1II + 'Add' ) ( [ i1Ii11III1 , x ] )
  if 17 - 17: Ii % Ii . IiI11Ii111 . IiI11Ii111 + Iii1i + I11iiIi11i1I
 return x
 if 82 - 82: ooOOO - IiIIii11Ii % I1I . ooOOO / iI1iII1I1I1i - Iii1i
def I1I1iIiIi1ii ( backend , inputs , kernel_size ) :
 if 48 - 48: I1I - ooOOO - oOo0O00 . Ii
 if 23 - 23: IiI11Ii111 - IiIIii11Ii
 if 55 - 55: Iii1i * IiI11Ii111
 if 35 - 35: ooo000 + oOO . OooOoo . I11iiIi11i1I % OooOoo
 if 28 - 28: oOO % I1I + IIiIIiIi11I1 - Oo / i1i1i1111I
 if 66 - 66: i1i1i1111I * oOO
 if 89 - 89: IIiIIiIi11I1 . i1 + Ii
 if 80 - 80: I1Ii1I1 - Iii1i * I11iiIi11i1I + ooo000 * Oo % oOO
 if 20 - 20: ooOOO
 if 10 - 10: OooOoo % i1iiIII111
 if 6 - 6: oOO % i1 * i1i1i1111I / ooOOO
 if 90 - 90: ooOOO * Ooo0Ooo + oOO * Ooo0Ooo * i1i1i1111I / oOo0O00
 if 53 - 53: Iii1i - i1i1i1111I + IiIIii11Ii . Ooo0Ooo . Ooo0Ooo
 if 75 - 75: I1I + OooOoo % i1i1i1111I
 if 69 - 69: Oo
 II1111iI = 2 if backend . image_data_format ( ) == 'channels_first' else 1
 IIo0 = backend . int_shape ( inputs ) [ II1111iI : ( II1111iI + 2 ) ]
 if 72 - 72: I1Ii1I1 % I1Ii1I1
 if isinstance ( kernel_size , int ) :
  kernel_size = ( kernel_size , kernel_size )
  if 24 - 24: Oo / Iii1i * Oo / OooOoo + I1I
 if IIo0 [ 0 ] is None :
  OO0iiII = ( 1 , 1 )
 else :
  OO0iiII = ( 1 - IIo0 [ 0 ] % 2 , 1 - IIo0 [ 1 ] % 2 )
  if 12 - 12: IiI11Ii111 - I11iiIi11i1I . Ii + ooo000
 oO0OooooOoO = ( kernel_size [ 0 ] // 2 , kernel_size [ 1 ] // 2 )
 if 15 - 15: I11iiIi11i1I % Ii - I1I
 return ( ( oO0OooooOoO [ 0 ] - OO0iiII [ 0 ] , oO0OooooOoO [ 0 ] ) ,
 ( oO0OooooOoO [ 1 ] - OO0iiII [ 1 ] , oO0OooooOoO [ 1 ] ) )
 if 58 - 58: ooOOO * IiIIii11Ii + Ooo0Ooo - iI1iII1I1I1i * Ooo0Ooo
class NOMModel :
 if 24 - 24: i1 * i1I
 if 39 - 39: oOO - Ii . IiIIii11Ii . Ooo0Ooo . Oo - IiIIii11Ii
 if 49 - 49: I1I - oOO - i1iiIII111 * I11iiIi11i1I - Ii % i1i1i1111I
 if 5 - 5: IiI11Ii111 * IIiIIiIi11I1 % ooOOO / I1Ii1I1 % IiI11Ii111
 if 7 - 7: Iii1i + IIiIIiIi11I1 + I1I
 if 17 - 17: ooo000 - Ii / Ooo0Ooo + IiIIii11Ii / i1I * iI1iII1I1I1i
 if 19 - 19: IIiIIiIi11I1 / Iii1i
 MobileNet_V1 = o0o0
 MobileNet_V2 = iiIi1Ii
 MobileNet_V3_Small = iIIiIII1Ii1i
 MobileNet_V3_Large = oO00
 AttentionNet = Ii11
 if 75 - 75: ooOOO
class O0 :
 if 40 - 40: oOO * I11iiIi11i1I
 if 33 - 33: I1I % Ooo0Ooo . Iii1i
 if 37 - 37: Ii - Oo % I1I / IIiIIiIi11I1 . iI1iII1I1I1i
 if 22 - 22: OooOoo * OooOoo % iI1iII1I1I1i % IiIIii11Ii
 if 7 - 7: i1 + OooOoo * I11iiIi11i1I
 if 18 - 18: IiIIii11Ii % I11iiIi11i1I * Ii
 if 18 - 18: iI1iII1I1I1i + IiI11Ii111 - oOO % I11iiIi11i1I + I1I % IiI11Ii111
 def __init__ ( self , name : str = "" ) :
  if 62 - 62: Oo + Iii1i
  if 69 - 69: Ooo0Ooo - i1i1i1111I + I1Ii1I1 - oOO % i1iiIII111
  if 88 - 88: oOO . IiIIii11Ii % i1iiIII111
  if 30 - 30: IiIIii11Ii + ooOOO / I1Ii1I1 + I11iiIi11i1I / IiIIii11Ii
  if 22 - 22: oOo0O00
  if 53 - 53: i1i1i1111I
  if 92 - 92: Ii
  if 93 - 93: IiI11Ii111 + iI1iII1I1I1i * i1I
  if 96 - 96: I1Ii1I1 + i1 / Oo + OooOoo / I1Ii1I1 + Ooo0Ooo
  if 89 - 89: IiI11Ii111 % oOO
  if 78 - 78: ooo000 / Oo + IiIIii11Ii % i1iiIII111 - ooOOO * IiIIii11Ii
  self . _instanceClass : I1ooOoO0OooO = I1ooOoO0OooO . Config
  if 89 - 89: i1 . ooo000 + Oo - IiI11Ii111
  if 64 - 64: IiI11Ii111 % ooo000
  self . name : str = name
  if 34 - 34: IIiIIiIi11I1
  if 97 - 97: i1iiIII111 * Iii1i - iI1iII1I1I1i - IiI11Ii111
  self . splittable : bool = False
  if 34 - 34: I1Ii1I1 . Ii . OooOoo / I11iiIi11i1I + ooo000
  if 49 - 49: Iii1i - I1Ii1I1
  self . _train = None
  if 11 - 11: I11iiIi11i1I % Iii1i - i1i1i1111I % OooOoo
  if 91 - 91: iI1iII1I1I1i - IIiIIiIi11I1 . oOO / OooOoo
  self . generatorController : I111II1II111I . Controller = None
  if 28 - 28: IiI11Ii111 - IIiIIiIi11I1
  if 13 - 13: I1Ii1I1 . IIiIIiIi11I1
  self . outputsetInfo : Dict [ str , IiiIii1I1iIiII ] = { }
  if 23 - 23: I1Ii1I1 + oOO . ooo000 * Ii
  if 5 - 5: IiI11Ii111 . Oo
  self . _propagateDppNodes : Set [ str ] = set ( )
  if 20 - 20: i1i1i1111I + oOo0O00 - iI1iII1I1I1i + Ooo0Ooo % oOO % I1Ii1I1
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 33 - 33: i1 % I1I / i1i1i1111I * ooOOO - oOO
  if 91 - 91: I11iiIi11i1I * ooOOO - Oo
  if 48 - 48: I1I . Oo
  if 39 - 39: oOo0O00 + I11iiIi11i1I * I11iiIi11i1I * Iii1i
  if 49 - 49: IIiIIiIi11I1
  if 39 - 39: I11iiIi11i1I / ooo000 / IiI11Ii111 - oOo0O00
  if 63 - 63: I11iiIi11i1I
  if 27 - 27: IiI11Ii111 + I11iiIi11i1I % IiIIii11Ii
  if 49 - 49: OooOoo - IiIIii11Ii + i1
  if 94 - 94: IiIIii11Ii + ooo000 + i1iiIII111 . i1I
  if 97 - 97: I1I / I11iiIi11i1I
  pass
  if 75 - 75: i1iiIII111 / Ooo0Ooo . Oo % Iii1i / oOO - i1
 @ property
 def instanceClass ( self ) -> 'Source.Types' :
  if 14 - 14: I1Ii1I1 * OooOoo % i1iiIII111 % i1 . i1i1i1111I + I1I
  if 43 - 43: IIiIIiIi11I1 . Ii * iI1iII1I1I1i - IiIIii11Ii . i1i1i1111I
  if 41 - 41: oOO + ooo000
  if 24 - 24: IIiIIiIi11I1
  if 5 - 5: I11iiIi11i1I
  if 61 - 61: I1I . I1Ii1I1 * i1I % Oo . Oo
  if 15 - 15: I1Ii1I1 * iI1iII1I1I1i * oOO % oOo0O00 * Ii
  if 48 - 48: OooOoo % i1 - IiIIii11Ii + IiI11Ii111 % ooo000 % IiIIii11Ii
  if 91 - 91: i1I % i1I % Ii / IiIIii11Ii % I11iiIi11i1I
  if 24 - 24: i1iiIII111 + I1I . Oo
  return self . _instanceClass
  if 56 - 56: IIiIIiIi11I1 . i1
 @ property
 def sourceID ( self ) -> int :
  if 27 - 27: i1I % i1iiIII111 % iI1iII1I1I1i
  if 81 - 81: OooOoo . I1Ii1I1 * IiIIii11Ii
  if 26 - 26: i1I - oOo0O00 % OooOoo % oOO
  if 19 - 19: i1i1i1111I + ooOOO . Iii1i / iI1iII1I1I1i * Ii . i1i1i1111I
  if 96 - 96: Ooo0Ooo + i1 / Oo % Ii % IIiIIiIi11I1 * IiIIii11Ii
  if 90 - 90: ooo000 - ooOOO * IiI11Ii111 + I1Ii1I1 / i1I / I1I
  if 25 - 25: IIiIIiIi11I1
  if 40 - 40: OooOoo / oOO
  if 78 - 78: Ii . oOo0O00
  if 74 - 74: Ii % i1I - ooOOO + Ooo0Ooo . I1I
  return self . train . sources . index ( self )
  if 60 - 60: I1I . Ooo0Ooo
 @ property
 def oriShape ( self ) -> List [ int ] :
  if 56 - 56: Oo * IiIIii11Ii * I1Ii1I1 % oOO * I1Ii1I1 / ooOOO
  if 76 - 76: I11iiIi11i1I / IiIIii11Ii / IiI11Ii111 - iI1iII1I1I1i
  if 13 - 13: IiI11Ii111 % iI1iII1I1I1i . IiIIii11Ii + oOo0O00
  if 12 - 12: Ii / I11iiIi11i1I
  if 14 - 14: i1i1i1111I * i1 . Iii1i
  if 5 - 5: Ii
  if 96 - 96: i1I % IiI11Ii111 * Oo
  if 14 - 14: i1 + OooOoo + ooOOO
  if 74 - 74: i1i1i1111I + ooo000 + I1I . oOo0O00 + ooo000 - I1I
  if 73 - 73: iI1iII1I1I1i
  return self . generatorController [ I111II1II111I . Dataset . Types . Train ] . oriShape
  if 25 - 25: i1iiIII111 - i1iiIII111 - Ooo0Ooo * i1I . i1i1i1111I
 def __len__ ( self ) -> int :
  if 12 - 12: oOo0O00 % i1I
  if 1 - 1: Ii * OooOoo . IIiIIiIi11I1
  if 18 - 18: Oo * IIiIIiIi11I1 % IiIIii11Ii
  if 4 - 4: oOO % iI1iII1I1I1i
  if 26 - 26: i1i1i1111I % iI1iII1I1I1i
  if 34 - 34: IiI11Ii111 + IiIIii11Ii % Ooo0Ooo
  if 24 - 24: iI1iII1I1I1i + iI1iII1I1I1i - iI1iII1I1I1i * oOO
  if 98 - 98: i1i1i1111I / I11iiIi11i1I
  if 96 - 96: I1I - iI1iII1I1I1i / ooo000 / i1iiIII111
  if 56 - 56: I1I % I1Ii1I1 - Ii . i1iiIII111 + ooo000 . IiIIii11Ii
  return len ( self . generatorController [ self . train . currentSourceDataset ] )
  if 46 - 46: i1iiIII111 . IIiIIiIi11I1 . oOO * OooOoo * iI1iII1I1I1i
 @ property
 def epochSize ( self ) -> int :
  if 30 - 30: i1iiIII111 * Ii
  if 24 - 24: oOo0O00
  if 21 - 21: IIiIIiIi11I1
  if 18 - 18: IiI11Ii111
  if 77 - 77: I11iiIi11i1I % i1 / iI1iII1I1I1i * OooOoo / ooOOO
  if 17 - 17: I1I / ooOOO + OooOoo * Ii % iI1iII1I1I1i
  if 16 - 16: i1 / Iii1i
  if 21 - 21: Iii1i / IIiIIiIi11I1 . OooOoo
  if 29 - 29: oOO + ooOOO
  if 35 - 35: Ii + Oo + I1I
  return self . generatorController [ self . train . currentSourceDataset ] . epochSize
  if 85 - 85: oOO + iI1iII1I1I1i % IiIIii11Ii . i1iiIII111
 def getEpochSize ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> int :
  if 33 - 33: Ii . iI1iII1I1I1i + I1Ii1I1 * OooOoo + i1I
  if 84 - 84: IiI11Ii111 + Ii / i1I
  if 90 - 90: I1Ii1I1 % I1I / OooOoo * IiIIii11Ii . I1I
  if 86 - 86: I1Ii1I1 % I1I
  if 32 - 32: i1i1i1111I . I11iiIi11i1I
  if 54 - 54: ooo000 . ooo000 / oOo0O00 * ooo000 + i1I . I11iiIi11i1I
  if 6 - 6: iI1iII1I1I1i % i1i1i1111I / i1 . oOO
  if 39 - 39: Ii * Ii + I1Ii1I1 / IIiIIiIi11I1
  if 34 - 34: Iii1i / Ii * i1 * I1Ii1I1 % IiI11Ii111
  if 93 - 93: i1 + i1 - i1i1i1111I
  if 45 - 45: i1 - Ii - oOO / oOO * iI1iII1I1I1i + iI1iII1I1I1i
  if 17 - 17: Iii1i - I1I / ooo000 / Ooo0Ooo . IiIIii11Ii / i1I
  if 73 - 73: IiI11Ii111 % ooo000 . Iii1i - i1 / Oo * iI1iII1I1I1i
  if sourceDataset is None :
   sourceDataset = self . train . currentSourceDataset
   if 99 - 99: I11iiIi11i1I . Iii1i . i1iiIII111
  return self . generatorController [ sourceDataset ] . epochSize
  if 32 - 32: Oo / I1Ii1I1 - OooOoo
 @ property
 def shuffle ( self ) -> bool :
  if 74 - 74: OooOoo + Oo / i1I . I11iiIi11i1I
  if 93 - 93: ooOOO + i1i1i1111I - i1 / ooOOO
  if 11 - 11: I1Ii1I1 . Oo % ooo000 * ooo000 % Ii
  if 49 - 49: I1I + Ooo0Ooo
  if 94 - 94: I1I
  if 85 - 85: I11iiIi11i1I . I11iiIi11i1I + I11iiIi11i1I - IIiIIiIi11I1 - IIiIIiIi11I1
  if 60 - 60: i1i1i1111I
  if 4 - 4: i1I . I1I / I1Ii1I1 * iI1iII1I1I1i . ooo000
  if 24 - 24: I1I - ooo000 . IiI11Ii111
  if 48 - 48: oOO / i1I + i1i1i1111I * ooo000
  if self . train is None :
   raise ValueError ( "This source is not attached to a Train object yet. No shuffle can be determined." )
   if 79 - 79: IiIIii11Ii
  return self . train . buildConfigs [ self . train . buildNo ] . shuffle
  if 70 - 70: Iii1i / i1i1i1111I % Iii1i . Ooo0Ooo / iI1iII1I1I1i - i1iiIII111
 @ property
 def batchSize ( self ) -> int :
  if 69 - 69: oOO
  if 24 - 24: i1 / iI1iII1I1I1i - IiI11Ii111 % iI1iII1I1I1i
  if 100 - 100: IiI11Ii111 * I1I * IiIIii11Ii . IiI11Ii111 % I1I * ooo000
  if 42 - 42: I11iiIi11i1I + I11iiIi11i1I + I11iiIi11i1I - i1iiIII111
  if 70 - 70: i1 * I1Ii1I1 * IIiIIiIi11I1 + oOo0O00
  if 40 - 40: oOO / iI1iII1I1I1i
  if 90 - 90: ooOOO / Oo
  if 98 - 98: i1I / i1I / IiI11Ii111
  if 86 - 86: i1i1i1111I
  if 74 - 74: I11iiIi11i1I - Ooo0Ooo * Oo / i1 . IiIIii11Ii - IiI11Ii111
  if self . train is None :
   raise ValueError ( "This source is not attached to a Train object yet. No batch size can be determined." )
   if 55 - 55: oOO % I1Ii1I1 - Ii
  return self . train . buildConfigs [ self . train . buildNo ] . batchSize
  if 49 - 49: iI1iII1I1I1i % I1Ii1I1 * oOO / oOo0O00
 @ property
 def batchCountPerEpoch ( self ) -> int :
  if 20 - 20: I11iiIi11i1I . ooo000 / i1I * IiIIii11Ii * oOo0O00
  if 75 - 75: Ii
  if 10 - 10: i1 . Iii1i % I1Ii1I1 . i1I . ooOOO / oOo0O00
  if 52 - 52: I1I / I1Ii1I1 . iI1iII1I1I1i % i1I / i1iiIII111 % i1I
  if 74 - 74: OooOoo * oOo0O00 - I1I . IiI11Ii111 / i1i1i1111I / i1
  if 20 - 20: IiI11Ii111 / Ii * oOO - Ii + Ii
  if 97 - 97: i1iiIII111 . I1I - i1I
  if 29 - 29: i1 . i1 . IiI11Ii111
  if 78 - 78: OooOoo % Ii * i1i1i1111I
  if 25 - 25: Ii * I1I
  return self . generatorController [ self . train . currentSourceDataset ] . batchCountPerEpoch
  if 40 - 40: oOO / i1I
 @ property
 def testRatio ( self ) -> int :
  if 74 - 74: Oo * I1Ii1I1 % oOo0O00
  if 29 - 29: ooo000 + i1iiIII111
  if 2 - 2: oOo0O00 % oOO * Ooo0Ooo + oOo0O00 * IiIIii11Ii + Ooo0Ooo
  if 76 - 76: Iii1i * I1I / IiIIii11Ii - i1iiIII111 + i1
  if 16 - 16: IIiIIiIi11I1 + i1 + iI1iII1I1I1i + IIiIIiIi11I1 % Ooo0Ooo + oOo0O00
  if 82 - 82: IIiIIiIi11I1 / I1I
  if 26 - 26: IiI11Ii111 % IiI11Ii111
  if 49 - 49: ooOOO
  if 31 - 31: Ooo0Ooo . Oo
  if 12 - 12: iI1iII1I1I1i . Iii1i
  if self . train is None :
   raise ValueError ( "This source is not attached to a Train object yet. No test ratio can be determined." )
   if 35 - 35: i1I - Ooo0Ooo
  return self . train . testRatio
  if 98 - 98: oOO . I1I + I1I
 @ property
 def train ( self ) -> 'Train' :
  if 99 - 99: ooOOO / iI1iII1I1I1i . i1I + Ii
  if 79 - 79: I1Ii1I1 % Ooo0Ooo - oOO % Oo
  if 62 - 62: Ooo0Ooo . OooOoo + IIiIIiIi11I1 . i1 + i1iiIII111 - i1i1i1111I
  if 86 - 86: IIiIIiIi11I1 - oOo0O00 % IiIIii11Ii / Oo
  if 6 - 6: i1i1i1111I % i1iiIII111 - I11iiIi11i1I * IIiIIiIi11I1 % iI1iII1I1I1i % i1i1i1111I
  if 9 - 9: IIiIIiIi11I1 - IIiIIiIi11I1 + i1iiIII111 - i1i1i1111I / ooo000
  if 19 - 19: IiI11Ii111 - Ii - ooo000 - IiI11Ii111 % IiIIii11Ii % IiIIii11Ii
  if 11 - 11: Ii + OooOoo / oOO
  if 80 - 80: OooOoo - oOo0O00
  if 59 - 59: Ooo0Ooo / ooo000 - oOO
  return self . _train
  if 87 - 87: I1Ii1I1
 @ train . setter
 def train ( self , train : 'Train' ) -> 'Train' :
  if 72 - 72: Ooo0Ooo + oOo0O00 . i1iiIII111 + IiIIii11Ii + i1i1i1111I
  if 15 - 15: i1iiIII111 - i1I + I11iiIi11i1I + i1I / I11iiIi11i1I * OooOoo
  if 12 - 12: Iii1i - IiIIii11Ii % Ooo0Ooo
  if 40 - 40: IiI11Ii111 / ooo000 + I1Ii1I1 - I1I
  if 1 - 1: i1iiIII111 + oOo0O00 + Ooo0Ooo / ooOOO + i1I
  if 29 - 29: IIiIIiIi11I1 + Iii1i % oOO * I11iiIi11i1I
  if 61 - 61: Ooo0Ooo * oOO % I11iiIi11i1I / ooOOO * Oo % Ooo0Ooo
  if 75 - 75: IiIIii11Ii . ooo000 - OooOoo * oOO
  if 76 - 76: Iii1i % i1 - I1I
  if 44 - 44: i1i1i1111I * Ooo0Ooo % ooo000 / iI1iII1I1I1i + oOO - oOO
  if 7 - 7: Ooo0Ooo / ooo000 - Oo - iI1iII1I1I1i - I1Ii1I1
  if 8 - 8: Iii1i * i1 / Oo * i1 % Ii % I1Ii1I1
  if 7 - 7: i1i1i1111I
  if 99 - 99: Ii + Ooo0Ooo . OooOoo
  if any ( [ s . splittable != self . splittable for s in train . sources ] ) :
   raise ValueError ( "Sources are incompatible within the Train object. All sources should have consistent splittable nature." )
   if 37 - 37: Iii1i + IiI11Ii111 . Ii
   if 30 - 30: OooOoo / iI1iII1I1I1i + oOo0O00 / OooOoo
  self . _train = train
  if 39 - 39: IiIIii11Ii . ooo000
  if 76 - 76: Iii1i * oOO + oOO . OooOoo
  train . sources . append ( self )
  if 26 - 26: Iii1i
  if 52 - 52: IiI11Ii111 % I11iiIi11i1I / ooo000 + I1I
  if not self . splittable :
   train . testDatasetType = I111II1II111I . Dataset . TestSource . Assign
   for OOOooOo in train . buildConfigs :
    OOOooOo . crossValidationType = None
    if 86 - 86: iI1iII1I1I1i . IiI11Ii111 + Iii1i - i1i1i1111I . i1I
  return self . _train
  if 1 - 1: ooOOO . IiI11Ii111 - oOo0O00 * Ii % IiIIii11Ii
 @ property
 def propagateDppNodes ( self ) -> Dict [ str , 'DataPreprocessing.Node.Config' ] :
  if 12 - 12: oOo0O00 % I11iiIi11i1I % I11iiIi11i1I
  if 17 - 17: i1i1i1111I % Ii / I1Ii1I1
  if 60 - 60: I11iiIi11i1I + Oo
  if 83 - 83: ooOOO
  if 14 - 14: i1I % Ii + IiIIii11Ii - iI1iII1I1I1i
  if 25 - 25: i1
  if 23 - 23: i1i1i1111I + IiIIii11Ii + i1I / ooOOO - OooOoo
  if 67 - 67: IIiIIiIi11I1 - Oo - IiI11Ii111 * Ii
  if 23 - 23: ooo000 / oOO
  if 20 - 20: iI1iII1I1I1i * Ii % i1I % Iii1i - IIiIIiIi11I1
  return { dppKey : self . train . dppNodes [ dppKey ] for dppKey in self . _propagateDppNodes }
  if 82 - 82: IIiIIiIi11I1 + Ii / OooOoo + i1i1i1111I % IIiIIiIi11I1
 def addPropagateDppNodes ( self , dppKey : str ) :
  if 60 - 60: Ii * ooo000 % i1
  if 80 - 80: iI1iII1I1I1i - ooo000
  if 76 - 76: ooOOO % I1I * Oo . oOo0O00 / Ii * IiI11Ii111
  if 85 - 85: ooo000 % Iii1i * ooOOO * ooo000 / I11iiIi11i1I - IiI11Ii111
  if 73 - 73: Iii1i - Oo + Oo
  if 67 - 67: i1iiIII111 / ooOOO - OooOoo
  if 30 - 30: ooo000
  if 33 - 33: Oo * IiI11Ii111
  if 56 - 56: ooo000 + i1i1i1111I
  if 97 - 97: oOO
  self . _propagateDppNodes . add ( dppKey )
  if 58 - 58: i1I * ooo000 % Iii1i
 def removePropagateDppNodes ( self , dppKey : str ) :
  if 58 - 58: i1 - i1i1i1111I % oOo0O00 / i1iiIII111 . IIiIIiIi11I1
  if 92 - 92: OooOoo % oOO - ooOOO / i1 % i1iiIII111 - i1i1i1111I
  if 51 - 51: ooo000
  if 91 - 91: oOo0O00
  if 6 - 6: i1iiIII111 / i1I . IiIIii11Ii * i1 - Iii1i . IiI11Ii111
  if 61 - 61: IiIIii11Ii - ooOOO / I11iiIi11i1I
  if 30 - 30: I1I % i1i1i1111I * i1i1i1111I
  if 40 - 40: ooo000 . i1iiIII111 + i1
  if 28 - 28: IiI11Ii111 * i1iiIII111 * Ooo0Ooo
  if 76 - 76: Iii1i + Oo
  if dppKey in self . _propagateDppNodes :
   self . _propagateDppNodes . remove ( dppKey )
   if 29 - 29: i1iiIII111 * oOO % ooOOO - I11iiIi11i1I - oOo0O00
 def setOneWayReferenceToTrain ( self , train : 'Train' ) -> 'Train' :
  if 67 - 67: I11iiIi11i1I
  if 95 - 95: OooOoo + oOO / oOo0O00 / IIiIIiIi11I1 % I1I + OooOoo
  if 29 - 29: IiI11Ii111 / I1Ii1I1 % IiI11Ii111 + IiI11Ii111
  if 43 - 43: i1i1i1111I + ooOOO . Ii * I11iiIi11i1I - ooOOO * Ii
  if 2 - 2: ooo000 . IiI11Ii111 - iI1iII1I1I1i + Oo * IiI11Ii111 % i1i1i1111I
  if 20 - 20: Oo
  if 9 - 9: Ooo0Ooo
  if 88 - 88: I11iiIi11i1I / Ii / IiIIii11Ii * ooo000 + Oo + IiI11Ii111
  if 91 - 91: Iii1i * i1 * iI1iII1I1I1i % IiI11Ii111 . IIiIIiIi11I1
  if 96 - 96: oOo0O00
  if 79 - 79: Oo / Iii1i
  if 43 - 43: I1Ii1I1 . IiI11Ii111 . i1I * i1I
  if 62 - 62: I1Ii1I1 + ooOOO + Ii - oOO - I1I % IiIIii11Ii
  if 80 - 80: ooOOO + OooOoo - IiIIii11Ii * OooOoo . Oo
  self . _train = train
  if 17 - 17: oOO
  if 53 - 53: i1iiIII111 + i1I . Iii1i % Ii - IiI11Ii111 . oOo0O00
  self . prepareIteration ( )
  if 28 - 28: IiIIii11Ii
  return self . _train
  if 81 - 81: iI1iII1I1I1i + ooo000 . ooOOO / Oo + i1iiIII111
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> Any :
  if 14 - 14: Oo - OooOoo
  if 93 - 93: I1I . Iii1i - Oo
  if 24 - 24: I11iiIi11i1I * iI1iII1I1I1i / IiI11Ii111 . Oo
  if 63 - 63: I1Ii1I1 . ooOOO * OooOoo . ooo000
  if 31 - 31: Ooo0Ooo + oOO % i1I - i1iiIII111 + i1I / i1I
  if 13 - 13: Ii
  if 52 - 52: i1i1i1111I % Ooo0Ooo
  if 77 - 77: Ii - I1I % i1 / oOO
  if 59 - 59: IiIIii11Ii / oOO . oOo0O00 / Ii . i1i1i1111I
  if 61 - 61: oOo0O00
  if 58 - 58: Ii + i1 . oOO * i1i1i1111I
  if 49 - 49: ooo000
  if 4 - 4: Ooo0Ooo / i1i1i1111I
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getNextBatch ( )
  if 24 - 24: I1I + iI1iII1I1I1i / oOo0O00
 def getData ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None , batchIndexes : List [ int ] = None ) -> Any :
  if 73 - 73: I11iiIi11i1I - i1I % Ooo0Ooo
  if 65 - 65: i1 - ooOOO
  if 62 - 62: iI1iII1I1I1i
  if 18 - 18: I1Ii1I1 - IiI11Ii111 + IiI11Ii111
  if 75 - 75: I11iiIi11i1I % Ooo0Ooo % Ooo0Ooo % OooOoo
  if 8 - 8: i1iiIII111 * ooo000 . IIiIIiIi11I1
  if 18 - 18: i1 / Iii1i - i1 % I1Ii1I1 + I1I
  if 28 - 28: IiI11Ii111 . I11iiIi11i1I % OooOoo - IIiIIiIi11I1 * IIiIIiIi11I1
  if 100 - 100: OooOoo . IIiIIiIi11I1 % oOO + I1Ii1I1 % I1Ii1I1 % i1
  if 99 - 99: I1I
  if 11 - 11: iI1iII1I1I1i % IiI11Ii111 % Oo * i1 / Ooo0Ooo . IiIIii11Ii
  if 92 - 92: I1I / Oo + iI1iII1I1I1i
  if 39 - 39: oOo0O00 - oOO - Ooo0Ooo + Oo - IiI11Ii111
  if 37 - 37: oOo0O00 . IiI11Ii111 / i1i1i1111I + Ooo0Ooo
  if 15 - 15: I1Ii1I1 - Iii1i + i1 + ooOOO % iI1iII1I1I1i - OooOoo
  if 82 - 82: i1 . i1
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getData ( start , end , batchIndexes )
  if 92 - 92: Oo - oOo0O00
 def getRandItems ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None , randomSeed : int = None , randomCount : int = None ) :
  if 28 - 28: i1iiIII111 * oOo0O00 - oOO
  if 95 - 95: i1i1i1111I - i1i1i1111I * I1I + i1I
  if 48 - 48: i1 - Iii1i * I1I / i1i1i1111I + Iii1i - oOo0O00
  if 99 - 99: i1I / IIiIIiIi11I1 . IiI11Ii111 . i1iiIII111
  if 5 - 5: ooOOO
  if 18 - 18: IiIIii11Ii + I1Ii1I1 * i1 - IiIIii11Ii
  if 34 - 34: i1iiIII111
  if 64 - 64: i1i1i1111I
  if 93 - 93: Ooo0Ooo / I1Ii1I1 / IiI11Ii111 + oOO / ooOOO * i1iiIII111
  if 60 - 60: IiIIii11Ii
  if 75 - 75: i1I - i1i1i1111I % i1I + oOO
  if 17 - 17: ooOOO . i1i1i1111I - ooo000
  if 14 - 14: I1I . IIiIIiIi11I1 / ooOOO . IIiIIiIi11I1
  if 14 - 14: oOO
  if 41 - 41: Iii1i / i1I - Ooo0Ooo . Ooo0Ooo
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getRandItems ( randomSeed , randomCount )
  if 83 - 83: I1I
 def getVisualRandItems ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None , randomSeed : int = None , randomCount : int = None , visualRecord : int = None ) :
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getVisualRandItems ( randomSeed , randomCount , visualRecord )
  if 13 - 13: OooOoo . i1I
 def recoverToRawData ( self , items ) :
  if 72 - 72: ooOOO - ooo000 - i1 % Oo + ooo000
  if 11 - 11: I1I * oOo0O00
  if 55 - 55: i1i1i1111I . OooOoo % I1I - IiI11Ii111 / Ii / i1I
  if 5 - 5: IiIIii11Ii * OooOoo % oOO / i1
  if 1 - 1: i1I
  if 35 - 35: oOo0O00 / i1i1i1111I % Ooo0Ooo % i1I
  if 46 - 46: Ooo0Ooo % Ooo0Ooo . oOO
  if 88 - 88: i1i1i1111I * i1I + oOO . IiI11Ii111 % IiI11Ii111
  if 99 - 99: I1Ii1I1 . Iii1i
  if 26 - 26: Iii1i * I1Ii1I1 % iI1iII1I1I1i * Ooo0Ooo / ooo000 / i1iiIII111
  pass
  if 53 - 53: IiIIii11Ii * i1I - IiIIii11Ii - ooOOO
 def getPrintableItems ( self , dppKey : str , items : List [ Any ] , recovered : bool = True ) :
  if 24 - 24: i1I
  if 42 - 42: I1Ii1I1 / i1iiIII111 - oOo0O00 . Ooo0Ooo + i1iiIII111
  if 96 - 96: Ii - Ooo0Ooo . IiI11Ii111 / IiI11Ii111
  if 71 - 71: IiIIii11Ii * oOo0O00 % i1i1i1111I % IiIIii11Ii - I11iiIi11i1I
  if 39 - 39: ooOOO . Oo + I11iiIi11i1I - Iii1i - IiIIii11Ii
  if 24 - 24: i1 - ooOOO * IiI11Ii111
  if 73 - 73: i1iiIII111 % I1I . I11iiIi11i1I . I11iiIi11i1I / OooOoo % ooOOO
  if 35 - 35: Ii % IiI11Ii111 . i1iiIII111 . ooOOO * I1Ii1I1 / i1i1i1111I
  if 72 - 72: I1Ii1I1 / Iii1i / IIiIIiIi11I1
  if 36 - 36: oOo0O00 - IiIIii11Ii * ooOOO / Iii1i * Oo
  if 8 - 8: oOo0O00 - Ii % IiIIii11Ii / I1I - IiIIii11Ii * i1I
  if 59 - 59: oOO / oOo0O00 . Ooo0Ooo - oOo0O00 - oOo0O00 - IiI11Ii111
  pass
  if 32 - 32: Oo + ooo000
 def prepareIteration ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) :
  if 40 - 40: I11iiIi11i1I % ooOOO - IIiIIiIi11I1 / Iii1i * i1i1i1111I
  if 90 - 90: iI1iII1I1I1i % I1Ii1I1 * IiI11Ii111 / i1iiIII111 % I11iiIi11i1I
  if 59 - 59: Ii % Ooo0Ooo - IiIIii11Ii - OooOoo + ooOOO
  if 67 - 67: i1 + i1 . Ooo0Ooo + Ooo0Ooo % iI1iII1I1I1i
  if 27 - 27: ooOOO
  if 7 - 7: Ii . IiIIii11Ii % ooo000 / Ooo0Ooo + I1I - IIiIIiIi11I1
  if 24 - 24: Ooo0Ooo / IIiIIiIi11I1 % i1i1i1111I - OooOoo * I11iiIi11i1I
  if 100 - 100: ooOOO + oOo0O00 . IiIIii11Ii / i1 / Ooo0Ooo
  if 3 - 3: Ooo0Ooo % IiI11Ii111
  if 3 - 3: I11iiIi11i1I % IIiIIiIi11I1 - IIiIIiIi11I1 + IIiIIiIi11I1 % IiIIii11Ii / i1I
  self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . prepareIteration ( )
  if 35 - 35: i1 - I1Ii1I1 + I11iiIi11i1I
 def splitValidationDataset ( self , validation : float = 0.1 , randomFold : float = False ) :
  if 86 - 86: IiIIii11Ii / oOo0O00 - Ooo0Ooo
  if 20 - 20: Ooo0Ooo
  if 53 - 53: IIiIIiIi11I1 / i1iiIII111 / IiI11Ii111
  if 84 - 84: IiIIii11Ii + I11iiIi11i1I / I11iiIi11i1I % Ii
  if 98 - 98: i1i1i1111I
  if 64 - 64: i1I - ooo000 - IIiIIiIi11I1 - Oo * Ooo0Ooo + I1I
  if 3 - 3: iI1iII1I1I1i * IiIIii11Ii * OooOoo % iI1iII1I1I1i + iI1iII1I1I1i % iI1iII1I1I1i
  if 83 - 83: oOO - Ii . I1Ii1I1 . iI1iII1I1I1i
  if 27 - 27: i1
  if 60 - 60: i1iiIII111 - i1i1i1111I
  if 18 - 18: oOO + IIiIIiIi11I1 + IiI11Ii111
  if 75 - 75: OooOoo + i1
  if not self . splittable :
   raise ValueError ( "This source cannot be split. Please consider to use separate sources if you need to perform actions like cross validation." )
   if 34 - 34: I1Ii1I1 . i1i1i1111I * IiI11Ii111 . Ii % oOo0O00 - I1I
 def splitTestDataset ( self , test : float = 0.2 , shuffle : float = False ) -> 'Source.Config' :
  if 55 - 55: iI1iII1I1I1i - i1I * ooOOO + iI1iII1I1I1i - oOo0O00
  if 77 - 77: Ii * IiIIii11Ii
  if 5 - 5: oOO . I1Ii1I1
  if 62 - 62: i1I - I1Ii1I1
  if 14 - 14: Oo * Ooo0Ooo * IIiIIiIi11I1 * iI1iII1I1I1i * i1i1i1111I
  if 4 - 4: ooo000 - ooOOO % IiI11Ii111 - oOO / Ii
  if 17 - 17: i1I / iI1iII1I1I1i / Oo % IIiIIiIi11I1 * I11iiIi11i1I
  if 75 - 75: I1Ii1I1 * I11iiIi11i1I - Ooo0Ooo
  if 74 - 74: I1I
  if 4 - 4: oOo0O00 . Oo + i1I / IiI11Ii111 - IiI11Ii111 * Oo
  if 95 - 95: iI1iII1I1I1i * ooo000 . i1 . IIiIIiIi11I1
  if 5 - 5: I11iiIi11i1I
  if 87 - 87: Oo
  if 3 - 3: I1I - IiIIii11Ii + IIiIIiIi11I1 / ooOOO % Oo + OooOoo
  if 57 - 57: i1i1i1111I * IiIIii11Ii . I1I * I11iiIi11i1I * oOO * I1I
  if not self . splittable :
   raise ValueError ( "This source cannot be split. Please consider to use separate sources if you need to perform actions like cross validation." )
   if 40 - 40: oOO * iI1iII1I1I1i - IiI11Ii111 % ooOOO * Oo
  self . generatorController . splitTestDataset ( test , shuffle )
  if 45 - 45: i1I - I11iiIi11i1I - I11iiIi11i1I . Ooo0Ooo
 def getLocations ( self ) -> List [ str ] :
  if 71 - 71: Ooo0Ooo - i1iiIII111 / i1I
  if 74 - 74: I1Ii1I1 - I1I / ooo000 + i1i1i1111I
  if 89 - 89: i1I % IIiIIiIi11I1 . i1i1i1111I - Ii
  if 87 - 87: Ii / IIiIIiIi11I1 / Ooo0Ooo % Oo + oOO . IiI11Ii111
  if 88 - 88: ooOOO - i1i1i1111I - iI1iII1I1I1i
  if 73 - 73: I11iiIi11i1I / ooo000 % ooOOO % IIiIIiIi11I1 % oOO
  if 53 - 53: I1Ii1I1 % ooOOO
  if 50 - 50: iI1iII1I1I1i % Ooo0Ooo . IiIIii11Ii % i1i1i1111I + i1
  if 11 - 11: IIiIIiIi11I1 - I1I
  if 11 - 11: oOO / IiIIii11Ii . IiI11Ii111
  return self . generatorController . getLocations ( )
  if 1 - 1: ooo000 / Oo * OooOoo
 def getShape ( self , outputsetKey : str ) -> List [ int ] :
  if 76 - 76: i1iiIII111
  if 89 - 89: ooo000
  if 28 - 28: oOo0O00 * i1i1i1111I + I1Ii1I1 * i1iiIII111 % I11iiIi11i1I
  if 73 - 73: I1I
  if 98 - 98: I11iiIi11i1I
  if 77 - 77: IIiIIiIi11I1 . Oo % i1iiIII111 . I11iiIi11i1I % iI1iII1I1I1i
  if 19 - 19: I1I % i1 + Ii
  if 92 - 92: IIiIIiIi11I1 - i1i1i1111I + IIiIIiIi11I1 - OooOoo . i1I / I11iiIi11i1I
  if 71 - 71: I1I . IiI11Ii111 * i1I * IiI11Ii111 - ooo000
  if 68 - 68: I11iiIi11i1I - IiI11Ii111 % I1Ii1I1 - I1I + IIiIIiIi11I1
  if 17 - 17: I1I * iI1iII1I1I1i - i1iiIII111
  if 17 - 17: IiIIii11Ii * Ooo0Ooo
  if 31 - 31: Iii1i . I11iiIi11i1I * i1I * iI1iII1I1I1i
  return self . outputsetInfo [ outputsetKey ] . shape if outputsetKey in self . outputsetInfo else [ None , * self . oriShape [ 1 : ] ]
  if 25 - 25: Ooo0Ooo + i1i1i1111I
 def getHeader ( self , outputsetKey : str ) -> List [ str ] :
  if 25 - 25: Iii1i * i1iiIII111 % oOo0O00 / i1i1i1111I - IiIIii11Ii % i1
  if 45 - 45: iI1iII1I1I1i . iI1iII1I1I1i
  if 99 - 99: I11iiIi11i1I . iI1iII1I1I1i
  if 14 - 14: I1I * i1iiIII111 + IIiIIiIi11I1 * I11iiIi11i1I
  if 34 - 34: i1I / IIiIIiIi11I1 % Oo + IiIIii11Ii / i1
  if 16 - 16: I1I / ooOOO * IiI11Ii111 - i1I / I11iiIi11i1I - i1
  if 57 - 57: i1i1i1111I
  if 17 - 17: Oo - i1i1i1111I . Ii
  if 29 - 29: I1I / i1i1i1111I / I1Ii1I1 . iI1iII1I1I1i % IiI11Ii111
  if 60 - 60: ooOOO + I1Ii1I1 + Ooo0Ooo - IiI11Ii111 * ooo000 - I1Ii1I1
  if 84 - 84: I11iiIi11i1I / I1I / IIiIIiIi11I1
  if 56 - 56: iI1iII1I1I1i / oOO % i1 * i1i1i1111I
  if 29 - 29: Ooo0Ooo
  return self . outputsetInfo [ outputsetKey ] . header if outputsetKey in self . outputsetInfo else [ ]
  if 54 - 54: OooOoo . I1I * IIiIIiIi11I1 * oOO
 def close ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) :
  if 53 - 53: ooOOO % I1I / I1I % Ooo0Ooo * ooOOO
  if 86 - 86: oOo0O00 * oOO * OooOoo
  if 57 - 57: IiI11Ii111 * IiIIii11Ii
  if 34 - 34: Oo * ooo000 - ooOOO . I11iiIi11i1I % IIiIIiIi11I1
  if 90 - 90: Iii1i
  if 66 - 66: IiI11Ii111 / I11iiIi11i1I - OooOoo * OooOoo % IiIIii11Ii + IiI11Ii111
  if 8 - 8: IIiIIiIi11I1 + Oo / IiIIii11Ii + i1 - OooOoo
  if 90 - 90: IiIIii11Ii / I11iiIi11i1I % I11iiIi11i1I
  if 47 - 47: OooOoo % OooOoo . oOo0O00 * OooOoo . I11iiIi11i1I / Oo
  if 33 - 33: ooOOO
  self . generatorController . close ( sourceDataset or self . train . currentSourceDataset )
  if 80 - 80: IiI11Ii111 . iI1iII1I1I1i % i1i1i1111I / I1I / OooOoo . i1iiIII111
 @ staticmethod
 def convertDType ( npdtype ) :
  if 54 - 54: Iii1i % ooo000 % ooOOO / IiI11Ii111 % Ooo0Ooo / i1iiIII111
  if 74 - 74: IiIIii11Ii + Iii1i - i1i1i1111I
  if 92 - 92: I1Ii1I1 - I11iiIi11i1I - I1I + I11iiIi11i1I % iI1iII1I1I1i * ooOOO
  if 93 - 93: IIiIIiIi11I1 * Ooo0Ooo / ooOOO
  if 16 - 16: OooOoo % ooo000 % oOo0O00
  if 85 - 85: Oo
  if 72 - 72: Iii1i
  if 11 - 11: i1I / Ii . i1i1i1111I / iI1iII1I1I1i . Ooo0Ooo % i1
  if 49 - 49: Iii1i % Iii1i / Oo + Iii1i
  if 77 - 77: I1Ii1I1 / I11iiIi11i1I * Oo / IiIIii11Ii / oOO / IiIIii11Ii
  if 46 - 46: Iii1i * OooOoo
  if 100 - 100: i1i1i1111I % i1iiIII111 / oOO / i1 * i1
  if 67 - 67: oOO / i1iiIII111 * IIiIIiIi11I1 + Ooo0Ooo % IIiIIiIi11I1
  if npdtype == np . dtype ( 'float64' ) :
   return tf . float64
  elif npdtype == np . dtype ( 'float32' ) :
   return tf . float32
  elif npdtype == np . dtype ( 'int64' ) :
   return tf . int64
  elif npdtype == np . dtype ( 'int32' ) :
   return tf . int32
  elif npdtype . kind == "U" :
   return tf . string
  else :
   return tf . variant
   if 79 - 79: I1I * Ii * i1 / IiIIii11Ii
 @ staticmethod
 def getDataType ( string : str ) -> 'tf.DType' :
  if 74 - 74: ooo000 % Ii . Iii1i . ooOOO . ooo000
  if 67 - 67: OooOoo + oOo0O00
  if 13 - 13: Ii + Ooo0Ooo - I1Ii1I1 + I1I * I1I * i1iiIII111
  if 62 - 62: Oo
  if 75 - 75: Ooo0Ooo
  if 41 - 41: i1I
  if 18 - 18: Ii % IiIIii11Ii - IiIIii11Ii . iI1iII1I1I1i / Ii
  if 13 - 13: IIiIIiIi11I1 / Iii1i + Oo * IiI11Ii111 / iI1iII1I1I1i - Ooo0Ooo
  if 35 - 35: IiI11Ii111 + i1iiIII111
  if 39 - 39: IIiIIiIi11I1 - i1I . OooOoo / oOo0O00
  if 59 - 59: I1Ii1I1 / i1 . OooOoo * oOO + I11iiIi11i1I
  if 100 - 100: IIiIIiIi11I1
  if 52 - 52: OooOoo
  return { "tf.float32" : tf . float32 , "tf.int64" : tf . int64 } [ string ]
  if 76 - 76: IIiIIiIi11I1 / Ooo0Ooo . IiIIii11Ii * ooo000 / Oo - OooOoo
class iiI1i11iii ( O0 ) :
 if 98 - 98: I1I % i1iiIII111 * I11iiIi11i1I * ooOOO - iI1iII1I1I1i
 if 39 - 39: OooOoo . Iii1i + ooOOO
 if 32 - 32: I1Ii1I1 + I11iiIi11i1I * I11iiIi11i1I * i1 / IiIIii11Ii
 if 96 - 96: i1i1i1111I * IiIIii11Ii . I1Ii1I1 % Iii1i - ooOOO / IiIIii11Ii
 if 22 - 22: i1I + i1 / oOo0O00 + i1 - I1I
 if 22 - 22: i1i1i1111I
 if 10 - 10: IIiIIiIi11I1 + i1i1i1111I . IIiIIiIi11I1 . i1 / i1I
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 49 - 49: i1i1i1111I * i1I
  if 84 - 84: Oo
  if 89 - 89: Ii * Ooo0Ooo - i1 / I11iiIi11i1I - IiIIii11Ii + Ooo0Ooo
  if 60 - 60: I1Ii1I1
  if 28 - 28: Ii * Ooo0Ooo . oOo0O00 - Ii / Oo / OooOoo
  if 4 - 4: i1 - Ooo0Ooo / i1 - i1I
  if 48 - 48: oOo0O00 % i1 % I11iiIi11i1I / ooo000 * oOo0O00
  def __init__ ( self , controller : 'Source.Image.GeneratorController' ) :
   if 89 - 89: Oo + ooo000 / i1 - Iii1i
   if 44 - 44: I11iiIi11i1I - i1 * I11iiIi11i1I / i1 / i1
   if 9 - 9: IIiIIiIi11I1 - Ooo0Ooo / oOo0O00 * i1I
   if 83 - 83: i1iiIII111 / ooOOO
   if 51 - 51: IIiIIiIi11I1 . i1iiIII111 * i1iiIII111 * IiI11Ii111 - i1iiIII111
   if 72 - 72: oOO * ooo000 . I11iiIi11i1I - ooo000
   if 49 - 49: IiI11Ii111
   if 50 - 50: IiIIii11Ii % IIiIIiIi11I1 . ooo000 + I1I - ooo000 % I1Ii1I1
   if 29 - 29: oOO % ooOOO
   if 10 - 10: i1i1i1111I
   super ( ) . __init__ ( controller )
   if 60 - 60: oOO + ooOOO . IiIIii11Ii % Ooo0Ooo - Ii
   self . sourceType = None
   if 28 - 28: I1Ii1I1 - oOO / Iii1i
   self . _labelShape = [ ]
   if 20 - 20: IiIIii11Ii + oOO - i1i1i1111I
   self . _fileNames : Union [ List [ str ] , Dict [ str , List [ str ] ] ] = None
   if 62 - 62: ooo000 + OooOoo / IiI11Ii111 * Oo + ooOOO
   self . _imgData = np . array ( [ ] , dtype = float )
   if 85 - 85: oOo0O00 - Ii - OooOoo * I1I
   self . _labelData = np . array ( [ ] , dtype = float )
   if 60 - 60: Oo - Ii % ooOOO
   self . _sess = None
   if 24 - 24: ooo000 + oOo0O00 / i1i1i1111I
   self . _imgGraph = None
   if 55 - 55: IIiIIiIi11I1 * i1I + ooOOO - IiI11Ii111 % IiIIii11Ii % oOO
   self . _itr = None
   if 30 - 30: Ii - I11iiIi11i1I + Oo / OooOoo % i1i1i1111I
   self . _nextLabels = None
   if 14 - 14: oOo0O00 . IiIIii11Ii % Ooo0Ooo . oOO . iI1iII1I1I1i
   self . _nextImg = None
   if 75 - 75: i1 - ooOOO + Ooo0Ooo . Ii * I11iiIi11i1I
   self . _imgRawShape = [ ]
   if 72 - 72: IIiIIiIi11I1 + i1I
   self . _imgBytes = 0
   if 17 - 17: I1Ii1I1 / IIiIIiIi11I1 % I1I % i1I . i1i1i1111I % iI1iII1I1I1i
   self . _targetBytes = 0
   if 74 - 74: I1Ii1I1 * IiI11Ii111
   self . outputsetInfo = { }
   if 26 - 26: i1I * IiI11Ii111 % Ii * I11iiIi11i1I * IiIIii11Ii + i1
  def copy ( self ) -> 'Source.Image.Detail' :
   if 21 - 21: iI1iII1I1I1i - Ii - IiIIii11Ii + Ii
   if 27 - 27: oOO . IiI11Ii111 . OooOoo - oOo0O00
   if 89 - 89: Ooo0Ooo - i1iiIII111 * i1I * Iii1i
   if 44 - 44: IiI11Ii111 + IIiIIiIi11I1
   if 46 - 46: oOo0O00 + i1i1i1111I + Oo . IiIIii11Ii
   if 73 - 73: i1iiIII111 + IiIIii11Ii + i1iiIII111 + OooOoo - I1I
   if 23 - 23: iI1iII1I1I1i
   if 73 - 73: ooOOO
   if 89 - 89: Oo . ooo000 % I1I + IiIIii11Ii * IIiIIiIi11I1 * i1i1i1111I
   if 53 - 53: IIiIIiIi11I1
   if 2 - 2: IIiIIiIi11I1 % I1Ii1I1
   ii1IIiIIi : iiI1i11iii . GeneratorDetail = iiI1i11iii . GeneratorDetail ( self . controller )
   if 64 - 64: OooOoo . i1I
   if 33 - 33: oOo0O00 + i1I - IIiIIiIi11I1
   for Ii1I in [ "_epochSize" , "_oriShape" , "_itrIdx" , "_batchSize" , "_shuffle" , "_imgData" , "_labelData" , "sourceType" , "_labelShape" , "_fileNames" , "_imgRawShape" , "_imgBytes" , "_targetBytes" , "outputsetInfo" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 23 - 23: ooOOO . ooOOO / I11iiIi11i1I + I1I
   return ii1IIiIIi
   if 80 - 80: iI1iII1I1I1i . IIiIIiIi11I1 + I1Ii1I1
  @ property
  def labelShape ( self ) -> List [ int ] :
   if 28 - 28: oOO
   if 79 - 79: OooOoo . Ooo0Ooo * oOo0O00 % ooOOO
   if 50 - 50: i1i1i1111I + I1I - IIiIIiIi11I1
   if 18 - 18: OooOoo + i1
   if 65 - 65: oOO / IiI11Ii111
   if 20 - 20: i1iiIII111 - ooOOO % Ooo0Ooo
   if 49 - 49: IIiIIiIi11I1 / Ooo0Ooo * I11iiIi11i1I * I11iiIi11i1I / ooOOO - OooOoo
   if 82 - 82: ooOOO % IIiIIiIi11I1 / i1
   if 96 - 96: Oo % i1i1i1111I % IiIIii11Ii
   if 65 - 65: I11iiIi11i1I
   return self . _labelShape
   if 99 - 99: i1I % IIiIIiIi11I1 + Ooo0Ooo
  @ property
  def imgData ( self ) -> 'np.ndarray' :
   if 81 - 81: I1Ii1I1 * i1 - iI1iII1I1I1i % OooOoo
   if 34 - 34: Ooo0Ooo % i1iiIII111 / i1I * I1Ii1I1 / Oo
   if 53 - 53: i1 / IiIIii11Ii - I1I * i1i1i1111I - ooOOO
   if 27 - 27: IiI11Ii111 - IiI11Ii111
   if 48 - 48: Ooo0Ooo - I11iiIi11i1I
   if 70 - 70: oOo0O00 / IiI11Ii111 . i1i1i1111I * ooOOO % Oo * I1Ii1I1
   if 21 - 21: oOo0O00 + Iii1i - ooOOO / oOO * IiI11Ii111
   if 78 - 78: i1i1i1111I / I1Ii1I1 % oOo0O00 - IiI11Ii111 % I1Ii1I1 * oOO
   if 97 - 97: I1Ii1I1 % iI1iII1I1I1i . oOo0O00 + ooOOO % IiIIii11Ii
   if 79 - 79: ooo000 % I1I - OooOoo % Oo * OooOoo . Oo
   return self . _imgData
   if 74 - 74: I11iiIi11i1I . I1Ii1I1 - Iii1i * Ii
  @ property
  def labelData ( self ) -> 'np.ndarray' :
   if 10 - 10: OooOoo
   if 77 - 77: Oo - oOO
   if 18 - 18: IiI11Ii111 * Iii1i
   if 75 - 75: ooo000 + IIiIIiIi11I1 * IiIIii11Ii
   if 3 - 3: Iii1i + ooo000 + OooOoo . OooOoo
   if 33 - 33: ooOOO . i1i1i1111I . IIiIIiIi11I1 - I1I
   if 79 - 79: Ooo0Ooo * oOo0O00 * Ii + IIiIIiIi11I1 - i1i1i1111I - oOo0O00
   if 52 - 52: Oo . iI1iII1I1I1i - i1I - i1I - IiI11Ii111 / i1i1i1111I
   if 15 - 15: IiI11Ii111
   if 72 - 72: IiI11Ii111 * oOO * IiI11Ii111 / I1I - i1iiIII111 % OooOoo
   return self . _labelData
   if 59 - 59: Ooo0Ooo * IIiIIiIi11I1
  @ property
  def hasHeader ( self ) -> bool :
   if 39 - 39: I1I
   if 6 - 6: IiIIii11Ii + ooOOO . ooOOO - ooOOO * ooOOO / I1I
   if 68 - 68: i1 - i1I
   if 1 - 1: Iii1i * Oo - I1I * i1iiIII111 - i1I * Oo
   if 81 - 81: Ooo0Ooo
   if 14 - 14: i1iiIII111 / ooOOO + Ooo0Ooo % ooOOO % ooOOO
   if 60 - 60: Iii1i
   if 61 - 61: I1Ii1I1 % IiIIii11Ii / i1iiIII111 % Oo + iI1iII1I1I1i . I1Ii1I1
   if 43 - 43: IiIIii11Ii + Iii1i - IIiIIiIi11I1 / oOO * I1Ii1I1 % i1I
   if 19 - 19: oOo0O00
   return True
   if 59 - 59: I1Ii1I1 / IiI11Ii111 % I11iiIi11i1I * i1I
  def getHeader ( self , outputsetKey : str = "image" ) :
   if 76 - 76: ooOOO * I1Ii1I1
   if 72 - 72: I1I
   if 13 - 13: I11iiIi11i1I . Ooo0Ooo + iI1iII1I1I1i . i1I + Ooo0Ooo / i1iiIII111
   if 73 - 73: I11iiIi11i1I / iI1iII1I1I1i * I11iiIi11i1I * I11iiIi11i1I % i1iiIII111
   if 72 - 72: OooOoo * Oo % oOO % ooo000 % ooo000
   if 59 - 59: Oo - I11iiIi11i1I
   if 42 - 42: I11iiIi11i1I
   if 91 - 91: oOo0O00
   if 55 - 55: oOO + Ii
   if 71 - 71: IiIIii11Ii
   if 82 - 82: i1i1i1111I % I1I - i1I / I1Ii1I1
   if 83 - 83: I1Ii1I1 % I11iiIi11i1I % i1i1i1111I . ooo000 % ooOOO / I1I
   if 69 - 69: Oo
   return self . outputsetInfo [ outputsetKey ] . header
   if 12 - 12: Ii % I1I * I11iiIi11i1I * ooo000 * Ii + I1I
  def prepareIteration ( self ) :
   if 5 - 5: ooo000 * i1iiIII111 - i1iiIII111 * IIiIIiIi11I1
   if 44 - 44: oOO
   if 34 - 34: I1I / i1i1i1111I % IiI11Ii111 + Iii1i . ooo000 - Ooo0Ooo
   if 31 - 31: OooOoo / oOO + Ooo0Ooo . OooOoo . I1I / IIiIIiIi11I1
   if 91 - 91: i1I % IiIIii11Ii + IiIIii11Ii . ooOOO
   if 89 - 89: I1Ii1I1 + OooOoo * ooOOO / i1I * oOO
   if 86 - 86: IiI11Ii111 - oOo0O00 * OooOoo / Iii1i
   OoOOOooo000 : str = self . sourceType
   Ii1Ii : List [ int ] = self . attachObject . outputsetInfo [ "input" ] . shape [ 1 : ]
   self . _imgRawShape = Ii1Ii
   if 73 - 73: oOo0O00
   if 8 - 8: OooOoo * Ooo0Ooo
   if isinstance ( self . _fileNames , dict ) :
    ( self . _fileNames ) : dict
    for iI11iI in self . _fileNames . values ( ) :
     for o0OO00OO in iI11iI :
      if 6 - 6: Oo % iI1iII1I1I1i / i1iiIII111 . IIiIIiIi11I1
      if not os . path . exists ( o0OO00OO ) :
       raise ValueError ( "Data File not found: \"" + o0OO00OO + "\"" )
   elif isinstance ( self . _fileNames , list ) :
    ( self . _fileNames ) : list
    for o0OO00OO in self . _fileNames :
     if 81 - 81: Oo
     if not os . path . exists ( o0OO00OO ) :
      raise ValueError ( "Data File not found: \"" + o0OO00OO + "\"" )
      if 100 - 100: iI1iII1I1I1i / I1Ii1I1
   if OoOOOooo000 == "mnist" or OoOOOooo000 == "fashion-mnist" :
    if 30 - 30: Ooo0Ooo - i1iiIII111 / iI1iII1I1I1i
    ii1I1IIIIIIii : int
    iiiII : int
    with open ( self . _fileNames [ "input" ] [ 0 ] , "rb" ) as f :
     I11o0oO , iiiII = struct . unpack ( ">II" , f . read ( 8 ) )
     OOo00oOoOo : int = struct . unpack ( ">II" , f . read ( 8 ) )
     self . _imgData = np . array ( list ( f . read ( ) ) ) . reshape ( self . epochSize , Ii1Ii [ 0 ] , Ii1Ii [ 1 ] , Ii1Ii [ 2 ] )
     if 15 - 15: IIiIIiIi11I1 - IIiIIiIi11I1
    with open ( self . _fileNames [ "target" ] [ 0 ] , "rb" ) as f :
     I11o0oO , iiiII = struct . unpack ( ">II" , f . read ( 8 ) )
     self . _labelData = np . array ( list ( f . read ( ) ) ) . reshape ( self . epochSize , 1 )
     if 15 - 15: Ii . Ooo0Ooo . ooo000 + I11iiIi11i1I . OooOoo
     if 96 - 96: OooOoo % IiI11Ii111 . iI1iII1I1I1i / ooo000 / iI1iII1I1I1i + i1iiIII111
    self . batchIdxReset ( )
    if 97 - 97: IiI11Ii111 / I1Ii1I1 / IIiIIiIi11I1
    if 56 - 56: I1I / Ii * I1Ii1I1 / i1I
    if self . shuffle :
     self . _imgData , self . _labelData = o0ooo0oOoO . shuffleTogether ( self . _imgData , self . _labelData )
     if 25 - 25: oOO
   elif OoOOOooo000 in [ "cifar10" , "cifar100" , "stl10" ] :
    if 38 - 38: i1i1i1111I + i1i1i1111I * ooo000 . I11iiIi11i1I . I11iiIi11i1I
    o0OOOO0Oo0O : int = self . batchSize
    if 49 - 49: Oo / oOo0O00 - ooOOO % Iii1i / iI1iII1I1I1i / I11iiIi11i1I
    if 10 - 10: i1 * i1iiIII111 / oOo0O00 / oOO + IiIIii11Ii
    if 27 - 27: IIiIIiIi11I1
    self . _imgBytes = functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o * OoOo0o0oooO , Ii1Ii , 1 )
    self . _targetBytes = 2 if ( OoOOOooo000 == "cifar100" ) else 1
    IiiI111III : 'tf.data.FixedLengthRecordDataset' = tf . data . FixedLengthRecordDataset ( self . _fileNames , self . _imgBytes + self . _targetBytes )
    IiiI111III = IiiI111III . map ( self . mapDatasetImages )
    if self . shuffle :
     IiiI111III = IiiI111III . shuffle ( buffer_size = self . epochSize , reshuffle_each_iteration = True )
    IiiI111III = IiiI111III . repeat ( )
    IiiI111III = IiiI111III . batch ( o0OOOO0Oo0O , drop_remainder = self . dropRemainder )
    self . _itr = IiiI111III . __iter__ ( )
    if 84 - 84: i1I
  def _mapDatasetImage ( self , tfDatasetEle ) -> 'Train.RootData' :
   if 18 - 18: i1i1i1111I
   if 24 - 24: oOo0O00 % Oo + iI1iII1I1I1i
   if 9 - 9: oOo0O00 + I1I + ooo000 % oOO . Iii1i % IIiIIiIi11I1
   if 90 - 90: i1i1i1111I / OooOoo + ooOOO / IiI11Ii111 % I1I
   if 88 - 88: IIiIIiIi11I1 * OooOoo * i1I - IiIIii11Ii % i1I . Oo
   if 25 - 25: i1iiIII111 . I11iiIi11i1I
   if 42 - 42: ooOOO - I11iiIi11i1I
   if 47 - 47: ooOOO . I1Ii1I1 % iI1iII1I1I1i * oOo0O00 - OooOoo
   if 26 - 26: Ooo0Ooo / I1I % Iii1i % Oo % iI1iII1I1I1i + I1Ii1I1
   if 4 - 4: oOO
   if 6 - 6: OooOoo . iI1iII1I1I1i + IIiIIiIi11I1 / oOO * I1Ii1I1
   if 16 - 16: i1iiIII111
   if 52 - 52: i1 * I11iiIi11i1I / Ooo0Ooo . ooo000
   if 43 - 43: Ooo0Ooo + IIiIIiIi11I1
   Ii1Ii = self . _imgRawShape
   IIiIiIiIIIiiI = tf . cast ( tf . strided_slice ( tf . io . decode_raw ( tfDatasetEle , tf . uint8 ) , [ 0 ] , [ self . _targetBytes ] ) , tf . int32 )
   oo0O0OO = tf . transpose ( tf . reshape ( tf . strided_slice ( tf . io . decode_raw ( tfDatasetEle , tf . uint8 ) , [ self . _targetBytes ] , [ self . _targetBytes + self . _imgBytes ] ) , [ Ii1Ii [ 2 ] , Ii1Ii [ 0 ] , Ii1Ii [ 1 ] ] ) , [ 1 , 2 , 0 ] )
   if 62 - 62: Iii1i + ooOOO + IiI11Ii111 % IIiIIiIi11I1 / i1i1i1111I . Ii
   if 85 - 85: IIiIIiIi11I1 / Ii % iI1iII1I1I1i % oOO % Ii
   o0OOOOo0OO0O = tf . cast ( oo0O0OO , tf . float32 )
   IIiIiIiIIIiiI . set_shape ( [ self . _targetBytes ] )
   o0OOOOo0OO0O . set_shape ( [ * Ii1Ii ] )
   if 86 - 86: Ii % Iii1i * OooOoo . i1 + IiI11Ii111
   return { "target" : IIiIiIiIIIiiI , "input" : o0OOOOo0OO0O }
   if 5 - 5: I1Ii1I1 / IiIIii11Ii . IiI11Ii111
  def mapDatasetImages ( self , tfDatasetEle ) -> Dict [ str , Any ] :
   if 50 - 50: Iii1i - oOo0O00
   if 1 - 1: OooOoo * IiIIii11Ii + i1i1i1111I * i1i1i1111I - oOo0O00 % i1I
   if 36 - 36: I11iiIi11i1I / i1i1i1111I / i1iiIII111
   if 30 - 30: IiI11Ii111 % Ooo0Ooo
   if 2 - 2: Ii
   if 48 - 48: OooOoo % I1Ii1I1
   if 57 - 57: I1I + i1I + i1iiIII111 * IIiIIiIi11I1 % Ooo0Ooo + iI1iII1I1I1i
   if 40 - 40: oOo0O00 * I1I * I1I - I1Ii1I1 / Iii1i + i1
   if 19 - 19: ooo000 + IIiIIiIi11I1 - Oo % i1 - OooOoo * OooOoo
   if 51 - 51: i1i1i1111I - oOo0O00 . i1i1i1111I
   if 66 - 66: oOo0O00 / IIiIIiIi11I1 * iI1iII1I1I1i - I11iiIi11i1I
   if 40 - 40: i1iiIII111 - i1I
   if 60 - 60: oOo0O00 % ooo000 / Ii / IIiIIiIi11I1 . Oo
   if 87 - 87: i1i1i1111I
   iiI1iIi = self . _mapDatasetImage ( tfDatasetEle )
   if 33 - 33: Ii / oOO
   if 9 - 9: iI1iII1I1I1i / ooo000 / i1 . oOo0O00 * ooo000
   i11iiiIIi = { }
   i11iiiIIi [ self . attachObject . sourceID ] = iiI1iIi
   o00O0o0O = I1i11iii1iI1 ( i11iiiIIi )
   if 71 - 71: Ii * Oo . ooOOO - i1iiIII111
   iii1Oo = { dppKey : dppNode . getProcessedData ( o00O0o0O ) for dppKey , dppNode in self . attachObject . propagateDppNodes . items ( ) }
   return iII ( iiI1iIi , iii1Oo ) . toDict ( )
   if 32 - 32: i1
  def getNextBatch ( self ) -> 'np.ndarray|Source.PreprocessedData' :
   if 46 - 46: Ii % oOO . I11iiIi11i1I . Iii1i . Oo / Ii
   if 45 - 45: I1Ii1I1
   if 42 - 42: i1i1i1111I % I1Ii1I1
   if 88 - 88: oOo0O00 . Ooo0Ooo + i1I * IiI11Ii111 - i1iiIII111 + IiI11Ii111
   if 32 - 32: ooo000 - ooOOO + i1iiIII111 + i1i1i1111I / Iii1i % oOO
   if 92 - 92: i1iiIII111 % ooOOO + I11iiIi11i1I
   if 56 - 56: oOO + IIiIIiIi11I1
   if 9 - 9: I1Ii1I1 / i1iiIII111 % ooo000 . Iii1i * oOO
   if 90 - 90: Ii
   if 79 - 79: oOo0O00 % I1Ii1I1 + IIiIIiIi11I1 * i1i1i1111I - IiI11Ii111
   if self . sourceType in [ "cifar10" , "cifar100" , "stl10" ] :
    if 95 - 95: oOO % I1Ii1I1 . OooOoo + ooOOO - ooOOO / i1i1i1111I
    if not self . _initialized :
     self . prepareIteration ( )
     self . initialize ( )
     if 95 - 95: OooOoo + I1I + Iii1i + I11iiIi11i1I + Oo
     if 100 - 100: IiIIii11Ii % IiI11Ii111 / ooo000
     if 66 - 66: oOO . IiIIii11Ii
    I1iIIiIiIII = iII . fromDict ( next ( self . _itr ) )
    I1iIIiIiIII . toArray ( )
    return I1iIIiIiIII
    if 26 - 26: Ooo0Ooo
   elif self . sourceType in [ "mnist" , "fashion-mnist" ] :
    if 30 - 30: IiIIii11Ii + ooo000 * i1I . oOO . Ii
    if not self . _initialized :
     self . initialize ( )
     self . prepareIteration ( )
     if 50 - 50: oOo0O00 * I1Ii1I1
     if 92 - 92: IIiIIiIi11I1 % IIiIIiIi11I1 % iI1iII1I1I1i
    IiIIiiII = self . _itrIdx
    o0OOOO0Oo0O = self . batchSize
    if 21 - 21: i1iiIII111 / IIiIIiIi11I1 * OooOoo - OooOoo
    if 73 - 73: I1Ii1I1 % I11iiIi11i1I + i1i1i1111I % oOO
    if ( self . dropRemainder and ( IiIIiiII + 1 ) * o0OOOO0Oo0O > self . epochSize ) or ( ( not self . dropRemainder ) and IiIIiiII * o0OOOO0Oo0O >= self . epochSize ) :
     self . prepareIteration ( )
     IiIIiiII = self . batchIdx
     if 18 - 18: IiIIii11Ii + iI1iII1I1I1i / I1Ii1I1
     if 36 - 36: Ii . IiI11Ii111
    self . batchIdxIncrement ( )
    if 22 - 22: IiI11Ii111 * Ooo0Ooo % IiI11Ii111 * OooOoo + Iii1i % IIiIIiIi11I1
    if 5 - 5: iI1iII1I1I1i * I11iiIi11i1I . i1i1i1111I % i1iiIII111
    oO00IiII1iII = { colName : c [ IiIIiiII * o0OOOO0Oo0O : ( IiIIiiII + 1 ) * o0OOOO0Oo0O ] for colName , c in { "input" : self . _imgData , "target" : self . _labelData } . items ( ) }
    if 40 - 40: IiI11Ii111 + Ooo0Ooo
    if 60 - 60: IiI11Ii111
    return oO00IiII1iII
    if 85 - 85: I11iiIi11i1I / I1I % i1I * Oo
  def getData ( self , start : int = None , end : int = None , indexes : List [ int ] = None ) -> 'np.ndarray' :
   if 86 - 86: OooOoo
   if 66 - 66: Oo
   if 3 - 3: oOO
   if 5 - 5: i1
   if 87 - 87: Ii * OooOoo + Ooo0Ooo . i1iiIII111 / IIiIIiIi11I1
   if 18 - 18: i1 + ooOOO + ooOOO . oOO * Iii1i % I1Ii1I1
   if 12 - 12: I1Ii1I1 - iI1iII1I1I1i . oOo0O00 + IIiIIiIi11I1
   if 17 - 17: OooOoo * Ooo0Ooo - ooOOO * i1I / Oo . IIiIIiIi11I1
   if 24 - 24: i1 % iI1iII1I1I1i
   if 42 - 42: i1I
   if 69 - 69: OooOoo * I11iiIi11i1I * Iii1i - I11iiIi11i1I + IiI11Ii111 + IiIIii11Ii
   if 78 - 78: i1I % IIiIIiIi11I1
   if 71 - 71: ooo000 / IiI11Ii111 . i1I - IIiIIiIi11I1
   if 95 - 95: ooo000
   if 68 - 68: IIiIIiIi11I1 * ooOOO + Oo * i1i1i1111I
   if self . sourceType in [ "mnist" , "fashion-mnist" ] :
    if 67 - 67: IIiIIiIi11I1 * I1Ii1I1 - i1I
    OO0O00oO0oO = { "input" : self . _imgData , "target" : self . _labelData } . items ( )
    if indexes :
     I1iIIiIiIII = { colName : c [ indexes ] for colName , c in indexes }
    elif start or end :
     I1iIIiIiIII = { colName : c [ start : end ] for colName , c in indexes }
    else :
     I1iIIiIiIII = { colName : c [ : ] for colName , c in indexes }
   else :
    if 11 - 11: I1Ii1I1
    I1iIIiIiIII = { "input" : [ ] , "target" : [ ] }
    if 90 - 90: i1 - i1I . Oo . IiIIii11Ii
   return I1iIIiIiIII
   if 63 - 63: Iii1i * oOo0O00
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> Any :
   if 46 - 46: i1i1i1111I / i1I
   if 13 - 13: I1I + IIiIIiIi11I1
   if 41 - 41: Ooo0Ooo + ooo000 - i1iiIII111 - oOo0O00
   if 19 - 19: IiI11Ii111
   if 69 - 69: ooo000 - IiIIii11Ii + iI1iII1I1I1i . Ii
   if 64 - 64: I11iiIi11i1I . i1i1i1111I
   if 40 - 40: I1Ii1I1 * Iii1i . I1Ii1I1
   if 87 - 87: i1I
   if 95 - 95: i1i1i1111I
   if 51 - 51: oOo0O00 + ooo000 / i1i1i1111I * IiI11Ii111
   if 29 - 29: I11iiIi11i1I / I11iiIi11i1I + OooOoo
   if 38 - 38: Ooo0Ooo
   oO00IiII1iII = None
   if 67 - 67: oOO % I1I % I11iiIi11i1I
   if 94 - 94: I1I
   oOo0OO = self . copy ( )
   oOo0OO . overrideConfig ( { "shuffle" : True , "batchSize" : min ( randomCount , oOo0OO . batchSize ) } )
   if 6 - 6: IIiIIiIi11I1 . iI1iII1I1I1i
   if 8 - 8: I1I + oOO
   I1II1ii11i1ii = self . attachObject . train . currentSourceDataset
   self . attachObject . train . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Test )
   if 72 - 72: i1I - I11iiIi11i1I + I1Ii1I1 * IiIIii11Ii * i1i1i1111I
   if 61 - 61: IiI11Ii111 + ooOOO . IiIIii11Ii + I1Ii1I1 % I1I + oOo0O00
   while randomCount > 0 :
    o000oo0 = oOo0OO . getNextBatch ( )
    if oO00IiII1iII is None :
     oO00IiII1iII = o000oo0
    else :
     oO00IiII1iII += o000oo0
    randomCount -= self . batchSize
    if 41 - 41: Ooo0Ooo / Oo
   oOo0OO . close ( )
   if 31 - 31: i1iiIII111 - oOo0O00 / ooOOO / IiIIii11Ii
   if 79 - 79: OooOoo
   self . attachObject . train . assignCurrentSourceDataset ( I1II1ii11i1ii )
   if 46 - 46: ooo000 * oOO
   return oO00IiII1iII
   if 45 - 45: ooOOO - I1I / Oo . IiIIii11Ii + IiI11Ii111
  def getVisualRandItems ( self , randomSeed : int = None , randomCount : int = None , visualRecord : int = None ) -> Any :
   if 28 - 28: OooOoo * Ii * IIiIIiIi11I1 * Ii - I11iiIi11i1I
   oO00IiII1iII = None
   if 26 - 26: ooOOO + Ooo0Ooo . i1iiIII111 / ooo000 . Iii1i
   oOo0OO = self . copy ( )
   oOo0OO . overrideConfig ( { "shuffle" : True , "batchSize" : min ( randomCount , oOo0OO . batchSize ) } )
   if 80 - 80: i1i1i1111I + ooOOO * ooOOO + I1I % Ii
   I1II1ii11i1ii = self . attachObject . train . currentSourceDataset
   self . attachObject . train . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Test )
   if 95 - 95: Ooo0Ooo % Ii
   OOoo0ooo0OoOO = None
   O00oO = None
   IiIiiIiIi1 = { i : 0 for i in range ( 10 ) }
   while randomCount > 0 :
    o000oo0 = oOo0OO . getNextBatch ( )
    for f , oO0OOOOOOoo in zip ( o000oo0 [ 'input' ] , o000oo0 [ 'target' ] ) :
     ooo00O0o0O = oO0OOOOOOoo [ 0 ]
     if ( IiIiiIiIi1 [ ooo00O0o0O ] < visualRecord ) :
      IiIiiIiIi1 [ ooo00O0o0O ] = IiIiiIiIi1 [ ooo00O0o0O ] + 1
      I111i = np . expand_dims ( f , axis = 0 )
      if OOoo0ooo0OoOO is None :
       OOoo0ooo0OoOO = I111i
      else :
       OOoo0ooo0OoOO = np . vstack ( ( OOoo0ooo0OoOO , I111i ) )
      if O00oO is None :
       O00oO = oO0OOOOOOoo
      else :
       O00oO = np . vstack ( ( O00oO , oO0OOOOOOoo ) )
      randomCount -= 1
     if randomCount == 0 :
      break
   oO00IiII1iII = { 'input' : OOoo0ooo0OoOO , 'target' : O00oO }
   oOo0OO . close ( )
   if 37 - 37: Ooo0Ooo - Oo . oOo0O00 - IiIIii11Ii % I11iiIi11i1I / iI1iII1I1I1i
   self . attachObject . train . assignCurrentSourceDataset ( I1II1ii11i1ii )
   return oO00IiII1iII
   if 52 - 52: I11iiIi11i1I % iI1iII1I1I1i % Ooo0Ooo * oOo0O00
  def close ( self ) :
   if 37 - 37: i1i1i1111I / I1Ii1I1
   if 41 - 41: IiIIii11Ii - Iii1i - oOO
   if 3 - 3: iI1iII1I1I1i
   if 80 - 80: IIiIIiIi11I1 * ooo000
   if 22 - 22: Oo + oOo0O00
   if 81 - 81: IiI11Ii111
   if 69 - 69: Ii . i1iiIII111 / IIiIIiIi11I1 . i1iiIII111 % iI1iII1I1I1i / I1I
   super ( ) . close ( )
   if self . _sess :
    self . _sess . close ( )
    if 92 - 92: i1iiIII111 / I1Ii1I1 . Ooo0Ooo . OooOoo - oOO / OooOoo
 class GeneratorController ( I111II1II111I . Controller ) :
  if 59 - 59: ooOOO . IiI11Ii111 - IIiIIiIi11I1 - IIiIIiIi11I1 - i1i1i1111I
  if 39 - 39: i1 % ooo000 % oOO + IIiIIiIi11I1 % I11iiIi11i1I
  if 89 - 89: IIiIIiIi11I1 % I1I * i1i1i1111I % i1I / ooo000 + IiIIii11Ii
  if 63 - 63: Ii * OooOoo * i1I + Oo
  if 17 - 17: i1I - I1Ii1I1 . IiIIii11Ii
  if 77 - 77: oOO - Ooo0Ooo . oOo0O00 - i1i1i1111I . ooOOO - oOO
  if 76 - 76: i1I
  def __init__ ( self , attachObject : Union [ 'Source.Image' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 90 - 90: Oo
   if 91 - 91: I1Ii1I1 . oOO
   if 62 - 62: i1 % I1Ii1I1 / Ii * iI1iII1I1I1i - i1i1i1111I * oOo0O00
   if 55 - 55: Ii - i1i1i1111I / I11iiIi11i1I / IiI11Ii111 - i1 . OooOoo
   if 16 - 16: i1iiIII111 - IiIIii11Ii / I1Ii1I1
   if 89 - 89: i1 + oOO * I1I - OooOoo / I1Ii1I1
   if 10 - 10: IiIIii11Ii . iI1iII1I1I1i . iI1iII1I1I1i + oOO
   if 2 - 2: i1I - i1I * ooOOO
   if 9 - 9: ooOOO - OooOoo
   if 72 - 72: i1I - Ii - i1 + Ooo0Ooo / I11iiIi11i1I
   super ( ) . __init__ ( attachObject = attachObject )
   if 99 - 99: iI1iII1I1I1i - Ii % Ooo0Ooo . I11iiIi11i1I
  def setSourceType ( self , sourceType : str , coreDataDir : str ) :
   if 90 - 90: Oo * Oo % ooOOO * iI1iII1I1I1i
   if 49 - 49: I1Ii1I1 / i1i1i1111I
   if 34 - 34: i1i1i1111I * i1I . OooOoo + Ooo0Ooo
   if 51 - 51: I1I / ooo000 . iI1iII1I1I1i
   if 58 - 58: i1iiIII111 % oOo0O00
   if 33 - 33: i1iiIII111 * Ooo0Ooo + OooOoo % i1iiIII111
   if 34 - 34: IIiIIiIi11I1 - Oo
   if 72 - 72: i1iiIII111 * Ooo0Ooo . oOO
   if 86 - 86: Ii - i1i1i1111I . ooOOO % oOO
   if 36 - 36: oOo0O00 - I11iiIi11i1I * Ii
   if 29 - 29: iI1iII1I1I1i - Ooo0Ooo * Oo
   if 10 - 10: oOo0O00 - i1iiIII111 . oOO
   for ooo0oO in self . values ( ) :
    ooo0oO . sourceType = sourceType
    if 25 - 25: Oo - I11iiIi11i1I * iI1iII1I1I1i . Oo / ooOOO
    if 30 - 30: IiI11Ii111
   if sourceType == "cifar10" :
    self [ I111II1II111I . Dataset . Types . Train ] . _fileNames = [ coreDataDir + 'cifar-10-batches-bin/data_batch_%d.bin' % i for i in range ( 1 , 6 ) ]
    self [ I111II1II111I . Dataset . Types . Test ] . _fileNames = [ coreDataDir + 'cifar-10-batches-bin/test_batch.bin' ]
    self [ I111II1II111I . Dataset . Types . Train ] . _epochSize = 50000
    self [ I111II1II111I . Dataset . Types . Test ] . _epochSize = 10000
   elif sourceType == "cifar100" :
    self [ I111II1II111I . Dataset . Types . Train ] . _fileNames = [ coreDataDir + 'cifar-100-binary/train.bin' ]
    self [ I111II1II111I . Dataset . Types . Test ] . _fileNames = [ coreDataDir + 'cifar-100-binary/test.bin' ]
    self [ I111II1II111I . Dataset . Types . Train ] . _epochSize = 50000
    self [ I111II1II111I . Dataset . Types . Test ] . _epochSize = 10000
   elif sourceType == "stl10-labeled" :
    self [ I111II1II111I . Dataset . Types . Train ] . _fileNames = { "input" : [ coreDataDir + 'stl10-binary/train_X.bin' ] , "target" : [ coreDataDir + 'stl10-binary/train_y.bin' ] }
    self [ I111II1II111I . Dataset . Types . Test ] . _fileNames = { "input" : [ coreDataDir + 'stl10-binary/test_X.bin' ] , "target" : [ coreDataDir + 'stl10-binary/test_y.bin' ] }
    self [ I111II1II111I . Dataset . Types . Train ] . _epochSize = 5000
    self [ I111II1II111I . Dataset . Types . Test ] . _epochSize = 8000
   elif sourceType == "mnist" :
    self [ I111II1II111I . Dataset . Types . Train ] . _fileNames = { "input" : [ coreDataDir + 'train-images.idx3-ubyte' ] , "target" : [ coreDataDir + 'train-labels.idx1-ubyte' ] }
    self [ I111II1II111I . Dataset . Types . Test ] . _fileNames = { "input" : [ coreDataDir + 't10k-images.idx3-ubyte' ] , "target" : [ coreDataDir + 't10k-labels.idx1-ubyte' ] }
    self [ I111II1II111I . Dataset . Types . Train ] . _epochSize = 60000
    self [ I111II1II111I . Dataset . Types . Test ] . _epochSize = 10000
   elif sourceType == "fashion-mnist" :
    self [ I111II1II111I . Dataset . Types . Train ] . _fileNames = { "input" : [ coreDataDir + 'train-images-idx3-ubyte' ] , "target" : [ coreDataDir + 'train-labels-idx1-ubyte' ] }
    self [ I111II1II111I . Dataset . Types . Test ] . _fileNames = { "input" : [ coreDataDir + 't10k-images-idx3-ubyte' ] , "target" : [ coreDataDir + 't10k-labels-idx1-ubyte' ] }
    self [ I111II1II111I . Dataset . Types . Train ] . _epochSize = 60000
    self [ I111II1II111I . Dataset . Types . Test ] . _epochSize = 10000
   self [ I111II1II111I . Dataset . Types . Test ] . _shuffle = False
   if 100 - 100: I1Ii1I1
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.Image.GeneratorDetail' ] :
   if 7 - 7: i1i1i1111I % I1I % IiI11Ii111 - Oo
   if 17 - 17: IiI11Ii111 % iI1iII1I1I1i * Oo
   if 86 - 86: I1I - oOO
   if 70 - 70: OooOoo - Ii + Ii * oOo0O00 / OooOoo / ooOOO
   if 1 - 1: ooOOO . i1i1i1111I % Oo
   if 32 - 32: oOO . oOO . i1 . i1I - iI1iII1I1I1i
   if 88 - 88: ooOOO / i1i1i1111I * ooOOO - OooOoo / Ooo0Ooo * i1iiIII111
   if 33 - 33: i1iiIII111 % Ii . Iii1i . i1i1i1111I / Oo
   if 29 - 29: ooOOO / iI1iII1I1I1i . i1i1i1111I % I1Ii1I1 + ooo000 - i1
   if 23 - 23: i1I + ooOOO / IIiIIiIi11I1 % i1iiIII111
   return iiI1i11iii . GeneratorDetail
   if 47 - 47: i1iiIII111 / i1iiIII111 * IIiIIiIi11I1 % iI1iII1I1I1i % i1I * i1I
 def __init__ ( self , sourceType : str = "cifar10" , coreDataDir : str = None , flattenImg : bool = False , name : str = "" ) :
  if 56 - 56: i1 / I11iiIi11i1I
  if 56 - 56: I1Ii1I1 + iI1iII1I1I1i % ooOOO * OooOoo
  if 20 - 20: i1i1i1111I + iI1iII1I1I1i * IiIIii11Ii
  if 27 - 27: IiI11Ii111 * Ooo0Ooo * iI1iII1I1I1i - i1 + OooOoo - Oo
  if 97 - 97: OooOoo
  if 63 - 63: i1iiIII111 * oOO
  if 95 - 95: Ii
  if 57 - 57: Ii % oOo0O00 / IiIIii11Ii - IIiIIiIi11I1 - Iii1i * IIiIIiIi11I1
  if 85 - 85: I1Ii1I1 . ooOOO . ooOOO - IiIIii11Ii
  if 41 - 41: i1i1i1111I
  if 84 - 84: oOO * OooOoo * I1I
  if 36 - 36: IiI11Ii111 - i1 % oOO . i1iiIII111 + iI1iII1I1I1i * i1iiIII111
  if 37 - 37: iI1iII1I1I1i . Ii
  super ( ) . __init__ ( name = name )
  self . _instanceClass = I1ooOoO0OooO . Image
  if 55 - 55: I1I % IIiIIiIi11I1 - Iii1i - ooo000
  self . generatorController = iiI1i11iii . GeneratorController ( self )
  if 74 - 74: iI1iII1I1I1i % IiI11Ii111 % OooOoo * I11iiIi11i1I
  if 49 - 49: Ii * oOO
  if 22 - 22: IiI11Ii111 / Iii1i . IiIIii11Ii
  self . _sourceType = None
  if 35 - 35: ooo000 . iI1iII1I1I1i
  if 89 - 89: ooOOO
  self . coreDataDir = coreDataDir if ( coreDataDir is not None ) else ( "D:/tmp/" + ( "cifar10_data/" if sourceType == "cirfar10" else "cifar100_data/" if sourceType == "cirfar100" else "mnist" if sourceType == "mnist/" else "fashion-mnist" if sourceType == "fashion-mnist/" else "" ) )
  if 7 - 7: OooOoo % I1Ii1I1 / ooOOO
  if 7 - 7: Ooo0Ooo - Ooo0Ooo * ooo000 . Ii + ooOOO - ooo000
  self . flattenImg = flattenImg
  if 21 - 21: oOO % Ooo0Ooo * I1I - I11iiIi11i1I
  if 2 - 2: I1I
  if sourceType :
   self . setSourceType ( sourceType )
   if 26 - 26: I1I
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 99 - 99: I11iiIi11i1I + iI1iII1I1I1i * Ii % iI1iII1I1I1i
  if 58 - 58: iI1iII1I1I1i - IiIIii11Ii * i1 % Oo
  if 27 - 27: i1i1i1111I * i1I / I11iiIi11i1I - i1iiIII111 + i1I / Ooo0Ooo
  if 34 - 34: IiI11Ii111 * I1I * oOO % Ooo0Ooo % Oo
  if 91 - 91: I1I
  if 76 - 76: ooOOO + oOo0O00 / Ii
  if 42 - 42: i1i1i1111I * I1Ii1I1 - i1iiIII111
  if 47 - 47: Ii % i1i1i1111I % I11iiIi11i1I - IiI11Ii111 - IIiIIiIi11I1 - OooOoo
  if 97 - 97: iI1iII1I1I1i % Ooo0Ooo / IiIIii11Ii . i1i1i1111I . Iii1i
  if 87 - 87: I1I + IiIIii11Ii
  if 72 - 72: IiI11Ii111 % i1iiIII111
  if 18 - 18: Ii % Iii1i . i1I
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "generatorController" :
    if 56 - 56: I11iiIi11i1I . Ii
    self . generatorController . parseFromJSON ( iiiiIi1IiiIi )
    if 100 - 100: i1I
   elif Ii1I == "outputsetInfo" :
    if 69 - 69: ooo000 * I1I / i1i1i1111I * ooo000 - IiI11Ii111 + i1
    setattr ( self , Ii1I , { ok : ov for ( ok , ov ) in iiiiIi1IiiIi } )
    if 58 - 58: Ii + i1i1i1111I
   elif Ii1I == "_propagateDppNodes" :
    setattr ( self , Ii1I , set ( iiiiIi1IiiIi ) )
    if 5 - 5: Ii % Iii1i
   elif Ii1I not in [ "_testRatio" , "_hasHeader" , "batchSize" , "colConfigs" , "shuffle" , "epochSize" , "dppNodes" , "_type" , "_train" , "train" , "_instanceClass" ] :
    if 52 - 52: IiI11Ii111
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 43 - 43: IIiIIiIi11I1 * Iii1i / IiI11Ii111 . oOo0O00 / ooOOO
    if 16 - 16: I1Ii1I1 % ooOOO / I1Ii1I1 % I1Ii1I1 / oOo0O00
  self . train = train
  if 60 - 60: IiIIii11Ii
 @ property
 def train ( self ) -> 'Train' :
  if 84 - 84: Oo * i1i1i1111I + i1iiIII111
  if 82 - 82: IiIIii11Ii % oOo0O00
  if 72 - 72: IiI11Ii111 + iI1iII1I1I1i % i1i1i1111I * IiI11Ii111 . Ooo0Ooo
  if 82 - 82: OooOoo . i1 . Ooo0Ooo % ooo000 % i1i1i1111I
  if 82 - 82: oOO . i1I / IiI11Ii111 + i1iiIII111 - IIiIIiIi11I1 / Oo
  if 19 - 19: Iii1i * I1Ii1I1 + Iii1i + I1Ii1I1 % IIiIIiIi11I1
  if 37 - 37: IiI11Ii111 . Oo % oOo0O00 - oOo0O00
  if 30 - 30: IIiIIiIi11I1 * I1I
  if 4 - 4: Ii . Ii % I1Ii1I1 - IiI11Ii111 % i1i1i1111I
  if 94 - 94: Ii % ooOOO
  return self . _train
  if 13 - 13: ooOOO
 @ train . setter
 def train ( self , train : 'Train' ) -> 'Train' :
  if 7 - 7: I1I / ooOOO . ooo000 - IIiIIiIi11I1
  if 26 - 26: Ii
  if 93 - 93: ooo000 . ooo000 + IiI11Ii111 . i1i1i1111I * i1iiIII111
  if 72 - 72: I1I + I11iiIi11i1I . Ooo0Ooo % ooOOO - i1 - i1i1i1111I
  if 95 - 95: i1iiIII111 + I1I / Ooo0Ooo * Oo / IiI11Ii111
  if 2 - 2: i1i1i1111I - ooo000
  if 43 - 43: I11iiIi11i1I / ooOOO + Oo
  if 83 - 83: i1 - I1Ii1I1
  if 83 - 83: I1Ii1I1 - IIiIIiIi11I1 / Ooo0Ooo * ooOOO / i1I + ooo000
  if 21 - 21: IiIIii11Ii / I1I * OooOoo + I1Ii1I1
  if 59 - 59: ooOOO - Ii % Ooo0Ooo - Ooo0Ooo - i1I . Ooo0Ooo
  if 41 - 41: i1I + i1iiIII111 / ooOOO
  if 37 - 37: i1i1i1111I + Ooo0Ooo - I1Ii1I1 + i1I + i1
  if 24 - 24: oOO / oOO + IIiIIiIi11I1 % Ooo0Ooo
  if any ( [ s . splittable != self . splittable for s in train . sources ] ) :
   raise ValueError ( "Sources are incompatible within the Train object. All sources should have consistent splittable nature." )
   if 10 - 10: Ii
   if 85 - 85: ooOOO % OooOoo % IIiIIiIi11I1
  self . _train = train
  if 6 - 6: Ii % iI1iII1I1I1i % Oo * I1I
  if 12 - 12: iI1iII1I1I1i % I11iiIi11i1I / I11iiIi11i1I + OooOoo . I11iiIi11i1I . I1Ii1I1
  train . sources . append ( self )
  if 7 - 7: ooo000 * ooo000 + OooOoo . I11iiIi11i1I % I1I * Ooo0Ooo
  if 67 - 67: oOO - Ii - i1i1i1111I
  self . setSourceType ( self . sourceType )
  if 45 - 45: ooOOO . IiI11Ii111 / IiI11Ii111 / oOO % i1i1i1111I
  if 84 - 84: i1I - IIiIIiIi11I1 - Iii1i + oOo0O00 + Ooo0Ooo
  return self . _train
  if 35 - 35: I1I * Ii * IIiIIiIi11I1 - Ii / I11iiIi11i1I - Ii
 @ property
 def sourceType ( self ) -> str :
  if 98 - 98: I1Ii1I1 % iI1iII1I1I1i
  if 95 - 95: oOO % Ii
  if 75 - 75: I11iiIi11i1I % i1I * i1 + iI1iII1I1I1i - oOo0O00
  if 58 - 58: IiI11Ii111 - Iii1i / i1iiIII111 + Ii . IiIIii11Ii * oOO
  if 92 - 92: oOO - oOo0O00
  if 77 - 77: Ii - IiIIii11Ii . OooOoo + i1i1i1111I + I11iiIi11i1I
  if 66 - 66: I11iiIi11i1I * Ii % IiIIii11Ii * IiIIii11Ii
  if 3 - 3: I11iiIi11i1I - ooOOO % i1I / i1I
  if 48 - 48: Iii1i * IiI11Ii111 * oOO . oOo0O00 . I11iiIi11i1I % I1I
  if 43 - 43: I1Ii1I1
  return self . _sourceType
  if 55 - 55: I11iiIi11i1I / i1I - Ii
 def setSourceType ( self , sourceType : str ) :
  if 42 - 42: i1 - iI1iII1I1I1i . iI1iII1I1I1i * oOO - Oo
  if 7 - 7: oOO * i1 . IiIIii11Ii . i1iiIII111 - ooOOO
  if 13 - 13: Iii1i
  if 26 - 26: Ooo0Ooo
  if 75 - 75: OooOoo - I1I . I1Ii1I1 % oOO / Oo
  if 52 - 52: ooOOO . ooOOO / I1I
  if 19 - 19: I1Ii1I1 + IiI11Ii111 * I11iiIi11i1I / oOo0O00 * Iii1i
  if 55 - 55: I1I + oOO / oOo0O00
  if 47 - 47: iI1iII1I1I1i + IiI11Ii111
  if 98 - 98: ooOOO * IiI11Ii111 . I1I - iI1iII1I1I1i + Oo
  if 69 - 69: I11iiIi11i1I / I1I + OooOoo / Oo / IiI11Ii111
  self . _sourceType = sourceType
  if 45 - 45: I1Ii1I1
  if 13 - 13: ooOOO + I11iiIi11i1I * oOO - IiI11Ii111 * Ii - I11iiIi11i1I
  self . generatorController . setSourceType ( sourceType , self . coreDataDir )
  if 57 - 57: IIiIIiIi11I1 - Ii + IiI11Ii111
  if 2 - 2: Oo - I1I + ooo000 + i1 * Iii1i . oOO
  if sourceType == "cifar10" :
   self . outputsetInfo [ "input" ] = IiiIii1I1iIiII ( [ "Images" ] , [ None , 32 , 32 , 3 ] )
   self . outputsetInfo [ "target" ] = IiiIii1I1iIiII ( [ "Class Labels" ] , [ None , 1 ] )
  elif sourceType == "cifar100" :
   self . outputsetInfo [ "input" ] = IiiIii1I1iIiII ( [ "Images" ] , [ None , 32 , 32 , 3 ] )
   self . outputsetInfo [ "target" ] = IiiIii1I1iIiII ( [ "Class Labels" , "Fine Class Lables" ] , [ None , 2 ] )
  elif sourceType == "stl10-labeled" :
   self . outputsetInfo [ "input" ] = IiiIii1I1iIiII ( [ "Images" ] , [ None , 96 , 96 , 3 ] )
   self . outputsetInfo [ "target" ] = IiiIii1I1iIiII ( [ "Class Labels" ] , [ None , 1 ] )
  elif sourceType == "mnist" :
   self . outputsetInfo [ "input" ] = IiiIii1I1iIiII ( [ "Images" ] , [ None , 28 , 28 , 1 ] )
   self . outputsetInfo [ "target" ] = IiiIii1I1iIiII ( [ "Class Labels" ] , [ None , 1 ] )
  elif sourceType == "fashion-mnist" :
   self . outputsetInfo [ "input" ] = IiiIii1I1iIiII ( [ "Images" ] , [ None , 28 , 28 , 1 ] )
   self . outputsetInfo [ "target" ] = IiiIii1I1iIiII ( [ "Class Labels" ] , [ None , 1 ] )
   if 20 - 20: i1i1i1111I / Oo
   if 16 - 16: I11iiIi11i1I . oOo0O00 / I11iiIi11i1I
  if self . train :
   self . initializeDefaultDppNodes ( )
   if 54 - 54: Oo . i1i1i1111I + I1I - i1iiIII111 + IIiIIiIi11I1 + I11iiIi11i1I
 def initializeDefaultDppNodes ( self ) :
  if 68 - 68: oOo0O00 . iI1iII1I1I1i + oOo0O00
  if 62 - 62: IiIIii11Ii + oOO
  if 59 - 59: i1iiIII111 * ooo000 - i1i1i1111I - i1 - oOo0O00
  if 35 - 35: i1I - iI1iII1I1I1i % I1I / i1i1i1111I
  if 99 - 99: i1I
  if 57 - 57: IiIIii11Ii - Ii / oOo0O00
  if 42 - 42: Ii - IIiIIiIi11I1
  if 35 - 35: Oo - i1i1i1111I / I1I + Ooo0Ooo % OooOoo % Ooo0Ooo
  ii11I111ii = o0oo0o ( dtype = tf . float32 )
  ii11I111ii . appendOn ( self , "input" , "input" )
  self . addPropagateDppNodes ( "input" )
  if 57 - 57: Ii + iI1iII1I1I1i + iI1iII1I1I1i + Ii * iI1iII1I1I1i % oOo0O00
  if 88 - 88: ooOOO
  if self . sourceType in [ "cifar10" , "cifar100" ] :
   ii11I111ii . setTransform ( Oo000oO00O . ImageAugmentation . Flip ( ) )
   ii11I111ii . setTransform ( Oo000oO00O . ImageAugmentation . Brightness ( ) )
   ii11I111ii . setTransform ( Oo000oO00O . ImageAugmentation . Contrast ( ) )
   ii11I111ii . setTransform ( Oo000oO00O . Image . Normalize ( ) )
  elif self . sourceType in [ "fashion-mnist" , "mnist" ] :
   ii11I111ii . setTransform ( Oo000oO00O . Image . Normalize ( ) )
  else :
   ii11I111ii . clearTransform ( )
   if 16 - 16: i1iiIII111 + Oo . Oo * i1iiIII111
   if 77 - 77: i1 % oOO . IiIIii11Ii
  if self . sourceType in [ "cifar10" , "cifar100" , "stl10-labeled" , "fashion-mnist" , "mnist" ] :
   o0OOoOOOO0O = Ii1Ii1iii ( dtype = "tf.int64" )
   if 71 - 71: ooOOO + IiI11Ii111 / ooo000 - i1i1i1111I / Iii1i
   if 66 - 66: IIiIIiIi11I1 * oOO + oOo0O00 + Ii / I11iiIi11i1I
   if self . sourceType in [ "cifar10" , "stl10-labeled" , "fashion-mnist" , "mnist" ] :
    o0OOoOOOO0O . setClassCount ( 10 )
   elif self . sourceType == "cifar100" :
    o0OOoOOOO0O . setClassCount ( 100 )
    if 93 - 93: oOO * Oo * i1
    if 74 - 74: i1iiIII111 * IiI11Ii111 . ooOOO . iI1iII1I1I1i - I11iiIi11i1I . Ooo0Ooo
   o0OOoOOOO0O . appendOn ( self , "target" , "target" )
   if 90 - 90: Iii1i / IiIIii11Ii % ooo000 * I1Ii1I1
  else :
   self . train . dppNodes . remove ( "target" )
   self . removePropagateDppNodes ( "target" )
   if 49 - 49: IiI11Ii111 / I1Ii1I1
 def getData ( self , sourceDataset = None , start : int = None , end : int = None , batchIndexes : List [ int ] = None ) -> 'np.ndarray' :
  if 35 - 35: IiIIii11Ii
  if 12 - 12: Ii + i1i1i1111I
  if 60 - 60: iI1iII1I1I1i % I1I . Ooo0Ooo
  if 34 - 34: OooOoo
  if 42 - 42: Oo + i1I % Iii1i + Oo % ooo000 * ooOOO
  if 71 - 71: IIiIIiIi11I1 * IiI11Ii111 / oOO - ooo000
  if 41 - 41: iI1iII1I1I1i
  if 74 - 74: IiIIii11Ii % OooOoo
  if 47 - 47: iI1iII1I1I1i * oOo0O00
  if 88 - 88: ooOOO . i1iiIII111 - i1i1i1111I - iI1iII1I1I1i
  if 29 - 29: iI1iII1I1I1i - i1i1i1111I * iI1iII1I1I1i + iI1iII1I1I1i % i1I / i1
  if 1 - 1: oOO . oOO % IiI11Ii111 . I1Ii1I1
  if 3 - 3: I11iiIi11i1I / i1I / I1I - i1iiIII111 + i1
  if 22 - 22: IIiIIiIi11I1 % I11iiIi11i1I % IIiIIiIi11I1
  if 2 - 2: OooOoo / OooOoo . ooOOO * Ooo0Ooo + Oo + Ooo0Ooo
  if 99 - 99: ooo000
  raise ValueError ( "Using deprecated API." )
  if 49 - 49: ooOOO * i1I + I11iiIi11i1I + Iii1i / IIiIIiIi11I1
  if 36 - 36: I1I
  if sourceDataset is not None :
   return self . generatorController [ sourceDataset ] . getData ( start = start , end = end , batchIndexes = batchIndexes )
   if 75 - 75: oOo0O00 . IiIIii11Ii * OooOoo + I11iiIi11i1I / i1I
class O0OOO ( O0 ) :
 if 20 - 20: Oo - iI1iII1I1I1i . i1 . ooo000 % Ii
 if 71 - 71: i1I % OooOoo
 if 9 - 9: OooOoo - OooOoo * ooOOO * i1i1i1111I
 if 49 - 49: IIiIIiIi11I1 - I11iiIi11i1I / Ooo0Ooo
 if 71 - 71: i1iiIII111 . i1i1i1111I - ooo000 . Oo / i1iiIII111 - Ooo0Ooo
 if 24 - 24: OooOoo % i1 / i1 % i1
 if 9 - 9: Ooo0Ooo + IIiIIiIi11I1
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 49 - 49: I1I - i1I - oOO % i1I
  if 3 - 3: I11iiIi11i1I
  if 39 - 39: I1I * ooOOO % IiIIii11Ii % IiIIii11Ii . IiI11Ii111 * ooo000
  if 77 - 77: I1I . I1Ii1I1 / i1i1i1111I * oOo0O00 / i1I
  if 47 - 47: I1Ii1I1 / i1I % Iii1i
  if 25 - 25: I1I + Ooo0Ooo
  if 14 - 14: i1 + Iii1i % IiIIii11Ii
  def __init__ ( self , controller : 'Source.CustomImage.GeneratorController' ) :
   if 10 - 10: i1I % I1Ii1I1 + iI1iII1I1I1i
   if 62 - 62: oOo0O00 / oOo0O00 . Ooo0Ooo * IiIIii11Ii - Ii
   if 37 - 37: i1 * I1Ii1I1 % I11iiIi11i1I * I1Ii1I1
   if 30 - 30: Ooo0Ooo - oOO
   if 5 - 5: ooo000 - i1i1i1111I / I1Ii1I1 + IIiIIiIi11I1 * Oo
   if 57 - 57: iI1iII1I1I1i - Ooo0Ooo + I1Ii1I1 - Ii
   if 25 - 25: ooo000 - i1I . ooOOO
   if 35 - 35: IIiIIiIi11I1 % i1I % IiIIii11Ii + Ii
   if 7 - 7: IiI11Ii111 - OooOoo - Ooo0Ooo
   if 18 - 18: I11iiIi11i1I - IIiIIiIi11I1 % Ooo0Ooo
   super ( ) . __init__ ( controller )
   if 16 - 16: oOO - i1I / oOO - oOO % i1I . OooOoo
   self . sourceType = None
   if 70 - 70: Iii1i
   self . _labelShape = [ ]
   if 65 - 65: IIiIIiIi11I1 . ooo000 * oOO * OooOoo
   self . _hasHeader : bool = False
   if 15 - 15: i1iiIII111 - oOO % ooo000
   self . _path : str = None
   if 71 - 71: I1Ii1I1
   self . _fileNames : Union [ List [ str ] , Dict [ str , List [ str ] ] ] = None
   if 22 - 22: ooOOO / Oo - Oo + i1i1i1111I
   self . encoding : str = None
   if 85 - 85: i1 - i1i1i1111I
   self . _imgData = np . array ( [ ] , dtype = float )
   if 87 - 87: Ooo0Ooo - ooo000 / Oo . I11iiIi11i1I
   self . _oriCSVData : np . ndarray = None
   if 30 - 30: oOO - Oo + iI1iII1I1I1i
   self . _labelData = np . array ( [ ] , dtype = float )
   if 3 - 3: IIiIIiIi11I1 % i1i1i1111I . IiIIii11Ii + Ooo0Ooo . oOO + Iii1i
   self . _imgGraph = None
   if 37 - 37: i1iiIII111 % i1iiIII111 - i1iiIII111 + I1Ii1I1
   self . _itr = None
   if 49 - 49: Ooo0Ooo - ooOOO - i1i1i1111I * IiIIii11Ii + Iii1i - IiI11Ii111
   self . _nextLabels = None
   if 80 - 80: IiI11Ii111
   self . _nextImg = None
   if 7 - 7: oOO % IiIIii11Ii + i1i1i1111I * iI1iII1I1I1i
   self . _imgRawShape = [ ]
   if 35 - 35: I11iiIi11i1I / i1i1i1111I % Iii1i % Ii + i1I . i1iiIII111
   self . _imgBytes = 0
   if 52 - 52: i1I * oOo0O00
   self . _targetBytes = 0
   if 34 - 34: i1 + I1Ii1I1 / IIiIIiIi11I1 . I11iiIi11i1I * i1i1i1111I + i1iiIII111
   self . _labelDict = { }
   if 12 - 12: Ooo0Ooo - IIiIIiIi11I1 . i1I + I1I - I1I . Ooo0Ooo
   self . outputsetInfo = { }
   if 95 - 95: i1I / I1Ii1I1 - Oo
   self . _datasetType = "Train"
   if 82 - 82: ooo000 - Ii + IiI11Ii111 / OooOoo / iI1iII1I1I1i
  def copy ( self ) -> 'Source.CustomImage.Detail' :
   if 89 - 89: IiIIii11Ii - i1i1i1111I
   if 37 - 37: OooOoo * ooOOO . oOo0O00 + I11iiIi11i1I - Ooo0Ooo . I11iiIi11i1I
   if 76 - 76: IiIIii11Ii - OooOoo + oOO . I1Ii1I1 - iI1iII1I1I1i . ooo000
   if 56 - 56: OooOoo + iI1iII1I1I1i . Iii1i . Ii * Oo
   if 70 - 70: ooOOO % IiIIii11Ii - oOO - I1Ii1I1 - i1i1i1111I
   if 65 - 65: I11iiIi11i1I . Ooo0Ooo . ooo000 / I1Ii1I1 . i1I . Ooo0Ooo
   if 17 - 17: oOO - Ooo0Ooo * ooOOO . Iii1i + IiI11Ii111
   if 86 - 86: IIiIIiIi11I1 % iI1iII1I1I1i + Ooo0Ooo . oOO . IiIIii11Ii
   if 13 - 13: I11iiIi11i1I % Ooo0Ooo * Ii / oOo0O00
   if 28 - 28: I11iiIi11i1I - i1i1i1111I % i1iiIII111 * Oo % i1i1i1111I + Iii1i
   if 69 - 69: I1Ii1I1 % i1iiIII111 - IiIIii11Ii / IiIIii11Ii - Ooo0Ooo * IiI11Ii111
   ii1IIiIIi : I1ii11II11 . CustomImage . GeneratorDetail = O0OOO . GeneratorDetail ( self . controller )
   if 88 - 88: ooOOO
   if 68 - 68: ooOOO / i1iiIII111 . i1i1i1111I - iI1iII1I1I1i
   for Ii1I in [ "_epochSize" , "_oriShape" , "_batchSize" , "_shuffle" , "_imgData" , "_labelData" , "sourceType" , "_labelShape" , "_fileNames" , "_imgRawShape" , "_imgBytes" , "_targetBytes" , "outputsetInfo" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 79 - 79: i1iiIII111 % i1iiIII111 - I1I * ooOOO % I1I - oOo0O00
   return ii1IIiIIi
   if 26 - 26: IiIIii11Ii
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 23 - 23: oOO
   if 83 - 83: I11iiIi11i1I + Ii
   if 83 - 83: oOO % OooOoo
   if 43 - 43: Ooo0Ooo
   if 96 - 96: i1i1i1111I % ooo000
   if 59 - 59: I1Ii1I1 * iI1iII1I1I1i * ooo000 % ooOOO - Iii1i . Ii
   if 10 - 10: i1 % ooOOO
   if 35 - 35: Ii / IIiIIiIi11I1 * i1 * Iii1i . I11iiIi11i1I
   if 28 - 28: Iii1i - oOO * Iii1i % I1I + IIiIIiIi11I1 - IiI11Ii111
   if 74 - 74: i1iiIII111 % IiI11Ii111 . IiIIii11Ii - oOO / oOo0O00 + i1iiIII111
   if 37 - 37: ooo000
   for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
    if Ii1I == "_path" :
     iiiiIi1IiiIi = obj [ Ii1I ]
     if iiiiIi1IiiIi != None :
      self . path = iiiiIi1IiiIi
     else :
      if 36 - 36: IIiIIiIi11I1 % Ooo0Ooo - IiI11Ii111 % i1I - Ii % I1I
      if 19 - 19: I11iiIi11i1I / oOO + i1I . Iii1i + Iii1i . Oo
      for Oo0OOo000oo in [ "_hasHeader" , "encoding" , "_path" , "_fileNames" ] :
       setattr ( self , Oo0OOo000oo , obj [ Oo0OOo000oo ] )
    elif Ii1I not in [ "_controller" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 6 - 6: i1I % i1 % i1iiIII111 - i1iiIII111 % i1iiIII111
  @ property
  def oriData ( self ) -> 'np.ndarray' :
   if 22 - 22: Ooo0Ooo - I1Ii1I1
   if 53 - 53: I1I + iI1iII1I1I1i - i1iiIII111 . oOO - i1I % i1
   if 64 - 64: I1I . IIiIIiIi11I1 % ooo000 / Oo / I11iiIi11i1I - I11iiIi11i1I
   if 22 - 22: i1i1i1111I / oOo0O00 + iI1iII1I1I1i % IiI11Ii111 * oOo0O00
   if 60 - 60: i1 % i1iiIII111 / IIiIIiIi11I1 * I1Ii1I1
   if 49 - 49: oOo0O00
   if 37 - 37: IiI11Ii111 . IiIIii11Ii / OooOoo * OooOoo * I11iiIi11i1I
   if 6 - 6: Ii % i1I
   if 72 - 72: OooOoo . i1 + OooOoo + oOo0O00 / oOO
   if 37 - 37: Oo * ooOOO / i1I + IIiIIiIi11I1
   return self . _oriData
   if 62 - 62: I1Ii1I1 - I11iiIi11i1I - Ooo0Ooo + IiIIii11Ii + Iii1i
  @ property
  def epochSize ( self ) -> int :
   if 46 - 46: I11iiIi11i1I / i1 + oOo0O00 . i1 + oOo0O00 * OooOoo
   if 36 - 36: IiIIii11Ii + I1Ii1I1 / i1 . IiI11Ii111
   if 37 - 37: IiIIii11Ii . i1 / oOO . oOo0O00 + i1
   if 63 - 63: Ooo0Ooo / I1Ii1I1 * i1I + i1iiIII111 + oOO
   if 86 - 86: i1iiIII111 % I1Ii1I1
   if 12 - 12: IiIIii11Ii % IiI11Ii111 - i1iiIII111
   if 62 - 62: ooo000 - I1Ii1I1 . oOo0O00 + Ii
   if 10 - 10: oOo0O00
   if 25 - 25: i1iiIII111 . ooOOO
   if 68 - 68: i1 . I1Ii1I1 - IIiIIiIi11I1 . I11iiIi11i1I % iI1iII1I1I1i
   return ( self . _oriShape [ 0 ] if len ( self . _oriShape ) else None ) if self . _epochSize is None else self . _epochSize
   if 72 - 72: i1i1i1111I + IiIIii11Ii * Ii
  @ property
  def hasHeader ( self ) -> bool :
   if 47 - 47: OooOoo % ooo000 % Ii * IIiIIiIi11I1
   if 33 - 33: I1Ii1I1 + I11iiIi11i1I % iI1iII1I1I1i - i1iiIII111 + oOo0O00
   if 19 - 19: oOO * i1
   if 73 - 73: IIiIIiIi11I1 + I1Ii1I1
   if 82 - 82: Iii1i * oOO * iI1iII1I1I1i . IIiIIiIi11I1 / IiIIii11Ii + OooOoo
   if 48 - 48: i1 % oOo0O00 % i1iiIII111 / ooo000 % I1Ii1I1
   if 99 - 99: oOo0O00 - Oo
   if 89 - 89: Oo
   if 24 - 24: i1
   if 73 - 73: Oo . IIiIIiIi11I1 - I1I
   return self . _hasHeader
   if 57 - 57: IiI11Ii111 * Ooo0Ooo - I1Ii1I1
  def setData ( self , inputArray : Union [ list , 'np.ndarray' ] = [ ] , outputArray : Union [ list , 'np.ndarray' ] = [ ] , hasHeader : bool = True ) :
   if 81 - 81: Ii / Oo / ooOOO + OooOoo + oOO / IiI11Ii111
   if 78 - 78: ooOOO * iI1iII1I1I1i
   if 43 - 43: I1I + ooOOO - OooOoo . IIiIIiIi11I1 * oOO
   if 3 - 3: OooOoo * Iii1i * OooOoo % I1Ii1I1
   if 57 - 57: IiIIii11Ii . IiI11Ii111 % i1iiIII111
   if 94 - 94: OooOoo + Ii / IiIIii11Ii + Oo * ooOOO * I1Ii1I1
   if 39 - 39: Ooo0Ooo % IIiIIiIi11I1 / Ii . i1I
   if 75 - 75: ooOOO - I1Ii1I1 . i1I + ooo000 + oOO
   if 69 - 69: IiI11Ii111 . Oo . OooOoo . i1i1i1111I % iI1iII1I1I1i % ooOOO
   if 19 - 19: ooOOO % i1i1i1111I . iI1iII1I1I1i . OooOoo
   if 27 - 27: Ooo0Ooo * Iii1i - i1
   if 67 - 67: i1I
   if 4 - 4: i1
   OoOOOooo000 : str = self . sourceType
   self . _hasHeader = hasHeader
   if 13 - 13: I11iiIi11i1I . i1i1i1111I - Ii % i1
   if 54 - 54: i1 . ooOOO
   o0oi11I1iIi1IIiI = np . array ( inputArray )
   o00000 = np . array ( outputArray )
   self . _epochSize = len ( o00000 )
   if 9 - 9: i1 * Ii / Oo
   if 4 - 4: i1 - IiIIii11Ii * I11iiIi11i1I + i1i1i1111I / Ooo0Ooo . OooOoo
   if len ( o0oi11I1iIi1IIiI ) == 0 or len ( o00000 ) == 0 :
    raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
   elif len ( o0oi11I1iIi1IIiI ) != len ( o00000 ) :
    raise ValueError ( "Data and labels do not match" )
    if 11 - 11: I11iiIi11i1I % IiI11Ii111
   try :
    if OoOOOooo000 == "imageclassify" :
     if 86 - 86: Ooo0Ooo
     o0Oo0O = len ( o00000 [ 0 ] ) if o00000 . shape [ - 1 ] else 0
     o00o0oooo0 = ( "None:" + str ( o0Oo0O ) ) if o0Oo0O > 0 else None
     if 54 - 54: IiI11Ii111
     iIIII11i = o0oo0o ( dtype = tf . float32 )
     if 72 - 72: OooOoo - i1iiIII111 + i1iiIII111
     iIIII11i . appendOn ( self . attachObject , "input" , "input" )
     if 44 - 44: i1i1i1111I % Ii
     if 79 - 79: ooOOO
     if 20 - 20: IiIIii11Ii % i1iiIII111 - IiIIii11Ii % i1 . IIiIIiIi11I1
     oOOO0oOoo = Ii1Ii1iii ( sourceCol = o00o0oooo0 )
     if 19 - 19: oOo0O00 * IiIIii11Ii
     oOOO0oOoo . appendOn ( self . attachObject , "target" , "target" )
    elif OoOOOooo000 == "imageimage" :
     if 78 - 78: OooOoo % ooOOO - Ooo0Ooo - Oo / Ooo0Ooo
     iIIII11i = o0oo0o ( dtype = tf . float32 )
     iIIII11i . appendOn ( self . attachObject , "input" , "input" )
     if 90 - 90: i1iiIII111 % i1iiIII111 + Ooo0Ooo - Iii1i
     oOOO0oOoo = o0oo0o ( dtype = tf . float32 )
     oOOO0oOoo . appendOn ( self . attachObject , "target" , "target" )
   except :
    pass
    if 43 - 43: oOO - Oo % ooo000 - IiI11Ii111 / Iii1i
  def readCSVFile ( self , path = "" , encoding = "utf8" , hasHeader = True ) :
   if 20 - 20: ooOOO - I11iiIi11i1I . Oo / ooOOO % i1I
   if 48 - 48: Ii % ooOOO - IiI11Ii111 + Ooo0Ooo % i1i1i1111I / oOO
   if 68 - 68: Oo * I11iiIi11i1I * IiI11Ii111 - I11iiIi11i1I
   if 66 - 66: I1I / Oo + Ooo0Ooo % Iii1i * IiIIii11Ii % I11iiIi11i1I
   if 50 - 50: i1iiIII111
   if 87 - 87: i1iiIII111
   if 46 - 46: oOo0O00 . iI1iII1I1I1i * Oo % I1Ii1I1 / IiIIii11Ii
   if 15 - 15: i1iiIII111 - I11iiIi11i1I / Ii
   if 75 - 75: IiIIii11Ii
   if 70 - 70: ooOOO % Ii % I11iiIi11i1I / Oo % Ii * ooOOO
   if 13 - 13: Ii . iI1iII1I1I1i % I1Ii1I1 % I1I % ooo000 * I1Ii1I1
   if 41 - 41: Ii + oOo0O00 * i1I . i1 / iI1iII1I1I1i
   try :
    if 27 - 27: Ii - oOO
    with open ( path , encoding = encoding ) as f :
     IIi11ii1IIi = [ * csv . reader ( f ) ]
     if 93 - 93: I11iiIi11i1I
     if 23 - 23: I1Ii1I1 - oOO / IiIIii11Ii % i1iiIII111 - ooo000
    O00O0o = { r [ 0 ] : np . array ( r [ 1 : ] ) for r in IIi11ii1IIi if len ( r ) }
    if 8 - 8: ooo000 * I1I
    if 100 - 100: i1iiIII111 % Ii % Iii1i . ooOOO
    if 71 - 71: i1i1i1111I % oOO - oOO + oOo0O00 * Ooo0Ooo . IiIIii11Ii
    self . encoding = encoding
    self . _hasHeader = hasHeader
    if 84 - 84: i1i1i1111I
   except :
    raise ValueError ( "CSV file cannot be correctly read." )
    if 56 - 56: IiI11Ii111 / IiI11Ii111 * Oo / iI1iII1I1I1i % i1 / Ii
    if 85 - 85: I11iiIi11i1I * I11iiIi11i1I - i1 % IIiIIiIi11I1 % iI1iII1I1I1i - Ii
    if 39 - 39: Oo + i1I
   return O00O0o
   if 76 - 76: i1I / i1 . Iii1i
  def readFile ( self , path = "" , encoding = "utf8" , hasHeader = True ) :
   if 54 - 54: Ooo0Ooo + oOo0O00 % IiIIii11Ii * IIiIIiIi11I1 % oOo0O00
   if 83 - 83: oOo0O00
   if 42 - 42: I11iiIi11i1I
   if 63 - 63: IiIIii11Ii - Oo
   if 48 - 48: oOo0O00 + oOo0O00 / i1I + Iii1i / OooOoo
   if 92 - 92: i1
   if 38 - 38: Ii / ooOOO / I1I - I11iiIi11i1I / i1
   if 24 - 24: I1Ii1I1 . iI1iII1I1I1i % I1I * i1 + IiI11Ii111
   if 33 - 33: Oo
   if 57 - 57: i1i1i1111I - iI1iII1I1I1i
   if 70 - 70: I11iiIi11i1I + i1iiIII111 - oOO
   if 50 - 50: oOO / IIiIIiIi11I1 + I1I + Oo / Ooo0Ooo . ooOOO
   OoOOOooo000 : str = self . sourceType
   II1 : str = self . _datasetType . lower ( )
   OoOI1 : str = II1 + "data"
   Ooo0000000o0o : str = II1 + "label"
   if 60 - 60: oOo0O00 . i1 / Oo
   if not OoOOOooo000 :
    if 47 - 47: i1I % oOO % I11iiIi11i1I * Iii1i - ooo000 + OooOoo
    try :
     if 69 - 69: i1iiIII111
     self . _hasHeader = hasHeader
     self . _labelDict = self . readCSVFile ( self . _path + "label.csv" )
     if 78 - 78: ooo000 / I11iiIi11i1I
     if 65 - 65: i1 * Oo . Oo * Ooo0Ooo * Iii1i * Ooo0Ooo
     ( iIIII11iIi , iIIII11iIi , iI11iI ) = next ( os . walk ( self . _path + "traindata" ) )
     self . _imgData = np . vstack ( [ np . array ( [ tf . image . convert_image_dtype ( tf . image . decode_image ( tf . io . read_file ( self . _path + "traindata/" + f ) ) , tf . float32 ) ] ) for f in iI11iI if len ( f ) ] )
     self . _labelData = np . vstack ( [ np . array ( self . _labelDict [ f ] ) for f in iI11iI if len ( f ) ] )
    except :
     ( iIIII11iIi , iIIII11iIi , iI11iI ) = next ( os . walk ( self . _path + "traindata" ) )
     self . _imgData = np . vstack ( [ np . array ( [ tf . image . convert_image_dtype ( tf . image . decode_image ( tf . io . read_file ( self . _path + "traindata/" + f ) ) , tf . float32 ) ] ) for f in iI11iI if len ( f ) ] )
     self . _labelData = np . vstack ( [ np . array ( [ tf . image . convert_image_dtype ( tf . image . decode_image ( tf . io . read_file ( self . _path + "trainlabel/" + f ) ) , tf . float32 ) ] ) for f in iI11iI if len ( f ) ] )
     if 36 - 36: ooo000
   elif OoOOOooo000 == "imageclassify" :
    if 50 - 50: i1 . IIiIIiIi11I1 + Ooo0Ooo * i1i1i1111I / Oo
    self . _hasHeader = hasHeader
    self . _labelDict = self . readCSVFile ( self . _path + "label.csv" )
    if 73 - 73: I1Ii1I1 % Oo * i1 % i1i1i1111I
    if 90 - 90: I11iiIi11i1I . iI1iII1I1I1i % IiIIii11Ii + i1
    ( iIIII11iIi , iIIII11iIi , iI11iI ) = next ( os . walk ( self . _path + OoOI1 ) )
    self . _imgData = np . vstack ( [ np . array ( [ tf . image . convert_image_dtype ( tf . image . decode_image ( tf . io . read_file ( self . _path + OoOI1 + '/' + f ) ) , tf . float32 ) ] ) for f in iI11iI if len ( f ) ] )
    self . _labelData = np . vstack ( [ np . array ( self . _labelDict [ f ] ) for f in iI11iI if len ( f ) ] )
    if 45 - 45: I11iiIi11i1I
    if 93 - 93: Ooo0Ooo % I11iiIi11i1I / oOO + oOo0O00
    if 98 - 98: OooOoo - ooo000 * i1I - IiIIii11Ii
    if 6 - 6: IiIIii11Ii + I11iiIi11i1I
    if 72 - 72: i1iiIII111 . I1I / i1iiIII111 / IIiIIiIi11I1 + IiIIii11Ii
    if 78 - 78: oOo0O00 * oOO % ooo000 - IiI11Ii111
   elif OoOOOooo000 == "imageimage" :
    ( iIIII11iIi , iIIII11iIi , iI11iI ) = next ( os . walk ( self . _path + OoOI1 ) )
    self . _imgData = np . vstack ( [ np . array ( [ tf . image . convert_image_dtype ( tf . image . decode_image ( tf . io . read_file ( self . _path + OoOI1 + '/' + f ) ) , tf . float32 ) ] ) for f in iI11iI if len ( f ) ] )
    self . _labelData = np . vstack ( [ np . array ( [ tf . image . convert_image_dtype ( tf . image . decode_image ( tf . io . read_file ( self . _path + Ooo0000000o0o + '/' + f ) ) , tf . float32 ) ] ) for f in iI11iI if len ( f ) ] )
    if 57 - 57: oOo0O00
    if 24 - 24: I1Ii1I1 . oOo0O00
   self . setData ( inputArray = self . _imgData , outputArray = self . _labelData , hasHeader = hasHeader )
   if 36 - 36: I11iiIi11i1I * Ii % I1Ii1I1
   if 92 - 92: IIiIIiIi11I1 * Ii
   if 91 - 91: Iii1i + OooOoo
   if 34 - 34: I11iiIi11i1I . i1I - IIiIIiIi11I1 % i1iiIII111 % OooOoo % I11iiIi11i1I
  @ property
  def path ( self ) -> str :
   if 90 - 90: ooo000 * Ooo0Ooo % Oo - i1I + Ooo0Ooo . i1I
   if 51 - 51: Iii1i * IiIIii11Ii . i1I * oOO % i1iiIII111
   if 13 - 13: i1i1i1111I
   if 82 - 82: oOO
   if 97 - 97: OooOoo * I1Ii1I1 + Ooo0Ooo
   if 36 - 36: i1iiIII111
   if 10 - 10: i1iiIII111 % i1I % i1i1i1111I / IiI11Ii111
   if 13 - 13: IiIIii11Ii - IiIIii11Ii % Oo / ooo000 + Ii / IiI11Ii111
   if 64 - 64: IiI11Ii111 * iI1iII1I1I1i . IIiIIiIi11I1
   if 53 - 53: Ii + iI1iII1I1I1i . Iii1i / I1I
   return self . _path
   if 22 - 22: i1iiIII111 / IiIIii11Ii % OooOoo - oOO * I11iiIi11i1I / i1iiIII111
  @ path . setter
  def path ( self , val : str ) :
   if 84 - 84: Oo - Oo / IIiIIiIi11I1 + IiIIii11Ii % IiIIii11Ii
   if 7 - 7: I11iiIi11i1I + oOO - oOo0O00 . oOO % i1iiIII111 - Iii1i
   if 78 - 78: Oo / i1I - I1Ii1I1
   if 10 - 10: ooo000 - IiI11Ii111 - IIiIIiIi11I1 - i1i1i1111I
   if 62 - 62: i1 % Iii1i . ooo000
   if 16 - 16: IIiIIiIi11I1 - IiI11Ii111 % oOo0O00 + IiIIii11Ii + IIiIIiIi11I1 . Ii
   if 29 - 29: I1I
   if 50 - 50: I11iiIi11i1I * i1 - IiI11Ii111 / Oo . oOO + ooOOO
   if 27 - 27: Oo . i1i1i1111I / ooOOO / IIiIIiIi11I1 % I1Ii1I1 + OooOoo
   if 64 - 64: IiI11Ii111 % i1iiIII111 / OooOoo
   self . _path = val
   self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader )
   if 39 - 39: oOo0O00 . i1I / ooOOO % Oo . oOo0O00 . oOO
  def prepareIteration ( self ) :
   if 67 - 67: iI1iII1I1I1i
   if 40 - 40: I11iiIi11i1I % Oo . IiI11Ii111
   if 23 - 23: i1 - I11iiIi11i1I - I1Ii1I1 - oOO
   if 97 - 97: i1iiIII111 / IiI11Ii111 . IiI11Ii111 * OooOoo + i1i1i1111I + oOo0O00
   if 46 - 46: i1I % i1I
   if 88 - 88: i1i1i1111I % I1I + Ii . Iii1i + I1I - I11iiIi11i1I
   if 92 - 92: i1I - I11iiIi11i1I * iI1iII1I1I1i + i1I + i1iiIII111
   if 12 - 12: i1iiIII111 - Oo - Iii1i + i1iiIII111 / ooOOO
   o0OOOO0Oo0O : int = self . batchSize
   if 84 - 84: ooo000 . Iii1i . i1iiIII111
   if 28 - 28: oOO + i1I
   if len ( self . _imgData ) == 0 or len ( self . _labelData ) == 0 :
    self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader )
    if 61 - 61: ooo000 % IIiIIiIi11I1 % i1i1i1111I
    if 21 - 21: Iii1i
   IiiI111III : 'tf.data.Dataset' = tf . data . Dataset . from_tensor_slices ( ( self . _imgData , self . _labelData ) )
   IiiI111III = IiiI111III . map ( lambda OOoo00ooOo00O , oOO0OooooooO : self . mapDatasetImages ( OOoo00ooOo00O , oOO0OooooooO ) )
   if 54 - 54: I11iiIi11i1I * IiIIii11Ii / iI1iII1I1I1i - i1I / iI1iII1I1I1i
   if 72 - 72: ooOOO * i1i1i1111I
   if self . shuffle :
    IiiI111III = IiiI111III . shuffle ( buffer_size = self . epochSize , reshuffle_each_iteration = True )
   IiiI111III = IiiI111III . repeat ( )
   IiiI111III = IiiI111III . batch ( o0OOOO0Oo0O , drop_remainder = self . dropRemainder )
   if 24 - 24: Ii - i1 % IiIIii11Ii + I1I - iI1iII1I1I1i . Oo
   if 14 - 14: I1Ii1I1
   self . _itr = IiiI111III . __iter__ ( )
   if 42 - 42: OooOoo * IiI11Ii111 * i1iiIII111 - i1 - iI1iII1I1I1i % i1
  def mapDatasetImages ( self , img , label ) -> Dict [ str , Any ] :
   if 87 - 87: i1i1i1111I + iI1iII1I1I1i
   if 96 - 96: Iii1i / Ii + ooo000 + iI1iII1I1I1i + ooOOO % ooo000
   if 51 - 51: OooOoo - Oo - i1i1i1111I / oOo0O00 / Oo . i1
   if 94 - 94: IiIIii11Ii - i1
   if 58 - 58: i1I / iI1iII1I1I1i
   if 69 - 69: i1 . IiIIii11Ii - I1Ii1I1
   if 31 - 31: IiIIii11Ii + ooOOO
   if 80 - 80: I1Ii1I1 * I11iiIi11i1I . iI1iII1I1I1i - i1iiIII111 * Ii
   if 16 - 16: I1I / oOo0O00 * I1I + Ooo0Ooo * IiIIii11Ii
   if 89 - 89: i1iiIII111 . I1Ii1I1 / Ooo0Ooo - IiI11Ii111 / i1iiIII111
   if 56 - 56: IiIIii11Ii % ooOOO . OooOoo * IIiIIiIi11I1 / ooOOO . I11iiIi11i1I
   if 44 - 44: I1I . i1 . I11iiIi11i1I
   if 33 - 33: Ooo0Ooo * ooo000
   if 10 - 10: I1I
   if 47 - 47: oOO % ooOOO % IIiIIiIi11I1 + i1iiIII111 - I1Ii1I1 . IiI11Ii111
   iiI1iIi = { "target" : label , "input" : img }
   if 59 - 59: IiI11Ii111 * oOO % IiI11Ii111
   if 1 - 1: i1i1i1111I
   i11iiiIIi = { }
   i11iiiIIi [ self . attachObject . sourceID ] = iiI1iIi
   o00O0o0O = I1i11iii1iI1 ( i11iiiIIi )
   if 15 - 15: oOO
   iii1Oo = { dppKey : dppNode . getProcessedData ( o00O0o0O ) for dppKey , dppNode in self . attachObject . propagateDppNodes . items ( ) }
   return iII ( iiI1iIi , iii1Oo ) . toDict ( )
   if 14 - 14: Iii1i + I1Ii1I1 + i1iiIII111 % i1I % i1
  def getNextBatch ( self ) -> 'np.ndarray|Source.PreprocessedData' :
   if 93 - 93: oOO
   if 20 - 20: Iii1i
   if 57 - 57: Ii . IIiIIiIi11I1 % i1I - Ii % oOO
   if 64 - 64: Ooo0Ooo + ooOOO / IIiIIiIi11I1
   if 81 - 81: iI1iII1I1I1i / oOO / Ii / i1I . Ii / Ooo0Ooo
   if 28 - 28: ooo000 % Oo
   if 55 - 55: OooOoo
   if 20 - 20: ooOOO - OooOoo
   if 90 - 90: IIiIIiIi11I1
   if 71 - 71: iI1iII1I1I1i / i1i1i1111I - IiIIii11Ii . Iii1i * i1i1i1111I * oOO
   OoOOOooo000 : str = self . sourceType
   if 100 - 100: IiIIii11Ii / i1iiIII111
   if 12 - 12: I1I . oOO
   if not self . _initialized :
    self . prepareIteration ( )
    self . initialize ( )
    if 28 - 28: I11iiIi11i1I
    if 32 - 32: I1I % I1I
    if 37 - 37: I1Ii1I1 / ooOOO - ooOOO / Iii1i
   I1iIIiIiIII = iII . fromDict ( next ( self . _itr ) )
   I1iIIiIiIII . toArray ( )
   return I1iIIiIiIII
   if 5 - 5: IIiIIiIi11I1 . I1Ii1I1 + IiI11Ii111 + oOo0O00 . ooOOO * IIiIIiIi11I1
  def partition ( self , prop : float = 0.2 , shuffle : bool = False ) -> Tuple [ 'np.ndarray' , 'np.ndarray' ] :
   if 31 - 31: i1 / ooo000 / Ii - Ooo0Ooo - I1Ii1I1
   if 94 - 94: Iii1i % IiI11Ii111 * i1I * Ooo0Ooo + i1iiIII111 . OooOoo
   if 40 - 40: Iii1i + oOo0O00 % iI1iII1I1I1i - Oo * Ii . OooOoo
   if 57 - 57: IIiIIiIi11I1 * IiI11Ii111 % oOO
   if 53 - 53: IIiIIiIi11I1 - Oo % Ooo0Ooo . IiI11Ii111 + Ii
   if 17 - 17: I1I % I11iiIi11i1I * i1I
   if 56 - 56: I1I + ooo000 * IIiIIiIi11I1 * ooo000
   if 28 - 28: iI1iII1I1I1i
   if 22 - 22: iI1iII1I1I1i % iI1iII1I1I1i / iI1iII1I1I1i + I1I * oOO . I1Ii1I1
   if 87 - 87: Oo % i1i1i1111I / i1 / ooo000 % iI1iII1I1I1i . i1I
   if 21 - 21: ooo000 + OooOoo * I1Ii1I1 / OooOoo
   if 42 - 42: ooo000 + i1 * IiI11Ii111
   if 52 - 52: IiI11Ii111 / OooOoo * Ooo0Ooo - Oo % IIiIIiIi11I1 % ooo000
   if 73 - 73: I1I / I1Ii1I1 . i1i1i1111I + i1iiIII111
   if 98 - 98: oOO % ooOOO + Ooo0Ooo % i1I - oOO + oOo0O00
   IiOoOOOoO0 = self . epochSize
   iII11i1 = math . floor ( IiOoOOOoO0 * prop )
   if 58 - 58: ooo000
   if len ( self . _imgData ) == 0 or len ( self . _labelData ) == 0 :
    self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader )
   OO00O0O0OO00o = self . _imgData
   IIiIiIiIIIiiI = self . _labelData
   if 94 - 94: IiI11Ii111
   if 65 - 65: Ii % i1i1i1111I % i1iiIII111 + ooo000 . oOo0O00
   if shuffle :
    i11I1 = np . arange ( len ( IIiIiIiIIIiiI ) )
    np . random . shuffle ( i11I1 )
    OO00O0O0OO00o = OO00O0O0OO00o [ i11I1 ]
    IIiIiIiIIIiiI = IIiIiIiIIIiiI [ i11I1 ]
    if 50 - 50: Ooo0Ooo / Ii + IiIIii11Ii % i1I * i1iiIII111 + i1i1i1111I
    if 39 - 39: iI1iII1I1I1i + I1Ii1I1 / Oo % Ii - i1iiIII111
   ooOOoO0 = ( OO00O0O0OO00o [ iII11i1 : ] , IIiIiIiIIIiiI [ iII11i1 : ] )
   O0o0OOO00o = ( OO00O0O0OO00o [ : iII11i1 ] , IIiIiIiIIIiiI [ : iII11i1 ] )
   if 16 - 16: i1i1i1111I % ooOOO / IIiIIiIi11I1
   if 76 - 76: Ii - Iii1i + OooOoo
   if 6 - 6: i1i1i1111I + iI1iII1I1I1i + Iii1i / I1Ii1I1
   if 33 - 33: Oo * IiI11Ii111 * IiIIii11Ii . ooo000 / Ooo0Ooo / I1I
   if 76 - 76: oOO / Ooo0Ooo + Ii % IiIIii11Ii
   if 83 - 83: OooOoo - IiIIii11Ii
   if 53 - 53: IiIIii11Ii - I11iiIi11i1I + i1I . Oo . Oo * IIiIIiIi11I1
   return ooOOoO0 , O0o0OOO00o
   if 7 - 7: OooOoo % Oo * IIiIIiIi11I1 . Ooo0Ooo
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> Any :
   if 35 - 35: i1I * i1I
   if 56 - 56: ooo000
   if 60 - 60: ooOOO / IiIIii11Ii - Iii1i
   if 62 - 62: I1Ii1I1 . iI1iII1I1I1i % I1Ii1I1 * oOO + oOO * IIiIIiIi11I1
   if 14 - 14: I1Ii1I1 / I11iiIi11i1I
   if 61 - 61: OooOoo + I11iiIi11i1I * i1I
   if 4 - 4: IiIIii11Ii
   if 51 - 51: i1i1i1111I + OooOoo % i1I * oOo0O00
   if 86 - 86: i1iiIII111 . Ii
   if 36 - 36: I1I % i1i1i1111I % IIiIIiIi11I1
   if 25 - 25: Iii1i . ooo000 % i1iiIII111 * IIiIIiIi11I1 * iI1iII1I1I1i % i1I
   if 63 - 63: ooOOO
   oO00IiII1iII = None
   if 13 - 13: ooOOO - IiI11Ii111 / i1I
   if 34 - 34: i1i1i1111I / IiIIii11Ii
   oOo0OO = self . copy ( )
   oOo0OO . overrideConfig ( { "shuffle" : True , "batchSize" : min ( randomCount , oOo0OO . batchSize ) } )
   if 92 - 92: Ooo0Ooo - oOO * i1I / IIiIIiIi11I1 / I1I
   if 7 - 7: i1 - IiI11Ii111 * iI1iII1I1I1i / IIiIIiIi11I1 . oOo0O00 / oOO
   I1II1ii11i1ii = self . attachObject . train . currentSourceDataset
   self . attachObject . train . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Test )
   if 42 - 42: i1iiIII111 - oOo0O00 % i1I * IiI11Ii111
   if 1 - 1: i1I . ooOOO - i1I % iI1iII1I1I1i / iI1iII1I1I1i + i1I
   while randomCount > 0 :
    o000oo0 = oOo0OO . getNextBatch ( )
    if oO00IiII1iII is None :
     oO00IiII1iII = o000oo0
    else :
     oO00IiII1iII += o000oo0
    randomCount -= self . batchSize
    if 20 - 20: I11iiIi11i1I . IiIIii11Ii + i1i1i1111I / ooo000
   oOo0OO . close ( )
   if 51 - 51: oOo0O00 . oOo0O00 / ooOOO
   if 70 - 70: Ooo0Ooo - Oo * Oo
   self . attachObject . train . assignCurrentSourceDataset ( I1II1ii11i1ii )
   if 57 - 57: Ooo0Ooo . i1 / I1Ii1I1 . ooOOO
   return oO00IiII1iII
   if 66 - 66: I11iiIi11i1I % i1i1i1111I
 class GeneratorController ( I111II1II111I . Controller ) :
  if 28 - 28: Ii / IIiIIiIi11I1 / IiIIii11Ii / i1iiIII111 - I1Ii1I1 / Ooo0Ooo
  if 23 - 23: oOo0O00 + i1 % Oo
  if 41 - 41: OooOoo * i1I
  if 28 - 28: Oo
  if 13 - 13: ooo000 % IiIIii11Ii % oOo0O00 . IiIIii11Ii
  if 8 - 8: IiIIii11Ii % IiI11Ii111 + i1i1i1111I * oOo0O00 / oOO * Ooo0Ooo
  if 56 - 56: Ii . i1iiIII111 . i1 - ooOOO . I1I
  def __init__ ( self , attachObject : Union [ 'Source.CustomImage' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 60 - 60: Oo . I1I + i1I % I1Ii1I1
   if 93 - 93: oOo0O00
   if 38 - 38: i1iiIII111 / i1iiIII111 % i1i1i1111I / i1i1i1111I
   if 7 - 7: IIiIIiIi11I1
   if 77 - 77: I1Ii1I1 % iI1iII1I1I1i . Ii - IIiIIiIi11I1 + OooOoo - IiI11Ii111
   if 61 - 61: i1 / i1iiIII111 / Ooo0Ooo
   if 47 - 47: OooOoo / oOo0O00 % Iii1i - Oo
   if 20 - 20: oOO % ooOOO * I1Ii1I1 + ooo000 % i1I * i1
   if 29 - 29: ooOOO % I1Ii1I1 - i1I - IIiIIiIi11I1 * Ii
   if 61 - 61: iI1iII1I1I1i / Iii1i % IIiIIiIi11I1 % I1I / I1I * oOO
   super ( ) . __init__ ( attachObject = attachObject )
   if 82 - 82: ooo000
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.CustomImage.GeneratorDetail' ] :
   if 78 - 78: IiIIii11Ii * iI1iII1I1I1i . i1 % I11iiIi11i1I
   if 68 - 68: IiIIii11Ii * oOO + IiI11Ii111 % Oo
   if 81 - 81: oOo0O00 + ooo000
   if 91 - 91: IiIIii11Ii * OooOoo / i1I % iI1iII1I1I1i
   if 44 - 44: i1 * IiI11Ii111
   if 86 - 86: oOO % Ii - Ii . I1Ii1I1
   if 44 - 44: i1I * I1Ii1I1 % i1I % iI1iII1I1I1i
   if 89 - 89: i1I * iI1iII1I1I1i % oOo0O00 . Ooo0Ooo
   if 67 - 67: IiI11Ii111 % I1I - iI1iII1I1I1i / i1iiIII111 - ooOOO
   if 3 - 3: IiIIii11Ii + oOO . I1I
   return O0OOO . GeneratorDetail
   if 97 - 97: ooOOO % I1I . ooo000
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 17 - 17: IiI11Ii111 % i1iiIII111 + oOo0O00 + IIiIIiIi11I1 + i1I
   if 17 - 17: IiI11Ii111 * Iii1i - I1Ii1I1 % ooo000 * I11iiIi11i1I
   if 73 - 73: OooOoo . i1i1i1111I * oOO . oOO + oOO
   if 43 - 43: IiI11Ii111 / I1Ii1I1
   if 77 - 77: oOO - ooo000 * IiIIii11Ii
   if 3 - 3: OooOoo + ooo000 + Ii / Iii1i % Ii
   if 5 - 5: i1
   if 89 - 89: Iii1i . ooOOO - I1Ii1I1 . Ii - Iii1i
   if 80 - 80: Ii
   if 29 - 29: OooOoo
   for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
    if 68 - 68: iI1iII1I1I1i
    if Ii1I == "_datasets" :
     for I1Iii , i1iIii11II1Ii11 in iiiiIi1IiiIi . items ( ) :
      iiI1 = I111II1II111I . Dataset . Types . parse ( I1Iii )
      if iiI1 not in self :
       self [ iiI1 ] = self [ I111II1II111I . Dataset . Types . Train ] . copy ( )
      self [ iiI1 ] . _datasetType = iiI1 . name
      self [ iiI1 ] . parseFromJSON ( i1iIii11II1Ii11 )
      if 86 - 86: IiI11Ii111 / IiI11Ii111 * oOo0O00 * oOo0O00 * ooOOO - ooo000
      if 100 - 100: ooo000 / IiI11Ii111
    elif Ii1I not in [ "_attachObject" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 50 - 50: IIiIIiIi11I1 . i1 - oOO
  def setSourceType ( self , sourceType : str , coreDataDir : str ) :
   if 50 - 50: i1i1i1111I * I11iiIi11i1I
   if 52 - 52: i1iiIII111 + IiIIii11Ii
   if 41 - 41: Iii1i - Ii - IIiIIiIi11I1
   if 65 - 65: IiIIii11Ii
   if 40 - 40: iI1iII1I1I1i
   if 15 - 15: I11iiIi11i1I % IiI11Ii111
   if 77 - 77: Iii1i % i1i1i1111I . Ooo0Ooo - OooOoo
   if 11 - 11: I11iiIi11i1I % i1 - i1i1i1111I
   if 36 - 36: Ii * i1 * i1
   if 14 - 14: I1I / I1Ii1I1 + i1iiIII111
   if 26 - 26: Ii / oOO
   if 81 - 81: I1Ii1I1 . IIiIIiIi11I1 * oOo0O00 * IiI11Ii111 % IiI11Ii111 / i1i1i1111I
   for ooo0oO in self . values ( ) :
    ooo0oO . sourceType = sourceType
    if 77 - 77: Iii1i
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 95 - 95: i1i1i1111I
   if 17 - 17: Ii + IIiIIiIi11I1 . i1 / ooOOO + ooo000
   if 93 - 93: i1I - IiIIii11Ii * ooo000 / oOO
   if 97 - 97: oOO . ooo000 / i1i1i1111I % ooOOO + OooOoo
   if 31 - 31: i1I / i1I . IiI11Ii111 - oOO % Ii
   if 90 - 90: i1i1i1111I % oOO % i1i1i1111I
   if 62 - 62: Iii1i
   if 15 - 15: Oo % iI1iII1I1I1i % iI1iII1I1I1i
   if 2 - 2: ooOOO + ooOOO / I11iiIi11i1I - OooOoo
   if 12 - 12: I1I * i1I % oOo0O00 . IiIIii11Ii
   if 47 - 47: IiIIii11Ii
   if 53 - 53: oOo0O00 * I1Ii1I1 * OooOoo . ooOOO + oOo0O00 - OooOoo
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   IiOoOOOoO0 = Oooo0OOO . epochSize
   if 67 - 67: i1I + OooOoo + i1iiIII111 * i1I / oOo0O00 / OooOoo
   if 89 - 89: i1I
   if 2 - 2: IiIIii11Ii / oOo0O00 % i1
   if randomFold :
    ( i1I1i , OoOOIiiiI111 ) = Oooo0OOO . partition ( prop = validation , shuffle = True )
    if 95 - 95: IiI11Ii111 + Iii1i / i1iiIII111
    if 2 - 2: i1I % IIiIIiIi11I1 % I11iiIi11i1I + i1iiIII111
   else :
    if 20 - 20: I1Ii1I1 - IiI11Ii111 + OooOoo
    oo0oOo0O0 = math . floor ( 1 / validation )
    IiIIiiII = self . validationTime % oo0oOo0O0
    if 99 - 99: I11iiIi11i1I % Ooo0Ooo - ooOOO
    OO00O0O0OO00o = self . _imgData
    IIiIiIiIIIiiI = self . _labelData
    if 3 - 3: ooo000
    if 74 - 74: Ooo0Ooo + Iii1i % Ooo0Ooo . oOo0O00
    if IiIIiiII == 0 and Oooo0OOO . shuffle :
     if 36 - 36: i1 / iI1iII1I1I1i * i1i1i1111I . oOo0O00 * i1iiIII111 . IiIIii11Ii
     i11I1 = np . arange ( len ( IIiIiIiIIIiiI ) )
     np . random . shuffle ( i11I1 )
     OO00O0O0OO00o = OO00O0O0OO00o [ i11I1 ]
     IIiIiIiIIIiiI = IIiIiIiIIIiiI [ i11I1 ]
     if 9 - 9: IiIIii11Ii . iI1iII1I1I1i . i1iiIII111 - I11iiIi11i1I - i1i1i1111I - OooOoo
     if 31 - 31: I11iiIi11i1I * ooo000 - ooo000
    ii1i1II1iiiI = math . ceil ( IiOoOOOoO0 / oo0oOo0O0 )
    I1I1111 = IiIIiiII * ii1i1II1iiiI
    oOO0o00 = ( IiIIiiII + 1 ) * ii1i1II1iiiI
    if 21 - 21: Ii % i1i1i1111I % IiI11Ii111 . Ooo0Ooo
    if 31 - 31: ooo000 / I1Ii1I1
    i1I1i = ( np . vstack ( ( OO00O0O0OO00o [ : I1I1111 ] , OO00O0O0OO00o [ oOO0o00 : ] ) ) , np . vstack ( ( IIiIiIiIIIiiI [ : I1I1111 ] , IIiIiIiIIIiiI [ oOO0o00 : ] ) ) )
    OoOOIiiiI111 = ( OO00O0O0OO00o [ I1I1111 : oOO0o00 ] , IIiIiIiIIIiiI [ I1I1111 : oOO0o00 ] )
    if 48 - 48: I11iiIi11i1I - Ooo0Ooo
    if 28 - 28: iI1iII1I1I1i
    if 8 - 8: I1I
    if 100 - 100: Oo * ooo000 * oOO * IiI11Ii111 % I11iiIi11i1I - Ii
    if 32 - 32: OooOoo * i1
    if 13 - 13: i1I + oOO + ooOOO - i1I
    if 10 - 10: i1iiIII111 . Iii1i % Ii / IIiIIiIi11I1
   self [ I111II1II111I . Dataset . Types . ValidationTrain ] . setData ( inputArray = i1I1i [ 0 ] , outputArray = i1I1i [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Validation ] . setData ( inputArray = OoOOIiiiI111 [ 0 ] , outputArray = OoOOIiiiI111 [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   if 13 - 13: Ooo0Ooo + Oo . IiI11Ii111 . IiIIii11Ii % IIiIIiIi11I1 % I1Ii1I1
   if 35 - 35: i1i1i1111I . i1i1i1111I * i1
   self . validationTime += 1
   if 74 - 74: i1 * I1I . Ii . IiIIii11Ii
  def splitTestDataset ( self , test : float = 0.2 , shuffle : bool = False ) :
   if 13 - 13: oOO - oOo0O00 . Ooo0Ooo * Oo % Iii1i
   if 57 - 57: ooOOO - OooOoo / I1I - oOo0O00 . ooOOO / i1
   if 69 - 69: OooOoo * ooOOO
   if 92 - 92: i1I / Oo + IiIIii11Ii
   if 31 - 31: Oo + I1Ii1I1 . Iii1i + IIiIIiIi11I1 % i1iiIII111
   if 24 - 24: Iii1i - ooo000 * IiIIii11Ii - ooOOO * I1I * Oo
   if 13 - 13: Iii1i * IiI11Ii111
   if 53 - 53: IIiIIiIi11I1 - oOo0O00
   if 8 - 8: i1i1i1111I * ooOOO % I1Ii1I1 / IiIIii11Ii % I1Ii1I1 / Ii
   if 40 - 40: Iii1i / Iii1i
   if 50 - 50: Ii / i1iiIII111
   if 4 - 4: oOO - IIiIIiIi11I1 / IIiIIiIi11I1
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   ( i1I1i , ooo ) = Oooo0OOO . partition ( prop = test , shuffle = shuffle )
   if 26 - 26: IiIIii11Ii * I1I - oOo0O00
   if 55 - 55: OooOoo + Ooo0Ooo * oOo0O00 - IiI11Ii111 % I11iiIi11i1I % i1
   self [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = i1I1i [ 0 ] , outputArray = i1I1i [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Test ] . setData ( inputArray = ooo [ 0 ] , outputArray = ooo [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Test ] . _path = self [ I111II1II111I . Dataset . Types . Train ] . _path
   if 44 - 44: i1i1i1111I * IiI11Ii111 % iI1iII1I1I1i . i1 - Ooo0Ooo - ooo000
 def __init__ ( self , sourceType : str = "imageclassify" , coreDataDir : str = "" , name : str = "" ) :
  if 2 - 2: IiIIii11Ii / I1I % IIiIIiIi11I1 - I1Ii1I1
  if 37 - 37: oOo0O00 - Oo + IiIIii11Ii
  if 27 - 27: ooo000 - I11iiIi11i1I . Ii - I11iiIi11i1I + IiI11Ii111
  if 74 - 74: i1i1i1111I . IiIIii11Ii % i1i1i1111I
  if 38 - 38: oOO - I1I - oOO - IiI11Ii111 * oOo0O00
  if 41 - 41: I11iiIi11i1I . i1i1i1111I % i1 * oOo0O00
  if 80 - 80: i1i1i1111I / ooo000 * IiIIii11Ii - Iii1i + I1I * Oo
  if 1 - 1: I11iiIi11i1I / I11iiIi11i1I % IiI11Ii111 / ooo000 + I1I
  if 59 - 59: i1 - ooo000 * I11iiIi11i1I - I11iiIi11i1I % oOO
  if 99 - 99: Oo
  if 75 - 75: I1Ii1I1 / Oo / OooOoo + Oo
  if 13 - 13: i1iiIII111 / ooOOO / ooOOO . ooOOO + oOo0O00 * Iii1i
  if 59 - 59: i1i1i1111I . Oo
  super ( ) . __init__ ( name = name )
  self . _instanceClass = I1ooOoO0OooO . CustomImage
  if 23 - 23: ooo000 % iI1iII1I1I1i - i1I
  self . generatorController = O0OOO . GeneratorController ( self )
  if 100 - 100: Ooo0Ooo + Oo . IiI11Ii111 / IiIIii11Ii / Ii / i1i1i1111I
  if 75 - 75: I1I - I1I
  if 75 - 75: IIiIIiIi11I1 % IIiIIiIi11I1 + IIiIIiIi11I1
  self . _sourceType = None
  if 65 - 65: IIiIIiIi11I1 - ooo000 * I1Ii1I1 . Ooo0Ooo - IiIIii11Ii
  if 15 - 15: IiI11Ii111 * oOo0O00 / Oo
  self . coreDataDir = coreDataDir
  if 1 - 1: i1I
  if 53 - 53: Iii1i . i1i1i1111I + i1i1i1111I % i1 * Ooo0Ooo
  if 53 - 53: Ooo0Ooo . ooo000
  if 55 - 55: Iii1i
  if 22 - 22: i1i1i1111I
  if 12 - 12: ooOOO - Oo + I11iiIi11i1I * I11iiIi11i1I * i1 % ooOOO
  if len ( coreDataDir ) :
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . _path = coreDataDir
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader )
   if 58 - 58: i1i1i1111I / Oo . Iii1i . ooo000
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 7 - 7: i1
  if 1 - 1: i1iiIII111 % IIiIIiIi11I1 % IIiIIiIi11I1 / ooo000 . I1Ii1I1 . ooOOO
  if 42 - 42: Oo + IiIIii11Ii % i1i1i1111I
  if 29 - 29: I1Ii1I1 / OooOoo * Ooo0Ooo - Ii + oOO % Iii1i
  if 16 - 16: Ii * IiIIii11Ii * i1I - oOo0O00
  if 77 - 77: Ii * i1iiIII111 + oOO - ooOOO % Oo - ooOOO
  if 81 - 81: i1i1i1111I + I1Ii1I1
  if 2 - 2: ooOOO
  if 92 - 92: Oo * I11iiIi11i1I + I1Ii1I1
  if 96 - 96: i1 + i1iiIII111 - I11iiIi11i1I - IiIIii11Ii * oOO
  if 98 - 98: IIiIIiIi11I1 % ooOOO * i1 + Iii1i
  if 20 - 20: IiI11Ii111 % i1i1i1111I . oOo0O00 - i1iiIII111
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "generatorController" :
    if 56 - 56: I11iiIi11i1I
    self . generatorController . parseFromJSON ( iiiiIi1IiiIi )
    if 43 - 43: I1Ii1I1
   elif Ii1I == "outputsetInfo" :
    if 3 - 3: Ii + I11iiIi11i1I + I1I
    setattr ( self , Ii1I , { ok : ov for ( ok , ov ) in iiiiIi1IiiIi } )
    self . outputsetInfo [ "input" ] = IiiIii1I1iIiII ( self . outputsetInfo [ "input" ] [ "header" ] , self . outputsetInfo [ "input" ] [ "shape" ] )
    self . outputsetInfo [ "target" ] = IiiIii1I1iIiII ( self . outputsetInfo [ "target" ] [ "header" ] , self . outputsetInfo [ "target" ] [ "shape" ] )
    if 100 - 100: iI1iII1I1I1i + oOO - OooOoo
   elif Ii1I == "_propagateDppNodes" :
    setattr ( self , Ii1I , set ( iiiiIi1IiiIi ) )
    if 44 - 44: i1 . I1Ii1I1 * i1i1i1111I
   elif Ii1I not in [ "_testRatio" , "_hasHeader" , "batchSize" , "colConfigs" , "shuffle" , "epochSize" , "dppNodes" , "_type" , "_train" , "train" , "_instanceClass" ] :
    if 37 - 37: Ii - IIiIIiIi11I1 - i1i1i1111I % oOo0O00 % IiI11Ii111 / i1
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if 79 - 79: iI1iII1I1I1i * oOO * ooOOO
    if 57 - 57: Iii1i + oOo0O00 + ooo000 - IIiIIiIi11I1
  if self . sourceType :
   self . generatorController . setSourceType ( self . _sourceType , self . coreDataDir )
   if 34 - 34: i1iiIII111 * i1i1i1111I / i1
   if 65 - 65: I11iiIi11i1I - I1I / I1Ii1I1 - IIiIIiIi11I1
  self . train = train
  if 96 - 96: ooOOO % OooOoo * I1I * oOo0O00 - i1iiIII111 . i1i1i1111I
 @ property
 def train ( self ) -> 'Train' :
  if 61 - 61: iI1iII1I1I1i . IIiIIiIi11I1 + i1 * OooOoo / I1I % Ooo0Ooo
  if 15 - 15: Oo % oOo0O00
  if 24 - 24: Ii
  if 17 - 17: i1 - oOo0O00 * Iii1i * Ooo0Ooo / I1Ii1I1
  if 62 - 62: ooo000 + i1I / OooOoo + oOo0O00 / IiI11Ii111 / i1
  if 19 - 19: ooOOO - i1iiIII111 * Ii / I11iiIi11i1I
  if 18 - 18: Iii1i * IiIIii11Ii - I11iiIi11i1I % Oo
  if 58 - 58: i1i1i1111I / Ooo0Ooo . i1i1i1111I . OooOoo * Iii1i + I1I
  if 55 - 55: I1I
  if 54 - 54: oOO
  return self . _train
  if 19 - 19: Oo % iI1iII1I1I1i + IiIIii11Ii * I11iiIi11i1I
 @ train . setter
 def train ( self , train : 'Train' ) -> 'Train' :
  if 36 - 36: IIiIIiIi11I1 % IiIIii11Ii + I1Ii1I1 * i1i1i1111I % Ii
  if 85 - 85: I1I % IiI11Ii111 . i1 % i1I % i1 - IiIIii11Ii
  if 48 - 48: i1i1i1111I / i1
  if 31 - 31: Ooo0Ooo % ooo000 / I11iiIi11i1I
  if 45 - 45: i1
  if 69 - 69: Iii1i * ooOOO + oOO
  if 49 - 49: Oo . i1i1i1111I . I1I - IiI11Ii111 / Iii1i . Ii
  if 40 - 40: Oo / i1I % oOO * i1I * IiI11Ii111 / ooo000
  if 89 - 89: IIiIIiIi11I1 . I1I / I1Ii1I1 . Ooo0Ooo + ooo000 * i1i1i1111I
  if 34 - 34: ooo000 . OooOoo
  if 15 - 15: OooOoo . i1I + i1I
  if 85 - 85: i1I % oOo0O00 / OooOoo * IIiIIiIi11I1 . Oo
  if 85 - 85: i1iiIII111
  if 17 - 17: Oo / I1Ii1I1
  if any ( [ s . splittable != self . splittable for s in train . sources ] ) :
   raise ValueError ( "Sources are incompatible within the Train object. All sources should have consistent splittable nature." )
   if 69 - 69: i1i1i1111I + I1Ii1I1 + IIiIIiIi11I1 - IiIIii11Ii - IiIIii11Ii * i1I
   if 24 - 24: OooOoo / I1Ii1I1 + i1iiIII111
  self . _train = train
  if 35 - 35: IiIIii11Ii - i1iiIII111 % ooo000 - oOo0O00 / I1Ii1I1 % IiI11Ii111
  if 99 - 99: Ooo0Ooo % Oo * iI1iII1I1I1i % I1Ii1I1 + I11iiIi11i1I
  train . sources . append ( self )
  if 72 - 72: I11iiIi11i1I / iI1iII1I1I1i . I1Ii1I1 . OooOoo - i1iiIII111 + oOO
  if 46 - 46: oOo0O00 / i1
  self . generatorController . setSourceType ( self . _sourceType , self . coreDataDir )
  if 11 - 11: OooOoo - oOO . oOO / I11iiIi11i1I
  if 67 - 67: Ooo0Ooo * Iii1i . I11iiIi11i1I
  return self . _train
  if 53 - 53: Ooo0Ooo / i1iiIII111
 @ property
 def sourceType ( self ) -> str :
  if 78 - 78: IiI11Ii111
  if 37 - 37: Ooo0Ooo
  if 56 - 56: OooOoo + Ii + i1iiIII111 + OooOoo - i1I
  if 58 - 58: i1I + I1I / oOO
  if 33 - 33: i1I
  if 89 - 89: Oo / I11iiIi11i1I % Oo + i1iiIII111
  if 48 - 48: I1I * I11iiIi11i1I % Ooo0Ooo + iI1iII1I1I1i % i1 + I11iiIi11i1I
  if 38 - 38: ooo000 / i1I + IIiIIiIi11I1 / Ooo0Ooo
  if 56 - 56: Oo
  if 89 - 89: IIiIIiIi11I1 . ooo000
class I1111II11iI11 ( O0 ) :
 if 61 - 61: oOO
 if 58 - 58: oOo0O00 % Ii
 if 16 - 16: Ooo0Ooo
 if 60 - 60: ooo000 * IiIIii11Ii + ooOOO * IiIIii11Ii . Ii - I1Ii1I1
 if 8 - 8: i1i1i1111I * iI1iII1I1I1i % OooOoo / i1iiIII111 % ooo000 * i1iiIII111
 if 72 - 72: IiI11Ii111 . IiIIii11Ii . i1 * Iii1i % i1 + ooOOO
 if 54 - 54: I1I . oOo0O00 / Iii1i
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 27 - 27: IIiIIiIi11I1
  if 2 - 2: Ii / I11iiIi11i1I % i1iiIII111 * ooOOO * I1Ii1I1 * i1
  if 82 - 82: IiI11Ii111 % I1I % IIiIIiIi11I1
  if 83 - 83: I11iiIi11i1I / i1iiIII111 % Ooo0Ooo * Ii
  if 67 - 67: I1I - ooo000 * oOo0O00 + iI1iII1I1I1i - ooOOO
  if 53 - 53: i1i1i1111I . i1i1i1111I * Ii * ooOOO % IiI11Ii111 / i1I
  if 7 - 7: Ooo0Ooo
  def __init__ ( self , controller : 'Source.Noise.GeneratorController' ) :
   if 99 - 99: i1 * I11iiIi11i1I + IiIIii11Ii - ooOOO . Iii1i - Ii
   if 18 - 18: Iii1i / IiI11Ii111 . IiIIii11Ii
   if 91 - 91: oOo0O00 % i1 . ooOOO * IiI11Ii111 + i1i1i1111I % i1I
   if 47 - 47: ooOOO * Oo . iI1iII1I1I1i - IiI11Ii111 + Iii1i + I1I
   if 41 - 41: IiI11Ii111 + OooOoo * i1iiIII111
   if 29 - 29: i1iiIII111 . i1i1i1111I % i1iiIII111 / Oo + Ooo0Ooo / ooOOO
   if 1 - 1: oOO
   if 77 - 77: oOO / iI1iII1I1I1i * i1iiIII111 + oOO % ooo000 * oOO
   if 8 - 8: ooo000 * ooOOO - Iii1i / Ooo0Ooo
   if 58 - 58: IIiIIiIi11I1 % i1iiIII111
   super ( ) . __init__ ( controller )
   if 6 - 6: oOO - iI1iII1I1I1i
   if 83 - 83: I1Ii1I1 - Oo
   self . _noiseShape = [ ]
   if 71 - 71: i1i1i1111I % iI1iII1I1I1i - ooOOO
   if 43 - 43: oOo0O00 % i1I % Oo
   self . outputsetInfo = { }
   if 11 - 11: Oo - i1 - ooOOO * IIiIIiIi11I1
  def copy ( self ) -> 'Source.Noise.GeneratorDetail' :
   if 38 - 38: i1i1i1111I / i1I
   if 78 - 78: oOo0O00
   if 26 - 26: IiIIii11Ii
   if 1 - 1: iI1iII1I1I1i % IIiIIiIi11I1 . Ii . Ii / I1I / oOo0O00
   if 78 - 78: Ii + IiI11Ii111
   if 89 - 89: oOO . Iii1i / I11iiIi11i1I / Ooo0Ooo
   if 23 - 23: oOO % oOO . IiI11Ii111 % i1 % I1Ii1I1
   if 70 - 70: Ii . I11iiIi11i1I - OooOoo
   if 54 - 54: IiI11Ii111 * i1i1i1111I / I1I * ooOOO / i1I . Oo
   if 8 - 8: I1Ii1I1 . IiIIii11Ii / Oo % i1 - ooOOO / i1iiIII111
   if 28 - 28: I1Ii1I1 + Oo * IiIIii11Ii . oOO + IiI11Ii111 * Oo
   ii1IIiIIi : I1111II11iI11 . GeneratorDetail = I1111II11iI11 . GeneratorDetail ( self . controller )
   if 10 - 10: i1 % Ii . Ii / IiIIii11Ii * OooOoo
   if 100 - 100: I1I . ooOOO + i1i1i1111I * oOO
   for Ii1I in [ "_noiseShape" , "outputsetInfo" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 82 - 82: Ii + oOo0O00 * I1I
   return ii1IIiIIi
   if 66 - 66: IIiIIiIi11I1 . IiIIii11Ii + Ii + IiIIii11Ii + i1iiIII111 * oOO
  def getData ( self , batchSize : int = 1 ) -> 'tf.Tensor' :
   if 49 - 49: i1iiIII111 + ooo000 / oOo0O00
   if 51 - 51: IIiIIiIi11I1 . I1I / i1i1i1111I
   if 86 - 86: Oo + IiI11Ii111
   if 13 - 13: OooOoo - I11iiIi11i1I % ooOOO + i1 % IIiIIiIi11I1 + i1iiIII111
   if 29 - 29: oOo0O00 . Iii1i % Oo % I1Ii1I1 . OooOoo - i1
   if 82 - 82: OooOoo / IiI11Ii111
   if 53 - 53: i1I
   if 95 - 95: Iii1i . OooOoo
   if 6 - 6: Iii1i % oOo0O00 - I1I - IiI11Ii111
   if 94 - 94: I11iiIi11i1I * Iii1i . oOO
   if 96 - 96: IIiIIiIi11I1 . oOo0O00 + i1i1i1111I . Ii - I1Ii1I1 - i1
   if 4 - 4: IiI11Ii111 % ooo000 + Ooo0Ooo - IiI11Ii111 / i1i1i1111I % i1I
   if 77 - 77: I11iiIi11i1I % IiIIii11Ii / ooOOO % I1I
   OOo00oOoOo = self . _noiseShape
   OOo00oOoOo [ 0 ] = batchSize
   return tf . convert_to_tensor ( np . random . random ( size = OOo00oOoOo ) , dtype = tf . float32 )
   if 36 - 36: IIiIIiIi11I1 . i1iiIII111 - i1 . Iii1i - IiI11Ii111 / i1i1i1111I
  def getNextBatch ( self ) -> 'tf.Tensor' :
   if 78 - 78: IiIIii11Ii . Oo
   if 20 - 20: IiI11Ii111 . i1i1i1111I % i1I . I11iiIi11i1I
   if 98 - 98: Ooo0Ooo + OooOoo + oOo0O00
   if 82 - 82: OooOoo % IiIIii11Ii - I1I / I1I + Ii
   if 40 - 40: ooo000
   if 29 - 29: OooOoo + i1I
   if 48 - 48: i1i1i1111I % I1I . I1Ii1I1 + oOo0O00
   if 93 - 93: IiIIii11Ii . oOo0O00 + IiI11Ii111 - i1I * I11iiIi11i1I + i1i1i1111I
   if 90 - 90: Iii1i + I1Ii1I1 . I11iiIi11i1I . I11iiIi11i1I / i1I
   if 22 - 22: i1i1i1111I
   if 53 - 53: IIiIIiIi11I1 + Iii1i
   o0OOOO0Oo0O = self . batchSize
   if 16 - 16: ooOOO + I11iiIi11i1I . I11iiIi11i1I / ooOOO
   if 17 - 17: I1I * Ooo0Ooo * Oo / Ooo0Ooo - i1i1i1111I
   O00o000Oo : tf . Tensor = self . getData ( batchSize = o0OOOO0Oo0O )
   if 73 - 73: Iii1i / oOo0O00 . i1i1i1111I * Oo
   if 13 - 13: IiI11Ii111
   iii1Oo = { "noise" : O00o000Oo }
   if 38 - 38: I11iiIi11i1I % IiI11Ii111 % i1iiIII111 . IIiIIiIi11I1 - oOO % i1iiIII111
   I1iIIiIiIII = iII ( iii1Oo , iii1Oo )
   I1iIIiIiIII . toArray ( )
   return I1iIIiIiIII
   if 65 - 65: IiI11Ii111 + IIiIIiIi11I1 . ooo000 % Oo
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> 'tf.Tensor' :
   if 69 - 69: Ii * I1Ii1I1 + Oo
   if 12 - 12: I1I * ooOOO / Ii * Oo
   if 56 - 56: I1I / i1 . I1I % i1
   if 99 - 99: ooo000 / IIiIIiIi11I1 . oOO % oOo0O00
   if 34 - 34: i1I % I11iiIi11i1I % IiIIii11Ii / IIiIIiIi11I1 % ooOOO + I11iiIi11i1I
   if 44 - 44: OooOoo . ooOOO
   if 98 - 98: IIiIIiIi11I1
   if 94 - 94: Oo % Ooo0Ooo * oOo0O00
   if 98 - 98: IiI11Ii111 * Iii1i - Ooo0Ooo + oOo0O00 * Iii1i
   if 7 - 7: ooOOO
   if 76 - 76: I1I
   if 32 - 32: i1I . ooOOO * I1Ii1I1 - ooo000
   if 18 - 18: ooo000
   if 31 - 31: i1iiIII111
   if 60 - 60: i1i1i1111I - iI1iII1I1I1i + i1 + IiIIii11Ii
   o0OOOO0Oo0O = randomCount
   if 42 - 42: i1 . ooOOO - i1 % Iii1i * ooo000 . IiI11Ii111
   if 88 - 88: IiIIii11Ii * i1I / Ooo0Ooo
   O00o000Oo : tf . Tensor = self . getData ( batchSize = o0OOOO0Oo0O )
   if 57 - 57: oOo0O00 / i1 * IIiIIiIi11I1 + i1i1i1111I . IiI11Ii111 + I1Ii1I1
   if 58 - 58: Ii . ooo000 / IIiIIiIi11I1 % OooOoo + I11iiIi11i1I
   iii1Oo = { "noise" : O00o000Oo }
   if 80 - 80: ooo000
   I1iIIiIiIII = iII ( iii1Oo , iii1Oo )
   I1iIIiIiIII . toArray ( )
   return I1iIIiIiIII
   if 51 - 51: ooOOO . i1 - Ooo0Ooo * I1I + Ii
 class GeneratorController ( I111II1II111I . Controller ) :
  if 33 - 33: IiI11Ii111 * IiI11Ii111 - Ooo0Ooo
  if 84 - 84: iI1iII1I1I1i - Oo * iI1iII1I1I1i + Ii - Ooo0Ooo
  if 63 - 63: Iii1i . i1i1i1111I * oOO / Iii1i . oOo0O00 / I1I
  if 9 - 9: Ii . IiI11Ii111 . I1Ii1I1 % IiIIii11Ii * I1I
  if 28 - 28: ooo000 / IiI11Ii111 + oOo0O00
  if 58 - 58: I1Ii1I1
  if 72 - 72: Ooo0Ooo
  def __init__ ( self , attachObject : Union [ 'Source.Noise' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 24 - 24: ooo000 / i1I + i1iiIII111 * iI1iII1I1I1i - IiI11Ii111 * i1I
   if 62 - 62: ooOOO
   if 91 - 91: Ooo0Ooo * IiIIii11Ii % ooOOO - oOo0O00 % I1Ii1I1 + I11iiIi11i1I
   if 70 - 70: i1iiIII111 / oOO . I1I / ooo000 * I11iiIi11i1I - Ii
   if 85 - 85: I1Ii1I1 / I1I - IiIIii11Ii + iI1iII1I1I1i % i1I
   if 61 - 61: IiI11Ii111 / IiI11Ii111 % iI1iII1I1I1i % OooOoo
   if 44 - 44: I1I % IIiIIiIi11I1 * Ooo0Ooo + oOO
   if 85 - 85: i1I / I11iiIi11i1I * Ii + IiIIii11Ii
   if 41 - 41: I1Ii1I1 - I11iiIi11i1I
   if 48 - 48: i1I / i1i1i1111I / oOo0O00 / i1 . ooo000
   super ( ) . __init__ ( attachObject = attachObject )
   if 6 - 6: I1I * IIiIIiIi11I1 * i1i1i1111I - i1iiIII111
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.Noise.GeneratorDetail' ] :
   if 7 - 7: i1 . I11iiIi11i1I * ooo000 . ooOOO
   if 77 - 77: Ii
   if 97 - 97: I11iiIi11i1I % Iii1i
   if 64 - 64: oOO / i1
   if 91 - 91: oOo0O00
   if 7 - 7: IiI11Ii111 - i1i1i1111I + Ooo0Ooo
   if 15 - 15: Ooo0Ooo / IiIIii11Ii
   if 21 - 21: I1I % I1I % i1iiIII111 / i1iiIII111 - iI1iII1I1I1i
   if 33 - 33: oOO + IiIIii11Ii / iI1iII1I1I1i
   if 35 - 35: IIiIIiIi11I1 / iI1iII1I1I1i
   return I1111II11iI11 . GeneratorDetail
   if 24 - 24: ooOOO
 def __init__ ( self , sourceType = "noise" , noiseShape = [ None , 1 ] , name : str = "" ) :
  if 31 - 31: ooOOO / I1I + i1 . IiIIii11Ii % Oo
  if 74 - 74: oOO - I11iiIi11i1I - iI1iII1I1I1i
  if 89 - 89: i1
  if 79 - 79: i1 . I11iiIi11i1I * IiIIii11Ii
  if 35 - 35: Ooo0Ooo / ooo000
  if 46 - 46: i1i1i1111I * i1 % Iii1i / ooo000 % Ooo0Ooo
  if 59 - 59: Oo / I1Ii1I1 - Ooo0Ooo + i1iiIII111 % oOO - oOO
  if 33 - 33: iI1iII1I1I1i + i1iiIII111
  if 72 - 72: oOO . I11iiIi11i1I . Ooo0Ooo
  if 9 - 9: i1iiIII111
  if 86 - 86: Ooo0Ooo / i1iiIII111 * I11iiIi11i1I / ooOOO
  if 51 - 51: i1iiIII111 . ooo000 % oOo0O00 + i1I / Iii1i . IiIIii11Ii
  if 11 - 11: Ooo0Ooo
  super ( ) . __init__ ( name = name )
  if 47 - 47: I11iiIi11i1I * ooo000 % iI1iII1I1I1i * i1
  self . _instanceClass = I1ooOoO0OooO . Noise
  if 67 - 67: I1Ii1I1 / i1iiIII111 - i1I + IiI11Ii111 % I1I / Oo
  self . generatorController = I1111II11iI11 . GeneratorController ( self )
  if 18 - 18: IiI11Ii111 * Oo / IiIIii11Ii * i1 / Iii1i
  self . _noiseShape = noiseShape
  if 85 - 85: i1iiIII111
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 11 - 11: IiIIii11Ii - I1I / i1 + i1i1i1111I
  if 73 - 73: i1iiIII111 - iI1iII1I1I1i * oOo0O00
  if 80 - 80: I11iiIi11i1I * Ooo0Ooo . I11iiIi11i1I + ooo000 + I1Ii1I1
  if 35 - 35: Oo / I1I + Ooo0Ooo + i1 . i1i1i1111I + i1i1i1111I
  if 36 - 36: IiIIii11Ii / i1iiIII111 % Oo + OooOoo
  if 65 - 65: IiI11Ii111
  if 36 - 36: Iii1i / i1iiIII111 + ooOOO / Iii1i . i1I
  if 40 - 40: oOo0O00 - Iii1i % Oo + i1i1i1111I
  if 39 - 39: IiIIii11Ii - i1 / i1I
  if 43 - 43: IiIIii11Ii . iI1iII1I1I1i * Ooo0Ooo + Ooo0Ooo . I11iiIi11i1I - Iii1i
  if 70 - 70: I1Ii1I1 . ooOOO
  if 56 - 56: I1I + Iii1i * OooOoo - I1Ii1I1 * i1I % IiIIii11Ii
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   if Ii1I == "generatorController" :
    if 43 - 43: i1iiIII111 . iI1iII1I1I1i
    self . generatorController . parseFromJSON ( iiiiIi1IiiIi )
    if 22 - 22: Oo / oOO + i1I % i1iiIII111 - IiIIii11Ii + i1I
   elif Ii1I == "outputsetInfo" :
    if 54 - 54: Oo + oOO / OooOoo % oOO % oOO
    setattr ( self , Ii1I , { ok : ov for ( ok , ov ) in iiiiIi1IiiIi } )
    if 60 - 60: i1I - IiI11Ii111 * IiI11Ii111
   elif Ii1I == "_propagateDppNodes" :
    setattr ( self , Ii1I , set ( iiiiIi1IiiIi ) )
    if 2 - 2: i1iiIII111 * ooo000 * OooOoo % OooOoo . oOO
   elif Ii1I not in [ "_testRatio" , "_hasHeader" , "batchSize" , "colConfigs" , "shuffle" , "epochSize" , "dppNodes" , "_type" , "_train" , "train" , "_instanceClass" ] :
    if 82 - 82: OooOoo + I11iiIi11i1I
    setattr ( self , Ii1I , iiiiIi1IiiIi )
    if Ii1I == "_noiseShape" :
     print ( iiiiIi1IiiIi )
     if 58 - 58: IIiIIiIi11I1 * ooo000 + IIiIIiIi11I1 - I1I
     if 83 - 83: IiIIii11Ii
  self . train = train
  if 81 - 81: ooOOO * iI1iII1I1I1i . ooOOO . IiI11Ii111 - ooo000
  if 72 - 72: IiI11Ii111 . IiI11Ii111 * Iii1i
  self . generatorController [ I111II1II111I . Dataset . Types . Train ] . _noiseShape = self . _noiseShape
  self . generatorController [ I111II1II111I . Dataset . Types . Test ] . _noiseShape = self . _noiseShape
  self . generatorController [ I111II1II111I . Dataset . Types . Train ] . _epochSize = self . _epochSize
  self . generatorController [ I111II1II111I . Dataset . Types . Test ] . _epochSize = self . _epochSize
  if 60 - 60: IiIIii11Ii * IiIIii11Ii . Iii1i / I1I
 def getHeader ( self , outputsetKey : str ) -> List [ str ] :
  if 43 - 43: I11iiIi11i1I
  if 29 - 29: Ooo0Ooo % Ooo0Ooo . I11iiIi11i1I - ooOOO
  if 40 - 40: ooOOO - Oo . IiIIii11Ii / I11iiIi11i1I * i1I
  if 22 - 22: Iii1i - ooo000 . oOO % i1i1i1111I / OooOoo % IiI11Ii111
  if 8 - 8: i1iiIII111 + Iii1i
  if 57 - 57: oOo0O00 / ooo000 % ooOOO + i1I
  if 99 - 99: oOO % IiIIii11Ii . i1iiIII111 % iI1iII1I1I1i . ooOOO - i1
  if 37 - 37: OooOoo
  if 11 - 11: Ii - Iii1i / i1 - I11iiIi11i1I + I1I
  if 22 - 22: I11iiIi11i1I + Ooo0Ooo
  if 25 - 25: IiIIii11Ii . Oo / I1I
  if 72 - 72: IIiIIiIi11I1 - oOo0O00 * iI1iII1I1I1i . ooOOO . I11iiIi11i1I + IiIIii11Ii
  if 96 - 96: iI1iII1I1I1i . i1 . ooOOO % ooo000 + I11iiIi11i1I
  return self . outputsetInfo [ outputsetKey ] [ "header" ] [ 0 ] if outputsetKey in self . outputsetInfo else [ ]
  if 36 - 36: ooo000 % Ooo0Ooo . I1Ii1I1
class IiiIii1I1iIiII :
 if 36 - 36: i1 + I11iiIi11i1I % I1I % i1 * Ii
 if 84 - 84: oOo0O00 + oOO % I11iiIi11i1I . IiI11Ii111 * I11iiIi11i1I + Oo
 if 19 - 19: I11iiIi11i1I * ooo000
 if 59 - 59: iI1iII1I1I1i % IiI11Ii111
 if 50 - 50: Iii1i
 if 68 - 68: Iii1i * IIiIIiIi11I1 * Ii % oOo0O00
 if 74 - 74: I1I . I1Ii1I1 / ooo000 * Oo / I1Ii1I1
 def __init__ ( self , header : List [ str ] = [ ] , shape : List [ int ] = None ) :
  if 86 - 86: Oo * iI1iII1I1I1i * iI1iII1I1I1i
  if 55 - 55: I1I % Ooo0Ooo * Oo - i1I / Iii1i
  if 71 - 71: Ii + i1iiIII111 % OooOoo + Ii + Oo
  if 19 - 19: IIiIIiIi11I1 / i1i1i1111I / oOo0O00 + i1i1i1111I / OooOoo
  if 46 - 46: iI1iII1I1I1i % ooo000 . iI1iII1I1I1i + I1Ii1I1 . ooOOO
  if 35 - 35: OooOoo + i1I . Oo % I11iiIi11i1I + oOO . IiIIii11Ii
  if 38 - 38: IiIIii11Ii . Iii1i * IiI11Ii111 . i1iiIII111 % i1i1i1111I
  if 56 - 56: Iii1i + OooOoo + i1 % ooOOO + Oo
  if 3 - 3: iI1iII1I1I1i / Ii / I11iiIi11i1I % OooOoo
  if 24 - 24: ooOOO - i1iiIII111 - ooOOO
  if 82 - 82: Ii % I1I - ooOOO
  if 38 - 38: I11iiIi11i1I - I1Ii1I1 . oOo0O00 / IIiIIiIi11I1 . I1Ii1I1 . Ooo0Ooo
  self . header = header
  if 83 - 83: OooOoo * Ooo0Ooo * Oo . I11iiIi11i1I
  self . shape = shape
  if 69 - 69: i1
class iII :
 if 68 - 68: oOo0O00
 if 41 - 41: IiI11Ii111 . Iii1i - I11iiIi11i1I - oOo0O00 / oOO
 if 89 - 89: oOo0O00
 if 74 - 74: Oo + Oo . ooo000
 if 97 - 97: i1I + ooOOO - i1I * oOO + IIiIIiIi11I1 % Ii
 if 77 - 77: oOo0O00 * ooo000 % ooOOO + IiIIii11Ii
 if 80 - 80: Ii
 def __init__ ( self , rootData : Any = None , dppData : Dict [ str , Any ] = { } ) :
  if 3 - 3: I11iiIi11i1I * IIiIIiIi11I1 . IiIIii11Ii / i1i1i1111I . I1I + ooOOO
  if 68 - 68: i1I / oOO * i1i1i1111I
  if 40 - 40: IIiIIiIi11I1 % i1 % Iii1i % Iii1i % i1I
  if 4 - 4: iI1iII1I1I1i . OooOoo . Iii1i % I1Ii1I1
  if 94 - 94: Ii % Oo * i1 / IIiIIiIi11I1 / Iii1i % IiI11Ii111
  if 15 - 15: i1I
  if 14 - 14: oOO % iI1iII1I1I1i / IIiIIiIi11I1
  if 27 - 27: IIiIIiIi11I1 - IiI11Ii111 . oOo0O00
  if 78 - 78: i1iiIII111 + oOO - i1i1i1111I / Iii1i * IiI11Ii111 - Ii
  if 69 - 69: Iii1i + oOO / i1iiIII111 - IiIIii11Ii / i1I
  if 49 - 49: I1I / i1iiIII111 * ooo000 + iI1iII1I1I1i
  if 97 - 97: i1 + I1I % IIiIIiIi11I1 - OooOoo % i1I
  self . rootData = rootData
  if 43 - 43: Ii + iI1iII1I1I1i + I1I % iI1iII1I1I1i
  self . dppData = dppData
  if 50 - 50: OooOoo
 def toArray ( self ) :
  if 72 - 72: IiIIii11Ii + OooOoo * I11iiIi11i1I % Ii . OooOoo
  if 33 - 33: oOo0O00 . OooOoo . i1iiIII111 / oOO
  if 1 - 1: I11iiIi11i1I * i1I + IiIIii11Ii
  if 95 - 95: Oo
  if 1 - 1: i1I + IIiIIiIi11I1 - OooOoo
  if 90 - 90: oOO - i1i1i1111I + IiIIii11Ii % iI1iII1I1I1i - I11iiIi11i1I
  if 66 - 66: I1I * Oo / I1Ii1I1 - I1I
  if 75 - 75: IiIIii11Ii - IIiIIiIi11I1
  if isinstance ( self . rootData , dict ) :
   self . rootData = { outputKey : np . array ( self . rootData [ outputKey ] ) for outputKey in self . rootData }
  else :
   self . rootData = np . array ( self . rootData )
  self . dppData = { dppKey : np . array ( self . dppData [ dppKey ] ) for dppKey in self . dppData }
  if 100 - 100: ooOOO + ooOOO
 def __add__ ( self , other : 'Source.PreprocessedData' ) -> 'Source.PreprocessedData' :
  if 88 - 88: Ii % iI1iII1I1I1i
  if 57 - 57: I1Ii1I1 + oOo0O00 . IiI11Ii111
  if 43 - 43: oOo0O00
  if 87 - 87: ooOOO % iI1iII1I1I1i * Ooo0Ooo * oOo0O00
  if 40 - 40: IiIIii11Ii . IIiIIiIi11I1 . i1iiIII111 % i1iiIII111 % OooOoo / Ooo0Ooo
  if 50 - 50: I1Ii1I1 + oOO
  if 61 - 61: Ooo0Ooo . oOo0O00 % ooOOO + ooOOO / oOO % IIiIIiIi11I1
  if 74 - 74: i1iiIII111 / I11iiIi11i1I - ooo000 + i1i1i1111I
  if 14 - 14: ooOOO % i1iiIII111
  if 12 - 12: Iii1i / OooOoo * IiI11Ii111 % Iii1i % Iii1i / I1I
  if 96 - 96: IIiIIiIi11I1 * Iii1i / IiIIii11Ii % I1Ii1I1 - Iii1i + IiIIii11Ii
  if 64 - 64: OooOoo * ooOOO . i1I
  if 62 - 62: i1i1i1111I / Ooo0Ooo . Ooo0Ooo
  if 36 - 36: Ooo0Ooo - iI1iII1I1I1i / Ii - iI1iII1I1I1i
  O0O0OO00o = iII ( )
  if 50 - 50: Ooo0Ooo
  if 90 - 90: OooOoo + OooOoo . I1Ii1I1 / IiIIii11Ii * oOO
  if isinstance ( self . rootData , dict ) :
   O0O0OO00o . rootData = { outputKey : np . concatenate ( [ self . rootData [ outputKey ] , other . rootData [ outputKey ] ] ) for outputKey in self . rootData }
  else :
   O0O0OO00o . rootData = np . concatenate ( self . rootData , other . rootData )
   if 68 - 68: i1 / ooOOO % Oo
   if 49 - 49: i1I + i1I - oOo0O00 % ooOOO - Oo . oOO
  O0O0OO00o . dppData = { dppKey : np . concatenate ( [ self . dppData [ dppKey ] , other . dppData [ dppKey ] ] ) for dppKey in self . dppData }
  if 8 - 8: I11iiIi11i1I - i1 . i1i1i1111I . Iii1i
  return O0O0OO00o
  if 30 - 30: i1i1i1111I - IiI11Ii111 + ooOOO
 def toDict ( self ) -> Dict [ str , Any ] :
  if 94 - 94: I1I / Oo - Ooo0Ooo . IIiIIiIi11I1 - ooOOO
  if 58 - 58: i1i1i1111I / I1I / Oo + Oo
  if 62 - 62: OooOoo
  if 60 - 60: i1 % i1iiIII111
  if 94 - 94: IIiIIiIi11I1 % OooOoo / I11iiIi11i1I
  if 97 - 97: IIiIIiIi11I1 % IIiIIiIi11I1 . IIiIIiIi11I1 * i1iiIII111
  if 98 - 98: I1Ii1I1
  if 35 - 35: IiI11Ii111 / Oo % Ii / i1i1i1111I - i1iiIII111
  if 44 - 44: i1I % I1Ii1I1 * I1I % iI1iII1I1I1i - IiIIii11Ii
  if 24 - 24: I1I / ooo000 + IiIIii11Ii + i1iiIII111 . i1I . OooOoo
  return { "rootData" : self . rootData , "dppData" : self . dppData }
  if 64 - 64: ooOOO + Iii1i . IIiIIiIi11I1 - I11iiIi11i1I + I11iiIi11i1I + I11iiIi11i1I
 @ staticmethod
 def fromDict ( dictObj : Dict [ str , Any ] ) -> 'Source.PreprocessedData' :
  if 98 - 98: ooo000 + OooOoo
  if 42 - 42: Ii % Oo + i1i1i1111I % Oo . I11iiIi11i1I - oOO
  if 1 - 1: Oo % I1Ii1I1
  if 43 - 43: ooOOO + IiIIii11Ii / ooOOO . i1 * oOo0O00
  if 38 - 38: OooOoo - Iii1i
  if 35 - 35: oOo0O00 . i1I % I11iiIi11i1I . Ii
  if 33 - 33: iI1iII1I1I1i + IiIIii11Ii % oOo0O00 / i1 / Ii
  if 49 - 49: ooo000 - ooOOO . OooOoo + i1
  if 54 - 54: i1I * I1I / I1Ii1I1 % Ii / Iii1i + I1Ii1I1
  if 46 - 46: OooOoo . IiI11Ii111 % Ooo0Ooo + oOO * I1I
  if 4 - 4: IIiIIiIi11I1 / IiI11Ii111 % oOo0O00
  if 3 - 3: Ooo0Ooo % I11iiIi11i1I - IiI11Ii111 . ooo000 % ooOOO
  if 89 - 89: ooOOO - Ooo0Ooo * i1iiIII111 - I1I % IiIIii11Ii
  return iII ( dictObj [ "rootData" ] , dictObj [ "dppData" ] )
  if 21 - 21: IiIIii11Ii % IIiIIiIi11I1
class o0ooo0oOoO ( O0 ) :
 if 92 - 92: I1Ii1I1
 if 16 - 16: I1Ii1I1 / IIiIIiIi11I1 * Oo . i1I . i1 / i1iiIII111
 if 57 - 57: I1I - IiI11Ii111
 if 30 - 30: Ii + i1i1i1111I
 if 78 - 78: IIiIIiIi11I1 / Oo
 if 74 - 74: IIiIIiIi11I1 * Iii1i * Oo / Iii1i
 if 42 - 42: IIiIIiIi11I1 * Oo
 class GeneratorDetail ( I111II1II111I . Detail ) :
  if 99 - 99: i1I . OooOoo % i1iiIII111 . I1I / iI1iII1I1I1i
  if 87 - 87: i1 + OooOoo . ooOOO % iI1iII1I1I1i
  if 95 - 95: i1 + i1i1i1111I / OooOoo + ooo000 . Ooo0Ooo
  if 33 - 33: oOo0O00 + Iii1i + iI1iII1I1I1i * ooOOO * i1i1i1111I / IIiIIiIi11I1
  if 67 - 67: i1 % Ii . IIiIIiIi11I1 + IiIIii11Ii
  if 22 - 22: IiIIii11Ii - I11iiIi11i1I * I1I
  if 49 - 49: OooOoo % IiI11Ii111 % ooo000
  def __init__ ( self , controller : 'Source.Table.GeneratorController' ) :
   if 52 - 52: Iii1i . i1 - Iii1i . I1Ii1I1 - Oo
   if 72 - 72: IiIIii11Ii - i1
   if 93 - 93: oOO / Oo / I11iiIi11i1I
   if 14 - 14: oOO
   if 72 - 72: OooOoo + ooOOO % i1 * I1Ii1I1
   if 11 - 11: oOo0O00 - i1 % i1iiIII111
   if 33 - 33: Oo + IiI11Ii111 . IiIIii11Ii - IIiIIiIi11I1 % IIiIIiIi11I1
   if 86 - 86: Ooo0Ooo * i1I * IIiIIiIi11I1 % ooo000 % oOO . iI1iII1I1I1i
   if 8 - 8: IiI11Ii111 % I1I * ooOOO + I1Ii1I1 * iI1iII1I1I1i
   if 55 - 55: I1I % i1i1i1111I
   super ( ) . __init__ ( controller )
   if 60 - 60: Ii - iI1iII1I1I1i - i1 / Ii * IiI11Ii111 * Ooo0Ooo
   if 56 - 56: Oo + I1Ii1I1 - i1 . IiIIii11Ii . i1I
   self . _oriData : np . ndarray = None
   if 16 - 16: I1I - oOo0O00 . I1I
   if 4 - 4: ooo000 % ooo000 . Iii1i
   self . _hasHeader : bool = False
   if 47 - 47: IiIIii11Ii
   if 88 - 88: i1
   self . _delimiter : str = None
   if 43 - 43: I11iiIi11i1I
  def copy ( self ) -> 'Source.Table.GeneratorDetail' :
   if 27 - 27: ooo000 * oOo0O00 . Iii1i * oOO . Oo
   if 73 - 73: I1Ii1I1 / OooOoo * i1 % oOO / Iii1i
   if 2 - 2: IiIIii11Ii + oOo0O00 - ooOOO / i1iiIII111
   if 99 - 99: IiI11Ii111 . I1Ii1I1 - i1I / Oo - OooOoo
   if 38 - 38: OooOoo * I1Ii1I1
   if 56 - 56: ooo000
   if 57 - 57: ooo000 / Ooo0Ooo
   if 6 - 6: I11iiIi11i1I / ooOOO % ooOOO
   if 41 - 41: IiI11Ii111 + Iii1i
   if 82 - 82: i1i1i1111I + I1Ii1I1 / I1I
   if 58 - 58: IiIIii11Ii
   ii1IIiIIi : o0ooo0oOoO . GeneratorDetail = o0ooo0oOoO . GeneratorDetail ( self . controller )
   if 31 - 31: IiI11Ii111 - i1 + IiI11Ii111
   if 90 - 90: i1iiIII111 * IiIIii11Ii * IiI11Ii111
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_oriData" , "_itrCount" , "_hasHeader" , "delimiter" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 17 - 17: Oo * i1iiIII111 * Oo * oOo0O00 + IIiIIiIi11I1
   return ii1IIiIIi
   if 31 - 31: I1I + i1I . I1I / ooo000
  @ property
  def oriData ( self ) -> 'np.ndarray' :
   if 49 - 49: Iii1i / i1iiIII111 / ooOOO
   if 52 - 52: OooOoo
   if 66 - 66: IiIIii11Ii
   if 81 - 81: i1I / Oo * I1I
   if 18 - 18: i1iiIII111 + Ooo0Ooo
   if 98 - 98: Ii . Ii . oOo0O00 . i1iiIII111 * IIiIIiIi11I1 + oOO
   if 31 - 31: i1 + ooOOO - OooOoo % ooo000
   if 18 - 18: i1I / oOO
   if 53 - 53: oOO . I11iiIi11i1I * i1i1i1111I % ooo000 % IiIIii11Ii / IiI11Ii111
   if 100 - 100: OooOoo
   return self . _oriData
   if 34 - 34: ooOOO . I1I * OooOoo . ooOOO
  @ property
  def epochSize ( self ) -> int :
   if 5 - 5: i1i1i1111I * oOo0O00
   if 8 - 8: Oo % oOo0O00 * OooOoo % ooOOO . i1i1i1111I
   if 57 - 57: Iii1i
   if 91 - 91: IiI11Ii111
   if 12 - 12: Ii + OooOoo / ooOOO
   if 70 - 70: Ooo0Ooo . I1Ii1I1 + oOo0O00 . oOO * Ooo0Ooo % I1I
   if 27 - 27: Iii1i / Ii * I1Ii1I1 * I11iiIi11i1I - i1I / iI1iII1I1I1i
   if 8 - 8: iI1iII1I1I1i
   if 25 - 25: i1iiIII111 % oOO / Oo
   if 2 - 2: i1
   return ( self . _oriShape [ 0 ] if len ( self . _oriShape ) else None ) if self . _epochSize is None else self . _epochSize
   if 55 - 55: i1i1i1111I
  @ property
  def hasHeader ( self ) -> bool :
   if 100 - 100: Ii + ooo000 * iI1iII1I1I1i + ooo000 + ooo000 * Oo
   if 25 - 25: i1i1i1111I - Ii . ooo000 - ooOOO * iI1iII1I1I1i
   if 29 - 29: i1 . Oo - I11iiIi11i1I
   if 34 - 34: ooo000
   if 13 - 13: oOO * i1iiIII111 * ooOOO
   if 56 - 56: Ii
   if 66 - 66: i1i1i1111I
   if 65 - 65: i1iiIII111 - I1I . OooOoo
   if 4 - 4: I1Ii1I1 - i1i1i1111I - Ooo0Ooo + oOO
   if 35 - 35: i1 / oOo0O00 . ooo000 - ooOOO % ooo000
   return self . _hasHeader
   if 30 - 30: i1 % oOO + I1I - Iii1i * i1i1i1111I
  @ property
  def delimiter ( self ) -> str :
   if 68 - 68: oOo0O00 + Iii1i + I1Ii1I1 * OooOoo + oOO
   if 35 - 35: OooOoo . i1I
   if 48 - 48: Oo / Ii / i1
   if 48 - 48: oOo0O00 % iI1iII1I1I1i
   if 23 - 23: i1I / Iii1i . iI1iII1I1I1i - I11iiIi11i1I / I1Ii1I1 * i1iiIII111
   if 22 - 22: I1Ii1I1 + i1 / i1i1i1111I
   if 84 - 84: I1I
   if 24 - 24: I1I - OooOoo + iI1iII1I1I1i . Ooo0Ooo
   if 93 - 93: i1I - Ii - IiI11Ii111 % oOO * ooOOO
   if 47 - 47: Iii1i / i1iiIII111
   return self . _delimiter
   if 74 - 74: IiI11Ii111 - oOO % IiIIii11Ii + oOo0O00 + IIiIIiIi11I1 / i1
  def setData ( self , inputArray : Union [ list , 'np.ndarray' ] = [ ] , outputArray : Union [ list , 'np.ndarray' ] = [ ] , hasHeader : bool = True ) :
   if 1 - 1: Oo % i1 - Iii1i
   if 65 - 65: I11iiIi11i1I
   if 30 - 30: Oo % IiIIii11Ii
   if 74 - 74: I1Ii1I1 - iI1iII1I1I1i - Ooo0Ooo
   if 86 - 86: i1I - iI1iII1I1I1i % Ii - IiI11Ii111 + i1i1i1111I
   if 92 - 92: iI1iII1I1I1i * i1I
   if 64 - 64: oOO % OooOoo
   if 33 - 33: IiIIii11Ii / IiIIii11Ii % IiI11Ii111 * I1I
   if 19 - 19: Ii
   if 80 - 80: IiIIii11Ii + i1iiIII111 - ooo000 - Iii1i % Oo
   if 64 - 64: IiI11Ii111 / I1Ii1I1 * I11iiIi11i1I - IiI11Ii111 % I11iiIi11i1I
   if 48 - 48: IiIIii11Ii
   if 45 - 45: i1I . i1iiIII111 - oOO - Ooo0Ooo . IiI11Ii111 * Oo
   self . _hasHeader = hasHeader
   if 99 - 99: I1I / ooOOO . Iii1i * ooOOO
   if 16 - 16: IiIIii11Ii / I11iiIi11i1I + Oo
   o0oi11I1iIi1IIiI = np . array ( inputArray )
   o00000 = np . array ( outputArray )
   if 25 - 25: I1Ii1I1 . I11iiIi11i1I - I1Ii1I1 % Ii
   if 3 - 3: I1Ii1I1 % IiI11Ii111 . i1
   if len ( o0oi11I1iIi1IIiI . shape ) != 2 :
    raise ValueError ( "Input Shape must be a 2-dimensional array." )
   elif len ( o00000 . shape ) != 2 and len ( o00000 ) != 0 :
    raise ValueError ( "Output Shape must be a 2-dimensional array." )
    if 45 - 45: oOo0O00 + I11iiIi11i1I . oOo0O00 . Ooo0Ooo
    if 76 - 76: Ii + i1i1i1111I - oOo0O00 * IiIIii11Ii . Ii % ooOOO
   Oooo0Oo00 = np . column_stack ( ( o0oi11I1iIi1IIiI , o00000 ) ) if ( len ( o00000 ) == len ( o0oi11I1iIi1IIiI ) and len ( o0oi11I1iIi1IIiI ) > 0 ) else o0oi11I1iIi1IIiI
   if 97 - 97: I1I + IiI11Ii111 + IiI11Ii111 - Ii * I1I
   if 48 - 48: Oo + Ooo0Ooo . IiI11Ii111 % I11iiIi11i1I
   OOo00oOoOo = [ * ( Oooo0Oo00 [ 1 : ] . shape if hasHeader else Oooo0Oo00 . shape ) ] if len ( Oooo0Oo00 ) else [ 0 ]
   self . _oriShape = OOo00oOoOo
   if 55 - 55: IIiIIiIi11I1
   if 64 - 64: oOo0O00 % i1 . Iii1i . IiI11Ii111 + i1iiIII111 * i1
   if len ( Oooo0Oo00 ) == 0 :
    raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
    if 23 - 23: Iii1i * IiIIii11Ii % I11iiIi11i1I
    if 4 - 4: OooOoo * iI1iII1I1I1i - OooOoo
   elif ( self . oriData is not None and len ( self . oriData ) > 0 ) and Oooo0Oo00 . shape [ 1 : ] != self . oriData . shape [ 1 : ] :
    raise ValueError ( "Data cannot be reset with a different shape" )
    if 56 - 56: ooo000 - OooOoo % oOo0O00 * ooOOO % iI1iII1I1I1i
    if 35 - 35: I1Ii1I1 % IiI11Ii111 + Ooo0Ooo - i1I
    if 17 - 17: i1iiIII111 - ooOOO % Ii
   self . _oriData = Oooo0Oo00 if len ( Oooo0Oo00 ) else np . array ( [ ] )
   if 27 - 27: Ooo0Ooo / i1i1i1111I / I1Ii1I1
   if 8 - 8: IIiIIiIi11I1 . oOo0O00 % ooOOO
   if len ( o00000 ) :
    Iiiii1iiiI = len ( o0oi11I1iIi1IIiI [ 0 ] ) if o0oi11I1iIi1IIiI . shape [ - 1 ] else 0
    o0Oo0O = len ( o00000 [ 0 ] ) if o00000 . shape [ - 1 ] else 0
    iiIIiiI1 = ( "None:" + str ( Iiiii1iiiI ) ) if Iiiii1iiiI > 0 else None
    o00o0oooo0 = ( str ( Iiiii1iiiI ) + ":None" ) if o0Oo0O > 0 else None
    if len ( o0oi11I1iIi1IIiI ) :
     iIIII11i = Ii1Ii1iii ( sourceCol = iiIIiiI1 )
     iIIII11i . appendOn ( self . attachObject , "input" )
    if len ( o00000 ) :
     oOOO0oOoo = Ii1Ii1iii ( sourceCol = o00o0oooo0 )
     oOOO0oOoo . appendOn ( self . attachObject , "target" )
     if 54 - 54: oOo0O00 . i1i1i1111I + I1Ii1I1 / I1I % Oo
  def prepareIteration ( self ) :
   if 12 - 12: Oo - oOO
   if 88 - 88: oOO + i1
   if 5 - 5: i1 - Ii - OooOoo . IIiIIiIi11I1 - IIiIIiIi11I1
   if 3 - 3: ooOOO % ooOOO . I11iiIi11i1I / I1Ii1I1
   if 34 - 34: i1 % oOo0O00 . Ooo0Ooo + I1Ii1I1 % Ii
   if 35 - 35: i1i1i1111I
   if 70 - 70: IIiIIiIi11I1
   if 79 - 79: I11iiIi11i1I % Iii1i . Ooo0Ooo
   if not self . initialized :
    self . initialize ( )
    if 45 - 45: i1 + IIiIIiIi11I1 + IiIIii11Ii % IIiIIiIi11I1 * ooo000
    if 42 - 42: I1I
   self . batchIdxReset ( )
   if 78 - 78: Oo . Oo / OooOoo / i1i1i1111I
   if 4 - 4: Iii1i * i1 * oOo0O00 / iI1iII1I1I1i
   if self . shuffle :
    self . _shuffleData ( )
    if 18 - 18: Oo * OooOoo / ooo000 + i1
  def _shuffleData ( self ) :
   if 100 - 100: I11iiIi11i1I + i1i1i1111I + oOo0O00 % I11iiIi11i1I % Ooo0Ooo
   if 80 - 80: Iii1i + OooOoo
   if 69 - 69: Iii1i + ooOOO . I11iiIi11i1I - iI1iII1I1I1i % I1I - IiIIii11Ii
   if 27 - 27: I11iiIi11i1I - ooo000 - IiI11Ii111 - i1i1i1111I - Ii - I1Ii1I1
   if 61 - 61: i1I + i1i1i1111I . iI1iII1I1I1i . I1Ii1I1
   if 100 - 100: I1I % Oo + Ooo0Ooo
   if 62 - 62: Oo
   if 4 - 4: IIiIIiIi11I1 * iI1iII1I1I1i
   np . random . shuffle ( self . oriData [ 1 : ] if self . hasHeader else self . oriData )
   if 43 - 43: I11iiIi11i1I + IiI11Ii111 - i1iiIII111 * i1I
  def getHeader ( self , outputsetKey : str = None ) :
   if 93 - 93: IIiIIiIi11I1 - I1I * oOO
   if 83 - 83: i1iiIII111 * I1Ii1I1 / i1I . Ooo0Ooo - ooOOO - IiIIii11Ii
   if 72 - 72: iI1iII1I1I1i
   if 12 - 12: Ooo0Ooo . i1iiIII111 + Ii - OooOoo . ooOOO
   if 51 - 51: IiIIii11Ii % ooo000
   if 49 - 49: IiIIii11Ii . i1i1i1111I . i1I * iI1iII1I1I1i + OooOoo
   if 41 - 41: oOo0O00 % iI1iII1I1I1i % ooo000 - I1Ii1I1 . I11iiIi11i1I - i1iiIII111
   if 29 - 29: oOo0O00
   if 89 - 89: Iii1i * Iii1i * I1Ii1I1 . IIiIIiIi11I1 / IIiIIiIi11I1 - I1I
   if 56 - 56: IiIIii11Ii
   if 11 - 11: i1 . oOo0O00 - i1iiIII111 + IiI11Ii111
   if 96 - 96: Ooo0Ooo / ooOOO
   if 73 - 73: i1I - IiIIii11Ii % OooOoo . ooo000 + i1i1i1111I
   if outputsetKey is not None and outputsetKey != "table" :
    raise ValueError ( "outputsetKey is not supported for Table Source." )
    if 92 - 92: i1iiIII111 * IiIIii11Ii
   if not self . hasHeader or self . oriData is None or len ( self . oriData ) == 0 :
    if 78 - 78: Ooo0Ooo * I1Ii1I1 % i1
    i11 = [ str ( chr ( ord ( 'A' ) + idx ) ) for idx in range ( 0 , self . oriShape [ - 1 ] ) ]
   elif self . hasHeader and ( self . oriData is not None and len ( self . oriData ) > 0 ) :
    if 95 - 95: IiIIii11Ii / Ii - I1I
    i11 = self . oriData [ 0 ]
    if 47 - 47: oOO
   return i11
   if 28 - 28: i1 / Oo % ooOOO % I11iiIi11i1I
  def getData ( self , start : int = None , end : int = None , indexes : List [ int ] = None ) -> 'np.ndarray' :
   if 54 - 54: Ooo0Ooo
   if 9 - 9: Iii1i + I11iiIi11i1I + oOo0O00 + IIiIIiIi11I1 % I1I + i1I
   if 6 - 6: I1Ii1I1
   if 95 - 95: I11iiIi11i1I
   if 89 - 89: ooOOO . i1I . ooOOO - ooo000 - ooOOO
   if 24 - 24: oOo0O00 % oOO . I1Ii1I1
   if 61 - 61: I1I + iI1iII1I1I1i . Oo
   if 39 - 39: iI1iII1I1I1i . IIiIIiIi11I1 + Oo * iI1iII1I1I1i + i1I + i1I
   if 100 - 100: ooOOO - I1Ii1I1 - Ooo0Ooo / i1i1i1111I - i1i1i1111I * iI1iII1I1I1i
   if 52 - 52: ooOOO
   if 64 - 64: I1Ii1I1
   if 58 - 58: ooOOO * Ii * i1I + ooo000 % i1i1i1111I
   if 13 - 13: iI1iII1I1I1i
   if 22 - 22: oOO - Oo % ooOOO
   if 86 - 86: i1 + ooOOO * i1i1i1111I - IiI11Ii111
   if 83 - 83: Ii + Iii1i
   if self . oriData is None or len ( self . oriData ) == 0 :
    return np . array ( [ ] )
    if 12 - 12: Ii / i1I / i1I % IiIIii11Ii * oOo0O00 + I11iiIi11i1I
    if 16 - 16: ooo000 / i1 - OooOoo . i1I
   IIooO = ( self . oriData [ 1 : ] if self . hasHeader else self . oriData ) . copy ( )
   if 33 - 33: Ooo0Ooo * OooOoo . Ooo0Ooo
   if 61 - 61: oOo0O00
   if start is not None or end is not None :
    return IIooO [ start : end ]
   elif indexes is not None :
    if any ( [ ( idx >= len ( IIooO ) or idx < - len ( IIooO ) ) for idx in indexes ] ) :
     raise ValueError ( "Some of the requested indexes are out of range." )
    return IIooO [ indexes ]
   else :
    return IIooO
    if 5 - 5: Iii1i / IiI11Ii111 * I1I - i1i1i1111I
  def getNextBatch ( self ) -> 'np.ndarray' :
   if 57 - 57: ooo000 % oOO + iI1iII1I1I1i % ooOOO . IiI11Ii111 / Ooo0Ooo
   if 53 - 53: Ii * Iii1i * I11iiIi11i1I % iI1iII1I1I1i - Iii1i % Iii1i
   if 4 - 4: i1
   if 26 - 26: I1I
   if 38 - 38: I1Ii1I1 . IIiIIiIi11I1 + i1i1i1111I + oOO . i1i1i1111I
   if 75 - 75: IiI11Ii111 / Oo . IiIIii11Ii * Iii1i + ooo000 + I1Ii1I1
   if 53 - 53: i1iiIII111 * IiIIii11Ii % i1I . i1iiIII111 - I1I
   if 78 - 78: IiIIii11Ii % iI1iII1I1I1i + IiI11Ii111 - Iii1i * i1I
   if 35 - 35: i1iiIII111
   if 67 - 67: Oo / IiIIii11Ii % Ii % i1
   if 44 - 44: i1I * Ooo0Ooo . I1Ii1I1 / ooOOO
   if not self . initialized :
    self . initialize ( )
    self . prepareIteration ( )
    if 71 - 71: i1
    if 74 - 74: i1I / ooOOO * I11iiIi11i1I / OooOoo - Ooo0Ooo - i1iiIII111
   IiIIiiII = self . batchIdx
   o0OOOO0Oo0O = self . batchSize
   if 9 - 9: oOo0O00 . I1Ii1I1 . Iii1i . IIiIIiIi11I1 * I1I * Oo
   if 81 - 81: ooo000
   if ( self . dropRemainder and ( IiIIiiII + 1 ) * o0OOOO0Oo0O > self . epochSize ) or ( ( not self . dropRemainder ) and IiIIiiII * o0OOOO0Oo0O >= self . epochSize ) :
    self . prepareIteration ( )
    IiIIiiII = self . batchIdx
    if 86 - 86: ooo000 / IIiIIiIi11I1 - ooo000
    if 59 - 59: i1I / iI1iII1I1I1i . Iii1i . oOo0O00
   O00o000Oo = self . getData ( start = IiIIiiII * o0OOOO0Oo0O , end = ( IiIIiiII + 1 ) * o0OOOO0Oo0O )
   if 87 - 87: i1i1i1111I + Ii
   if 91 - 91: I11iiIi11i1I / ooOOO - IiI11Ii111 - I1Ii1I1
   self . batchIdxIncrement ( )
   if 26 - 26: IIiIIiIi11I1
   return O00o000Oo
   if 92 - 92: ooo000 * Oo . iI1iII1I1I1i + I11iiIi11i1I * OooOoo % oOo0O00
  def getRandItems ( self , randomSeed : int = None , randomCount : int = None ) -> 'np.ndarray' :
   if 33 - 33: i1iiIII111 . ooOOO - ooo000 / I1I + IiI11Ii111
   if 86 - 86: ooOOO % IiI11Ii111 + IiIIii11Ii . Oo
   if 86 - 86: ooo000
   if 12 - 12: oOo0O00 . I11iiIi11i1I
   if 99 - 99: i1i1i1111I - i1I * i1iiIII111 + ooOOO . ooo000
   if 24 - 24: Oo . I1I
   if 64 - 64: oOO
   if 77 - 77: iI1iII1I1I1i / ooo000
   if 55 - 55: Ooo0Ooo / IiIIii11Ii % i1
   if 2 - 2: oOo0O00 + Oo . ooOOO * I1I
   if 52 - 52: ooOOO * Ooo0Ooo + Iii1i % I1Ii1I1
   if 36 - 36: ooo000 - ooOOO - IiIIii11Ii * OooOoo . i1I % iI1iII1I1I1i
   if 10 - 10: i1I % i1 / IiI11Ii111 . iI1iII1I1I1i + OooOoo * i1
   if 43 - 43: ooOOO * I11iiIi11i1I
   if 68 - 68: IIiIIiIi11I1 . Oo * ooo000 % i1i1i1111I / OooOoo + i1I
   if self . oriData is None or len ( self . oriData ) == 0 :
    return np . array ( [ ] )
    if 9 - 9: i1i1i1111I + I11iiIi11i1I - OooOoo - OooOoo . oOo0O00
    if 30 - 30: I11iiIi11i1I . IiIIii11Ii . iI1iII1I1I1i % I1I * OooOoo
   IIooO = ( self . oriData [ 1 : ] if self . hasHeader else self . oriData )
   if 35 - 35: I1I * Oo * i1i1i1111I % i1I + ooOOO
   if 24 - 24: oOO - oOo0O00 % IIiIIiIi11I1 + i1I / IiI11Ii111
   Oo0o0oo0 = np . arange ( len ( IIooO ) )
   np . random . seed ( randomSeed )
   np . random . shuffle ( Oo0o0oo0 )
   np . random . seed ( )
   if 66 - 66: ooo000 / IIiIIiIi11I1 . I11iiIi11i1I . IIiIIiIi11I1
   if 96 - 96: IiI11Ii111
   return IIooO [ list ( Oo0o0oo0 [ : randomCount ] ) ] . copy ( )
   if 57 - 57: oOO / i1i1i1111I + I1I
  def partition ( self , prop : float = 0.2 , shuffle : float = False ) -> Tuple [ 'np.ndarray' , 'np.ndarray' ] :
   if 17 - 17: i1I . iI1iII1I1I1i * i1 . I1I - oOO
   if 70 - 70: i1iiIII111 % I1I % ooOOO
   if 31 - 31: oOo0O00 % IIiIIiIi11I1 % I1Ii1I1
   if 94 - 94: iI1iII1I1I1i - i1i1i1111I % oOo0O00 / Ii + oOo0O00 % oOO
   if 32 - 32: i1i1i1111I - ooo000
   if 62 - 62: i1iiIII111 + oOO - IiI11Ii111 - oOo0O00
   if 51 - 51: iI1iII1I1I1i + iI1iII1I1I1i - I11iiIi11i1I * ooo000 * i1
   if 35 - 35: IiIIii11Ii
   if 69 - 69: IiI11Ii111 * Ii
   if 79 - 79: Ii - oOo0O00 * Ooo0Ooo * I1I % OooOoo / iI1iII1I1I1i
   if 28 - 28: i1I + IIiIIiIi11I1 + oOo0O00 . IiIIii11Ii * i1iiIII111 * i1
   if 82 - 82: Ii * Ii . i1I
   if 74 - 74: ooo000 * Ooo0Ooo * ooOOO * i1I - IiI11Ii111
   if 86 - 86: iI1iII1I1I1i . I1I * Iii1i - iI1iII1I1I1i * ooOOO * I1I
   if 35 - 35: IiIIii11Ii - Ii * I1Ii1I1 . I11iiIi11i1I % Ii
   IiOoOOOoO0 = self . epochSize
   iII11i1 = math . floor ( IiOoOOOoO0 * prop )
   IIi11ii1IIi = self . oriData . copy ( ) [ 1 : ] if self . hasHeader else self . oriData . copy ( )
   if 77 - 77: i1iiIII111 + Ii % I1Ii1I1 + i1i1i1111I
   if 88 - 88: i1iiIII111 % Ooo0Ooo . IiIIii11Ii / IIiIIiIi11I1
   if shuffle :
    np . random . shuffle ( IIi11ii1IIi )
    if 64 - 64: I11iiIi11i1I . i1I
    if 60 - 60: I11iiIi11i1I . i1 % i1i1i1111I - oOo0O00 - IiIIii11Ii
   ooOOoO0 = IIi11ii1IIi [ iII11i1 : ]
   O0o0OOO00o = IIi11ii1IIi [ : iII11i1 ]
   if 86 - 86: i1 % oOO % OooOoo * i1i1i1111I
   if 51 - 51: Oo
   if self . hasHeader :
    ooOOoO0 = np . vstack ( ( self . oriData [ [ 0 ] ] , ooOOoO0 ) )
    O0o0OOO00o = np . vstack ( ( self . oriData [ [ 0 ] ] , O0o0OOO00o ) )
    if 77 - 77: I11iiIi11i1I + I11iiIi11i1I * ooOOO / iI1iII1I1I1i / oOO
    if 95 - 95: Ii
   return ooOOoO0 , O0o0OOO00o
   if 69 - 69: Ii . Iii1i
 class GeneratorController ( I111II1II111I . Controller ) :
  if 62 - 62: IIiIIiIi11I1 / oOo0O00 . I1Ii1I1
  if 21 - 21: IiI11Ii111 - i1 . I1Ii1I1 - ooo000
  if 36 - 36: i1 / iI1iII1I1I1i / oOO
  if 67 - 67: IIiIIiIi11I1 + i1I + OooOoo
  if 49 - 49: iI1iII1I1I1i - iI1iII1I1I1i
  if 27 - 27: OooOoo
  if 26 - 26: i1 . Ooo0Ooo . Ii + I11iiIi11i1I
  def __init__ ( self , attachObject : Union [ 'Source.Table' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 100 - 100: IiIIii11Ii + IIiIIiIi11I1 . i1I / IiI11Ii111
   if 91 - 91: Ii * i1iiIII111
   if 10 - 10: iI1iII1I1I1i - I11iiIi11i1I . oOO % ooOOO - ooOOO % ooOOO
   if 92 - 92: Oo / I11iiIi11i1I
   if 16 - 16: ooOOO
   if 8 - 8: IIiIIiIi11I1 * Oo / Oo % i1I * iI1iII1I1I1i * IiIIii11Ii
   if 97 - 97: I11iiIi11i1I * I1Ii1I1 / IIiIIiIi11I1 - Iii1i
   if 35 - 35: Ooo0Ooo * oOO % iI1iII1I1I1i
   if 54 - 54: I11iiIi11i1I + ooo000
   if 43 - 43: OooOoo - I1I / Ii
   super ( ) . __init__ ( attachObject = attachObject )
   if 25 - 25: I11iiIi11i1I
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.Table.GeneratorDetail' ] :
   if 43 - 43: oOO / IIiIIiIi11I1 % IiIIii11Ii . IIiIIiIi11I1 - Ooo0Ooo
   if 66 - 66: I1Ii1I1
   if 3 - 3: iI1iII1I1I1i + I1Ii1I1
   if 32 - 32: OooOoo . I1Ii1I1
   if 57 - 57: I11iiIi11i1I . Iii1i . oOO % iI1iII1I1I1i % Ii
   if 26 - 26: oOo0O00 + Ii % iI1iII1I1I1i
   if 61 - 61: i1 % oOo0O00
   if 45 - 45: i1iiIII111 - i1
   if 41 - 41: oOO - i1iiIII111 * ooo000 * I11iiIi11i1I * I1I
   if 70 - 70: IiIIii11Ii . i1iiIII111 . ooo000 / Ooo0Ooo % Ooo0Ooo
   return o0ooo0oOoO . GeneratorDetail
   if 63 - 63: Ooo0Ooo + Iii1i + Iii1i - Iii1i
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 73 - 73: i1 . iI1iII1I1I1i
   if 40 - 40: Iii1i
   if 81 - 81: i1 - OooOoo % IiI11Ii111 + oOO + ooOOO * Ii
   if 30 - 30: i1
   if 83 - 83: I1I % IIiIIiIi11I1
   if 85 - 85: I1Ii1I1 + ooOOO % I11iiIi11i1I / i1iiIII111
   if 12 - 12: IIiIIiIi11I1 * Ooo0Ooo + ooo000 + i1iiIII111
   if 69 - 69: ooOOO * i1I - Oo * i1i1i1111I % ooo000
   if 43 - 43: i1 - I11iiIi11i1I - Ii
   if 46 - 46: i1iiIII111 + iI1iII1I1I1i
   if 98 - 98: i1i1i1111I + Ii - oOo0O00 - IiIIii11Ii % OooOoo
   if 99 - 99: ooo000 - ooo000 . IiIIii11Ii + OooOoo / I1Ii1I1 * ooo000
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   IiOoOOOoO0 = Oooo0OOO . epochSize
   if 56 - 56: Ooo0Ooo / i1iiIII111 * i1i1i1111I
   if 75 - 75: Ooo0Ooo - Oo / OooOoo * Ooo0Ooo - i1iiIII111 / Iii1i
   if 41 - 41: i1iiIII111 . Oo % IIiIIiIi11I1 * I11iiIi11i1I
   if randomFold :
    ( i1I1i , OoOOIiiiI111 ) = Oooo0OOO . partition ( prop = validation , shuffle = True )
    if 82 - 82: Ooo0Ooo - I1I * I1Ii1I1 + oOO
    if 29 - 29: I1I / I11iiIi11i1I
   else :
    if 31 - 31: I1Ii1I1 - I1I - IIiIIiIi11I1
    oo0oOo0O0 = math . floor ( 1 / validation )
    IiIIiiII = self . validationTime % oo0oOo0O0
    IIi11ii1IIi = Oooo0OOO . oriData . copy ( ) [ 1 : ] if Oooo0OOO . hasHeader else Oooo0OOO . oriData . copy ( )
    if 13 - 13: i1I
    if 11 - 11: OooOoo * ooo000 . oOo0O00 . oOo0O00 + Iii1i
    if IiIIiiII == 0 and Oooo0OOO . shuffle :
     np . random . shuffle ( IIi11ii1IIi )
     if 78 - 78: I11iiIi11i1I * I1I / Ii * i1i1i1111I
     if 99 - 99: I1I
    ii1i1II1iiiI = math . ceil ( IiOoOOOoO0 / oo0oOo0O0 )
    I1I1111 = IiIIiiII * ii1i1II1iiiI
    oOO0o00 = ( IiIIiiII + 1 ) * ii1i1II1iiiI
    i1I1i = np . vstack ( ( IIi11ii1IIi [ : I1I1111 ] , IIi11ii1IIi [ oOO0o00 : ] ) )
    OoOOIiiiI111 = IIi11ii1IIi [ I1I1111 : oOO0o00 ]
    if 37 - 37: Ooo0Ooo / i1iiIII111 + OooOoo . iI1iII1I1I1i % oOO
    if 99 - 99: I11iiIi11i1I + i1i1i1111I
    if Oooo0OOO . hasHeader :
     i1I1i = np . vstack ( ( Oooo0OOO . oriData [ [ 0 ] ] , i1I1i ) )
     OoOOIiiiI111 = np . vstack ( ( Oooo0OOO . oriData [ [ 0 ] ] , OoOOIiiiI111 ) )
     if 83 - 83: IIiIIiIi11I1 + oOo0O00 . ooo000 * IiI11Ii111 / IIiIIiIi11I1
     if 4 - 4: I1I . IiIIii11Ii + I1Ii1I1 * i1I * iI1iII1I1I1i
   self [ I111II1II111I . Dataset . Types . ValidationTrain ] . setData ( inputArray = i1I1i , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Validation ] . setData ( inputArray = OoOOIiiiI111 , hasHeader = Oooo0OOO . hasHeader )
   if 7 - 7: i1iiIII111 - i1i1i1111I . IIiIIiIi11I1 - IIiIIiIi11I1 / i1
   if 28 - 28: I1I * i1I / IIiIIiIi11I1 * Ooo0Ooo * IiI11Ii111
   self . validationTime += 1
   if 98 - 98: Oo
  def splitTestDataset ( self , test : float = 0.2 , shuffle : float = False ) :
   if 32 - 32: I11iiIi11i1I
   if 99 - 99: i1 / IiIIii11Ii - oOO * ooOOO % OooOoo
   if 58 - 58: oOO / Ooo0Ooo . IiIIii11Ii + IIiIIiIi11I1 / ooo000
   if 56 - 56: ooOOO
   if 14 - 14: Ii * i1 . oOo0O00 - IiIIii11Ii / oOO
   if 64 - 64: Oo
   if 53 - 53: oOo0O00 . OooOoo * iI1iII1I1I1i / IiIIii11Ii
   if 39 - 39: Ii
   if 75 - 75: iI1iII1I1I1i % Ooo0Ooo + I11iiIi11i1I
   if 43 - 43: OooOoo + Ooo0Ooo . iI1iII1I1I1i - I1Ii1I1 . IiI11Ii111 + ooOOO
   if 35 - 35: I11iiIi11i1I + i1iiIII111
   if 34 - 34: i1I . oOO
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   ( i1I1i , ooo ) = Oooo0OOO . partition ( prop = test , shuffle = shuffle )
   if 81 - 81: Iii1i - IIiIIiIi11I1 % ooOOO % I11iiIi11i1I * I11iiIi11i1I / i1I
   if 26 - 26: oOo0O00 / I11iiIi11i1I / i1i1i1111I . I1I / Ooo0Ooo
   self [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = i1I1i , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Test ] . setData ( inputArray = ooo , hasHeader = Oooo0OOO . hasHeader )
   if 21 - 21: I1I * OooOoo % I11iiIi11i1I % iI1iII1I1I1i - IIiIIiIi11I1
 def __init__ ( self , inputArray : List [ List [ Union [ float , int , str ] ] ] = [ ] , outputArray : List [ List [ Union [ float , int , str ] ] ] = [ ] , hasHeader : bool = False , name : str = "" ) :
  if 70 - 70: I1I - i1 . Iii1i + IiIIii11Ii / ooOOO - i1
  if 32 - 32: i1iiIII111 * I1I . iI1iII1I1I1i % I11iiIi11i1I % ooo000
  if 29 - 29: ooOOO
  if 4 - 4: Oo + I11iiIi11i1I % I11iiIi11i1I % I11iiIi11i1I
  if 51 - 51: Oo / I11iiIi11i1I * ooo000 / IIiIIiIi11I1
  if 38 - 38: I1I * Ii / oOo0O00 / i1I
  if 35 - 35: Ii - IIiIIiIi11I1 / oOO - Iii1i
  if 82 - 82: Ii - oOO + I1I . oOO
  if 27 - 27: I1I * Iii1i * Ooo0Ooo
  if 80 - 80: i1
  if 41 - 41: ooo000 + i1i1i1111I + iI1iII1I1I1i - Ii / Iii1i % Ooo0Ooo
  if 73 - 73: OooOoo
  if 22 - 22: oOO
  if 79 - 79: I1I . OooOoo * I1I - Iii1i . i1i1i1111I
  super ( ) . __init__ ( name = name )
  if 32 - 32: Ii % Ooo0Ooo % IiI11Ii111 / ooo000 * Ooo0Ooo
  self . splittable = True
  if 22 - 22: I1I / i1I . I1Ii1I1 . ooo000 / Ooo0Ooo
  self . _instanceClass = I1ooOoO0OooO . Table
  if 57 - 57: IiIIii11Ii + oOO / I1I
  self . generatorController = o0ooo0oOoO . GeneratorController ( self )
  if 61 - 61: i1iiIII111 / IiI11Ii111 - IiI11Ii111 * IIiIIiIi11I1 % i1 * oOo0O00
  if 51 - 51: IiI11Ii111 * IiI11Ii111 / oOO . OooOoo + Oo
  if len ( inputArray ) or len ( outputArray ) :
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = inputArray , outputArray = outputArray , hasHeader = hasHeader )
   if 100 - 100: iI1iII1I1I1i + i1iiIII111 % i1I % oOO / i1I - I1I
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 71 - 71: Ii * i1
  if 72 - 72: ooOOO * OooOoo - I11iiIi11i1I
  if 74 - 74: ooOOO % Oo / Oo
  if 35 - 35: I11iiIi11i1I + ooo000 + i1I . I11iiIi11i1I - oOo0O00 . oOO
  if 96 - 96: I11iiIi11i1I
  if 76 - 76: Iii1i * i1I / Oo . i1i1i1111I % i1i1i1111I % ooOOO
  if 5 - 5: OooOoo * ooOOO % oOO % I1I
  if 9 - 9: Iii1i . IIiIIiIi11I1 . Iii1i * IIiIIiIi11I1 + i1
  if 64 - 64: I1I / I11iiIi11i1I % Oo - ooOOO
  if 6 - 6: ooo000 * i1I . oOo0O00 % I1Ii1I1 / I1Ii1I1
  if 4 - 4: IiIIii11Ii / oOo0O00
  if 37 - 37: oOO
  if "generatorController" not in obj :
   if 16 - 16: I1Ii1I1 - IIiIIiIi11I1
   for Ii1I in Oooo0OooOOOo0 ( obj , [ "encoding" , "_hasHeader" , "delimiter" ] ) :
    iiiiIi1IiiIi = obj [ Ii1I ]
    if Ii1I == "_path" :
     if 95 - 95: Ooo0Ooo . IIiIIiIi11I1
     self . generatorController [ I111II1II111I . Dataset . Types . Train ] . path = iiiiIi1IiiIi
     if 77 - 77: I1I
    elif Ii1I == "_hasHeader" :
     for ooo0oO in self . generatorController . values ( ) :
      if 30 - 30: i1 + oOo0O00 * ooo000 * i1i1i1111I / I11iiIi11i1I
      ooo0oO . _hasHeader = iiiiIi1IiiIi
      if 96 - 96: ooo000 - I1Ii1I1 . oOo0O00
    elif Ii1I == "encoding" :
     for ooo0oO in self . generatorController . values ( ) :
      if 5 - 5: OooOoo * I1I % I11iiIi11i1I - i1I
      ooo0oO . encoding = iiiiIi1IiiIi
    elif Ii1I == "_delimiter" :
     for ooo0oO in self . generatorController . values ( ) :
      if 43 - 43: Ii + IIiIIiIi11I1 + IIiIIiIi11I1 * i1I - I1Ii1I1 / Ii
      ooo0oO . _delimiter = iiiiIi1IiiIi
      if 65 - 65: oOo0O00 % Oo
    elif Ii1I == "outputsetInfo" :
     if 67 - 67: i1I % Ooo0Ooo + i1iiIII111 % ooOOO % Oo - I1I
     setattr ( self , Ii1I , { ok : ov for ( ok , ov ) in iiiiIi1IiiIi } )
     if 52 - 52: Ooo0Ooo % I1I + oOO - OooOoo . i1i1i1111I % i1i1i1111I
    elif Ii1I == "_propagateDppNodes" :
     setattr ( self , Ii1I , set ( iiiiIi1IiiIi ) )
     if 62 - 62: i1i1i1111I * Iii1i
    elif Ii1I not in [ "_testRatio" , "_hasHeader" , "batchSize" , "colConfigs" , "shuffle" , "epochSize" , "dppNodes" , "_type" , "_train" , "train" , "_instanceClass" ] :
     if 41 - 41: i1i1i1111I * i1iiIII111
     setattr ( self , Ii1I , iiiiIi1IiiIi )
  else :
   if 53 - 53: oOO - I1I
   for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
    if Ii1I == "generatorController" :
     if 10 - 10: ooOOO / OooOoo
     self . generatorController . parseFromJSON ( iiiiIi1IiiIi )
     if 79 - 79: IiI11Ii111 * ooo000 / IIiIIiIi11I1 + IiI11Ii111 - i1iiIII111 - Ii
    elif Ii1I == "outputsetInfo" :
     if 32 - 32: i1i1i1111I
     setattr ( self , Ii1I , { ok : ov for ( ok , ov ) in iiiiIi1IiiIi } )
     if 68 - 68: iI1iII1I1I1i . IIiIIiIi11I1 * I1I
    elif Ii1I not in [ "_testRatio" , "_hasHeader" , "batchSize" , "colConfigs" , "shuffle" , "epochSize" , "dppNodes" , "_type" , "_train" , "train" , "_instanceClass" ] :
     if 4 - 4: i1iiIII111 + IiI11Ii111 * IIiIIiIi11I1 * Oo - ooOOO
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 28 - 28: Ooo0Ooo * Oo % i1i1i1111I - IiI11Ii111 + i1i1i1111I * OooOoo
     if 8 - 8: oOo0O00 - oOo0O00 + ooo000
  self . train = train
  if 17 - 17: i1i1i1111I + IiI11Ii111 / oOo0O00 - Ooo0Ooo
 @ property
 def hasHeader ( self ) -> bool :
  if 52 - 52: i1 % Ooo0Ooo + IiI11Ii111 + IiIIii11Ii . iI1iII1I1I1i
  if 41 - 41: iI1iII1I1I1i . I1Ii1I1
  if 98 - 98: Ooo0Ooo % Oo / i1i1i1111I
  if 31 - 31: i1 / oOO * i1i1i1111I
  if 25 - 25: Oo . Ooo0Ooo
  if 3 - 3: OooOoo - i1iiIII111 - Ooo0Ooo . oOo0O00
  if 97 - 97: I1I . oOO - Iii1i + ooo000 * iI1iII1I1I1i % I1Ii1I1
  if 21 - 21: iI1iII1I1I1i * i1 / i1i1i1111I
  if 17 - 17: Ii
  if 58 - 58: oOo0O00 - OooOoo
  return self . generatorController [ self . train . currentSourceDataset ] . hasHeader
  if 63 - 63: i1i1i1111I + ooo000
 def setData ( self , data : 'np.ndarray' , sourceDataset : 'DataGenerator.Dataset.Types' = None , hasHeader : bool = True ) :
  if 5 - 5: Ooo0Ooo % iI1iII1I1I1i + i1i1i1111I - i1iiIII111 - IiIIii11Ii / ooOOO
  if 31 - 31: IiI11Ii111 - oOo0O00 % I11iiIi11i1I
  if 2 - 2: i1i1i1111I - i1i1i1111I % oOO
  if 64 - 64: IIiIIiIi11I1 . Ii - IIiIIiIi11I1 % I1I - I1Ii1I1
  if 79 - 79: I1I / I1I - I1I / Oo + OooOoo + i1
  if 96 - 96: i1iiIII111 * oOo0O00 + i1 * oOo0O00 / I11iiIi11i1I . ooo000
  if 32 - 32: I1I % Oo
  if 56 - 56: ooo000 / I11iiIi11i1I % I1Ii1I1 * Iii1i - I11iiIi11i1I
  if 53 - 53: IiIIii11Ii * I1Ii1I1 . i1 . Ii - Ii % ooo000
  if 6 - 6: i1i1i1111I / IIiIIiIi11I1 * OooOoo + ooOOO - oOo0O00
  if 68 - 68: oOO % Oo % oOO - oOO * i1
  if 84 - 84: oOo0O00 % Ooo0Ooo / I1Ii1I1
  self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . setData ( inputArray = data , hasHeader = hasHeader )
  if 95 - 95: Iii1i * i1i1i1111I + Oo
 def hasData ( self , dppKey : str = None , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> bool :
  if 72 - 72: ooo000 + IIiIIiIi11I1 + Ooo0Ooo
  if 13 - 13: oOO
  if 21 - 21: i1 % Ooo0Ooo + Ii % Iii1i % ooo000
  if 78 - 78: ooOOO + ooo000 + I1I
  if 25 - 25: i1iiIII111 / Ooo0Ooo / i1i1i1111I
  if 41 - 41: I1Ii1I1 % I11iiIi11i1I - Ii . Ooo0Ooo + OooOoo
  if 44 - 44: Ooo0Ooo
  if 49 - 49: I1I . ooo000 * I1Ii1I1 . i1iiIII111 - Oo
  if 96 - 96: i1iiIII111 / I1I * I1I - OooOoo
  if 27 - 27: IiI11Ii111 / Iii1i . Iii1i
  if 89 - 89: Ooo0Ooo - IiI11Ii111 - ooOOO
  if 41 - 41: Ooo0Ooo / Iii1i % iI1iII1I1I1i % Ii / i1I
  if 6 - 6: i1iiIII111 * I1I / ooo000 / Oo / ooOOO
  if 43 - 43: Ooo0Ooo * IiIIii11Ii . I1Ii1I1
  if 24 - 24: IiIIii11Ii + Oo + ooo000 % i1iiIII111 - IIiIIiIi11I1 - Ooo0Ooo
  iiII1I = self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . oriData
  if 11 - 11: I11iiIi11i1I + ooOOO . Oo / Iii1i
  if 3 - 3: Ooo0Ooo . Oo / oOO * I1I / I11iiIi11i1I + Ooo0Ooo
  if iiII1I is None or len ( iiII1I ) == 0 :
   return False
   if 27 - 27: oOO / oOO - I1I % i1i1i1111I
  if dppKey is not None :
   if 83 - 83: I11iiIi11i1I * Ii % oOo0O00
   if dppKey not in self . train . dppNodes :
    return False
    if 36 - 36: I1Ii1I1 + ooo000 - ooOOO - iI1iII1I1I1i + Ii
    if 85 - 85: Ooo0Ooo * IiI11Ii111
   IiiiI11 = self . train . dppNodes [ dppKey ]
   I1iIiIIiiI = [ i for i in range ( 0 , ( iiII1I . shape [ - 1 ] if IiiiI11 . source is None else self . train . dppNodes [ IiiiI11 . source ] . getShape ( ) [ - 1 ] ) ) ]
   iIi11I = IiiiI11 . sourceCol
   oo00OOO = self . arraySlice ( [ I1iIiIIiiI ] , iIi11I ) [ 0 ]
   return len ( oo00OOO )
  else :
   return iiII1I is not None and len ( iiII1I ) > 0
   if 23 - 23: OooOoo - OooOoo
 def getDppNodeData ( self , dppKey , step : 'DataPreprocessing.Node.Columns.StepEnum' = Ii1Ii1iii . StepEnum . Output , sourceDataset : 'DataGenerator.Dataset.Types' = None , start : int = None , end : int = None ) -> 'np.ndarray' :
  if 67 - 67: IiI11Ii111 / Ii - Oo - i1iiIII111 / IIiIIiIi11I1
  if 77 - 77: Ooo0Ooo - IiI11Ii111 % i1 + ooo000 + IiIIii11Ii % Oo
  if 30 - 30: iI1iII1I1I1i + IiI11Ii111 + i1 + IiI11Ii111 + ooo000
  if 58 - 58: IIiIIiIi11I1 % i1 * i1i1i1111I - IiIIii11Ii
  if 24 - 24: I1I - Ii / Ii * OooOoo - iI1iII1I1I1i - OooOoo
  if 82 - 82: i1i1i1111I . i1 * ooo000 + i1I
  if 36 - 36: i1i1i1111I * Ooo0Ooo / i1 - Ooo0Ooo
  if 43 - 43: IIiIIiIi11I1
  if 95 - 95: Oo / ooOOO
  if 4 - 4: IiI11Ii111 + Iii1i . I11iiIi11i1I - i1
  if 86 - 86: OooOoo - Ii
  if 23 - 23: I1Ii1I1 . Iii1i / Iii1i % Ooo0Ooo % I1Ii1I1 . Iii1i
  if 65 - 65: oOO + Ii / i1iiIII111 - i1 - i1
  if 90 - 90: ooo000 / IiIIii11Ii % I1I
  if 6 - 6: ooOOO / oOO . i1iiIII111 - OooOoo - Ooo0Ooo / oOo0O00
  if 1 - 1: ooo000 . IIiIIiIi11I1
  if 42 - 42: IiI11Ii111
  if 96 - 96: Oo * iI1iII1I1I1i % i1iiIII111 + oOo0O00 + IiI11Ii111
  iiII1I = self . generatorController [ self . train . currentSourceDataset ] . oriData
  if 2 - 2: ooo000 - Ooo0Ooo * i1
  if 76 - 76: IiIIii11Ii
  if iiII1I is None or len ( iiII1I ) == 0 :
   return np . array ( [ ] )
   if 89 - 89: OooOoo + i1iiIII111 % ooo000 / I1I
   if 48 - 48: ooOOO . ooOOO / Iii1i / IiIIii11Ii - iI1iII1I1I1i
  if dppKey not in self . train . dppNodes :
   raise ValueError ( "The column key cannot be found." )
   if 61 - 61: i1i1i1111I - Iii1i / Iii1i / Ooo0Ooo
   if 84 - 84: Oo
  I1 = self . train . dppNodes [ dppKey ]
  if 76 - 76: iI1iII1I1I1i - I1I - i1i1i1111I
  return I1 . getData ( step , start , end )
  if 69 - 69: OooOoo + ooOOO / oOO - I1I % Ii
 def getHeader ( self , outputsetKey : str = None ) -> List [ str ] :
  if 50 - 50: OooOoo * Iii1i % i1iiIII111 * IiIIii11Ii * oOo0O00
  if 86 - 86: i1i1i1111I % I1Ii1I1
  if 72 - 72: oOO + i1I / I1I + Ii % I1Ii1I1 . oOo0O00
  if 13 - 13: ooo000 / Ii * i1iiIII111 / I1Ii1I1 + oOO + IiIIii11Ii
  if 88 - 88: I11iiIi11i1I + i1i1i1111I . OooOoo / ooOOO - oOo0O00
  if 63 - 63: oOO % ooOOO
  if 62 - 62: IiI11Ii111
  if 61 - 61: I11iiIi11i1I + Ooo0Ooo * IiIIii11Ii * Oo / oOO / IiIIii11Ii
  if 48 - 48: IiI11Ii111 - IiI11Ii111
  if 98 - 98: ooo000 - I1Ii1I1
  if 45 - 45: Iii1i % Ii . i1
  if 96 - 96: iI1iII1I1I1i
  if 88 - 88: I11iiIi11i1I * Iii1i - oOo0O00
  if 12 - 12: iI1iII1I1I1i * iI1iII1I1I1i * ooo000 % Iii1i / iI1iII1I1I1i
  return self . generatorController [ self . train . currentSourceDataset ] . getHeader ( outputsetKey )
  if 65 - 65: I11iiIi11i1I
 def getNextBatch ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None ) -> 'np.ndarray' :
  if 4 - 4: i1I + i1 - I11iiIi11i1I / i1i1i1111I
  if 39 - 39: i1iiIII111 / IiI11Ii111 * I1I - I1I * i1i1i1111I + i1i1i1111I
  if 44 - 44: ooOOO / IiIIii11Ii . IIiIIiIi11I1
  if 58 - 58: i1iiIII111 / i1iiIII111 % Iii1i / OooOoo % I1Ii1I1
  if 56 - 56: I11iiIi11i1I + i1 / I11iiIi11i1I * Oo
  if 97 - 97: IiI11Ii111 + I1Ii1I1 / oOO
  if 78 - 78: iI1iII1I1I1i + Oo % I11iiIi11i1I
  if 87 - 87: i1iiIII111
  if 25 - 25: IIiIIiIi11I1 / oOO * Oo + OooOoo / i1I / IiIIii11Ii
  if 82 - 82: i1iiIII111 / Ooo0Ooo * Ooo0Ooo + Iii1i . IiIIii11Ii
  if 56 - 56: oOo0O00
  if 12 - 12: ooOOO
  if 72 - 72: I11iiIi11i1I - ooo000 % iI1iII1I1I1i + ooOOO . Ooo0Ooo
  if 65 - 65: IIiIIiIi11I1 * I11iiIi11i1I / i1I
  return self . generatorController . getNextBatch ( datasetType = ( sourceDataset or self . train . currentSourceDataset ) )
  if 51 - 51: oOO . Oo
 def getData ( self , sourceDataset = None , start : int = None , end : int = None , indexes : List [ int ] = None ) -> 'np.ndarray' :
  if 17 - 17: i1i1i1111I * Ooo0Ooo % i1 - IiI11Ii111 * Oo - OooOoo
  if 81 - 81: IIiIIiIi11I1 / iI1iII1I1I1i * IIiIIiIi11I1 / I1I
  if 2 - 2: oOo0O00 . I11iiIi11i1I . Iii1i + IIiIIiIi11I1 * I11iiIi11i1I . i1iiIII111
  if 11 - 11: iI1iII1I1I1i - i1i1i1111I + ooo000 * i1i1i1111I
  if 4 - 4: iI1iII1I1I1i - i1I
  if 72 - 72: i1 + i1I / i1i1i1111I - I1I % I11iiIi11i1I
  if 11 - 11: IIiIIiIi11I1
  if 71 - 71: I11iiIi11i1I / Ooo0Ooo / IiI11Ii111 - Oo - Iii1i / IIiIIiIi11I1
  if 74 - 74: IIiIIiIi11I1 % IiI11Ii111 . I1I
  if 21 - 21: ooOOO
  if 15 - 15: oOO . i1 + IIiIIiIi11I1 % IiI11Ii111 * Ii
  if 13 - 13: oOo0O00 * i1 . iI1iII1I1I1i % I1Ii1I1
  if 95 - 95: ooOOO / I1Ii1I1
  if 86 - 86: i1iiIII111 . I1I + Ii % iI1iII1I1I1i . i1I / OooOoo
  if 27 - 27: iI1iII1I1I1i + I11iiIi11i1I % Oo % oOo0O00
  if 56 - 56: Ooo0Ooo + ooOOO * I1Ii1I1 % Ooo0Ooo / Ii
  if 33 - 33: IIiIIiIi11I1 . OooOoo
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getData ( start = start , end = end , indexes = indexes )
  if 47 - 47: Ii + ooOOO . Ooo0Ooo % OooOoo . Oo - i1
 def getRandItems ( self , sourceDataset : 'DataGenerator.Dataset.Types' = None , randomSeed : int = None , randomCount : int = None ) :
  if 95 - 95: Iii1i % I1I + OooOoo - i1i1i1111I - IIiIIiIi11I1 - i1i1i1111I
  if 87 - 87: I1I + I11iiIi11i1I
  if 84 - 84: Ii % ooo000 % i1I * i1I + oOo0O00
  if 83 - 83: ooo000 % i1I / oOo0O00 / Iii1i
  if 42 - 42: Ii * iI1iII1I1I1i * Ooo0Ooo / ooo000 + i1i1i1111I
  if 11 - 11: iI1iII1I1I1i * ooOOO * IIiIIiIi11I1 . ooOOO * IiI11Ii111
  if 76 - 76: Oo . IiIIii11Ii + IiI11Ii111 / Oo . i1I + IiI11Ii111
  if 57 - 57: oOo0O00 - i1
  if 42 - 42: IIiIIiIi11I1 . Oo . IiI11Ii111 * i1I / Iii1i + IiIIii11Ii
  if 6 - 6: ooo000 - Iii1i . Oo % Ooo0Ooo * IiIIii11Ii
  if 5 - 5: IiI11Ii111 * i1I / I11iiIi11i1I
  if 7 - 7: oOo0O00 . I1Ii1I1 + i1i1i1111I
  if 68 - 68: OooOoo . i1 . ooo000
  if 19 - 19: i1 + ooo000 / Ooo0Ooo + oOo0O00
  if 32 - 32: ooOOO % I1Ii1I1 * iI1iII1I1I1i . IiIIii11Ii
  if 37 - 37: IiIIii11Ii + I1Ii1I1
  return self . generatorController [ sourceDataset or self . train . currentSourceDataset ] . getRandItems ( randomSeed = randomSeed , randomCount = randomCount )
  if 32 - 32: i1I * OooOoo / ooOOO
 def recoverToRawData ( self , items ) :
  if 11 - 11: ooo000 * oOO % Ii
  if 97 - 97: iI1iII1I1I1i * oOO / Ooo0Ooo + Iii1i . i1 - oOO
  if 69 - 69: Iii1i + Oo * Iii1i % i1iiIII111 * i1i1i1111I
  if 2 - 2: i1i1i1111I . I1I % i1i1i1111I
  if 97 - 97: i1iiIII111 + oOo0O00 . i1i1i1111I . IiIIii11Ii * OooOoo % OooOoo
  if 68 - 68: I11iiIi11i1I + IiIIii11Ii
  if 60 - 60: Iii1i - i1I / Ii % Oo - IiIIii11Ii % Ooo0Ooo
  if 4 - 4: I11iiIi11i1I / ooo000 + OooOoo
  if 44 - 44: I11iiIi11i1I * i1 . Ooo0Ooo
  if 49 - 49: oOO . Ii % IiI11Ii111 . iI1iII1I1I1i
  if 20 - 20: IiI11Ii111 + i1iiIII111 + OooOoo
  if 13 - 13: Oo / i1iiIII111
  if 48 - 48: I1I * ooOOO . ooOOO * Iii1i
  return items
  if 35 - 35: Ooo0Ooo * ooOOO % IIiIIiIi11I1
 def getPrintableItems ( self , items : Union [ List , 'np.ndarray' ] , outputsetKey : str = None , recovered = True ) :
  if 59 - 59: I1Ii1I1 - IiI11Ii111 - Oo
  if 37 - 37: I1Ii1I1 * i1I
  if 19 - 19: Iii1i . i1I - ooo000 - iI1iII1I1I1i
  if 41 - 41: I11iiIi11i1I + Oo / Ii . Oo % I1I / ooOOO
  if 69 - 69: I1Ii1I1 / ooo000 / i1iiIII111 + Oo . oOO
  if 56 - 56: I11iiIi11i1I % i1i1i1111I * iI1iII1I1I1i
  if 95 - 95: oOO . Ii * IiI11Ii111 - oOo0O00
  if 52 - 52: Oo * Ii / Iii1i / i1
  if 45 - 45: I1Ii1I1 / I1I . Iii1i + ooo000
  if 34 - 34: Iii1i / i1I * oOO + IIiIIiIi11I1
  if 52 - 52: i1i1i1111I
  if 90 - 90: i1i1i1111I / i1 / i1iiIII111 . i1i1i1111I - Oo + IiI11Ii111
  if 47 - 47: I1I / OooOoo - i1i1i1111I + i1 / oOO
  if 56 - 56: IiI11Ii111 % iI1iII1I1I1i
  if 45 - 45: oOO - I1I / I11iiIi11i1I
  if outputsetKey is not None :
   raise ValueError ( "Table Source is not supported for outputsetKey parameter." )
   if 44 - 44: Oo / IiIIii11Ii / I1I - i1
  OO0oo0OoooOO = ""
  O0000000 = ( Ii1II11 ( items ) . tolist ( ) if items . __class__ . __name__ == "ndarray" else items )
  ooo000o = O0000000 [ 0 ] . __class__ . __name__ == "list"
  if ( not ooo000o ) or len ( O0000000 [ 0 ] ) == 1 :
   OO0oo0OoooOO = "Value"
   if ooo000o :
    O0000000 = [ c [ 0 ] for c in O0000000 ]
  else :
   OO0oo0OoooOO = "Table"
  return [ [ OO0oo0OoooOO , json . dumps ( i ) ] for i in O0000000 ]
  if 100 - 100: Ooo0Ooo / IiI11Ii111 + Ooo0Ooo / i1iiIII111 - i1I . i1
 @ staticmethod
 def convertCatToNumbers ( column , oneHot = False , manualList = None ) :
  if 62 - 62: Ii . Oo
  if 53 - 53: oOO % i1i1i1111I
  if 61 - 61: OooOoo / i1i1i1111I . I1I . I1Ii1I1
  if 66 - 66: i1i1i1111I . i1i1i1111I
  if 1 - 1: iI1iII1I1I1i % oOo0O00
  if 61 - 61: IiI11Ii111 * IiIIii11Ii
  if 56 - 56: Ooo0Ooo + i1I * oOo0O00 * i1i1i1111I - Ii / iI1iII1I1I1i
  if 19 - 19: Ooo0Ooo
  if 14 - 14: I1Ii1I1
  if 65 - 65: i1I + Ooo0Ooo
  if 82 - 82: ooo000
  if 81 - 81: ooo000 . ooOOO * oOO * Oo / I1I / Ii
  if 51 - 51: I1Ii1I1 . I11iiIi11i1I + I11iiIi11i1I - i1i1i1111I . Ii
  if 17 - 17: IIiIIiIi11I1 / Ooo0Ooo . Oo
  if 18 - 18: Ii - Ooo0Ooo
  if 89 - 89: oOo0O00
  if len ( column . shape ) > 1 :
   column = column . reshape ( [ - 1 ] )
   if 94 - 94: i1iiIII111 + oOO
   if 56 - 56: oOo0O00 . I11iiIi11i1I + I1Ii1I1
  if manualList is None :
   manualList = { v : idx for idx , v in enumerate ( { * column } ) }
   if 29 - 29: I1I
   if 90 - 90: I1Ii1I1 + iI1iII1I1I1i % i1 / Iii1i / iI1iII1I1I1i
  if oneHot :
   return { "data" : [ [ 1 if c == v else 0 for c in column ] for v in manualList . keys ( ) ] , "dict" : manualList }
  else :
   return { "data" : [ [ manualList [ c ] if c in manualList else - 1 ] for c in column ] , "dict" : manualList }
   if 58 - 58: IiIIii11Ii - I1I
 @ staticmethod
 def convertNumbersToCat ( columns , manualList ) :
  if 40 - 40: iI1iII1I1I1i + ooo000 + Iii1i + OooOoo
  if 25 - 25: IiIIii11Ii
  if 46 - 46: i1i1i1111I + Oo / oOo0O00 / I11iiIi11i1I / i1iiIII111 / IiI11Ii111
  if 81 - 81: i1i1i1111I - Ooo0Ooo . Iii1i
  if 81 - 81: ooOOO
  if 7 - 7: ooo000 / IIiIIiIi11I1
  if 55 - 55: Oo * i1 / iI1iII1I1I1i + Oo % Iii1i
  if 2 - 2: I1I / ooo000 . IiIIii11Ii - IiI11Ii111 * ooo000 . I1Ii1I1
  if 5 - 5: i1I . I11iiIi11i1I * iI1iII1I1I1i - i1I
  if 43 - 43: oOo0O00
  if 26 - 26: ooo000 . I11iiIi11i1I + i1iiIII111 + IIiIIiIi11I1 * iI1iII1I1I1i * IiIIii11Ii
  if 39 - 39: Oo % ooo000 * Ii
  if 86 - 86: IIiIIiIi11I1 . i1i1i1111I / Ooo0Ooo + Ooo0Ooo
  if 25 - 25: I1Ii1I1 - IiI11Ii111 - ooOOO + IiI11Ii111 * I1I
  if 8 - 8: Ooo0Ooo . oOo0O00 * oOO
  return np . array ( [ np . array ( [ k for k , v in manualList . items ( ) if v == r ] ) for r in columns ] )
  if 58 - 58: Iii1i
 @ staticmethod
 def getDataClassCount ( array : 'np.ndarray' ) -> int :
  if 19 - 19: Iii1i * IiI11Ii111 + i1I / ooo000
  if 87 - 87: Oo . IIiIIiIi11I1 - ooOOO
  if 38 - 38: Ii + i1 . i1i1i1111I - Ii - iI1iII1I1I1i
  if 41 - 41: Oo % Iii1i . Iii1i . OooOoo . oOO
  if 28 - 28: Ii - IiIIii11Ii / Ooo0Ooo * Ii / oOO / i1
  if 47 - 47: Ii / i1 + I11iiIi11i1I * i1I
  if 82 - 82: Ii . ooOOO + i1i1i1111I
  if 29 - 29: ooo000
  if 41 - 41: iI1iII1I1I1i * OooOoo . IiIIii11Ii . Oo . OooOoo
  if 19 - 19: OooOoo / i1i1i1111I - i1 * Iii1i / Ii % oOo0O00
  if 50 - 50: Oo * IiI11Ii111 / i1 - i1i1i1111I
  if 10 - 10: i1I - Oo - IIiIIiIi11I1
  if 90 - 90: Ooo0Ooo
  return len ( { * np . reshape ( array , [ - 1 ] ) } )
  if 17 - 17: oOO - i1i1i1111I / IiIIii11Ii + ooo000
 @ staticmethod
 def shuffleTogether ( * columns ) :
  if 60 - 60: iI1iII1I1I1i + Ii + ooo000 / IiIIii11Ii . Ooo0Ooo % Oo
  if 71 - 71: i1i1i1111I - i1 * iI1iII1I1I1i + IIiIIiIi11I1 . i1i1i1111I - I1I
  if 58 - 58: oOO % Ooo0Ooo * oOo0O00 - i1I + IiIIii11Ii
  if 77 - 77: iI1iII1I1I1i / Ooo0Ooo % I1Ii1I1 * ooo000
  if 46 - 46: Oo % IIiIIiIi11I1 . IiI11Ii111 % I1I - i1i1i1111I % i1i1i1111I
  if 63 - 63: I1I / oOO * I11iiIi11i1I % ooOOO / Iii1i
  if 86 - 86: IiIIii11Ii * I11iiIi11i1I
  if 50 - 50: I1I - oOO
  if 4 - 4: IiI11Ii111 - iI1iII1I1I1i / OooOoo / Iii1i . I11iiIi11i1I
  if 59 - 59: iI1iII1I1I1i - oOo0O00
  if 23 - 23: oOo0O00 + i1iiIII111 / oOo0O00 - Iii1i % I11iiIi11i1I - i1I
  if 33 - 33: ooo000
  if 17 - 17: i1 % i1iiIII111 . IiI11Ii111 - ooo000
  if 40 - 40: oOO % iI1iII1I1I1i
  i1IiiI = np . array ( list ( zip ( * columns ) ) , dtype = object )
  if 91 - 91: ooOOO + oOO / I1Ii1I1 - I1Ii1I1
  if 29 - 29: I1I
  np . random . shuffle ( i1IiiI )
  if 1 - 1: Iii1i . i1iiIII111 * i1i1i1111I
  if 21 - 21: ooOOO % Ooo0Ooo % I1I % Iii1i + IiI11Ii111 + IiIIii11Ii
  return ( np . array ( z ) for z in zip ( * i1IiiI ) )
  if 26 - 26: oOo0O00 * i1 . I1Ii1I1 + iI1iII1I1I1i
 @ staticmethod
 def getColList ( colCount , rangeStr : str = None ) -> List [ int ] :
  if 5 - 5: I1Ii1I1 * Iii1i
  if 26 - 26: i1i1i1111I * ooo000 / ooo000 / i1
  if 74 - 74: I11iiIi11i1I / I1Ii1I1 + oOO + OooOoo . Ii
  if 1 - 1: IiIIii11Ii % i1i1i1111I + IiIIii11Ii / Ooo0Ooo / OooOoo
  if 21 - 21: I11iiIi11i1I % Iii1i . IiIIii11Ii % Ii . Ii
  if 94 - 94: IiI11Ii111 . ooo000 - iI1iII1I1I1i + oOo0O00 % Oo
  if 7 - 7: I1I . i1I . IIiIIiIi11I1
  if 96 - 96: i1i1i1111I
  if 15 - 15: Iii1i - IIiIIiIi11I1 % OooOoo % i1 / i1iiIII111 % i1iiIII111
  if 38 - 38: I11iiIi11i1I - iI1iII1I1I1i + IIiIIiIi11I1 - i1iiIII111
  if 5 - 5: ooo000 * ooOOO / iI1iII1I1I1i + i1I . oOo0O00 + oOo0O00
  if 23 - 23: Ii + ooo000 - ooOOO - oOo0O00
  if 37 - 37: Ii
  if 49 - 49: i1I
  if 22 - 22: I11iiIi11i1I
  if rangeStr is None :
   return [ i for i in range ( 0 , colCount ) ]
   if 82 - 82: OooOoo . OooOoo / Ii
  return OoOo0000o . parse ( colCount , rangeStr )
  if 92 - 92: oOO * IIiIIiIi11I1
 @ staticmethod
 def arraySlice ( nparray : 'np.ndarray' , rangeStr : str = "None:None" ) -> 'np.ndarray' :
  if 88 - 88: I1I - oOO * oOo0O00 * OooOoo
  if 75 - 75: I11iiIi11i1I . ooo000 + OooOoo . i1 / Oo % I11iiIi11i1I
  if 18 - 18: IiIIii11Ii * Oo * oOo0O00
  if 95 - 95: Ooo0Ooo
  if 99 - 99: oOo0O00 / I1Ii1I1 . IiI11Ii111
  if 24 - 24: IIiIIiIi11I1 - I1I * Ooo0Ooo . iI1iII1I1I1i
  if 69 - 69: Iii1i + I1I + ooOOO - i1 + IiI11Ii111 . iI1iII1I1I1i
  if 89 - 89: OooOoo + i1I / iI1iII1I1I1i
  if 20 - 20: Oo . oOO * Iii1i - I1Ii1I1 + I11iiIi11i1I
  if 33 - 33: i1i1i1111I / IiIIii11Ii . I11iiIi11i1I
  if 59 - 59: iI1iII1I1I1i
  if 77 - 77: ooOOO
  if 71 - 71: I1I . I11iiIi11i1I % i1I / i1i1i1111I % Iii1i * I11iiIi11i1I
  if 51 - 51: oOo0O00
  if 35 - 35: IiIIii11Ii . i1 % i1iiIII111 % i1I . i1i1i1111I % I11iiIi11i1I
  if isinstance ( nparray , list ) :
   try :
    nparray = np . array ( nparray )
   except :
    raise ValueError ( "The list data is not supported for arraySlice() method. It should be a list convertible to an `np.ndarray` object." )
    if 9 - 9: ooo000 % i1I * Ooo0Ooo
    if 35 - 35: I1I + iI1iII1I1I1i / i1iiIII111 . IIiIIiIi11I1 % ooOOO * i1
  if not isinstance ( nparray , np . ndarray ) :
   raise ValueError ( "The nparray data is not supported for arraySlice() method. It should be an `np.ndarray` or `list` object." )
   if 30 - 30: I1I + ooOOO
   if 10 - 10: I11iiIi11i1I
  IiI1I11Iiii1 = len ( nparray [ 0 ] )
  if not OoOo0000o . validate ( IiI1I11Iiii1 , rangeStr ) :
   raise ValueError ( "Index range string is not valid." )
   if 34 - 34: i1 % OooOoo . OooOoo * oOo0O00 . iI1iII1I1I1i % I1Ii1I1
   if 68 - 68: i1 + IiI11Ii111 * I1I + IiIIii11Ii
  oo0I11 = OoOo0000o . toIndexer ( rangeStr )
  return nparray [ ... , oo0I11 ]
  if 6 - 6: Oo - iI1iII1I1I1i * Ii % oOO % ooo000 % IiIIii11Ii
 @ staticmethod
 def tensorSlice ( tensor : 'tf.Tensor|np.ndarray|list' , rangeStr : str = "None:None" ) -> 'tf.Tensor' :
  if 74 - 74: oOo0O00 + IIiIIiIi11I1 . I1Ii1I1 / oOo0O00 / I1Ii1I1
  if 43 - 43: I1I
  if 65 - 65: iI1iII1I1I1i . i1iiIII111 + i1iiIII111 - i1i1i1111I
  if 59 - 59: IiI11Ii111 * ooOOO
  if 22 - 22: Ii / Ooo0Ooo * i1I . oOo0O00
  if 95 - 95: I11iiIi11i1I + IiIIii11Ii
  if 22 - 22: IiIIii11Ii
  if 68 - 68: Iii1i - i1iiIII111 % oOo0O00
  if 96 - 96: OooOoo
  if 37 - 37: IIiIIiIi11I1 + oOO % I1I + Iii1i . i1iiIII111 * Iii1i
  if 60 - 60: i1iiIII111 / i1iiIII111 / I1Ii1I1 / oOo0O00 + IiI11Ii111 + OooOoo
  if 75 - 75: i1iiIII111 * IIiIIiIi11I1 * iI1iII1I1I1i % ooo000 % Oo * OooOoo
  if 72 - 72: Ii . ooOOO / I1Ii1I1 / I1Ii1I1
  if 48 - 48: ooOOO / IIiIIiIi11I1 - i1iiIII111 - i1i1i1111I
  if 51 - 51: Ooo0Ooo * Iii1i / i1i1i1111I / IIiIIiIi11I1
  if isinstance ( tensor , list ) or isinstance ( tensor , np . ndarray ) :
   try :
    tensor = tf . convert_to_tensor ( tensor )
   except :
    raise ValueError ( "The list data is not supported for tensorSlice() method. It should be a list convertible to an `tf.Tensor` object." )
    if 85 - 85: Oo . Ooo0Ooo
    if 21 - 21: ooOOO + i1i1i1111I / i1I - i1i1i1111I - iI1iII1I1I1i * Ooo0Ooo
  if not isinstance ( tensor , tf . Tensor ) :
   raise ValueError ( "The nparray data is not supported for tensorSlice() method. It should be an `tf.Tensor`, `np.ndarray` or `list` object." )
   if 6 - 6: Iii1i
   if 81 - 81: oOO . I1I * i1I
  IiI1I11Iiii1 = tensor . shape [ - 1 ]
  if not OoOo0000o . validate ( IiI1I11Iiii1 , rangeStr ) :
   raise ValueError ( "Index range string is not valid." )
   if 25 - 25: ooo000 * Ooo0Ooo * ooo000 - OooOoo
   if 51 - 51: I11iiIi11i1I
  oo0I11 = OoOo0000o . toIndexer ( rangeStr )
  if 79 - 79: i1iiIII111 * I11iiIi11i1I % I1I
  if isinstance ( oo0I11 , list ) :
   if 81 - 81: Ii . i1iiIII111 / i1iiIII111 * oOO
   if 35 - 35: IIiIIiIi11I1 / i1I - IIiIIiIi11I1
   return tf . concat ( [ tf . reshape ( tensor [ ... , idx ] , ( * ( s for s in tensor . shape [ : - 1 ] ) , 1 ) ) for idx in oo0I11 ] , axis = - 1 )
  else :
   return tensor [ ... , oo0I11 ]
   if 31 - 31: iI1iII1I1I1i . Iii1i + ooOOO
class o0o0oo0 ( o0ooo0oOoO ) :
 if 16 - 16: IiIIii11Ii * I11iiIi11i1I
 if 69 - 69: ooOOO . OooOoo / oOO . Iii1i
 if 91 - 91: I11iiIi11i1I - i1I * IiI11Ii111
 if 8 - 8: i1I
 if 65 - 65: Ooo0Ooo * Ooo0Ooo + I1I - ooOOO / IiIIii11Ii
 if 76 - 76: ooOOO * IIiIIiIi11I1 . iI1iII1I1I1i . I1Ii1I1 + oOo0O00
 if 58 - 58: IiI11Ii111 - oOO / i1iiIII111 % OooOoo . Iii1i . i1iiIII111
 class GeneratorDetail ( o0ooo0oOoO . GeneratorDetail ) :
  if 24 - 24: ooo000 + I1Ii1I1 + I1Ii1I1 - i1iiIII111 + oOO
  if 56 - 56: I1I
  if 36 - 36: i1i1i1111I - oOo0O00 + Iii1i . Oo
  if 24 - 24: Iii1i % oOo0O00 . oOo0O00 / oOO . I1Ii1I1
  if 37 - 37: oOO / Iii1i % ooo000
  if 60 - 60: I1Ii1I1 / I1I + i1I / Iii1i
  if 51 - 51: oOo0O00 + I1Ii1I1 * i1 / Iii1i . i1i1i1111I
  def __init__ ( self , controller : 'Source.MySQL.GeneratorController' ) :
   if 23 - 23: i1i1i1111I + oOO / i1 / Iii1i - iI1iII1I1I1i * IiI11Ii111
   if 8 - 8: I1I
   if 8 - 8: ooOOO / I1Ii1I1
   if 60 - 60: I1I * ooo000 . i1 - OooOoo * ooOOO
   if 11 - 11: I11iiIi11i1I . ooOOO . oOO - oOo0O00 * i1i1i1111I
   if 46 - 46: IiIIii11Ii / I11iiIi11i1I
   if 71 - 71: I11iiIi11i1I * Iii1i
   if 92 - 92: i1i1i1111I / ooOOO / I11iiIi11i1I / Ii - iI1iII1I1I1i . ooo000
   if 78 - 78: oOo0O00 . Iii1i
   if 20 - 20: ooOOO % i1i1i1111I % OooOoo % i1I
   super ( ) . __init__ ( controller )
   if 25 - 25: I1Ii1I1 - i1I
   if 58 - 58: IiI11Ii111 + IiIIii11Ii / IiIIii11Ii
   self . _oriData : np . ndarray = None
   if 3 - 3: Ooo0Ooo * i1I / OooOoo + Ii * IIiIIiIi11I1 + Ooo0Ooo
   self . _itrCount : int = 0
   if 27 - 27: i1i1i1111I . i1i1i1111I
   self . _hasHeader : bool = False
   if 22 - 22: i1iiIII111
   if 16 - 16: i1I + ooOOO % OooOoo
   if 60 - 60: oOO % iI1iII1I1I1i + Iii1i . Oo
   if 17 - 17: i1I / oOO - ooOOO - i1iiIII111
   if 16 - 16: oOO - IiIIii11Ii % Iii1i * IiIIii11Ii
   self . encoding : str = None
   if 87 - 87: I11iiIi11i1I
   self . _host : str = None
   self . _user : str = None
   self . _password : str = None
   self . _database : str = None
   self . _table : str = None
   if 1 - 1: Ii - i1 . i1i1i1111I * Iii1i + oOO
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 100 - 100: Ooo0Ooo . iI1iII1I1I1i / i1I / oOo0O00 - I1Ii1I1 . IIiIIiIi11I1
   if 99 - 99: OooOoo % I1Ii1I1 / oOo0O00 / i1 / OooOoo / I1I
   if 5 - 5: iI1iII1I1I1i * Ii * i1i1i1111I * I1Ii1I1 * ooo000
   if 71 - 71: i1 . I1I
   if 35 - 35: iI1iII1I1I1i / ooOOO
   if 91 - 91: OooOoo - OooOoo
   if 26 - 26: I1Ii1I1 % Ii - ooo000 . OooOoo - IiI11Ii111
   if 36 - 36: IIiIIiIi11I1 % I1Ii1I1
   if 34 - 34: iI1iII1I1I1i / i1I
   if 25 - 25: Ooo0Ooo * IiI11Ii111 / Ii
   if obj [ '_host' ] is not None :
    for Ii1I in [ "_host" , "_user" , "_password" , "_database" , "_table" ] :
     setattr ( self , Ii1I , obj [ Ii1I ] )
     if 61 - 61: I1Ii1I1 / IIiIIiIi11I1 - i1iiIII111
    self . readFile ( host = self . _host , user = self . _user , password = self . _password , database = self . _database , table = self . _table )
    if 68 - 68: iI1iII1I1I1i % oOo0O00 . ooo000 / i1 + i1I
    if 26 - 26: IiI11Ii111 - Ii - I1I
    if 17 - 17: oOo0O00 % Ii * oOo0O00 + IiIIii11Ii - Ooo0Ooo
    if 44 - 44: oOo0O00 * i1 % IIiIIiIi11I1 - OooOoo % Ii
    if 70 - 70: oOo0O00 * ooo000 + OooOoo . Oo * Iii1i
    if 61 - 61: i1I - oOO . oOO
    if 20 - 20: Oo - Ii - i1 . Ooo0Ooo
    if 31 - 31: Iii1i / ooOOO . Ooo0Ooo
    if 46 - 46: I1Ii1I1 / iI1iII1I1I1i % I1Ii1I1 % Iii1i % i1iiIII111 - i1
    if 46 - 46: ooOOO % I1Ii1I1 % i1i1i1111I - ooo000 * OooOoo % i1i1i1111I
    if 30 - 30: IiIIii11Ii % Oo
    if 49 - 49: Oo / ooOOO % oOO % i1
    if 37 - 37: I1I
    if 39 - 39: Ii - Oo % IIiIIiIi11I1
    if 61 - 61: I1I * I1I + i1
    if 61 - 61: IiI11Ii111 - i1I * ooOOO
    if 97 - 97: i1 + i1I . IiIIii11Ii
  def copy ( self ) -> 'Source.MySQL.GeneratorDetail' :
   if 19 - 19: Ooo0Ooo - i1 . Iii1i % IiIIii11Ii . i1 - ooOOO
   if 58 - 58: i1 * OooOoo % oOO
   if 93 - 93: i1iiIII111 / IiI11Ii111 % oOO - oOo0O00 + IiIIii11Ii
   if 45 - 45: oOo0O00 . i1iiIII111 . oOO
   if 98 - 98: IiI11Ii111 * ooOOO . Ii % ooo000
   if 6 - 6: IiI11Ii111 - I1Ii1I1 * ooOOO + IiI11Ii111
   if 89 - 89: OooOoo % I1I
   if 12 - 12: Iii1i / IiI11Ii111 + oOo0O00 . oOO - oOo0O00
   if 6 - 6: i1I * Iii1i + ooOOO % ooOOO / IIiIIiIi11I1
   if 35 - 35: IIiIIiIi11I1 % IIiIIiIi11I1 % OooOoo % Ooo0Ooo
   if 66 - 66: oOo0O00 / I11iiIi11i1I + i1i1i1111I / oOo0O00
   ii1IIiIIi : I1ii11II11 . MySQL . GeneratorDetail = I1ii11II11 . MySQL . GeneratorDetail ( self . controller )
   if 5 - 5: iI1iII1I1I1i . ooOOO . I1Ii1I1 - Ii - i1
   if 99 - 99: i1I / ooOOO + i1I * oOO * i1
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_oriData" , "_itrCount" , "_hasHeader" , "_host" , "_user" , "_password" , "_database" , "_table" , "encoding" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 42 - 42: Ooo0Ooo / OooOoo
   return ii1IIiIIi
   if 20 - 20: IIiIIiIi11I1 - i1iiIII111 - Ooo0Ooo . IIiIIiIi11I1 / IiI11Ii111
  def readFile ( self , host : str = "" , user : str = "" , password : str = "" , database : str = "" , table : str = "" , encoding : str = "utf8" , hasHeader : bool = False ) :
   if 28 - 28: i1iiIII111 * IiIIii11Ii
   if 34 - 34: ooOOO . oOO . IiIIii11Ii + ooo000 % I1Ii1I1
   if 26 - 26: I1I . ooo000 % iI1iII1I1I1i - i1 + ooOOO
   if 87 - 87: ooOOO . iI1iII1I1I1i - IIiIIiIi11I1 . Iii1i * Ooo0Ooo . oOo0O00
   if 42 - 42: IIiIIiIi11I1 * I1I
   if 45 - 45: IiI11Ii111 * Iii1i
   if 9 - 9: oOo0O00 / i1
   if 93 - 93: oOo0O00 % oOo0O00 - i1I + oOo0O00
   if 33 - 33: Iii1i . Iii1i + Oo
   if 58 - 58: Ooo0Ooo * IiIIii11Ii - Ii / Iii1i
   if 30 - 30: IiI11Ii111 % ooOOO * i1i1i1111I
   if 100 - 100: i1iiIII111
   if 17 - 17: I1Ii1I1 % oOo0O00 - Ii + ooOOO % Oo
   if 3 - 3: ooo000 % OooOoo - Iii1i + I1I * i1iiIII111 . ooOOO
   if 55 - 55: IIiIIiIi11I1 % iI1iII1I1I1i % oOo0O00
   if 83 - 83: Ooo0Ooo - i1iiIII111 % i1I . OooOoo / oOO % Ooo0Ooo
   import mysql . connector
   try :
    print ( host , user , password , database , table )
    iiii1i11i = mysql . connector . connect (
 host = host ,
 user = user ,
 passwd = password ,
 database = database
 )
    if 83 - 83: I11iiIi11i1I % I11iiIi11i1I / ooOOO . Ooo0Ooo . IiI11Ii111
    I11Ii1Ii = "SELECT * FROM " + table
    if 22 - 22: ooo000 + IIiIIiIi11I1 * oOO + i1I + i1
    IIiIiIiIi11Ii = iiii1i11i . cursor ( )
    if 19 - 19: i1 % Iii1i
    IIiIiIiIi11Ii . execute ( I11Ii1Ii )
    if 39 - 39: iI1iII1I1I1i - OooOoo % I11iiIi11i1I % I1I + IIiIIiIi11I1
    i11Iii = IIiIiIiIi11Ii . fetchall ( )
    if 81 - 81: Iii1i * I1Ii1I1 * i1i1i1111I
    OOO0Oo0oO0o00 = list ( map ( list , i11Iii ) )
    if 54 - 54: oOO + OooOoo
    print ( OOO0Oo0oO0o00 )
    if 80 - 80: I1Ii1I1 / ooOOO % OooOoo / iI1iII1I1I1i / i1i1i1111I . i1iiIII111
    if 17 - 17: IiIIii11Ii * IIiIIiIi11I1
    self . _host = host
    self . _user = user
    self . _password = password
    self . _database = database
    self . _table = table
    self . encoding = encoding
    self . _hasHeader = False
    if 67 - 67: oOo0O00
   except :
    raise ValueError ( "MySQL Server cannot be correctly connect." )
    if 71 - 71: oOO
    if 8 - 8: IiIIii11Ii . oOo0O00
   self . setData ( inputArray = OOO0Oo0oO0o00 , hasHeader = False )
   if 99 - 99: i1iiIII111
  @ property
  def host ( self ) -> str :
   return self . _host
   if 66 - 66: IiI11Ii111 - IiI11Ii111
   if 9 - 9: ooOOO . oOO . Ooo0Ooo
   if 89 - 89: IiIIii11Ii . i1 - Iii1i % Iii1i + Iii1i
   if 40 - 40: I1Ii1I1 + OooOoo + Ooo0Ooo
   if 41 - 41: Ii - IIiIIiIi11I1 - IiI11Ii111
   if 23 - 23: oOO % i1 % oOo0O00 / IiIIii11Ii
   if 68 - 68: i1I
   if 56 - 56: Ooo0Ooo % Iii1i / i1iiIII111 % ooo000 * IiIIii11Ii - i1iiIII111
   if 7 - 7: iI1iII1I1I1i / oOo0O00 - IIiIIiIi11I1 * i1I % i1 . i1
   if 79 - 79: Iii1i
  @ host . setter
  def host ( self , val : str ) :
   self . _host = val
   if 62 - 62: I1Ii1I1 - ooo000 % i1I
   if 14 - 14: Ii
   if 43 - 43: Ooo0Ooo
   if 83 - 83: I1I % I11iiIi11i1I + IIiIIiIi11I1 * ooo000 - I1I - Oo
   if 56 - 56: IiI11Ii111
   if 71 - 71: ooOOO - Ii * i1 + Ooo0Ooo - Ii - ooOOO
   if 11 - 11: Iii1i . i1i1i1111I - I1Ii1I1
   if 99 - 99: i1iiIII111 * Ii / Ii - iI1iII1I1I1i + IiI11Ii111 % i1
   if 35 - 35: I1Ii1I1 . oOo0O00 . oOO % i1i1i1111I + i1iiIII111 + IIiIIiIi11I1
   self . readFile ( host = self . _host , user = self . _user , password = self . _password , database = self . _database , table = self . _table )
   if 90 - 90: ooo000 + IiIIii11Ii . Ii - i1 - iI1iII1I1I1i
  @ property
  def user ( self ) -> str :
   return self . _user
   if 57 - 57: Oo
   if 65 - 65: ooOOO / Iii1i / Oo + IiIIii11Ii / i1
   if 21 - 21: ooo000 . Oo
   if 74 - 74: Oo * i1 - IIiIIiIi11I1
   if 97 - 97: oOo0O00 . ooOOO * I1Ii1I1 * oOo0O00 . I1Ii1I1 . Ii
   if 77 - 77: Ii . OooOoo
   if 83 - 83: i1 % ooOOO * Ooo0Ooo % IiIIii11Ii / iI1iII1I1I1i + IIiIIiIi11I1
   if 96 - 96: I1I + iI1iII1I1I1i * I1Ii1I1
   if 77 - 77: oOo0O00 + I1Ii1I1 . I1Ii1I1 + i1i1i1111I . Oo * ooo000
   if 75 - 75: I1I * ooo000 - ooOOO + Iii1i
  @ property
  def password ( self ) -> str :
   return self . _password
   if 96 - 96: I11iiIi11i1I * Ii . I1I + ooo000 % I1Ii1I1 + Ooo0Ooo
   if 67 - 67: oOO . Ooo0Ooo * Iii1i
   if 41 - 41: Ii % Ii
   if 80 - 80: IiIIii11Ii
   if 72 - 72: i1i1i1111I % Ooo0Ooo / i1I
   if 45 - 45: Ooo0Ooo + Ooo0Ooo + ooo000 - i1
   if 26 - 26: oOO
   if 2 - 2: ooOOO + I1I
   if 60 - 60: ooo000 . iI1iII1I1I1i
   if 54 - 54: iI1iII1I1I1i % Oo + oOo0O00 * ooo000 * ooOOO
  @ property
  def database ( self ) -> str :
   return self . _database
   if 51 - 51: ooo000
   if 24 - 24: i1i1i1111I * ooOOO . oOO
   if 23 - 23: i1i1i1111I . iI1iII1I1I1i * oOo0O00 * oOo0O00 + Ooo0Ooo
   if 78 - 78: I1Ii1I1 - oOo0O00 - i1I % IIiIIiIi11I1
   if 26 - 26: Oo . I1I / IiI11Ii111 . i1I * ooo000 + ooo000
   if 21 - 21: IIiIIiIi11I1 % i1iiIII111 % I1I + ooo000
   if 99 - 99: Ooo0Ooo
   if 36 - 36: OooOoo - i1I . Ooo0Ooo - I11iiIi11i1I + I11iiIi11i1I
   if 52 - 52: oOO . I1Ii1I1 . Oo + i1i1i1111I * i1 / IiI11Ii111
   if 67 - 67: IIiIIiIi11I1 - IIiIIiIi11I1 / i1I . i1i1i1111I + ooo000
  @ property
  def table ( self ) -> str :
   return self . table
   if 71 - 71: ooo000 . i1i1i1111I * IiIIii11Ii
   if 62 - 62: Ooo0Ooo / IiIIii11Ii / i1i1i1111I - Ii % OooOoo - oOO
   if 25 - 25: Ii . i1iiIII111 - Oo . Ooo0Ooo
   if 65 - 65: i1
   if 13 - 13: i1 . iI1iII1I1I1i * IiIIii11Ii
   if 97 - 97: OooOoo % Oo - OooOoo * ooOOO - ooOOO . Ii
   if 57 - 57: I1Ii1I1 % Iii1i * Ooo0Ooo * i1 / Oo
   if 43 - 43: Ooo0Ooo . IIiIIiIi11I1 * I1Ii1I1 % ooOOO - Iii1i / iI1iII1I1I1i
   if 11 - 11: Oo . I1I
   if 81 - 81: Oo - iI1iII1I1I1i / I11iiIi11i1I . i1I / iI1iII1I1I1i
 class GeneratorController ( o0ooo0oOoO . GeneratorController ) :
  if 93 - 93: i1iiIII111
  if 26 - 26: I11iiIi11i1I + Oo - oOo0O00 / Ii * oOO * I1I
  if 73 - 73: iI1iII1I1I1i + i1i1i1111I * oOo0O00 / IiI11Ii111
  if 97 - 97: OooOoo + IiIIii11Ii / IIiIIiIi11I1
  if 56 - 56: i1iiIII111 * Ii . iI1iII1I1I1i * ooOOO + Oo % oOo0O00
  if 21 - 21: ooOOO / iI1iII1I1I1i
  if 11 - 11: Ii * iI1iII1I1I1i + Oo + IiI11Ii111 - I1I
  def __init__ ( self , attachObject : Union [ 'Source.MySQL' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 85 - 85: IiIIii11Ii . oOo0O00
   if 39 - 39: i1I
   if 72 - 72: Oo + OooOoo % Oo - IiI11Ii111
   if 78 - 78: Iii1i % OooOoo + i1I - Oo % oOo0O00
   if 71 - 71: i1i1i1111I - Ooo0Ooo . i1iiIII111 % ooo000 * I1Ii1I1
   if 42 - 42: oOo0O00
   if 51 - 51: i1I % I1Ii1I1 * ooo000
   if 80 - 80: i1i1i1111I / IIiIIiIi11I1 - Oo - I11iiIi11i1I
   if 12 - 12: ooo000 . Oo
   if 21 - 21: I1Ii1I1
   super ( ) . __init__ ( attachObject = attachObject )
   if 53 - 53: ooOOO / I1I / Oo * Ooo0Ooo % Ooo0Ooo
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.MySQL.GeneratorDetail' ] :
   if 87 - 87: Ii
   if 45 - 45: IIiIIiIi11I1 % oOo0O00 * i1I * IiI11Ii111 * oOo0O00 * IiIIii11Ii
   if 32 - 32: Oo
   if 4 - 4: Iii1i % I1I
   if 52 - 52: ooOOO % IIiIIiIi11I1 . Oo + IiI11Ii111
   if 95 - 95: oOO * I11iiIi11i1I / iI1iII1I1I1i - Oo / IIiIIiIi11I1 % i1I
   if 70 - 70: i1i1i1111I % Oo . I1Ii1I1 / iI1iII1I1I1i
   if 71 - 71: oOO + I1Ii1I1 * Ii . I1Ii1I1 - i1i1i1111I - OooOoo
   if 50 - 50: Iii1i + I11iiIi11i1I
   if 86 - 86: ooo000 / OooOoo . ooo000 * I1Ii1I1 * oOo0O00
   return I1ii11II11 . MySQL . GeneratorDetail
   if 79 - 79: IIiIIiIi11I1 % oOo0O00 / i1iiIII111 % Ii % IiI11Ii111 - IiIIii11Ii
 def __init__ ( self , host : str = "" , user : str = "" , password : str = "" , database : str = "" , table : str = "" , encoding : str = "utf8" , hasHeader : bool = False , name : str = "" ) :
  if 28 - 28: OooOoo
  if 7 - 7: I1I / i1iiIII111 . Oo + i1I / I11iiIi11i1I / IiIIii11Ii
  if 4 - 4: i1I - IIiIIiIi11I1
  if 97 - 97: I1I
  if 42 - 42: Oo % IIiIIiIi11I1 + i1iiIII111
  if 15 - 15: Iii1i * ooOOO + oOo0O00
  if 99 - 99: I1I * ooo000 - Ii
  if 85 - 85: Ooo0Ooo
  if 61 - 61: I1I / ooo000 . IiIIii11Ii - IiIIii11Ii
  if 54 - 54: OooOoo . ooo000
  if 13 - 13: i1i1i1111I - ooo000
  if 39 - 39: i1
  if 20 - 20: iI1iII1I1I1i % I1I * IiIIii11Ii
  if 60 - 60: Ii
  if 5 - 5: Oo . i1I - iI1iII1I1I1i . ooOOO
  if 13 - 13: I11iiIi11i1I - i1i1i1111I - ooOOO * iI1iII1I1I1i % I1I
  if 12 - 12: Ooo0Ooo * Oo . Ii
  if 33 - 33: IIiIIiIi11I1 + I1I + oOo0O00 . i1
  super ( ) . __init__ ( name = name )
  if 2 - 2: IIiIIiIi11I1 . Oo . ooo000 . I11iiIi11i1I + I11iiIi11i1I / IiIIii11Ii
  if 18 - 18: OooOoo - I1Ii1I1 % i1I % IIiIIiIi11I1
  self . _instanceClass = I1ooOoO0OooO . MySQL
  if 98 - 98: IiIIii11Ii % Oo + OooOoo
  if 93 - 93: ooOOO / IiI11Ii111 + I11iiIi11i1I + I11iiIi11i1I * Ii - i1I
  self . generatorController = I1ii11II11 . MySQL . GeneratorController ( self )
  if 28 - 28: iI1iII1I1I1i - ooOOO + I11iiIi11i1I
  if 37 - 37: Ooo0Ooo * Iii1i % I1I % ooo000 * i1 * ooo000
  if len ( host ) :
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . readFile ( host = host , user = user , password = password , database = database , table = table , encoding = encoding , hasHeader = False )
   if 52 - 52: IiIIii11Ii . iI1iII1I1I1i
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 95 - 95: ooOOO . iI1iII1I1I1i / iI1iII1I1I1i % Oo - i1i1i1111I * I1Ii1I1
  if 60 - 60: ooo000 . I1I . ooo000 . oOO % oOO
  if 14 - 14: i1I % Ii
  if 15 - 15: I11iiIi11i1I - i1iiIII111 + ooo000 - iI1iII1I1I1i + Ii / Iii1i
  if 58 - 58: I1Ii1I1 . I11iiIi11i1I . i1 . I1Ii1I1 / Oo + OooOoo
  if 41 - 41: Ooo0Ooo % Oo . I1I
  if 31 - 31: IiIIii11Ii % I1I * ooo000
  if 68 - 68: i1I
  if 98 - 98: i1I
  if 69 - 69: Ooo0Ooo - oOo0O00 - Ooo0Ooo % iI1iII1I1I1i
  if 11 - 11: ooOOO * i1i1i1111I - IiIIii11Ii / i1I . i1
  super ( ) . parseJSON ( obj , train )
  if 61 - 61: Ii
class iI1 ( o0ooo0oOoO ) :
 if 41 - 41: IIiIIiIi11I1 - i1iiIII111
 if 37 - 37: oOO / Ii + Oo - ooo000
 if 85 - 85: I1Ii1I1 * I11iiIi11i1I
 if 27 - 27: IIiIIiIi11I1 - IiIIii11Ii - IIiIIiIi11I1 * IiI11Ii111 / oOO
 if 46 - 46: iI1iII1I1I1i . Oo * oOo0O00
 if 74 - 74: i1i1i1111I % IiI11Ii111 % Oo * I1Ii1I1 - IiIIii11Ii . OooOoo
 if 77 - 77: OooOoo % i1
 class GeneratorDetail ( o0ooo0oOoO . GeneratorDetail ) :
  if 86 - 86: oOo0O00
  if 9 - 9: oOo0O00 . ooo000 * iI1iII1I1I1i % IiIIii11Ii . i1i1i1111I - OooOoo
  if 24 - 24: Ooo0Ooo
  if 55 - 55: i1i1i1111I - IiIIii11Ii + IiIIii11Ii * i1iiIII111 - ooOOO . ooo000
  if 57 - 57: i1iiIII111 + IiIIii11Ii . Ii - i1iiIII111
  if 90 - 90: I1I / oOo0O00 - oOo0O00 - oOO
  if 32 - 32: IiI11Ii111
  def __init__ ( self , controller : 'Source.CSV.GeneratorController' ) :
   if 17 - 17: IIiIIiIi11I1 . IIiIIiIi11I1 - oOo0O00 . Ooo0Ooo * I1Ii1I1
   if 26 - 26: Oo . I11iiIi11i1I * I1Ii1I1
   if 84 - 84: I1Ii1I1 / oOO + oOo0O00 % oOO + IiI11Ii111 . i1iiIII111
   if 87 - 87: iI1iII1I1I1i - Oo
   if 10 - 10: IiIIii11Ii . Oo
   if 93 - 93: IIiIIiIi11I1 - oOO % i1 / IiIIii11Ii
   if 47 - 47: i1
   if 46 - 46: iI1iII1I1I1i / IiIIii11Ii
   if 76 - 76: IiIIii11Ii / i1i1i1111I
   if 86 - 86: oOo0O00 % i1 . Ii % IIiIIiIi11I1 % oOO
   super ( ) . __init__ ( controller )
   if 60 - 60: i1i1i1111I + oOo0O00 * IiIIii11Ii * I11iiIi11i1I / oOO
   if 41 - 41: I1I % I11iiIi11i1I
   self . _oriData : np . ndarray = None
   if 49 - 49: iI1iII1I1I1i + i1I . Ooo0Ooo % i1
   self . _itrCount : int = 0
   if 54 - 54: ooOOO % I1I / i1iiIII111 % i1I
   self . _hasHeader : bool = False
   if 44 - 44: ooOOO - OooOoo / i1i1i1111I / oOo0O00 + Ii % oOO
   self . _path : str = None
   if 9 - 9: OooOoo / I11iiIi11i1I + I1I . i1I
   self . _fileName : str = None
   if 92 - 92: IIiIIiIi11I1 / Oo % Ooo0Ooo % I1Ii1I1
   self . encoding : str = None
   if 28 - 28: oOo0O00 - i1iiIII111 % IiI11Ii111 - i1i1i1111I * i1iiIII111 - IIiIIiIi11I1
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 65 - 65: Ii * I1I . ooo000
   if 55 - 55: Ii / Ooo0Ooo
   if 92 - 92: I1I / Iii1i - ooo000 - I1Ii1I1 . i1iiIII111 - IiI11Ii111
   if 36 - 36: ooOOO + IiIIii11Ii / i1 / IIiIIiIi11I1 * oOO % Iii1i
   if 97 - 97: Ii / oOO * i1i1i1111I
   if 56 - 56: IIiIIiIi11I1 + oOO * OooOoo - Iii1i / iI1iII1I1I1i
   if 37 - 37: IiI11Ii111 + I1I % Ii
   if 89 - 89: OooOoo . Iii1i / ooo000
   if 25 - 25: Ii - oOO - IiIIii11Ii . I1Ii1I1 % i1i1i1111I
   if 68 - 68: ooo000
   if 77 - 77: i1iiIII111 - IiIIii11Ii / iI1iII1I1I1i * oOo0O00
   for Ii1I in Oooo0OooOOOo0 ( obj , [ "_hasHeader" , "encoding" , "_path" ] ) :
    iiiiIi1IiiIi = obj [ Ii1I ]
    if Ii1I == "_path" :
     if iiiiIi1IiiIi is not None :
      self . path = iiiiIi1IiiIi
     else :
      if 51 - 51: IiIIii11Ii . ooOOO - oOO
      for Oo0OOo000oo in [ "_hasHeader" , "encoding" , "_path" , "_fileName" ] :
       setattr ( self , Oo0OOo000oo , obj [ Oo0OOo000oo ] )
    elif Ii1I not in [ "_controller" , "_oriShape" , "_oriData" , "_epochSize" , "_itrCount" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 2 - 2: ooo000 - i1i1i1111I / oOo0O00 - IiI11Ii111 % IiIIii11Ii
  def copy ( self ) -> 'Source.CSV.GeneratorDetail' :
   if 79 - 79: i1 + Ooo0Ooo
   if 16 - 16: i1
   if 69 - 69: oOO + Oo - ooOOO - oOo0O00
   if 45 - 45: IiI11Ii111 * OooOoo . Ii . i1iiIII111
   if 27 - 27: Ooo0Ooo . oOo0O00
   if 2 - 2: iI1iII1I1I1i . ooo000 % I11iiIi11i1I + i1i1i1111I % i1I + iI1iII1I1I1i
   if 51 - 51: i1i1i1111I * Iii1i % Oo
   if 62 - 62: IiI11Ii111 % i1 * I11iiIi11i1I
   if 25 - 25: iI1iII1I1I1i % IiIIii11Ii % Iii1i - I11iiIi11i1I
   if 34 - 34: iI1iII1I1I1i . iI1iII1I1I1i % Ii - Iii1i
   if 38 - 38: OooOoo + iI1iII1I1I1i
   ii1IIiIIi : I1ii11II11 . CSV . GeneratorDetail = I1ii11II11 . CSV . GeneratorDetail ( self . controller )
   if 95 - 95: IiIIii11Ii % i1iiIII111 % oOo0O00 / Oo
   if 7 - 7: oOo0O00 + Ii / I1Ii1I1 / Iii1i
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_oriData" , "_itrCount" , "_hasHeader" , "_path" , "_fileName" , "encoding" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 71 - 71: ooOOO
   return ii1IIiIIi
   if 4 - 4: I11iiIi11i1I
  def readFile ( self , path = "" , encoding = "utf8" , hasHeader = True ) :
   if 36 - 36: oOO
   if 52 - 52: I1Ii1I1 + I1I / i1I + Iii1i - I1I + i1I
   if 54 - 54: oOo0O00 / IiI11Ii111 % i1iiIII111 - I11iiIi11i1I + IiI11Ii111 / oOo0O00
   if 67 - 67: OooOoo . i1 - I1Ii1I1 + Ooo0Ooo
   if 59 - 59: I1I + IIiIIiIi11I1
   if 12 - 12: Iii1i + I1Ii1I1 % Ooo0Ooo % i1 - i1i1i1111I * oOO
   if 76 - 76: Iii1i % Oo
   if 42 - 42: Iii1i + oOo0O00 . Iii1i
   if 14 - 14: i1iiIII111 / Ii * I1I
   if 6 - 6: ooo000 . ooOOO * ooOOO - Oo * i1 - Oo
   if 86 - 86: oOO + Ii
   if 77 - 77: i1iiIII111 + ooo000 * I1Ii1I1 - ooo000 * I11iiIi11i1I
   try :
    if 11 - 11: Oo
    with open ( path , encoding = encoding ) as f :
     IIi11ii1IIi = [ * csv . reader ( f ) ]
     if 4 - 4: ooOOO . i1i1i1111I + iI1iII1I1I1i
     if 40 - 40: Ooo0Ooo . Ooo0Ooo + IiIIii11Ii / i1i1i1111I * i1i1i1111I
    OOO0Oo0oO0o00 = np . vstack ( [ np . array ( r , dtype = object ) for r in IIi11ii1IIi if len ( r ) ] )
    if 37 - 37: Iii1i * IiI11Ii111 . I11iiIi11i1I . oOO + I1I + IiI11Ii111
    if 32 - 32: I1I
    self . _path = path
    self . _fileName = path [ max ( [ path . rfind ( "/" ) , path . rfind ( "\\" ) ] ) + 1 : ]
    self . encoding = encoding
    self . _hasHeader = hasHeader
    if 83 - 83: i1iiIII111 % iI1iII1I1I1i + iI1iII1I1I1i . IiI11Ii111 * oOo0O00
   except :
    raise ValueError ( "CSV file cannot be correctly read." )
    if 31 - 31: i1iiIII111 + OooOoo / OooOoo / iI1iII1I1I1i
    if 30 - 30: IiI11Ii111 - Oo
   self . setData ( inputArray = OOO0Oo0oO0o00 , hasHeader = hasHeader )
   if 68 - 68: I1Ii1I1
  @ property
  def path ( self ) -> str :
   if 44 - 44: OooOoo
   if 94 - 94: Ooo0Ooo / IiIIii11Ii - oOO / I1Ii1I1 * oOo0O00 - oOO
   if 14 - 14: Oo * OooOoo
   if 19 - 19: Iii1i / ooOOO * i1I
   if 90 - 90: I11iiIi11i1I - Ooo0Ooo + oOo0O00 * oOo0O00 * i1i1i1111I * I1I
   if 17 - 17: Ii * IIiIIiIi11I1
   if 10 - 10: oOO
   if 99 - 99: IiIIii11Ii / IiIIii11Ii - oOO
   if 75 - 75: oOo0O00 % I11iiIi11i1I
   if 67 - 67: IiIIii11Ii . Ii % i1i1i1111I - OooOoo % OooOoo % I1Ii1I1
   return self . _path
   if 10 - 10: ooo000 / I11iiIi11i1I + ooOOO
  @ path . setter
  def path ( self , val : str ) :
   if 89 - 89: Ooo0Ooo * i1i1i1111I + i1 - i1i1i1111I
   if 35 - 35: Ii
   if 65 - 65: IIiIIiIi11I1 % i1 % ooo000 + oOO . oOo0O00 % IiIIii11Ii
   if 24 - 24: oOo0O00 / i1iiIII111 * OooOoo
   if 39 - 39: I11iiIi11i1I - Iii1i
   if 11 - 11: oOO . oOO / i1I - IIiIIiIi11I1
   if 97 - 97: Ii
   if 35 - 35: oOO . I1I + Oo / IIiIIiIi11I1 * iI1iII1I1I1i + IiIIii11Ii
   if 9 - 9: ooo000 * IiIIii11Ii % ooOOO
   if 49 - 49: IIiIIiIi11I1
   self . _path = val
   self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader )
   if 52 - 52: oOO * I1I / oOo0O00 . iI1iII1I1I1i + Oo - Oo
  @ property
  def fileName ( self ) -> str :
   if 7 - 7: IiIIii11Ii / i1i1i1111I
   if 38 - 38: ooOOO - oOo0O00 % i1i1i1111I
   if 29 - 29: Ooo0Ooo / iI1iII1I1I1i % i1i1i1111I * IiI11Ii111 - I1Ii1I1 / oOO
   if 99 - 99: ooo000 % I1Ii1I1 + IIiIIiIi11I1
   if 9 - 9: iI1iII1I1I1i + Oo . i1 - oOo0O00 % ooo000 / ooo000
   if 41 - 41: i1i1i1111I
   if 17 - 17: IIiIIiIi11I1 / iI1iII1I1I1i + i1i1i1111I / I11iiIi11i1I % oOo0O00 - Iii1i
   if 52 - 52: IiIIii11Ii . OooOoo
   if 88 - 88: oOO / oOO . i1iiIII111 + ooo000
   if 73 - 73: IiIIii11Ii + Oo - IIiIIiIi11I1
   return self . _fileName
   if 47 - 47: i1i1i1111I - ooOOO
  def getLocations ( self ) -> List [ str ] :
   if 21 - 21: iI1iII1I1I1i . IiI11Ii111
   if 65 - 65: i1 - Ii
   if 60 - 60: Ii / iI1iII1I1I1i
   if 3 - 3: ooOOO / Iii1i / OooOoo
   if 55 - 55: IiI11Ii111 + ooo000
   if 6 - 6: I11iiIi11i1I . i1iiIII111 * i1I . oOo0O00
   if 82 - 82: I1Ii1I1
   if 12 - 12: i1
   if 16 - 16: I1I + I1I % Oo
   if 49 - 49: IiIIii11Ii
   return [ self . fileName ] if self . fileName else [ ]
   if 31 - 31: I11iiIi11i1I . Ii / I1Ii1I1 / iI1iII1I1I1i / IIiIIiIi11I1
 class GeneratorController ( o0ooo0oOoO . GeneratorController ) :
  if 78 - 78: ooOOO + IiI11Ii111 / i1i1i1111I * I1Ii1I1
  if 1 - 1: OooOoo % iI1iII1I1I1i / IIiIIiIi11I1 . i1 . oOo0O00 + I11iiIi11i1I
  if 1 - 1: i1I . i1I % Oo / IiI11Ii111
  if 51 - 51: IIiIIiIi11I1 . Iii1i - i1i1i1111I
  if 41 - 41: Iii1i . i1 + IiIIii11Ii % I1Ii1I1 * Ooo0Ooo % i1I
  if 12 - 12: I1I . IIiIIiIi11I1 / Iii1i
  if 39 - 39: Oo % iI1iII1I1I1i
  def __init__ ( self , attachObject : Union [ 'Source.CSV' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 75 - 75: Ii / OooOoo / Oo / Ii . IiI11Ii111
   if 27 - 27: oOO - i1i1i1111I % i1I / ooo000 + i1iiIII111
   if 89 - 89: IiIIii11Ii / IIiIIiIi11I1 % i1I / I1I
   if 88 - 88: I1Ii1I1
   if 85 - 85: I11iiIi11i1I - i1I
   if 24 - 24: i1iiIII111 - i1I - oOO % oOo0O00 - IIiIIiIi11I1
   if 96 - 96: oOo0O00
   if 83 - 83: IiI11Ii111 + ooOOO - i1I - I1Ii1I1 * i1
   if 59 - 59: i1i1i1111I . IiI11Ii111 - i1 + ooOOO
   if 29 - 29: oOO - Iii1i
   super ( ) . __init__ ( attachObject = attachObject )
   if 35 - 35: Iii1i % OooOoo - I1I % OooOoo . OooOoo
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.CSV.GeneratorDetail' ] :
   if 65 - 65: I1I % i1i1i1111I + Iii1i / ooOOO
   if 95 - 95: IiIIii11Ii / i1 - oOo0O00 + i1i1i1111I / Oo / Ooo0Ooo
   if 91 - 91: i1I . iI1iII1I1I1i . I1I % ooo000 % i1I
   if 83 - 83: ooo000
   if 89 - 89: OooOoo % iI1iII1I1I1i % Iii1i . IIiIIiIi11I1 * I1Ii1I1 - i1iiIII111
   if 74 - 74: I1Ii1I1 - ooOOO . I1Ii1I1 % i1i1i1111I - oOo0O00
   if 21 - 21: IiI11Ii111 . I11iiIi11i1I + Ooo0Ooo
   if 89 - 89: ooo000 + oOO * ooo000 / I1I
   if 26 - 26: IiI11Ii111 . i1
   if 26 - 26: I1Ii1I1 % oOo0O00
   return I1ii11II11 . CSV . GeneratorDetail
   if 49 - 49: IiI11Ii111 . I1I * i1 - OooOoo
 def __init__ ( self , fileName : str = "" , encoding : str = "utf8" , hasHeader : bool = True , name : str = "" ) :
  if 71 - 71: Oo . i1iiIII111
  if 45 - 45: Ooo0Ooo . IiIIii11Ii - I1Ii1I1 * Oo . I11iiIi11i1I * Ooo0Ooo
  if 5 - 5: OooOoo * Oo
  if 40 - 40: ooo000 * ooOOO + oOo0O00
  if 78 - 78: ooo000 % Ii % ooo000 * I1Ii1I1 + I1Ii1I1
  if 61 - 61: oOo0O00 . i1
  if 68 - 68: oOo0O00 . OooOoo . ooOOO . i1iiIII111 + Ooo0Ooo - oOo0O00
  if 36 - 36: IIiIIiIi11I1 + iI1iII1I1I1i * Ii / oOO . IiIIii11Ii . Iii1i
  if 86 - 86: ooOOO . oOO + IiIIii11Ii % OooOoo + I11iiIi11i1I
  if 43 - 43: i1i1i1111I / i1iiIII111
  if 69 - 69: I11iiIi11i1I % OooOoo / oOo0O00 / oOO / ooOOO
  if 76 - 76: oOO / Ooo0Ooo - i1i1i1111I - Ooo0Ooo
  if 99 - 99: i1i1i1111I
  if 5 - 5: oOo0O00 % IiIIii11Ii * IiI11Ii111 . oOO
  super ( ) . __init__ ( name = name )
  if 46 - 46: i1I % IiIIii11Ii . IIiIIiIi11I1
  if 79 - 79: ooo000 + i1I . IIiIIiIi11I1 + Oo / IIiIIiIi11I1 * I11iiIi11i1I
  self . _instanceClass = I1ooOoO0OooO . CSV
  if 98 - 98: Iii1i + ooo000 / ooo000 * IIiIIiIi11I1 * ooo000
  if 41 - 41: I11iiIi11i1I / i1iiIII111 % I1I
  self . generatorController = I1ii11II11 . CSV . GeneratorController ( self )
  if 65 - 65: i1iiIII111
  if 26 - 26: I1I + OooOoo
  if len ( fileName ) :
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . readFile ( fileName = fileName , encoding = encoding , hasHeader = hasHeader )
   if 49 - 49: I11iiIi11i1I * I1Ii1I1 % IIiIIiIi11I1
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 53 - 53: Oo % Iii1i + oOO * IiIIii11Ii % Ii
  if 7 - 7: IiI11Ii111 % IiI11Ii111
  if 7 - 7: Ooo0Ooo - oOO + oOO / Ii
  if 83 - 83: OooOoo * i1 - oOO + Ooo0Ooo
  if 57 - 57: I11iiIi11i1I / i1iiIII111 . I11iiIi11i1I
  if 68 - 68: Oo % Ii + Iii1i / i1I
  if 12 - 12: IIiIIiIi11I1 / I1Ii1I1 . i1 % IiI11Ii111 - Ii . Iii1i
  if 20 - 20: Ooo0Ooo / iI1iII1I1I1i / i1I * i1
  if 44 - 44: i1I % ooOOO + i1i1i1111I * i1 + OooOoo - i1iiIII111
  if 77 - 77: i1I + Oo + OooOoo % I11iiIi11i1I / i1I
  if 19 - 19: i1iiIII111 * Ii * IIiIIiIi11I1 / IiI11Ii111 + ooOOO
  super ( ) . parseJSON ( obj , train )
  if 7 - 7: Ii * iI1iII1I1I1i - i1 % iI1iII1I1I1i
class ii1I11I1IIi ( o0ooo0oOoO ) :
 if 23 - 23: iI1iII1I1I1i / i1
 if 74 - 74: Ii / I1I
 if 82 - 82: iI1iII1I1I1i
 if 48 - 48: IiIIii11Ii
 if 93 - 93: OooOoo . Ooo0Ooo - IIiIIiIi11I1 . i1I
 if 5 - 5: I11iiIi11i1I % Ii
 if 59 - 59: I1Ii1I1 . i1i1i1111I * Iii1i - i1I + Ii
 class GeneratorDetail ( o0ooo0oOoO . GeneratorDetail ) :
  if 16 - 16: i1I * Ooo0Ooo / Ii + i1 . IiI11Ii111
  if 73 - 73: IiIIii11Ii
  if 49 - 49: oOo0O00 / ooOOO / Oo - Oo * I1I
  if 41 - 41: I1I . IiIIii11Ii % IiI11Ii111 * IIiIIiIi11I1 / ooOOO * ooo000
  if 71 - 71: Ooo0Ooo
  if 20 - 20: OooOoo
  if 56 - 56: I1I % i1i1i1111I - IIiIIiIi11I1 + ooOOO . Iii1i
  def __init__ ( self , controller : 'Source.CSV.GeneratorController' ) :
   if 52 - 52: oOo0O00 / Oo - OooOoo . i1iiIII111 / Oo
   if 60 - 60: i1I + i1iiIII111
   if 63 - 63: oOo0O00 + IiI11Ii111
   if 25 - 25: I1I - I1I . Ii . oOO
   if 48 - 48: Ooo0Ooo + oOo0O00 . i1I % IIiIIiIi11I1 . IiIIii11Ii - oOo0O00
   if 85 - 85: oOo0O00 % iI1iII1I1I1i . iI1iII1I1I1i - oOO + i1 / Oo
   if 55 - 55: Ooo0Ooo % iI1iII1I1I1i + Ii
   if 23 - 23: i1i1i1111I . oOO - ooOOO . IIiIIiIi11I1
   if 35 - 35: i1I - oOo0O00
   if 89 - 89: Ii % oOo0O00 + ooo000 * i1
   super ( ) . __init__ ( controller )
   if 44 - 44: i1i1i1111I + i1 + i1iiIII111 . I11iiIi11i1I / i1 - IIiIIiIi11I1
   if 60 - 60: I1I + IiI11Ii111
   self . _oriData : np . ndarray = None
   if 83 - 83: i1I * i1i1i1111I
   self . _itrCount : int = 0
   if 86 - 86: IiI11Ii111 - I11iiIi11i1I - IiIIii11Ii
   self . _hasHeader : bool = False
   if 10 - 10: IIiIIiIi11I1 - i1
   self . _path : str = None
   if 76 - 76: I11iiIi11i1I
   self . _fileName : str = None
   if 81 - 81: ooOOO % i1 * I11iiIi11i1I * I1I
   self . encoding : str = None
   if 63 - 63: I1Ii1I1 . i1iiIII111 + I1Ii1I1
   self . _delimiter : str = ","
   if 98 - 98: Ii + Ii * IiIIii11Ii / OooOoo / ooOOO
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 37 - 37: Ooo0Ooo - oOO % i1
   if 27 - 27: ooo000 . Ii - IIiIIiIi11I1
   if 62 - 62: Ooo0Ooo % ooo000
   if 59 - 59: I11iiIi11i1I - oOO
   if 53 - 53: oOO * ooo000 * Oo - iI1iII1I1I1i % I1I . I1Ii1I1
   if 2 - 2: OooOoo * I1Ii1I1 / Ooo0Ooo * IIiIIiIi11I1 - I1Ii1I1
   if 21 - 21: ooo000 * OooOoo - I1Ii1I1 / I1I
   if 22 - 22: Iii1i * i1iiIII111 - Ooo0Ooo * Oo % oOO
   if 72 - 72: i1I
   if 46 - 46: iI1iII1I1I1i - ooOOO + iI1iII1I1I1i
   if 50 - 50: Ooo0Ooo % IiI11Ii111 . Oo . IiI11Ii111 - i1i1i1111I / Iii1i
   for Ii1I in Oooo0OooOOOo0 ( obj , [ "_hasHeader" , "encoding" , "_delimiter" , "_path" ] ) :
    iiiiIi1IiiIi = obj [ Ii1I ]
    if Ii1I == "_path" :
     if iiiiIi1IiiIi is not None :
      self . path = iiiiIi1IiiIi
     else :
      if 79 - 79: i1 % Ii * OooOoo % IiIIii11Ii + Iii1i . oOo0O00
      for Oo0OOo000oo in [ "_hasHeader" , "encoding" , "_delimiter" , "_path" , "_fileName" ] :
       setattr ( self , Oo0OOo000oo , obj [ Oo0OOo000oo ] )
    elif Ii1I not in [ "_controller" , "_oriShape" , "_oriData" , "_epochSize" , "_itrCount" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 80 - 80: IIiIIiIi11I1 % Ii * i1I % i1
  def copy ( self ) -> 'Source.CSV.GeneratorDetail' :
   if 56 - 56: ooo000 . I1Ii1I1 / iI1iII1I1I1i / Ii * I1Ii1I1 . ooo000
   if 12 - 12: i1I - I1I + i1 + I1Ii1I1
   if 80 - 80: ooo000 . ooOOO * ooo000
   if 4 - 4: i1i1i1111I
   if 48 - 48: ooo000 . Iii1i - IIiIIiIi11I1
   if 23 - 23: oOO % ooo000 * I11iiIi11i1I + Ii / i1I
   if 66 - 66: Ooo0Ooo - oOo0O00
   if 95 - 95: Ooo0Ooo
   if 48 - 48: IIiIIiIi11I1
   if 92 - 92: ooo000 + i1 - IiIIii11Ii % iI1iII1I1I1i
   if 48 - 48: iI1iII1I1I1i
   ii1IIiIIi : I1ii11II11 . CSV . GeneratorDetail = ii1I11I1IIi . GeneratorDetail ( self . controller )
   if 12 - 12: I1Ii1I1 + oOo0O00 / i1i1i1111I
   if 35 - 35: i1I * Ii . Iii1i % i1iiIII111 * i1I / Iii1i
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_oriData" , "_itrCount" , "_hasHeader" , "_path" , "_fileName" , "encoding" , "_delimiter" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 37 - 37: Ii
   return ii1IIiIIi
   if 35 - 35: ooOOO + oOO . iI1iII1I1I1i . i1I - i1iiIII111 / Ii
  def readFile ( self , path = "" , encoding = "utf8" , hasHeader = True , delimiter = "," ) :
   if 71 - 71: IIiIIiIi11I1 * Ii
   if 7 - 7: I11iiIi11i1I + I11iiIi11i1I - i1I * I1Ii1I1
   if 27 - 27: IIiIIiIi11I1 / OooOoo % ooo000 . oOO / IIiIIiIi11I1 . ooo000
   if 75 - 75: IIiIIiIi11I1 % IiI11Ii111 / Ii . ooo000
   if 35 - 35: oOO * oOo0O00
   if 20 - 20: i1 / Ooo0Ooo % i1I / ooo000 . i1
   if 99 - 99: I11iiIi11i1I % I11iiIi11i1I * Iii1i - OooOoo + IIiIIiIi11I1
   if 51 - 51: iI1iII1I1I1i / i1 * ooOOO + ooo000 % ooo000
   if 74 - 74: oOo0O00
   if 18 - 18: oOo0O00 + i1iiIII111 / i1iiIII111
   if 45 - 45: i1I % I11iiIi11i1I / i1 + oOO / ooo000 - i1iiIII111
   if 82 - 82: oOO + ooOOO / oOO . i1
   try :
    if 34 - 34: IiIIii11Ii
    with open ( path , encoding = encoding ) as f :
     ooOOoOO00oO = os . path . splitext ( path ) [ 1 ]
     if ooOOoOO00oO == ".txt" :
      i1IiI1i = f . readlines ( )
      IIi11ii1IIi = [ ]
      for o0OOOOo0o in i1IiI1i :
       IIi11ii1IIi . append ( o0OOOOo0o . strip ( ) . split ( delimiter ) )
     else :
      IIi11ii1IIi = [ * csv . reader ( f ) ]
      if 48 - 48: i1I % I11iiIi11i1I + ooOOO * OooOoo
      if 98 - 98: I1Ii1I1 + IiI11Ii111 + iI1iII1I1I1i - ooo000 / i1I
    OOO0Oo0oO0o00 = np . vstack ( [ np . array ( r , dtype = object ) for r in IIi11ii1IIi if len ( r ) ] )
    if 50 - 50: IiI11Ii111
    if 81 - 81: I1Ii1I1
    self . _path = path
    self . _fileName = path [ max ( [ path . rfind ( "/" ) , path . rfind ( "\\" ) ] ) + 1 : ]
    self . encoding = encoding
    self . _hasHeader = hasHeader
    if 25 - 25: i1iiIII111 . I11iiIi11i1I . i1 * i1iiIII111 / Iii1i
   except :
    raise ValueError ( "CSV file cannot be correctly read." )
    if 40 - 40: I11iiIi11i1I + IiIIii11Ii
    if 90 - 90: oOO * ooo000
   self . setData ( inputArray = OOO0Oo0oO0o00 , hasHeader = hasHeader )
   if 65 - 65: Oo + i1i1i1111I
  @ property
  def path ( self ) -> str :
   if 80 - 80: I1I
   if 84 - 84: I1I % IiIIii11Ii - ooo000
   if 31 - 31: IiIIii11Ii % oOO - i1 + i1i1i1111I * IiI11Ii111
   if 89 - 89: IiIIii11Ii + Ooo0Ooo
   if 84 - 84: I1Ii1I1 * OooOoo % IIiIIiIi11I1
   if 85 - 85: I1Ii1I1 % ooo000 / i1i1i1111I % i1
   if 11 - 11: oOo0O00 / Iii1i / ooOOO
   if 22 - 22: i1 % IiI11Ii111 * iI1iII1I1I1i
   if 56 - 56: I11iiIi11i1I + IiI11Ii111 + Ii . ooo000 . Ii
   if 81 - 81: I1Ii1I1 / IiI11Ii111
   return self . _path
   if 49 - 49: IiI11Ii111 % Oo / oOo0O00 * ooo000 + Ooo0Ooo
  @ path . setter
  def path ( self , val : str ) :
   if 20 - 20: I11iiIi11i1I / IiIIii11Ii / Oo
   if 81 - 81: ooo000 + i1iiIII111 * Iii1i / i1i1i1111I
   if 79 - 79: oOo0O00 % ooOOO
   if 4 - 4: iI1iII1I1I1i - IiIIii11Ii * i1i1i1111I
   if 47 - 47: i1iiIII111 * Ooo0Ooo
   if 50 - 50: I11iiIi11i1I % i1iiIII111
   if 20 - 20: Ii / i1i1i1111I / Ooo0Ooo
   if 62 - 62: Iii1i % oOo0O00
   if 58 - 58: IIiIIiIi11I1 - i1 % Ii % i1i1i1111I
   if 65 - 65: I11iiIi11i1I * oOo0O00
   self . _path = val
   self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader , delimiter = self . delimiter )
   if 96 - 96: i1 . IiI11Ii111 * Ii
  @ property
  def fileName ( self ) -> str :
   if 13 - 13: I1I
   if 81 - 81: Ii % I1Ii1I1 / i1iiIII111
   if 43 - 43: ooo000 . I11iiIi11i1I . IIiIIiIi11I1 % OooOoo / I1I
   if 82 - 82: i1 + Ii * i1 / IIiIIiIi11I1 - oOO % i1
   if 22 - 22: i1I * ooo000 . i1i1i1111I - ooo000 / I11iiIi11i1I
   if 14 - 14: oOO
   if 24 - 24: i1I + I1I * OooOoo * I1I % i1iiIII111 / i1iiIII111
   if 59 - 59: oOo0O00 + i1iiIII111 + Ooo0Ooo * i1 % oOO + i1
   if 48 - 48: Ii . I1I * I1Ii1I1
   if 94 - 94: oOO - iI1iII1I1I1i % Ooo0Ooo % Ooo0Ooo
   return self . _fileName
   if 16 - 16: i1
  @ property
  def delimiter ( self ) -> str :
   if 1 - 1: ooOOO
   if 37 - 37: Oo + oOo0O00 . oOO
   if 96 - 96: IiI11Ii111 % Ooo0Ooo . iI1iII1I1I1i / ooo000
   if 51 - 51: ooOOO
   if 33 - 33: i1I % ooo000 . i1I + iI1iII1I1I1i / i1 % Iii1i
   if 9 - 9: Oo * Ii
   if 43 - 43: Oo - i1I - IiI11Ii111 * i1 + i1i1i1111I % I11iiIi11i1I
   if 94 - 94: oOO - IIiIIiIi11I1 - oOo0O00
   if 84 - 84: oOo0O00 * i1iiIII111 - ooo000 % OooOoo * i1i1i1111I
   if 68 - 68: oOo0O00 + Iii1i * Ooo0Ooo * i1iiIII111
   return self . _delimiter
   if 63 - 63: OooOoo
   if 20 - 20: oOO + OooOoo + iI1iII1I1I1i
  def getLocations ( self ) -> List [ str ] :
   if 64 - 64: i1
   if 2 - 2: IiI11Ii111 + Ooo0Ooo - oOO . Ii * IiIIii11Ii . IiIIii11Ii
   if 16 - 16: oOo0O00 / Oo
   if 22 - 22: i1i1i1111I * IiIIii11Ii
   if 7 - 7: i1 / IIiIIiIi11I1 - ooOOO - IIiIIiIi11I1 * Ooo0Ooo + IIiIIiIi11I1
   if 31 - 31: IiI11Ii111 % Iii1i - Ii . OooOoo / ooo000 . ooo000
   if 30 - 30: IIiIIiIi11I1
   if 88 - 88: OooOoo . oOO / oOo0O00 . oOo0O00
   if 17 - 17: ooo000 . Ii - IIiIIiIi11I1
   if 22 - 22: IiI11Ii111 * i1I % i1iiIII111 + oOo0O00 / i1iiIII111
   return [ self . fileName ] if self . fileName else [ ]
   if 63 - 63: I11iiIi11i1I - oOo0O00 / I11iiIi11i1I
 class GeneratorController ( o0ooo0oOoO . GeneratorController ) :
  if 24 - 24: iI1iII1I1I1i / I11iiIi11i1I - I1I % I11iiIi11i1I + i1 + I1I
  if 28 - 28: OooOoo - ooOOO
  if 99 - 99: Ii % Iii1i . IiI11Ii111 . i1I . I1I
  if 72 - 72: Ooo0Ooo * i1i1i1111I * oOo0O00 * iI1iII1I1I1i
  if 25 - 25: OooOoo / Ii
  if 86 - 86: I1I * i1 * IiI11Ii111 % IiIIii11Ii
  if 85 - 85: Oo + Iii1i
  def __init__ ( self , attachObject : Union [ 'Source.CSV' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 31 - 31: ooOOO * IiIIii11Ii * IiIIii11Ii + Oo . i1iiIII111 + I1I
   if 8 - 8: I1I - Iii1i . OooOoo / Iii1i % iI1iII1I1I1i . iI1iII1I1I1i
   if 32 - 32: Ooo0Ooo * IiIIii11Ii + Ii + oOo0O00
   if 40 - 40: I1Ii1I1 - Iii1i / I1I * IiI11Ii111 - i1I % i1iiIII111
   if 61 - 61: i1 + Ii % I1Ii1I1 * i1I % Oo % I1Ii1I1
   if 82 - 82: OooOoo
   if 67 - 67: I1Ii1I1
   if 10 - 10: ooo000 / ooOOO
   if 91 - 91: i1i1i1111I
   if 93 - 93: ooo000
   super ( ) . __init__ ( attachObject = attachObject )
   if 54 - 54: IiI11Ii111 % OooOoo
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.CSV.GeneratorDetail' ] :
   if 57 - 57: i1 * Ii * i1i1i1111I % IiIIii11Ii * i1iiIII111
   if 46 - 46: iI1iII1I1I1i
   if 72 - 72: i1 . Ii * i1iiIII111 % I11iiIi11i1I
   if 91 - 91: IiIIii11Ii * Ii . iI1iII1I1I1i . i1I - Ii / i1I
   if 80 - 80: iI1iII1I1I1i . iI1iII1I1I1i / Iii1i % Iii1i % I11iiIi11i1I * IiIIii11Ii
   if 19 - 19: oOo0O00 % I1I - Ii
   if 94 - 94: Ooo0Ooo % Ooo0Ooo + ooo000 % oOo0O00 / I1I
   if 98 - 98: i1 . IiI11Ii111 + i1I
   if 78 - 78: i1iiIII111 / oOo0O00 + IiIIii11Ii % IiIIii11Ii % oOO / IiI11Ii111
   if 20 - 20: Ooo0Ooo
   return ii1I11I1IIi . GeneratorDetail
   if 93 - 93: OooOoo / i1 * Iii1i + I1Ii1I1
 def __init__ ( self , fileName : str = "" , encoding : str = "utf8" , hasHeader : bool = True , name : str = "" , delimiter = "," ) :
  if 71 - 71: IiIIii11Ii % I1I - i1 - iI1iII1I1I1i
  if 41 - 41: i1iiIII111 % OooOoo / ooo000 + oOO - i1I
  if 52 - 52: i1i1i1111I - Ooo0Ooo / iI1iII1I1I1i . i1
  if 53 - 53: Ooo0Ooo * ooOOO + I1I . Ooo0Ooo + I11iiIi11i1I
  if 59 - 59: OooOoo * i1i1i1111I % OooOoo
  if 75 - 75: Iii1i / I1I + i1i1i1111I . i1 * i1i1i1111I . OooOoo
  if 99 - 99: IiIIii11Ii
  if 47 - 47: Ii
  if 15 - 15: i1I * OooOoo / Ooo0Ooo + Ooo0Ooo
  if 84 - 84: I11iiIi11i1I . ooOOO - OooOoo
  if 78 - 78: oOO * Ii % ooo000
  if 36 - 36: Ii * I11iiIi11i1I - oOO + ooo000 . IiI11Ii111 * oOO
  if 98 - 98: oOo0O00 / i1I * IiIIii11Ii
  if 78 - 78: IiIIii11Ii % I1Ii1I1 % i1 * OooOoo
  super ( ) . __init__ ( name = name )
  if 39 - 39: i1i1i1111I . Ooo0Ooo + iI1iII1I1I1i / IIiIIiIi11I1
  if 19 - 19: oOO
  self . _instanceClass = I1ooOoO0OooO . CSV
  if 87 - 87: iI1iII1I1I1i
  self . generatorController = ii1I11I1IIi . GeneratorController ( self )
  if 83 - 83: oOO + i1iiIII111 / I1I + i1i1i1111I % Iii1i
  if 51 - 51: i1i1i1111I - oOO / ooo000 . ooOOO
  if len ( fileName ) :
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . readFile ( fileName = fileName , encoding = encoding , hasHeader = hasHeader )
   if 16 - 16: Iii1i / i1I
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 90 - 90: I1I - i1iiIII111 * iI1iII1I1I1i % OooOoo % OooOoo . IiI11Ii111
  if 43 - 43: Ooo0Ooo . i1 . IiI11Ii111 % IiI11Ii111 % oOO
  if 77 - 77: IiIIii11Ii
  if 83 - 83: i1iiIII111 . OooOoo
  if 48 - 48: oOo0O00 - IiI11Ii111 . OooOoo / i1i1i1111I % I1I + ooOOO
  if 81 - 81: IiI11Ii111 . IiI11Ii111 . iI1iII1I1I1i % I11iiIi11i1I
  if 59 - 59: OooOoo % I1I - i1iiIII111
  if 88 - 88: I1I / ooo000 / Ii . Iii1i
  if 24 - 24: I1I . oOo0O00 . I1Ii1I1 + IiIIii11Ii
  if 98 - 98: Ii . Oo * i1i1i1111I * IiI11Ii111 . Iii1i . IiIIii11Ii
  if 27 - 27: Ii - i1I * ooo000 % Oo * OooOoo - IiI11Ii111
  super ( ) . parseJSON ( obj , train )
  if 23 - 23: I1I % OooOoo / i1I * i1 % IIiIIiIi11I1
class OooII ( o0ooo0oOoO ) :
 if 27 - 27: IiI11Ii111
 if 63 - 63: IIiIIiIi11I1
 if 42 - 42: ooo000 - I11iiIi11i1I / iI1iII1I1I1i / ooo000 % IiIIii11Ii - ooo000
 if 52 - 52: iI1iII1I1I1i * ooo000
 if 31 - 31: I1I - i1iiIII111 / iI1iII1I1I1i + ooOOO / i1i1i1111I . I11iiIi11i1I
 if 77 - 77: IiIIii11Ii
 if 80 - 80: Oo % oOO . i1iiIII111 * oOO - ooo000 % Oo
 class GeneratorDetail ( o0ooo0oOoO . GeneratorDetail ) :
  if 43 - 43: I1I + i1i1i1111I + i1
  if 42 - 42: i1I * Ii / ooo000 - IIiIIiIi11I1 - I11iiIi11i1I % I11iiIi11i1I
  if 80 - 80: I11iiIi11i1I - OooOoo + i1iiIII111 - oOO * oOo0O00
  if 87 - 87: ooo000 - OooOoo * oOo0O00 / IiI11Ii111 + I1Ii1I1 - OooOoo
  if 59 - 59: ooo000 - I11iiIi11i1I . IIiIIiIi11I1 * IiIIii11Ii . IIiIIiIi11I1
  if 4 - 4: Ii . i1i1i1111I % oOo0O00 / oOo0O00 / OooOoo
  if 75 - 75: oOo0O00 - Oo / Oo / I11iiIi11i1I
  def __init__ ( self , controller : 'Source.TXT.GeneratorController' ) :
   if 82 - 82: Oo + OooOoo % ooo000 . OooOoo + Ii
   if 2 - 2: IiI11Ii111
   if 1 - 1: iI1iII1I1I1i % oOO * IiI11Ii111 - I1Ii1I1 - oOO
   if 1 - 1: IiIIii11Ii % I11iiIi11i1I - Oo * Iii1i * Oo
   if 1 - 1: i1 + Ii
   if 34 - 34: IIiIIiIi11I1 + i1I - I1I - IIiIIiIi11I1 % Oo
   if 52 - 52: IiI11Ii111 - IiI11Ii111 * Iii1i
   if 80 - 80: OooOoo + OooOoo * IiIIii11Ii / Ii
   if 22 - 22: I1I . IiI11Ii111 * Ii / I1I / i1I
   super ( ) . __init__ ( controller )
   if 21 - 21: i1i1i1111I % i1I + iI1iII1I1I1i - I1I / Ii . ooo000
   if 3 - 3: i1I
   self . _oriData : np . ndarray = None
   if 51 - 51: IiIIii11Ii . i1I
   self . _itrCount : int = 0
   if 84 - 84: oOO + i1iiIII111 . Ooo0Ooo % i1I * IiI11Ii111 . i1iiIII111
   self . _hasHeader : bool = False
   if 49 - 49: I1I % I11iiIi11i1I
   self . _path : str = None
   if 84 - 84: Oo + Ii - oOO + ooo000
   self . _fileName : str = None
   if 74 - 74: I1Ii1I1
   self . encoding : str = None
   if 79 - 79: Ooo0Ooo
   self . _delimiter : str = ","
   if 43 - 43: I1Ii1I1 % I1Ii1I1 % Oo . IiIIii11Ii / Oo % ooo000
   self . _datasetType = "Train"
   if 14 - 14: IiIIii11Ii - IIiIIiIi11I1
   self . _delimiter : str = None
   if 2 - 2: oOo0O00 % oOO * I1Ii1I1
   if 89 - 89: IiI11Ii111 / ooOOO % oOO - i1iiIII111 / Iii1i
  def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
   if 14 - 14: i1 % i1 % Ooo0Ooo / Oo
   if 42 - 42: iI1iII1I1I1i . Ooo0Ooo / IIiIIiIi11I1 - Ooo0Ooo . OooOoo
   if 86 - 86: OooOoo - Ooo0Ooo - IiIIii11Ii
   if 62 - 62: ooo000 . iI1iII1I1I1i + IiIIii11Ii + Iii1i % OooOoo
   if 65 - 65: ooOOO / OooOoo . Oo * i1i1i1111I . I1Ii1I1 % I1I
   if 93 - 93: OooOoo . ooo000 - Oo % IiI11Ii111
   if 15 - 15: I1Ii1I1 - i1iiIII111 - I1Ii1I1
   if 85 - 85: Oo * I1I * IiIIii11Ii - I1Ii1I1 * ooOOO * I1I
   if 73 - 73: i1iiIII111 / oOO - ooOOO
   if 91 - 91: Ii
   if 52 - 52: oOO + i1i1i1111I - I11iiIi11i1I + i1 + oOO + Oo
   for Ii1I in Oooo0OooOOOo0 ( obj , [ "_hasHeader" , "encoding" , "_delimiter" , "_path" ] ) :
    iiiiIi1IiiIi = obj [ Ii1I ]
    if Ii1I == "_path" :
     if iiiiIi1IiiIi is not None :
      self . path = iiiiIi1IiiIi
     else :
      if 40 - 40: I11iiIi11i1I . OooOoo % I1I + IIiIIiIi11I1 - IiIIii11Ii
      for Oo0OOo000oo in [ "_hasHeader" , "encoding" , "_delimiter" , "_path" , "_fileName" ] :
       setattr ( self , Oo0OOo000oo , obj [ Oo0OOo000oo ] )
    elif Ii1I not in [ "_controller" , "_oriShape" , "_oriData" , "_epochSize" , "_itrCount" ] :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 89 - 89: Ii % ooo000 . I1Ii1I1 - IIiIIiIi11I1 / i1i1i1111I - OooOoo
  def copy ( self ) -> 'Source.TXT.GeneratorDetail' :
   if 14 - 14: I1Ii1I1
   if 7 - 7: oOo0O00 - OooOoo / Ii . Ooo0Ooo + Ii % Oo
   if 100 - 100: ooo000 . IiIIii11Ii + oOo0O00 + Oo
   if 13 - 13: i1iiIII111 / iI1iII1I1I1i . I11iiIi11i1I / ooOOO * IIiIIiIi11I1 . IiIIii11Ii
   if 4 - 4: OooOoo / oOO - Oo / ooo000 . i1iiIII111 % OooOoo
   if 32 - 32: IiI11Ii111 * I1I * i1I
   if 22 - 22: Ii / Ii % I1Ii1I1 / Ii + Iii1i * iI1iII1I1I1i
   if 22 - 22: Oo * Oo / iI1iII1I1I1i % i1iiIII111 % I1Ii1I1 + IIiIIiIi11I1
   if 1 - 1: i1I . oOo0O00
   if 42 - 42: ooOOO - Ooo0Ooo * I1I
   if 80 - 80: oOo0O00 . i1 / Ooo0Ooo . OooOoo % Iii1i
   ii1IIiIIi : I1ii11II11 . TXT . GeneratorDetail = OooII . GeneratorDetail ( self . controller )
   if 59 - 59: IiIIii11Ii % iI1iII1I1I1i / i1 + OooOoo
   if 96 - 96: ooo000
   for Ii1I in [ "_epochSize" , "_oriShape" , "_controller" , "_batchSize" , "_shuffle" , "_oriData" , "_itrCount" , "_hasHeader" , "_path" , "_fileName" , "encoding" , "_delimiter" ] :
    setattr ( ii1IIiIIi , Ii1I , getattr ( self , Ii1I ) )
    if 83 - 83: I1I
   return ii1IIiIIi
   if 39 - 39: IiI11Ii111
  def setData ( self , inputArray : Union [ list , 'np.ndarray' ] = [ ] , outputArray : Union [ list , 'np.ndarray' ] = [ ] , hasHeader : bool = True ) :
   if 22 - 22: Oo - i1 / iI1iII1I1I1i % ooOOO * Ii + I1Ii1I1
   if 16 - 16: i1 + i1i1i1111I . IiIIii11Ii
   if 73 - 73: IiI11Ii111 + oOO - Ooo0Ooo * Ooo0Ooo
   if 37 - 37: Oo % I1I
   if 24 - 24: oOo0O00 . i1iiIII111 + IiI11Ii111 . I1Ii1I1
   if 41 - 41: I11iiIi11i1I . oOo0O00 / IiIIii11Ii
   if 10 - 10: Oo % IiI11Ii111
   if 42 - 42: IIiIIiIi11I1 * IiI11Ii111 . I1Ii1I1 + I1I - ooo000
   if 100 - 100: iI1iII1I1I1i / I1Ii1I1 + i1iiIII111 / i1iiIII111 % i1I / Ooo0Ooo
   if 31 - 31: OooOoo . i1I % I11iiIi11i1I
   if 28 - 28: i1iiIII111 * IIiIIiIi11I1 + I11iiIi11i1I . iI1iII1I1I1i * iI1iII1I1I1i + Ooo0Ooo
   if 42 - 42: ooo000 % oOO
   if 27 - 27: ooOOO % I1Ii1I1 / IIiIIiIi11I1 + Ooo0Ooo * i1i1i1111I . oOo0O00
   self . _hasHeader = hasHeader
   if 29 - 29: I11iiIi11i1I / i1 / IiIIii11Ii
   if 4 - 4: i1I % ooOOO - ooOOO + Ooo0Ooo
   o0oi11I1iIi1IIiI = np . array ( inputArray )
   o00000 = np . array ( outputArray )
   self . _epochSize = len ( o00000 )
   if 72 - 72: Oo - ooOOO - Iii1i % i1iiIII111 % I1Ii1I1 + IiI11Ii111
   if 99 - 99: iI1iII1I1I1i . IIiIIiIi11I1 . Ooo0Ooo % IiIIii11Ii * I1I
   if len ( o0oi11I1iIi1IIiI ) == 0 or len ( o00000 ) == 0 :
    raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
   elif len ( o0oi11I1iIi1IIiI ) != len ( o00000 ) :
    raise ValueError ( "Data and labels do not match" )
    if 24 - 24: iI1iII1I1I1i
   try :
    if 82 - 82: i1I
    Oooo0Oo00 = np . column_stack ( ( o0oi11I1iIi1IIiI , o00000 ) ) if ( len ( o00000 ) == len ( o0oi11I1iIi1IIiI ) and len ( o0oi11I1iIi1IIiI ) > 0 ) else o0oi11I1iIi1IIiI
    if 15 - 15: IIiIIiIi11I1
    if 61 - 61: Ooo0Ooo % oOo0O00 * ooo000 % ooo000 + i1iiIII111 * I11iiIi11i1I
    OOo00oOoOo = [ * ( Oooo0Oo00 [ 1 : ] . shape if hasHeader else Oooo0Oo00 . shape ) ] if len ( Oooo0Oo00 ) else [ 0 ]
    self . _oriShape = OOo00oOoOo
    if 85 - 85: oOo0O00 % OooOoo % oOo0O00 . IiIIii11Ii - oOO
    if 42 - 42: ooOOO . i1I . I1Ii1I1 % ooo000
    if len ( Oooo0Oo00 ) == 0 :
     raise ValueError ( "Some data should be set instead of `None` or array with zero length" )
     if 36 - 36: ooo000 / Ii % IiIIii11Ii / i1iiIII111 % I1Ii1I1 + IiIIii11Ii
     if 9 - 9: OooOoo . i1iiIII111 % Iii1i + i1i1i1111I
    elif ( self . oriData is not None and len ( self . oriData ) > 0 ) and Oooo0Oo00 . shape [ 1 : ] != self . oriData . shape [ 1 : ] :
     raise ValueError ( "Data cannot be reset with a different shape" )
     if 58 - 58: IiIIii11Ii * i1I + IiI11Ii111 % i1 % ooOOO
     if 25 - 25: I1Ii1I1 . i1i1i1111I + IiIIii11Ii . I1Ii1I1
     if 65 - 65: IiI11Ii111 + Ooo0Ooo
    self . _oriData = Oooo0Oo00 if len ( Oooo0Oo00 ) else np . array ( [ ] )
    self . _oriData = np . insert ( self . _oriData , 0 , np . array ( [ "input" , "target" ] , dtype = object ) , axis = 0 )
    if 93 - 93: Ii / Ii
    if 30 - 30: Oo + I1Ii1I1 - i1i1i1111I - ooOOO
   except :
    pass
    if 98 - 98: oOO - IiI11Ii111 . Iii1i - I1Ii1I1
  def readCSVFile ( self , path = "" , encoding = "utf8" , hasHeader = True ) :
   if 90 - 90: i1i1i1111I
   if 46 - 46: I1Ii1I1 . I11iiIi11i1I * Ii - iI1iII1I1I1i + i1I
   if 91 - 91: OooOoo / Iii1i . ooOOO / Ooo0Ooo / I1I * ooo000
   if 32 - 32: i1i1i1111I - I11iiIi11i1I
   if 36 - 36: Iii1i - IiI11Ii111 - i1 * IIiIIiIi11I1
   if 14 - 14: I1Ii1I1 * oOO . i1iiIII111 / I1I * ooOOO % Oo
   if 23 - 23: Oo / Ooo0Ooo . I1I * oOO
   if 13 - 13: I11iiIi11i1I . ooOOO . i1I
   if 87 - 87: IIiIIiIi11I1 / Ii - I1Ii1I1 * IIiIIiIi11I1
   if 7 - 7: I1Ii1I1
   if 16 - 16: Iii1i
   if 85 - 85: Iii1i % IiI11Ii111 % I11iiIi11i1I
   try :
    if 94 - 94: I1Ii1I1 - Ooo0Ooo
    with open ( path , encoding = encoding ) as f :
     IIi11ii1IIi = [ * csv . reader ( f ) ]
     if 53 - 53: oOO - oOo0O00 . OooOoo
     if 70 - 70: I1I . oOO % IiIIii11Ii
    O00O0o = { r [ 0 ] : np . array ( r [ 1 : ] ) for r in IIi11ii1IIi if len ( r ) }
    if 29 - 29: i1i1i1111I - ooo000 - I1I + ooOOO
    if 61 - 61: i1 % IiIIii11Ii
    if 23 - 23: oOo0O00 . i1i1i1111I * Ii % ooOOO * iI1iII1I1I1i * Oo
    self . encoding = encoding
    self . _hasHeader = hasHeader
    if 66 - 66: Iii1i / Oo / Oo . I1Ii1I1 . iI1iII1I1I1i
   except :
    raise ValueError ( "CSV file cannot be correctly read." )
    if 34 - 34: i1iiIII111 . Ii + IiI11Ii111 * I11iiIi11i1I
    if 42 - 42: ooo000 * Ii - I1Ii1I1 - IiIIii11Ii . ooOOO + ooo000
    if 94 - 94: IiI11Ii111 - ooo000 - Oo
   return O00O0o
   if 70 - 70: oOo0O00 - I11iiIi11i1I / Ooo0Ooo
  def readTXTFile ( self , file_with_path , ) :
   with open ( file_with_path , encoding = "utf-8" ) as f :
    ooOOoOO00oO = os . path . splitext ( file_with_path ) [ 1 ]
    if ooOOoOO00oO == ".txt" :
     i1IiI1i = f . read ( ) . strip ( )
   return i1IiI1i
   if 53 - 53: Ii + I1Ii1I1
  def readFile ( self , path = "" , encoding = "utf8" , hasHeader = True , delimiter = "," ) :
   II1 : str = self . _datasetType . lower ( )
   if 98 - 98: i1iiIII111 + oOO . i1i1i1111I * i1iiIII111 % i1
   if 66 - 66: I1Ii1I1
   if 34 - 34: I1I % i1i1i1111I
   if 14 - 14: Iii1i . IiI11Ii111 . IiIIii11Ii
   if 60 - 60: i1I / i1i1i1111I + IiI11Ii111 * IIiIIiIi11I1 % ooo000
   if 41 - 41: Ii / ooOOO * I1Ii1I1 % OooOoo - i1iiIII111 . IiIIii11Ii
   if 6 - 6: Ooo0Ooo % I11iiIi11i1I
   if 92 - 92: Oo
   if 9 - 9: OooOoo % oOO . ooOOO - Ii
   if 50 - 50: i1I + I1Ii1I1 / iI1iII1I1I1i . IiIIii11Ii / IiIIii11Ii * ooo000
   if 17 - 17: OooOoo
   OoOI1 : str = II1 + "data"
   try :
    if 88 - 88: i1I / i1I + IiIIii11Ii + I1I . i1i1i1111I * IiI11Ii111
    if 70 - 70: I11iiIi11i1I + IIiIIiIi11I1 + Ii * IIiIIiIi11I1 * i1i1i1111I
    if 91 - 91: Iii1i / I1Ii1I1 * IiIIii11Ii . ooo000
    if 93 - 93: Oo
    if 27 - 27: i1I % IIiIIiIi11I1 + i1iiIII111 - I11iiIi11i1I % IiIIii11Ii + iI1iII1I1I1i
    if 52 - 52: Ii . i1iiIII111
    if 21 - 21: Ooo0Ooo
    if 69 - 69: Iii1i
    if 92 - 92: Ooo0Ooo % I1I . iI1iII1I1I1i % i1
    if 87 - 87: oOo0O00 * i1iiIII111 / i1i1i1111I - i1i1i1111I * OooOoo . i1
    if 40 - 40: Ii - IIiIIiIi11I1 + OooOoo * i1I
    if 7 - 7: I11iiIi11i1I / oOO
    if 13 - 13: i1I / I1I * OooOoo - IiI11Ii111 % Oo % oOO
    if 63 - 63: I1Ii1I1 / Oo / I11iiIi11i1I . i1i1i1111I
    if 94 - 94: Ii + I1I % Iii1i
    self . _path = path
    self . _fileName = path [ max ( [ path . rfind ( "/" ) , path . rfind ( "\\" ) ] ) + 1 : ]
    self . encoding = encoding
    self . _hasHeader = hasHeader
    if 53 - 53: ooOOO * I1Ii1I1 % OooOoo - i1i1i1111I * ooOOO
    if 65 - 65: i1 - ooo000 + I1Ii1I1
    self . _hasHeader = hasHeader
    self . _labelDict = self . readCSVFile ( self . _path + "label.csv" )
    if 58 - 58: ooOOO . IiIIii11Ii / ooo000 + i1
    if 30 - 30: IIiIIiIi11I1
    ( iIIII11iIi , iIIII11iIi , iI11iI ) = next ( os . walk ( self . _path + OoOI1 ) )
    self . _inputData = np . vstack ( [ np . array ( [ self . readTXTFile ( self . _path + OoOI1 + '/' + f ) ] ) for f in iI11iI if len ( f ) ] )
    self . _labelData = np . vstack ( [ np . array ( self . _labelDict [ f ] ) for f in iI11iI if len ( f ) ] )
    if 17 - 17: I1I * OooOoo . i1iiIII111 * Ooo0Ooo
   except :
    raise ValueError ( "TXT file cannot be correctly read." )
    if 73 - 73: Oo - oOo0O00 * IiI11Ii111 - IiIIii11Ii
    if 51 - 51: ooOOO
   self . setData ( inputArray = self . _inputData , outputArray = self . _labelData , hasHeader = hasHeader )
   if 22 - 22: Ooo0Ooo - Ii * i1 + i1I / Iii1i / I1I
  @ property
  def path ( self ) -> str :
   if 29 - 29: Iii1i . oOO % oOO % I1I % ooo000 % Oo
   if 43 - 43: oOo0O00 + ooOOO / oOO / I11iiIi11i1I
   if 13 - 13: I11iiIi11i1I . ooo000 + I1Ii1I1 * I11iiIi11i1I % I1Ii1I1 * Iii1i
   if 15 - 15: IIiIIiIi11I1
   if 17 - 17: oOO * iI1iII1I1I1i
   if 15 - 15: Ooo0Ooo . I11iiIi11i1I + IIiIIiIi11I1 % IiI11Ii111 % i1 % i1
   if 83 - 83: I1Ii1I1 / I1Ii1I1 . I1I + i1iiIII111
   if 30 - 30: i1iiIII111 - oOo0O00 * I1Ii1I1 . iI1iII1I1I1i * oOO
   if 53 - 53: Ooo0Ooo * IIiIIiIi11I1 . ooOOO
   if 10 - 10: I11iiIi11i1I % i1i1i1111I . oOo0O00 / Ooo0Ooo
   return self . _path
   if 73 - 73: i1i1i1111I + oOO % IiIIii11Ii + I11iiIi11i1I / i1I
  @ path . setter
  def path ( self , val : str ) :
   if 30 - 30: IIiIIiIi11I1
   if 44 - 44: Iii1i . i1I * Ooo0Ooo + i1i1i1111I * oOO + oOO
   if 3 - 3: i1I . IiI11Ii111 / I1I + IiI11Ii111 + I11iiIi11i1I / IIiIIiIi11I1
   if 11 - 11: oOo0O00 + i1
   if 73 - 73: i1iiIII111
   if 85 - 85: Ooo0Ooo / IiIIii11Ii - IiIIii11Ii / ooOOO % Ooo0Ooo
   if 40 - 40: IiIIii11Ii - Ooo0Ooo / I1Ii1I1
   if 100 - 100: I1I
   if 28 - 28: IIiIIiIi11I1 * ooo000 % OooOoo . oOo0O00 . Oo
   if 42 - 42: I11iiIi11i1I * Ii / Oo
   self . _path = val
   self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader , delimiter = self . delimiter )
   if 86 - 86: Ooo0Ooo . Ooo0Ooo + Oo / i1i1i1111I / OooOoo
  @ property
  def fileName ( self ) -> str :
   if 69 - 69: i1 * i1i1i1111I
   if 1 - 1: Ii % ooo000 * OooOoo % i1iiIII111 % OooOoo . ooOOO
   if 88 - 88: Iii1i % I1Ii1I1 % i1i1i1111I * IiI11Ii111 % Ii . Iii1i
   if 75 - 75: i1
   if 99 - 99: I1I + i1i1i1111I
   if 14 - 14: Ii % ooOOO
   if 60 - 60: iI1iII1I1I1i / Iii1i * i1 . Oo * IiIIii11Ii % i1i1i1111I
   if 25 - 25: Iii1i + IiIIii11Ii
   if 31 - 31: i1
   if 34 - 34: I11iiIi11i1I + IiIIii11Ii + Iii1i + I1Ii1I1
   return self . _fileName
   if 37 - 37: Ooo0Ooo * Ii
  @ property
  def delimiter ( self ) -> str :
   if 40 - 40: Oo
   if 5 - 5: ooOOO - Ii
   if 72 - 72: Ii . i1iiIII111 + OooOoo . ooo000
   if 91 - 91: IiI11Ii111 + oOO - ooOOO * oOo0O00
   if 87 - 87: ooo000 - Oo
   if 5 - 5: IiIIii11Ii / ooOOO % IiIIii11Ii + oOO / iI1iII1I1I1i
   if 76 - 76: Oo * I11iiIi11i1I + i1i1i1111I % I1I * Oo + IiIIii11Ii
   if 63 - 63: Oo % OooOoo % i1i1i1111I % Ooo0Ooo / ooOOO % IIiIIiIi11I1
   if 90 - 90: ooo000
   if 81 - 81: i1i1i1111I . Ii . IiI11Ii111 - oOO
   return self . _delimiter
   if 46 - 46: i1I
   if 23 - 23: oOO . ooOOO . i1I / Ooo0Ooo % I1Ii1I1 % IIiIIiIi11I1
   if 16 - 16: i1I - ooOOO / Oo / IIiIIiIi11I1
  def getLocations ( self ) -> List [ str ] :
   if 48 - 48: Ii / I1I
   if 94 - 94: OooOoo * Iii1i - I1Ii1I1
   if 36 - 36: IiI11Ii111 - Ooo0Ooo - IiIIii11Ii / I1I - oOo0O00
   if 100 - 100: OooOoo - I1Ii1I1 / i1i1i1111I * I11iiIi11i1I - oOo0O00 / Oo
   if 75 - 75: i1 + OooOoo / ooOOO % Ii
   if 75 - 75: ooOOO % OooOoo
   if 32 - 32: I1I . I1I / Ooo0Ooo
   if 42 - 42: i1i1i1111I + Oo % OooOoo - I1I
   if 1 - 1: iI1iII1I1I1i / IIiIIiIi11I1 . ooo000 % IiI11Ii111 % i1i1i1111I
   if 6 - 6: oOO . I1Ii1I1 - I1Ii1I1 % OooOoo + i1I % i1I
   return [ self . fileName ] if self . fileName else [ ]
   if 92 - 92: ooo000
  def partition ( self , prop : float = 0.2 , shuffle : bool = False ) -> Tuple [ 'np.ndarray' , 'np.ndarray' ] :
   if 26 - 26: Ooo0Ooo % iI1iII1I1I1i - IiI11Ii111 / i1 / I1Ii1I1 * i1iiIII111
   if 16 - 16: I1Ii1I1
   if 54 - 54: I1I * i1i1i1111I / oOo0O00 - Ii / i1i1i1111I
   if 63 - 63: i1I
   if 77 - 77: Ii . i1iiIII111 - IIiIIiIi11I1 . oOo0O00 * oOO + Ii
   if 79 - 79: oOo0O00 - Ooo0Ooo . IiI11Ii111 + iI1iII1I1I1i / i1
   if 4 - 4: i1I + Oo / IiI11Ii111
   if 37 - 37: Ii - OooOoo
   if 14 - 14: I1Ii1I1 . i1I % iI1iII1I1I1i + IiIIii11Ii % oOO
   if 79 - 79: Ii
   if 88 - 88: Ooo0Ooo
   if 58 - 58: iI1iII1I1I1i . IiI11Ii111 / ooo000 + OooOoo * i1
   if 97 - 97: I1Ii1I1 . IIiIIiIi11I1 - ooOOO % Oo . ooo000
   if 99 - 99: I11iiIi11i1I % IiI11Ii111 * OooOoo - iI1iII1I1I1i * oOO + IiIIii11Ii
   if 49 - 49: i1
   IiOoOOOoO0 = self . epochSize
   iII11i1 = math . floor ( IiOoOOOoO0 * prop )
   if 50 - 50: Ooo0Ooo / oOO / I1I - oOo0O00
   if len ( self . _inputData ) == 0 or len ( self . _labelData ) == 0 :
    self . readFile ( path = self . _path , encoding = self . encoding , hasHeader = self . hasHeader )
   Ooo000oo = self . _inputData
   IIiIiIiIIIiiI = self . _labelData
   if 11 - 11: Oo / I11iiIi11i1I - i1I + Iii1i * Oo * OooOoo
   if 52 - 52: OooOoo . I1I + ooOOO / oOo0O00 % IiIIii11Ii . i1I
   if shuffle :
    i11I1 = np . arange ( len ( IIiIiIiIIIiiI ) )
    np . random . shuffle ( i11I1 )
    Ooo000oo = Ooo000oo [ i11I1 ]
    IIiIiIiIIIiiI = IIiIiIiIIIiiI [ i11I1 ]
    if 97 - 97: ooOOO . Iii1i - OooOoo % ooo000 * IiIIii11Ii
    if 8 - 8: oOO + I1I / IIiIIiIi11I1 * IiI11Ii111
   ooOOoO0 = ( Ooo000oo [ iII11i1 : ] , IIiIiIiIIIiiI [ iII11i1 : ] )
   O0o0OOO00o = ( Ooo000oo [ : iII11i1 ] , IIiIiIiIIIiiI [ : iII11i1 ] )
   if 49 - 49: i1
   if 48 - 48: I1Ii1I1 % i1i1i1111I - oOO * I1I
   if 21 - 21: i1i1i1111I + i1i1i1111I . Ooo0Ooo * Ooo0Ooo % ooo000
   if 82 - 82: IiI11Ii111 % i1I . IiI11Ii111 + i1i1i1111I + Ooo0Ooo
   if 66 - 66: oOo0O00 . IiIIii11Ii . IiI11Ii111 . I1Ii1I1 / iI1iII1I1I1i - I1Ii1I1
   if 69 - 69: i1 - IiIIii11Ii + i1 * Ii
   if 2 - 2: Ii - Oo / i1I
   return ooOOoO0 , O0o0OOO00o
   if 37 - 37: ooo000 . ooOOO + I1I + i1iiIII111 / oOo0O00 % I1Ii1I1
 class GeneratorController ( o0ooo0oOoO . GeneratorController ) :
  if 39 - 39: Ii - ooOOO % i1iiIII111 * Iii1i
  if 36 - 36: I1I - IIiIIiIi11I1
  if 9 - 9: i1iiIII111 / i1I - oOO * Oo . ooOOO . IIiIIiIi11I1
  if 82 - 82: i1iiIII111 % Oo / I11iiIi11i1I
  if 17 - 17: Ooo0Ooo * IIiIIiIi11I1 * Ii
  if 14 - 14: oOO % i1 . ooOOO + I1I
  if 18 - 18: oOO
  def __init__ ( self , attachObject : Union [ 'Source.TXT' , 'DataPreprocessing.Node.SourceLike' ] ) :
   if 99 - 99: OooOoo
   if 54 - 54: IiIIii11Ii . iI1iII1I1I1i . IiI11Ii111
   if 43 - 43: IiIIii11Ii - iI1iII1I1I1i * i1I - i1i1i1111I
   if 89 - 89: Oo . i1
   if 43 - 43: oOo0O00 / OooOoo / I11iiIi11i1I % ooo000 / IiI11Ii111
   if 53 - 53: i1I
   if 84 - 84: I1Ii1I1 * ooOOO + IiIIii11Ii
   if 68 - 68: I11iiIi11i1I / I1I . OooOoo - OooOoo
   if 57 - 57: i1I - iI1iII1I1I1i / i1I * Ii
   if 86 - 86: i1i1i1111I + I1I / Oo
   super ( ) . __init__ ( attachObject = attachObject )
   if 57 - 57: oOo0O00 * Ooo0Ooo * i1 / i1 % Ooo0Ooo
  @ property
  def detailType ( self ) -> Callable [ ... , 'Source.TXT.GeneratorDetail' ] :
   if 81 - 81: i1I - Iii1i
   if 44 - 44: IIiIIiIi11I1
   if 29 - 29: oOo0O00
   if 35 - 35: OooOoo . oOo0O00 . oOo0O00 - i1 - i1iiIII111 % I1Ii1I1
   if 33 - 33: ooo000 * OooOoo / ooo000 . Iii1i
   if 27 - 27: I11iiIi11i1I . iI1iII1I1I1i . ooo000 / i1iiIII111 * Oo
   if 11 - 11: I1Ii1I1 / iI1iII1I1I1i
   if 35 - 35: IIiIIiIi11I1 % IiIIii11Ii * Ii
   if 16 - 16: I1Ii1I1 % I11iiIi11i1I . oOO
   if 6 - 6: iI1iII1I1I1i % Ii % i1i1i1111I * i1 + i1 - IiIIii11Ii
   return OooII . GeneratorDetail
   if 58 - 58: Iii1i . Oo * OooOoo
   if 20 - 20: i1 / Ii * i1i1i1111I . IiI11Ii111
  def splitValidationDataset ( self , validation : float = 0.1 , randomFold : bool = False ) :
   if 100 - 100: i1I / oOO * Ii % OooOoo % I11iiIi11i1I % OooOoo
   if 5 - 5: IiIIii11Ii
   if 43 - 43: oOO
   if 46 - 46: i1i1i1111I % iI1iII1I1I1i % IiIIii11Ii * IiI11Ii111
   if 82 - 82: I1Ii1I1 - i1i1i1111I - I1I
   if 22 - 22: Ooo0Ooo . I11iiIi11i1I
   if 24 - 24: oOO . ooo000 . Oo / i1 - Iii1i
   if 1 - 1: i1i1i1111I - i1
   if 37 - 37: i1iiIII111 / oOO / oOo0O00 + i1
   if 56 - 56: OooOoo + Ii * Oo + Iii1i
   if 97 - 97: I11iiIi11i1I - Iii1i
   if 29 - 29: iI1iII1I1I1i . ooo000
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   IiOoOOOoO0 = Oooo0OOO . epochSize
   if 93 - 93: Ii + oOO . I1Ii1I1 - i1 * I1I
   if 89 - 89: Oo + oOO - oOO * i1i1i1111I . ooOOO
   if 27 - 27: I1Ii1I1
   if randomFold :
    ( i1I1i , OoOOIiiiI111 ) = Oooo0OOO . partition ( prop = validation , shuffle = True )
    if 89 - 89: oOO / I11iiIi11i1I
    if 15 - 15: OooOoo % oOo0O00 - OooOoo * I11iiIi11i1I + OooOoo
   else :
    if 55 - 55: ooOOO + I11iiIi11i1I
    oo0oOo0O0 = math . floor ( 1 / validation )
    IiIIiiII = self . validationTime % oo0oOo0O0
    if 51 - 51: I11iiIi11i1I % iI1iII1I1I1i
    Ooo000oo = self . _inputData
    IIiIiIiIIIiiI = self . _labelData
    if 61 - 61: i1iiIII111 . i1iiIII111 - Ii . Oo . Iii1i % i1
    if 41 - 41: OooOoo - i1iiIII111 . ooOOO / Iii1i
    if IiIIiiII == 0 and Oooo0OOO . shuffle :
     if 74 - 74: oOO * i1
     i11I1 = np . arange ( len ( IIiIiIiIIIiiI ) )
     np . random . shuffle ( i11I1 )
     Ooo000oo = Ooo000oo [ i11I1 ]
     IIiIiIiIIIiiI = IIiIiIiIIIiiI [ i11I1 ]
     if 46 - 46: i1iiIII111 - ooo000
     if 11 - 11: I1I . iI1iII1I1I1i % IiI11Ii111 * ooo000
    ii1i1II1iiiI = math . ceil ( IiOoOOOoO0 / oo0oOo0O0 )
    I1I1111 = IiIIiiII * ii1i1II1iiiI
    oOO0o00 = ( IiIIiiII + 1 ) * ii1i1II1iiiI
    if 63 - 63: iI1iII1I1I1i - Iii1i
    if 35 - 35: I1Ii1I1
    i1I1i = ( np . vstack ( ( Ooo000oo [ : I1I1111 ] , Ooo000oo [ oOO0o00 : ] ) ) , np . vstack ( ( IIiIiIiIIIiiI [ : I1I1111 ] , IIiIiIiIIIiiI [ oOO0o00 : ] ) ) )
    OoOOIiiiI111 = ( Ooo000oo [ I1I1111 : oOO0o00 ] , IIiIiIiIIIiiI [ I1I1111 : oOO0o00 ] )
    if 42 - 42: ooOOO / iI1iII1I1I1i % i1i1i1111I % IiI11Ii111
    if 78 - 78: IIiIIiIi11I1 + I1Ii1I1
    if 46 - 46: i1 * Iii1i - I11iiIi11i1I . OooOoo
    if 41 - 41: I1Ii1I1
    if 25 - 25: i1I . I1Ii1I1 - I1I - i1 * Ooo0Ooo
    if 45 - 45: I11iiIi11i1I / IIiIIiIi11I1 + iI1iII1I1I1i - i1 / ooo000 * I1Ii1I1
    if 27 - 27: IiIIii11Ii / OooOoo * oOO
   self [ I111II1II111I . Dataset . Types . ValidationTrain ] . setData ( inputArray = i1I1i [ 0 ] , outputArray = i1I1i [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Validation ] . setData ( inputArray = OoOOIiiiI111 [ 0 ] , outputArray = OoOOIiiiI111 [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   if 77 - 77: Iii1i - ooOOO - i1iiIII111 - I1I
   if 20 - 20: IiIIii11Ii * I1I - oOO
   self . validationTime += 1
   if 17 - 17: iI1iII1I1I1i . I1I % ooo000
  def splitTestDataset ( self , test : float = 0.2 , shuffle : bool = False ) :
   if 43 - 43: IiI11Ii111 % i1I
   if 65 - 65: IiIIii11Ii * i1iiIII111 * IiIIii11Ii . I1Ii1I1 % Ii
   if 51 - 51: i1 / Ii - iI1iII1I1I1i - Oo % ooOOO . OooOoo
   if 72 - 72: IIiIIiIi11I1 + oOO % IIiIIiIi11I1
   if 26 - 26: Oo / ooo000 * oOO / I1I / oOO . oOO
   if 86 - 86: i1
   if 47 - 47: oOO % iI1iII1I1I1i % i1i1i1111I
   if 34 - 34: IiI11Ii111 . I1Ii1I1
   if 30 - 30: ooOOO - ooo000 - Ii - IiIIii11Ii + IiI11Ii111 % ooOOO
   if 43 - 43: oOO / ooOOO
   if 93 - 93: IiIIii11Ii / I11iiIi11i1I - I11iiIi11i1I * iI1iII1I1I1i + Oo * IiIIii11Ii
   if 89 - 89: IiIIii11Ii . IIiIIiIi11I1 % Iii1i
   Oooo0OOO = self [ I111II1II111I . Dataset . Types . Train ]
   ( i1I1i , ooo ) = Oooo0OOO . partition ( prop = test , shuffle = shuffle )
   if 84 - 84: i1i1i1111I + oOo0O00 / IiIIii11Ii
   if 30 - 30: oOo0O00
   self [ I111II1II111I . Dataset . Types . Train ] . setData ( inputArray = i1I1i [ 0 ] , outputArray = i1I1i [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Test ] . setData ( inputArray = ooo [ 0 ] , outputArray = ooo [ 1 ] , hasHeader = Oooo0OOO . hasHeader )
   self [ I111II1II111I . Dataset . Types . Test ] . _path = self [ I111II1II111I . Dataset . Types . Train ] . _path
   if 93 - 93: i1 * i1iiIII111 / Ooo0Ooo
   if 54 - 54: iI1iII1I1I1i + Ooo0Ooo / I1Ii1I1 * Ooo0Ooo + ooo000 / IiIIii11Ii
 def __init__ ( self , coreDataDir : str = "" , fileName : str = "" , encoding : str = "utf8" , hasHeader : bool = True , name : str = "" , delimiter = "," ) :
  if 69 - 69: ooo000 % i1iiIII111 / ooo000
  if 85 - 85: I11iiIi11i1I
  if 12 - 12: oOO
  if 42 - 42: I11iiIi11i1I % Iii1i . IiIIii11Ii + i1I
  if 65 - 65: i1I % ooOOO / IiI11Ii111 . ooo000 % iI1iII1I1I1i . Ooo0Ooo
  if 37 - 37: OooOoo / Iii1i % IIiIIiIi11I1
  if 53 - 53: OooOoo % oOo0O00 + oOO
  if 76 - 76: iI1iII1I1I1i - ooOOO * oOO % ooOOO + oOO
  if 46 - 46: ooo000
  if 60 - 60: i1i1i1111I % oOo0O00 + ooOOO - i1I * IiIIii11Ii + i1I
  if 77 - 77: oOO + IiIIii11Ii
  if 77 - 77: Oo * Ooo0Ooo . IiIIii11Ii . i1 * i1 + i1
  if 52 - 52: Oo - I1Ii1I1 * I11iiIi11i1I % i1i1i1111I
  if 7 - 7: i1I - Iii1i . ooOOO % OooOoo % Oo + IIiIIiIi11I1
  super ( ) . __init__ ( name = name )
  if 73 - 73: IiIIii11Ii - I1Ii1I1 / IiIIii11Ii
  if 50 - 50: IiI11Ii111 / I1Ii1I1 + I1I * Iii1i
  self . _instanceClass = I1ooOoO0OooO . TXT
  if 89 - 89: Iii1i / i1i1i1111I + i1
  self . generatorController = OooII . GeneratorController ( self )
  if 23 - 23: I11iiIi11i1I . I1Ii1I1 - oOo0O00 + ooo000
  if 51 - 51: i1 / Ii
  self . coreDataDir = coreDataDir
  if 70 - 70: Oo - I11iiIi11i1I + I1Ii1I1 % Ii + IIiIIiIi11I1
  if 12 - 12: I1I / IiI11Ii111
  if len ( coreDataDir ) :
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . _path = coreDataDir
   self . generatorController [ I111II1II111I . Dataset . Types . Train ] . readFile ( path = self . _path , encoding = encoding , hasHeader = hasHeader , filename = filename )
   if 97 - 97: iI1iII1I1I1i % OooOoo + I1I
 def parseJSON ( self , obj : Dict [ str , Any ] , train : 'Train' ) :
  if 47 - 47: ooo000 % i1I + i1i1i1111I / oOo0O00
  if 78 - 78: iI1iII1I1I1i
  if 7 - 7: IiIIii11Ii - iI1iII1I1I1i * ooOOO * Ii
  if 80 - 80: Iii1i - I1Ii1I1
  if 39 - 39: i1i1i1111I . i1i1i1111I
  if 76 - 76: Ii * i1iiIII111 / OooOoo - I1I
  if 49 - 49: Ooo0Ooo . I1I * I11iiIi11i1I
  if 53 - 53: Iii1i - IiIIii11Ii
  if 62 - 62: Ii - Ooo0Ooo - IIiIIiIi11I1
  if 7 - 7: Ii . Ii
  if 90 - 90: Oo . I1Ii1I1 . IIiIIiIi11I1
  super ( ) . parseJSON ( obj , train )
  if 93 - 93: Oo - I11iiIi11i1I / iI1iII1I1I1i - OooOoo
class I1ooOoO0OooO ( II1i1I ) :
 if 75 - 75: oOO * I1I
 if 88 - 88: oOO + i1iiIII111 - oOO + i1i1i1111I * I11iiIi11i1I / ooOOO
 if 69 - 69: i1iiIII111 + i1iiIII111 . i1 - i1 + Ooo0Ooo . iI1iII1I1I1i
 if 67 - 67: oOO / i1i1i1111I + Iii1i . iI1iII1I1I1i
 if 26 - 26: OooOoo + ooOOO % oOo0O00 - i1i1i1111I . Oo - i1
 if 73 - 73: ooo000 % I1I
 if 8 - 8: IiIIii11Ii * OooOoo % IiIIii11Ii * OooOoo % IiI11Ii111
 if 67 - 67: Oo % I1Ii1I1
 Config = 0
 if 19 - 19: Ooo0Ooo . Oo * oOO * I1I / I1I
 Table = 1
 if 100 - 100: ooOOO % Oo
 CSV = 2
 if 74 - 74: Iii1i - Iii1i * IIiIIiIi11I1
 Image = 3
 if 71 - 71: Oo + Oo % iI1iII1I1I1i + IIiIIiIi11I1 * Ii + ooOOO
 CustomImage = 4
 if 12 - 12: IiI11Ii111
 Noise = 5
 if 2 - 2: IIiIIiIi11I1 . I1I % Oo
 MySQL = 6
 if 22 - 22: I1Ii1I1 % I1I / Ooo0Ooo % Ooo0Ooo
 MSSQL = 7
 if 70 - 70: OooOoo * I1I % i1 - Oo
 TXT = 8
 if 94 - 94: Ooo0Ooo % Ii % I11iiIi11i1I % I11iiIi11i1I
class I1ii11II11 :
 if 72 - 72: I1I * IiI11Ii111
 if 8 - 8: IiIIii11Ii . I1Ii1I1 / I11iiIi11i1I / I1Ii1I1 % i1i1i1111I + I1Ii1I1
 if 82 - 82: I1I - ooOOO - IIiIIiIi11I1
 if 52 - 52: Ooo0Ooo - i1i1i1111I
 if 66 - 66: Ii * IIiIIiIi11I1 * Ii
 if 69 - 69: I1I - i1i1i1111I - ooo000 . IIiIIiIi11I1 . Oo + i1
 if 47 - 47: OooOoo * Iii1i - I11iiIi11i1I . I11iiIi11i1I - I1I . I1Ii1I1
 class Tensor :
  if 37 - 37: i1I
  if 62 - 62: Ooo0Ooo
  if 24 - 24: ooOOO / i1iiIII111 - oOO + Iii1i . OooOoo
  if 79 - 79: ooOOO
  if 56 - 56: Ooo0Ooo / oOO . Ooo0Ooo % Ii
  if 10 - 10: IIiIIiIi11I1 . I1Ii1I1 / I11iiIi11i1I / IiI11Ii111
  if 58 - 58: oOO
  def __init__ ( self , ** kwargs ) :
   if 80 - 80: OooOoo + Ii * IiI11Ii111 * I11iiIi11i1I * Oo . oOo0O00
   if 80 - 80: Ii
   if 12 - 12: iI1iII1I1I1i % Ii . Oo % Ooo0Ooo / iI1iII1I1I1i * ooo000
   if 10 - 10: oOO . I11iiIi11i1I / I1I * i1i1i1111I * Iii1i
   if 89 - 89: i1I . I1I
   if 77 - 77: i1i1i1111I % i1 . IIiIIiIi11I1 + Oo + I1I / i1i1i1111I
   if 43 - 43: iI1iII1I1I1i - IIiIIiIi11I1 . i1 / i1i1i1111I . IiI11Ii111 * I1Ii1I1
   if 71 - 71: OooOoo * i1i1i1111I % Oo / Ii
   self . _tensors = { ** kwargs }
   if 29 - 29: ooo000
  def __getitem__ ( self , key : str ) -> 'tf.Tensor' :
   if 25 - 25: IiI11Ii111
   if 70 - 70: Ii * Ooo0Ooo % I1I
   if 6 - 6: IiI11Ii111 * i1 * oOo0O00 - i1iiIII111 * oOO % i1iiIII111
   if 55 - 55: ooOOO / Ii + I11iiIi11i1I - i1iiIII111 % oOO
   if 54 - 54: oOO . i1 % i1I . i1I / i1i1i1111I / i1I
   if 89 - 89: Ooo0Ooo / I1I * I1I . IiI11Ii111 + i1I
   if 34 - 34: Oo . i1 / Oo - ooo000 - I1I . i1
   if 32 - 32: i1I - Iii1i * i1iiIII111 * I11iiIi11i1I * I11iiIi11i1I
   if 53 - 53: i1iiIII111
   if 54 - 54: i1iiIII111 * Oo / I1I / i1i1i1111I + IIiIIiIi11I1 + IIiIIiIi11I1
   if 44 - 44: Oo . ooOOO + Ooo0Ooo . i1I % Ii / iI1iII1I1I1i
   if 98 - 98: i1i1i1111I * I1I / Oo / I1Ii1I1
   if 57 - 57: Ii * OooOoo % ooOOO
   return self . _tensors [ key ]
   if 38 - 38: I1I - I1Ii1I1 - iI1iII1I1I1i / Ii - i1i1i1111I
  def __iter__ ( self ) -> Iterable [ str ] :
   if 42 - 42: Ii % i1iiIII111 . I1I
   if 98 - 98: Oo - Ii / oOO * Oo
   if 56 - 56: OooOoo - Iii1i * I11iiIi11i1I * Iii1i
   if 80 - 80: i1I + IIiIIiIi11I1 / ooo000 . iI1iII1I1I1i
   if 20 - 20: Ooo0Ooo % Oo % ooo000 / i1I . I1I + IiI11Ii111
   if 27 - 27: I1Ii1I1 % Iii1i / ooo000
   if 61 - 61: Ooo0Ooo + I1I - i1i1i1111I / IIiIIiIi11I1 - i1i1i1111I
   if 82 - 82: oOO % ooo000 + Oo - i1 / i1I
   if 18 - 18: I11iiIi11i1I / Oo % I11iiIi11i1I * I1I
   if 94 - 94: IiI11Ii111 % i1iiIII111 * ooo000 / ooOOO
   return self . _tensors . __iter__ ( )
   if 79 - 79: IiIIii11Ii * ooOOO
  def items ( self ) -> Iterable [ Tuple [ str , 'tf.Tensor' ] ] :
   if 48 - 48: IiIIii11Ii / ooOOO / ooo000 . ooo000 . i1 - I11iiIi11i1I
   if 63 - 63: i1I / IiIIii11Ii
   if 11 - 11: ooOOO * i1i1i1111I + ooOOO % I11iiIi11i1I
   if 10 - 10: Ooo0Ooo / iI1iII1I1I1i
   if 83 - 83: ooOOO / oOo0O00
   if 16 - 16: I1I % oOO - i1I * OooOoo
   if 51 - 51: IiI11Ii111 + I1Ii1I1 + IIiIIiIi11I1
   if 75 - 75: I1I . Iii1i / I1I * i1i1i1111I
   if 29 - 29: Iii1i . i1
   if 27 - 27: i1 / i1i1i1111I - i1i1i1111I % I1I
   return self . _tensors . items ( )
   if 40 - 40: Oo / IiI11Ii111 - IIiIIiIi11I1 . I1I / oOO % oOO
  def keys ( self ) -> Iterable [ str ] :
   if 31 - 31: i1iiIII111 + Ii
   if 13 - 13: oOO
   if 100 - 100: OooOoo + iI1iII1I1I1i % ooo000 - i1 * OooOoo % i1iiIII111
   if 26 - 26: IIiIIiIi11I1
   if 100 - 100: Ooo0Ooo * Oo . I1Ii1I1 / Ooo0Ooo
   if 93 - 93: i1 + i1i1i1111I . ooOOO * Iii1i % Ooo0Ooo
   if 6 - 6: iI1iII1I1I1i - i1 % I1Ii1I1
   if 25 - 25: Iii1i - i1 + Oo - Iii1i
   if 43 - 43: IiIIii11Ii
   if 12 - 12: ooOOO / Ii % OooOoo - I1Ii1I1 % i1iiIII111 + i1i1i1111I
   return self . _tensors . keys ( )
   if 40 - 40: i1I * Ooo0Ooo . i1iiIII111 . i1
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] , train : 'Train' ) -> 'Source.Config' :
  if 25 - 25: IiI11Ii111 % Oo - i1 / iI1iII1I1I1i . i1iiIII111 / I1I
  if 27 - 27: Oo - Ii % OooOoo / I1I * I1I
  if 25 - 25: ooOOO % Ooo0Ooo * Iii1i
  if 8 - 8: I1I . Iii1i . ooo000 % i1
  if 66 - 66: i1I + IiI11Ii111 * I1Ii1I1 % IIiIIiIi11I1
  if 79 - 79: OooOoo + I11iiIi11i1I
  if 88 - 88: oOO * I11iiIi11i1I . ooo000 + IiI11Ii111 . Oo
  if 88 - 88: ooOOO % I1Ii1I1 + ooo000 . OooOoo % IiIIii11Ii
  if 50 - 50: IiI11Ii111 / i1I . I1I
  if 1 - 1: ooo000 * i1iiIII111 - Oo
  if 34 - 34: I1Ii1I1 - IIiIIiIi11I1 - i1I % ooOOO . I1Ii1I1 + OooOoo
  if 2 - 2: ooo000 - oOO % I11iiIi11i1I + i1I . Iii1i
  if 25 - 25: iI1iII1I1I1i . Oo
  if 67 - 67: I1I . IiIIii11Ii * Oo * ooOOO - ooOOO + ooo000
  if 42 - 42: IiI11Ii111 / i1I
  if 10 - 10: I1I . I1I - Oo * Iii1i
  if "_instanceClass" in obj :
   Iii1IiIiIII1 = getattr ( I1ii11II11 , I1ooOoO0OooO . getName ( obj [ "_instanceClass" ] ) ) ( )
  elif "_type" in obj :
   if obj [ "_type" ] == "TableSource" or obj [ "_type" ] == "Table" :
    Iii1IiIiIII1 = I1ii11II11 . Table ( )
   elif obj [ "_type" ] == "CSVSource" or obj [ "_type" ] == "CSV" :
    Iii1IiIiIII1 = I1ii11II11 . CSV ( )
   elif obj [ "_type" ] == "ImageSource" or obj [ "_type" ] == "Image" :
    Iii1IiIiIII1 = I1ii11II11 . Image ( )
   elif obj [ "_type" ] == "TXTSource" or obj [ "_type" ] == "TXT" :
    Iii1IiIiIII1 = I1ii11II11 . TXT ( )
  else :
   raise ValueError ( "Not supported JSON format for parsing a Source.Config object." )
   if 11 - 11: IiI11Ii111 + OooOoo
   if 5 - 5: i1iiIII111 % i1iiIII111 + IiIIii11Ii + IiIIii11Ii % oOo0O00 . i1i1i1111I
  Iii1IiIiIII1 . parseJSON ( obj , train )
  if 72 - 72: Ii
  return Iii1IiIiIII1
  if 85 - 85: IiIIii11Ii - i1 + iI1iII1I1I1i % Iii1i * I11iiIi11i1I % I1I
 Config = O0
 if 64 - 64: OooOoo / i1I . Iii1i % IiI11Ii111 . i1
 Table = o0ooo0oOoO
 if 57 - 57: Ii % i1
 CSV = ii1I11I1IIi
 if 32 - 32: i1 * Oo - I1Ii1I1 / i1I - Ii
 Image = iiI1i11iii
 if 27 - 27: i1 * I1Ii1I1 / I1I + Ii * IiI11Ii111 + i1i1i1111I
 CustomImage = O0OOO
 if 5 - 5: oOO
 Noise = I1111II11iI11
 if 78 - 78: oOo0O00
 MySQL = o0o0oo0
 if 86 - 86: I1Ii1I1 % Iii1i / oOO
 MSSQL = iI1
 if 50 - 50: ooo000
 TXT = OooII
 if 39 - 39: OooOoo * IIiIIiIi11I1 - IiIIii11Ii / ooOOO % I1Ii1I1 - i1i1i1111I
class oOoo :
 def __init__ ( self , isAccess : bool = False , weightPath : str = "./" , weightNames : str = None , _weightType : str = None ) :
  if 81 - 81: IiIIii11Ii % iI1iII1I1I1i
  if 83 - 83: ooo000 % i1iiIII111
  if 43 - 43: I1Ii1I1 . ooo000 - Oo - Ooo0Ooo * I11iiIi11i1I
  if 42 - 42: oOO . I11iiIi11i1I + Oo % OooOoo - I11iiIi11i1I
  if 51 - 51: IiIIii11Ii + I11iiIi11i1I . I11iiIi11i1I
  if 9 - 9: I1I * i1i1i1111I * I1I
  self . isAccess = isAccess
  if 31 - 31: OooOoo % IiI11Ii111
  if 12 - 12: i1i1i1111I * IIiIIiIi11I1 * Ii . I1I - i1iiIII111 . i1iiIII111
  if 85 - 85: Oo + i1 * i1I
  if 72 - 72: IIiIIiIi11I1
  if 13 - 13: ooOOO - i1i1i1111I / I1I
  if 78 - 78: OooOoo + IiIIii11Ii + oOO % I11iiIi11i1I
  if 19 - 19: Ii - IIiIIiIi11I1
  if 29 - 29: i1 / IIiIIiIi11I1 / OooOoo
  if 17 - 17: i1 . IiI11Ii111
  if 7 - 7: iI1iII1I1I1i % iI1iII1I1I1i - i1iiIII111 / oOo0O00 + Oo % iI1iII1I1I1i
  if 76 - 76: oOO / Ii
  if 28 - 28: Oo * IiIIii11Ii + oOO
  self . weightPath = weightPath
  self . weightNames = weightNames
  self . _weightType = _weightType
  if 51 - 51: iI1iII1I1I1i + i1iiIII111
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 96 - 96: Iii1i + Ooo0Ooo % Ooo0Ooo . I11iiIi11i1I
  if 49 - 49: iI1iII1I1I1i * iI1iII1I1I1i
  if 48 - 48: oOo0O00 - ooOOO / oOO - Iii1i / I1Ii1I1 - IiIIii11Ii
  if 12 - 12: ooOOO
  if 28 - 28: Ooo0Ooo * ooOOO % IiIIii11Ii
  if 53 - 53: Iii1i - Iii1i * OooOoo + ooOOO - IiI11Ii111
  if 73 - 73: i1i1i1111I - i1 / Iii1i - oOO % Iii1i
  if 34 - 34: ooOOO . Ii + IIiIIiIi11I1 - Ooo0Ooo / I1Ii1I1 / oOo0O00
  if 92 - 92: I1I . Ooo0Ooo
  if 50 - 50: ooOOO . OooOoo % i1i1i1111I . Ooo0Ooo
  if 83 - 83: Ooo0Ooo - I11iiIi11i1I / i1iiIII111
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   setattr ( self , Ii1I , iiiiIi1IiiIi )
   if 63 - 63: iI1iII1I1I1i - I1I * i1i1i1111I % i1 * Oo + Ooo0Ooo
class ooOO0Oo0o :
 class Types ( II1i1I ) :
  if 81 - 81: ooOOO % oOo0O00
  if 26 - 26: iI1iII1I1I1i / IiIIii11Ii % IiI11Ii111 * I11iiIi11i1I - i1
  if 10 - 10: oOO + IIiIIiIi11I1 / oOO - Oo
  if 100 - 100: i1i1i1111I
  if 38 - 38: OooOoo % OooOoo . i1iiIII111 / Iii1i * iI1iII1I1I1i
  if 68 - 68: IiI11Ii111 * Ooo0Ooo + Oo + IiIIii11Ii % Ooo0Ooo . ooo000
  if 87 - 87: OooOoo + IiIIii11Ii
  TFHub = 0
  if 42 - 42: i1I / oOo0O00 * i1i1i1111I
  if 63 - 63: i1iiIII111
  if 24 - 24: I1I - i1i1i1111I . ooo000 + I1Ii1I1 % i1i1i1111I
  if 19 - 19: I1I * OooOoo * Iii1i
  if 76 - 76: iI1iII1I1I1i . I1I
  if 70 - 70: Iii1i % OooOoo / IIiIIiIi11I1 / ooo000 % OooOoo % OooOoo
  if 78 - 78: Ii / Ii
  LadderPretrained = 1
  if 32 - 32: Oo * i1i1i1111I % I1Ii1I1 . IiIIii11Ii - OooOoo + i1i1i1111I
  Personal = 2
  if 39 - 39: Ooo0Ooo - ooo000 . ooOOO * IIiIIiIi11I1
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'Train.Weight.Weight' :
  I1i11 = ooOO0Oo0o ( )
  if 33 - 33: oOo0O00 - Ii
  if 5 - 5: IIiIIiIi11I1 % IiI11Ii111 * iI1iII1I1I1i . I1Ii1I1 + Iii1i
  if 61 - 61: i1iiIII111 / i1 - ooo000
  if 26 - 26: Iii1i % i1i1i1111I / Ooo0Ooo . i1i1i1111I / Ii / i1I
  if 78 - 78: ooo000 - I1Ii1I1 / Iii1i % i1 - oOo0O00 * IIiIIiIi11I1
  if 90 - 90: Oo
  if 85 - 85: ooo000 / IiIIii11Ii / IIiIIiIi11I1 / IIiIIiIi11I1 * ooOOO - I1Ii1I1
  if 56 - 56: I1I % Ii % iI1iII1I1I1i
  if 9 - 9: IiI11Ii111 / IIiIIiIi11I1
  if 44 - 44: i1 / IIiIIiIi11I1 + ooo000 / Ii . Iii1i + oOO
  if 39 - 39: Ii + I11iiIi11i1I - oOo0O00 + IiIIii11Ii / Ii . oOO
  if 54 - 54: i1 % oOO * oOO + Oo + IiI11Ii111 / IiI11Ii111
  I1i11 . parseJSON ( obj )
  return I1i11
  if 3 - 3: Ii + i1i1i1111I . IiI11Ii111 + i1iiIII111
 def __init__ ( self , saveConfig : 'Train.Weight.Config' = None , useConfig : 'Train.Weight.Config' = None ) :
  self . saveConfig = saveConfig
  if 72 - 72: oOO / Ooo0Ooo % Ii - i1iiIII111 % ooo000
  if 23 - 23: I11iiIi11i1I % oOo0O00 / i1I
  if 99 - 99: IiIIii11Ii * Ooo0Ooo - I1I - I1Ii1I1 - oOo0O00
  if 30 - 30: i1iiIII111 . I11iiIi11i1I * I1I . Ooo0Ooo - Ooo0Ooo
  if 48 - 48: IIiIIiIi11I1 . i1 % oOo0O00 * ooOOO / I1I % I11iiIi11i1I
  if 96 - 96: I11iiIi11i1I + I1I
  if 1 - 1: Oo - I1Ii1I1
  if 43 - 43: oOo0O00 % IiIIii11Ii * oOo0O00 * i1 * I1I . IIiIIiIi11I1
  if 99 - 99: Ii / oOO / OooOoo
  if 66 - 66: Ii
  self . useConfig = useConfig
  if 66 - 66: oOo0O00 % oOO / I1Ii1I1 / i1i1i1111I * I1I * OooOoo
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if 11 - 11: i1i1i1111I * i1I
   if 9 - 9: iI1iII1I1I1i
   if 47 - 47: IIiIIiIi11I1 * oOO
   if 80 - 80: I11iiIi11i1I / oOo0O00 % I11iiIi11i1I - Oo
   if 90 - 90: i1I % oOO - IiIIii11Ii
   if 78 - 78: i1i1i1111I / I1Ii1I1 - Ooo0Ooo
   if 91 - 91: I11iiIi11i1I . Oo / i1iiIII111 / i1i1i1111I % i1I / I1Ii1I1
   if 89 - 89: Iii1i . iI1iII1I1I1i
   if 65 - 65: Ooo0Ooo - IiI11Ii111 * i1iiIII111
   if iiiiIi1IiiIi is None or iiiiIi1IiiIi == "null" or iiiiIi1IiiIi == False :
    setattr ( self , Ii1I , None )
   else :
    if not hasattr ( self , Ii1I ) or getattr ( self , Ii1I ) is None :
     setattr ( self , Ii1I , oOoo ( ) )
    if iiiiIi1IiiIi is not None :
     getattr ( self , Ii1I ) . parseJSON ( iiiiIi1IiiIi )
     if 49 - 49: iI1iII1I1I1i . i1i1i1111I * I1Ii1I1 % I1Ii1I1 / I1I - oOO
 @ staticmethod
 def createBasicConfig ( isSaved : bool = True , saveWeightPath : str = "./" , saveWeightNames : str = "test" , saveWeightType : str = Types . Personal ,
 isUsed : bool = True , usedWeightPath : str = "./" , usedWeightNames : str = "test" , usedWeightType : str = Types . Personal ) -> 'Train.Weight.Weight' :
  if 72 - 72: IIiIIiIi11I1 * i1I
  if 61 - 61: i1i1i1111I + i1I / iI1iII1I1I1i * i1i1i1111I / IIiIIiIi11I1 * IIiIIiIi11I1
  if 1 - 1: i1iiIII111 - Oo - i1I + Ii
  if 37 - 37: i1iiIII111 % oOo0O00 % OooOoo + i1i1i1111I . IiI11Ii111 / oOo0O00
  if 36 - 36: ooOOO + Iii1i
  if 8 - 8: i1i1i1111I / IIiIIiIi11I1 * oOO + I11iiIi11i1I
  if 12 - 12: IiI11Ii111 . Iii1i - ooo000 - Ii * oOo0O00
  if 84 - 84: IiIIii11Ii - Oo . ooo000
  if 32 - 32: IiIIii11Ii * IIiIIiIi11I1 * i1i1i1111I / Ooo0Ooo % oOO
  if 98 - 98: Iii1i - Oo % ooOOO
  if 88 - 88: I11iiIi11i1I . I1I / iI1iII1I1I1i
  if 92 - 92: I11iiIi11i1I / I1Ii1I1 + I1I - IiIIii11Ii * I1I
  if 21 - 21: i1iiIII111 - i1I % i1I
  if 28 - 28: iI1iII1I1I1i . Ii / Iii1i % IiI11Ii111 . i1i1i1111I * i1
  if 39 - 39: Iii1i % i1 . IiI11Ii111 - i1i1i1111I
  if 47 - 47: OooOoo + Ii - I1Ii1I1
  if 56 - 56: i1i1i1111I - i1i1i1111I + i1i1i1111I % i1I
  if 32 - 32: Ii . ooOOO
  if 30 - 30: ooOOO - i1iiIII111 - IiI11Ii111
  if 12 - 12: Ooo0Ooo . I1I
  return ooOO0Oo0o ( saveConfig = None if isSaved is False else oOoo ( isAccess = isSaved , weightPath = saveWeightPath , weightNames = saveWeightNames , _weightType = saveWeightType ) ,
 useConfig = None if isUsed is False else oOoo ( isAccess = isUsed , weightPath = usedWeightPath , weightNames = usedWeightNames , _weightType = usedWeightType ) )
  if 66 - 66: I1Ii1I1
class I1i11iii1iI1 :
 if 71 - 71: Ooo0Ooo % ooOOO . oOO % i1I . oOo0O00 / oOO
 if 77 - 77: ooOOO + IIiIIiIi11I1 + i1I + oOO % IiI11Ii111
 if 35 - 35: i1 * I11iiIi11i1I % I1Ii1I1 . IiIIii11Ii
 if 39 - 39: Iii1i + Ooo0Ooo % IiI11Ii111
 if 77 - 77: IiI11Ii111
 if 62 - 62: IiIIii11Ii * i1iiIII111 + IIiIIiIi11I1 - IIiIIiIi11I1
 if 78 - 78: Iii1i / i1I + Iii1i
 def __init__ ( self , sourceData : List [ Union [ 'tf.Tensor' , 'np.ndarray' ] ] = [ ] , dppNodeData : Dict [ str , Union [ 'tf.Tensor' , 'np.ndarray' ] ] = { } ) :
  if 75 - 75: IiI11Ii111
  if 48 - 48: oOo0O00 + oOo0O00 + IiIIii11Ii . IiIIii11Ii - IiIIii11Ii
  if 88 - 88: IiI11Ii111 . Oo - IIiIIiIi11I1
  if 13 - 13: i1 / Oo * Iii1i / IIiIIiIi11I1 . oOO
  if 16 - 16: OooOoo + iI1iII1I1I1i - oOO * Ii - OooOoo / ooo000
  if 83 - 83: I11iiIi11i1I * IiIIii11Ii * Ii + IIiIIiIi11I1 / OooOoo - i1
  if 35 - 35: IiI11Ii111 * Ii * OooOoo * OooOoo - Oo
  if 72 - 72: IiI11Ii111
  if 100 - 100: I1Ii1I1 % Iii1i + IIiIIiIi11I1 * oOO - Ooo0Ooo
  if 42 - 42: oOO / i1 - oOo0O00 - oOO + IiI11Ii111 * i1iiIII111
  if 35 - 35: Ooo0Ooo * Oo - Iii1i - IiI11Ii111 % Iii1i
  if 52 - 52: OooOoo - OooOoo + OooOoo
  self . sources = sourceData
  if 89 - 89: i1 . i1iiIII111 . Iii1i + i1I * I1Ii1I1 . I1I
  if 97 - 97: iI1iII1I1I1i
  self . dppNodes = dppNodeData
  if 99 - 99: Iii1i + IiI11Ii111 + Ooo0Ooo . oOo0O00 % Ooo0Ooo / Ii
class o0o :
 if 33 - 33: oOO
 if 85 - 85: IiI11Ii111 * iI1iII1I1I1i * i1 + Ooo0Ooo / IiIIii11Ii
 if 73 - 73: ooo000 % i1 + I1Ii1I1 / i1I + Ii
 if 9 - 9: I1I % i1 - oOo0O00 + iI1iII1I1I1i
 if 6 - 6: I11iiIi11i1I . Ooo0Ooo . i1
 if 76 - 76: I11iiIi11i1I * I1Ii1I1
 if 31 - 31: ooo000 / ooOOO - I1Ii1I1 - I1Ii1I1 . IiI11Ii111
 def __init__ ( self , train : 'Train' , rootSources : List [ Union [ 'Source.Config' , 'DataPreprocessing.Node.SourceLike' ] ] , sourceDataset : 'DataGenerator.Dataset.Types' = None ) :
  if 75 - 75: oOo0O00 % i1iiIII111 + IIiIIiIi11I1 . oOO * IiI11Ii111 + Iii1i
  if 18 - 18: ooo000 % IiI11Ii111 + IIiIIiIi11I1 . i1i1i1111I - Oo / oOo0O00
  if 28 - 28: Iii1i
  if 21 - 21: I1I * Ii * ooo000 - I11iiIi11i1I * Ooo0Ooo
  if 89 - 89: i1 * I11iiIi11i1I
  if 14 - 14: iI1iII1I1I1i - IiIIii11Ii
  if 69 - 69: Iii1i / I11iiIi11i1I * I11iiIi11i1I
  if 23 - 23: ooOOO . i1 . Ooo0Ooo
  if 78 - 78: iI1iII1I1I1i % Iii1i % ooOOO * oOo0O00 + Ooo0Ooo
  if 38 - 38: i1 - I11iiIi11i1I
  if 90 - 90: i1i1i1111I * IIiIIiIi11I1 - IIiIIiIi11I1 + oOo0O00 * IIiIIiIi11I1 / ooo000
  if 70 - 70: i1iiIII111 * oOo0O00 . ooo000
  if 92 - 92: OooOoo
  self . sources = [ ( s if s in rootSources else None ) for s in train . sources ]
  if 86 - 86: oOo0O00 + IiIIii11Ii - Iii1i % Ooo0Ooo % OooOoo % Oo
  self . dppNodes = { dppNode . key : dppNode for dppNode in rootSources if isinstance ( dppNode , Oo0ooo0OO0 ) }
  if 51 - 51: Oo * i1iiIII111 / ooo000 / OooOoo + IiI11Ii111 + Oo
  self . sourceDataset = sourceDataset
  if 43 - 43: oOo0O00 * I1I / IIiIIiIi11I1 % oOO + Iii1i * oOO
 def __len__ ( self ) -> int :
  if 91 - 91: IIiIIiIi11I1 * Iii1i - Ii * IiI11Ii111 - I11iiIi11i1I . ooOOO
  if 99 - 99: i1iiIII111 + i1i1i1111I
  if 63 - 63: I1Ii1I1 * Ooo0Ooo % IIiIIiIi11I1 % OooOoo - i1I
  if 9 - 9: I11iiIi11i1I * ooOOO + iI1iII1I1I1i / ooo000 - OooOoo
  if 60 - 60: I11iiIi11i1I / oOo0O00 - Iii1i * i1I
  if 28 - 28: i1 / oOo0O00
  if 80 - 80: I11iiIi11i1I - Oo
  if 28 - 28: ooOOO / i1i1i1111I
  if 14 - 14: I11iiIi11i1I * i1 * oOo0O00 / OooOoo + ooo000
  if 44 - 44: I11iiIi11i1I / Ii + oOO % iI1iII1I1I1i
  return len ( self . sources ) + len ( self . dppNodes )
  if 55 - 55: IIiIIiIi11I1 + IiI11Ii111 + Ooo0Ooo + IiI11Ii111 + i1I + I1I
 def __next__ ( self ) -> 'Train.RootData' :
  if 8 - 8: Ooo0Ooo
  if 78 - 78: i1iiIII111 * oOO % iI1iII1I1I1i * I1I . I11iiIi11i1I
  if 15 - 15: Oo
  if 68 - 68: IiI11Ii111 + I1Ii1I1 * I1I
  if 30 - 30: i1iiIII111 + Ii * Oo % IiIIii11Ii
  if 32 - 32: I1I . Oo . ooo000
  if 57 - 57: Ii + iI1iII1I1I1i
  if 29 - 29: I1I % I11iiIi11i1I . Ooo0Ooo / Oo + IiIIii11Ii * Ooo0Ooo
  if 19 - 19: IIiIIiIi11I1 % Ii
  if 89 - 89: Iii1i * I1I / i1I - I1Ii1I1
  if 21 - 21: i1I + oOo0O00 * OooOoo - ooo000 % Iii1i + Oo
  iii1Oo = { dppKey : dppNode . getNextBatch ( sourceDataset = self . sourceDataset ) for dppKey , dppNode in self . dppNodes . items ( ) }
  if 84 - 84: i1iiIII111 % IiIIii11Ii . IiIIii11Ii / IiIIii11Ii + I1Ii1I1
  if 47 - 47: ooo000 / I1Ii1I1 / oOO
  IIooO = [ ]
  for O0oo0 in self . sources :
   iIiIiiI11 = O0oo0 . getNextBatch ( sourceDataset = self . sourceDataset )
   if 82 - 82: IIiIIiIi11I1 * IiIIii11Ii / I1Ii1I1 + Ii % ooOOO - i1
   if isinstance ( iIiIiiI11 , iII ) :
    IIooO . append ( iIiIiiI11 . rootData )
    for iI1Iiii1 , iiiI11i11Iii1 in iIiIiiI11 . dppData . items ( ) :
     iii1Oo [ iI1Iiii1 ] = iiiI11i11Iii1
   else :
    IIooO . append ( iIiIiiI11 )
    if 12 - 12: Ooo0Ooo . oOo0O00 % i1I
    if 72 - 72: Oo * oOo0O00
  return I1i11iii1iI1 ( IIooO , iii1Oo )
  if 75 - 75: Oo + i1I / I1Ii1I1 + Ooo0Ooo / i1I - Oo
 @ property
 def batchCountPerEpoch ( self ) -> int :
  if 75 - 75: I1Ii1I1 - ooOOO - i1iiIII111 . IiI11Ii111 * OooOoo
  if 66 - 66: i1iiIII111 - i1iiIII111
  if 96 - 96: i1I
  if 31 - 31: I11iiIi11i1I % IIiIIiIi11I1 / Oo
  if 65 - 65: IIiIIiIi11I1 - IIiIIiIi11I1 . OooOoo
  if 58 - 58: IIiIIiIi11I1 % oOo0O00
  if 84 - 84: i1i1i1111I . i1i1i1111I / Ooo0Ooo
  if 9 - 9: ooo000
  if 3 - 3: i1iiIII111 - oOO + I11iiIi11i1I % ooOOO % ooo000 . i1I
  if 84 - 84: I1Ii1I1 / oOO . i1i1i1111I
  return [ * self . sources , * ( self . dppNodes . values ( ) ) ] [ 0 ] . batchCountPerEpoch
  if 29 - 29: Iii1i . IiI11Ii111 + IIiIIiIi11I1
 @ property
 def epochSize ( self ) -> int :
  if 4 - 4: i1i1i1111I % I1I / Ooo0Ooo * oOo0O00 / IiIIii11Ii
  if 17 - 17: Ooo0Ooo * Iii1i . i1iiIII111 - Iii1i
  if 87 - 87: OooOoo - Ii % oOO . I1I % i1I
  if 95 - 95: oOo0O00 / oOo0O00 * IIiIIiIi11I1 * I1Ii1I1 * IiI11Ii111
  if 89 - 89: OooOoo % I1I / I1I + ooOOO - i1
  if 67 - 67: Ii . i1 * I1Ii1I1 / i1iiIII111
  if 53 - 53: I1I % I11iiIi11i1I - ooOOO
  if 28 - 28: Ooo0Ooo . Ii + i1i1i1111I - OooOoo
  if 74 - 74: Oo + IiIIii11Ii . i1iiIII111
  if 13 - 13: IIiIIiIi11I1 * i1iiIII111 * i1iiIII111 - OooOoo
  return [ * self . sources , * ( self . dppNodes . values ( ) ) ] [ 0 ] . epochSize
  if 96 - 96: i1iiIII111 . IiIIii11Ii - Ooo0Ooo
 def splitTestDataset ( self , ratio : float = 0.2 , shuffle : bool = True ) :
  if 9 - 9: OooOoo / oOO / Iii1i . i1 - I1I
  if 55 - 55: i1 / IiI11Ii111 / OooOoo . I1Ii1I1
  if 96 - 96: ooo000 + I1Ii1I1
  if 61 - 61: oOO
  if 16 - 16: Iii1i
  if 8 - 8: Oo - IIiIIiIi11I1 * i1i1i1111I % Iii1i - IiI11Ii111 - IiIIii11Ii
  if 96 - 96: i1 * Ooo0Ooo * iI1iII1I1I1i % OooOoo . I11iiIi11i1I * oOO
  if 76 - 76: IIiIIiIi11I1 - IIiIIiIi11I1 % ooo000 * IIiIIiIi11I1
  if 47 - 47: i1iiIII111
  if 55 - 55: i1 + IiI11Ii111 * OooOoo + IIiIIiIi11I1
  if 38 - 38: I1I . I1I - i1iiIII111
  if 26 - 26: I1I + oOO
  if self . sourceDataset not in [ None , I111II1II111I . Dataset . Types . Train ] :
   raise ValueError ( "Non training dataset cannot split test dataset." )
   if 34 - 34: Oo - ooo000 . I1I
   if 61 - 61: i1 . IiIIii11Ii % I11iiIi11i1I + I1Ii1I1 / oOo0O00 * i1I
  for O0oo0 in [ * self . sources , * ( self . dppNodes . values ( ) ) ] :
   if 20 - 20: iI1iII1I1I1i - i1I
   if not O0oo0 . splittable :
    raise ValueError ( "Some of the root sources are not splittable." )
    if 2 - 2: Oo / I1Ii1I1 . OooOoo - I1I % i1I
    if 33 - 33: oOo0O00
   O0oo0 . generatorController . splitTestDataset ( ratio , shuffle )
   if 49 - 49: Ooo0Ooo - Ii
 def nextCrossValidation ( self , buildConfig : 'Train.BuildConfig' ) :
  if 22 - 22: oOo0O00 . Iii1i / ooo000 - I11iiIi11i1I / i1i1i1111I
  if 64 - 64: i1i1i1111I % Iii1i - i1i1i1111I / ooOOO
  if 47 - 47: I11iiIi11i1I
  if 82 - 82: Ooo0Ooo . Ooo0Ooo % IiI11Ii111 - IIiIIiIi11I1 - i1i1i1111I
  if 95 - 95: IiIIii11Ii / ooo000
  if 22 - 22: I11iiIi11i1I / OooOoo % IIiIIiIi11I1 / Ii . ooo000
  if 1 - 1: oOo0O00 % IiI11Ii111
  if 21 - 21: I1I % Oo % I11iiIi11i1I
  if 4 - 4: OooOoo / IiI11Ii111 . oOO % Iii1i
  if 83 - 83: i1i1i1111I - I11iiIi11i1I + oOo0O00 % Ooo0Ooo * Iii1i - Ooo0Ooo
  if 12 - 12: Iii1i + i1iiIII111
  for O0oo0 in [ * self . sources , * ( self . dppNodes . values ( ) ) ] :
   if O0oo0 . splittable :
    if 52 - 52: ooo000 - IiI11Ii111 . IIiIIiIi11I1 + I1Ii1I1 + I1I
    O0oo0 . generatorController . splitValidationDataset ( validation = buildConfig . crossValidationProp , randomFold = buildConfig . crossValidationType == "rand" )
    if 86 - 86: ooo000
 def getData ( self , start : int = None , end : int = None ) -> 'Train.RootData' :
  if 45 - 45: Ooo0Ooo * i1I / ooo000
  if 2 - 2: IIiIIiIi11I1 % i1iiIII111 % IiIIii11Ii / I1Ii1I1 + oOo0O00 . I1Ii1I1
  if 96 - 96: IiIIii11Ii % OooOoo . IiI11Ii111 + Iii1i
  if 6 - 6: Oo - IiI11Ii111 . IIiIIiIi11I1 * I11iiIi11i1I / i1i1i1111I + IIiIIiIi11I1
  if 30 - 30: I11iiIi11i1I / i1iiIII111 . OooOoo / oOo0O00
  if 25 - 25: Ii . ooo000 + Iii1i * IiIIii11Ii - IIiIIiIi11I1
  if 13 - 13: oOO - Oo - Ooo0Ooo - iI1iII1I1I1i * Ii
  if 36 - 36: Oo % I1I
  if 18 - 18: Ooo0Ooo * ooo000 - i1iiIII111
  if 65 - 65: iI1iII1I1I1i
  if 75 - 75: I11iiIi11i1I + IiI11Ii111 % ooOOO + oOo0O00 + I11iiIi11i1I
  if 59 - 59: OooOoo % i1iiIII111 * i1i1i1111I / i1i1i1111I + i1i1i1111I * OooOoo
  if 36 - 36: oOO % ooOOO - IiIIii11Ii % I11iiIi11i1I
  if 50 - 50: I1I / I11iiIi11i1I - Oo . oOo0O00
  if 9 - 9: i1i1i1111I . Oo + ooOOO % ooo000 . i1iiIII111 / Ii
  iii1Oo = { dppKey : dppNode . getData ( sourceDataset = self . sourceDataset , start = start , end = end ) for dppKey , dppNode in self . dppNodes . items ( ) }
  if 81 - 81: oOO - Ooo0Ooo * oOO * I11iiIi11i1I - Ooo0Ooo
  if 66 - 66: i1 + IiIIii11Ii * i1iiIII111 + Iii1i - i1iiIII111
  IIooO = [ ]
  for O0oo0 in self . sources :
   iIiIiiI11 = O0oo0 . getData ( sourceDataset = self . sourceDataset , start = start , end = end )
   if 77 - 77: IiI11Ii111 / I1I
   if isinstance ( iIiIiiI11 , iII ) :
    IIooO . append ( iIiIiiI11 . rootData )
    for iI1Iiii1 , iiiI11i11Iii1 in iIiIiiI11 . dppData . items ( ) :
     iii1Oo [ iI1Iiii1 ] = iiiI11i11Iii1
   else :
    IIooO . append ( iIiIiiI11 )
    if 2 - 2: Ooo0Ooo / Ooo0Ooo - iI1iII1I1I1i . i1 % Ooo0Ooo
    if 71 - 71: oOo0O00 % Iii1i
  return I1i11iii1iI1 ( IIooO , iii1Oo )
  if 25 - 25: oOO * I1I * ooo000 + IiI11Ii111
 def getRandItems ( self , randomCount : int ) -> 'Train.RootData' :
  if 14 - 14: iI1iII1I1I1i / Ii / I1I % i1i1i1111I
  if 21 - 21: IiI11Ii111 . IIiIIiIi11I1 - ooOOO . OooOoo + i1 - OooOoo
  if 86 - 86: IiI11Ii111 . i1i1i1111I + OooOoo . i1
  if 56 - 56: I11iiIi11i1I + I1I
  if 37 - 37: IIiIIiIi11I1 / Ooo0Ooo . OooOoo
  if 96 - 96: i1 * i1 * ooo000
  if 90 - 90: I1I / IiI11Ii111 / Iii1i
  if 87 - 87: IiI11Ii111 / IiIIii11Ii - i1i1i1111I * Ooo0Ooo + Oo / i1
  if 77 - 77: I1Ii1I1 - Oo
  if 54 - 54: I11iiIi11i1I + i1iiIII111 + ooo000 * i1I / Iii1i
  if 95 - 95: I1I * oOo0O00
  if 66 - 66: ooOOO - i1iiIII111
  if 23 - 23: Iii1i . IIiIIiIi11I1 + I1I
  if 90 - 90: I1I - IIiIIiIi11I1 * i1I
  ooO0OoOo0 = int ( random . random ( ) * 100000 )
  if 60 - 60: i1I
  if 66 - 66: i1 * I11iiIi11i1I
  iii1Oo = { dppKey : dppNode . getRandItems ( sourceDataset = self . sourceDataset , randomSeed = ooO0OoOo0 , randomCount = randomCount ) for dppKey , dppNode in self . dppNodes . items ( ) }
  IIooO = [ ]
  if 2 - 2: I1I - oOO + Ooo0Ooo + IIiIIiIi11I1
  for O0oo0 in self . sources :
   iIiIiiI11 = O0oo0 . getRandItems ( sourceDataset = self . sourceDataset , randomSeed = ooO0OoOo0 , randomCount = randomCount )
   if 62 - 62: iI1iII1I1I1i + Ii - I11iiIi11i1I . Ooo0Ooo % IIiIIiIi11I1 * oOO
   if isinstance ( iIiIiiI11 , iII ) :
    IIooO . append ( iIiIiiI11 . rootData )
    for iI1Iiii1 , iiiI11i11Iii1 in iIiIiiI11 . dppData . items ( ) :
     iii1Oo [ iI1Iiii1 ] = iiiI11i11Iii1
   else :
    IIooO . append ( iIiIiiI11 )
    if 23 - 23: Ooo0Ooo * i1i1i1111I + Iii1i + IiIIii11Ii * IiI11Ii111 % i1
    if 45 - 45: i1I
  return I1i11iii1iI1 ( IIooO , iii1Oo )
  if 82 - 82: iI1iII1I1I1i % Oo
 def getVisualRandItems ( self , visualRecord : int ) -> 'Train.RootData' :
  III1I1III = visualRecord * 10
  if 86 - 86: IIiIIiIi11I1 / OooOoo - I1Ii1I1 * ooOOO . oOo0O00 + I1I
  ooO0OoOo0 = int ( random . random ( ) * 100000 )
  if 70 - 70: IIiIIiIi11I1 + i1i1i1111I + I1Ii1I1 - IiIIii11Ii
  iii1Oo = { dppKey : dppNode . getRandItems ( sourceDataset = self . sourceDataset , randomSeed = ooO0OoOo0 , randomCount = III1I1III ) for dppKey , dppNode in self . dppNodes . items ( ) }
  IIooO = [ ]
  for O0oo0 in self . sources :
   iIiIiiI11 = O0oo0 . getVisualRandItems ( sourceDataset = self . sourceDataset , randomSeed = ooO0OoOo0 , randomCount = III1I1III , visualRecord = visualRecord )
   if 40 - 40: Oo * i1I / I1I % OooOoo
   if isinstance ( iIiIiiI11 , iII ) :
    IIooO . append ( iIiIiiI11 . rootData )
    for iI1Iiii1 , iiiI11i11Iii1 in iIiIiiI11 . dppData . items ( ) :
     iii1Oo [ iI1Iiii1 ] = iiiI11i11Iii1
   else :
    IIooO . append ( iIiIiiI11 )
    if 69 - 69: i1I % Oo % i1I + I1Ii1I1 + IiI11Ii111
  return I1i11iii1iI1 ( IIooO , iii1Oo )
  if 19 - 19: Oo - ooo000 % Iii1i
 def closeCurrentDatasets ( self ) :
  if 93 - 93: iI1iII1I1I1i . I11iiIi11i1I - oOo0O00
  if 14 - 14: iI1iII1I1I1i . Iii1i . Iii1i
  if 54 - 54: I1Ii1I1 - I11iiIi11i1I - IiIIii11Ii + I11iiIi11i1I . oOo0O00
  if 40 - 40: Iii1i
  if 15 - 15: Ooo0Ooo * I1Ii1I1 - OooOoo / Ooo0Ooo . i1iiIII111 - oOo0O00
  if 68 - 68: ooo000 % ooOOO * ooo000 * i1iiIII111
  if 70 - 70: IiIIii11Ii
  if 79 - 79: oOO - IiI11Ii111 + iI1iII1I1I1i / Iii1i
  for O0oo0 in reversed ( self . sources ) :
   O0oo0 . generatorController . close ( self . sourceDataset )
   if 94 - 94: I1Ii1I1 - i1iiIII111 / oOo0O00
   if 60 - 60: iI1iII1I1I1i
  for ooOO00o in reversed ( [ * self . dppNodes . keys ( ) ] ) :
   self . dppNodes [ ooOO00o ] . generatorController . close ( self . sourceDataset )
   if 52 - 52: I1Ii1I1 * i1I + i1iiIII111 * I11iiIi11i1I
class iii11I :
 if 50 - 50: oOo0O00 / IIiIIiIi11I1 . OooOoo + i1I - IIiIIiIi11I1
 if 75 - 75: IiIIii11Ii / IiI11Ii111 . Ooo0Ooo % I1Ii1I1 * oOO - Ooo0Ooo
 if 23 - 23: i1iiIII111 . i1i1i1111I % IIiIIiIi11I1 + i1iiIII111 + iI1iII1I1I1i
 if 32 - 32: oOo0O00 + iI1iII1I1I1i / i1i1i1111I + I1I
 if 14 - 14: Oo
 if 2 - 2: Ii . IIiIIiIi11I1 . Ooo0Ooo . i1i1i1111I / i1i1i1111I / Oo
 if 26 - 26: iI1iII1I1I1i - IIiIIiIi11I1 - i1i1i1111I
 def __init__ ( self , noOfEpoch : int = 200 , batchSize : int = 64 , shuffle : bool = True ,
 exponentialLossDecay = 0.9 , exponentialVarDecay = 0.9999 ,
 crossValidationCount : int = 0 , crossValidationType : str = None , crossValidationProportion : float = 0.2 ,
 optimizer : str = "adam" , optimizerParams : Dict [ str , Any ] = { } ) :
  if 10 - 10: i1 / OooOoo * ooOOO . oOO / Iii1i - i1
  if 74 - 74: ooo000 * i1 / ooo000 / Ooo0Ooo
  if 19 - 19: IiIIii11Ii
  if 19 - 19: OooOoo - i1I / ooo000
  if 43 - 43: i1iiIII111
  if 31 - 31: IIiIIiIi11I1 % I11iiIi11i1I / Ooo0Ooo . i1i1i1111I * i1I + Oo
  if 50 - 50: Ooo0Ooo - OooOoo . IiIIii11Ii % IiIIii11Ii * Ii
  if 21 - 21: Ii + OooOoo - I11iiIi11i1I * I11iiIi11i1I % OooOoo
  if 100 - 100: ooOOO . IiIIii11Ii / Oo
  if 40 - 40: ooOOO - I1I - i1I + i1iiIII111 - i1
  if 43 - 43: oOo0O00 - i1I
  if 43 - 43: I1Ii1I1 + i1iiIII111
  if 56 - 56: I11iiIi11i1I
  if 66 - 66: Iii1i - i1i1i1111I - Oo
  if 60 - 60: I1I / ooo000 - oOO . i1i1i1111I
  if 48 - 48: i1iiIII111
  if 76 - 76: OooOoo - ooOOO % i1i1i1111I
  if 24 - 24: I11iiIi11i1I + i1iiIII111 + I1I * Iii1i . i1i1i1111I
  if 73 - 73: ooo000 / iI1iII1I1I1i / Iii1i - i1iiIII111 . I11iiIi11i1I
  if 77 - 77: IiIIii11Ii + Ooo0Ooo . Iii1i
  self . noOfEpoch = noOfEpoch
  if 74 - 74: i1i1i1111I
  self . batchSize = batchSize
  if 60 - 60: ooOOO % I1I % I1Ii1I1 % I1Ii1I1 / oOO * iI1iII1I1I1i
  self . shuffle = shuffle
  if 13 - 13: IiIIii11Ii % ooOOO + IIiIIiIi11I1
  self . dropRemainder = False
  if 15 - 15: oOO + iI1iII1I1I1i + i1i1i1111I . i1I
  self . exponentialLossDecay = exponentialLossDecay
  self . exponentialVarDecay = exponentialVarDecay
  if 98 - 98: oOO % i1i1i1111I . i1I . Iii1i
  if 91 - 91: oOo0O00 . i1 / Ii - i1i1i1111I - IiI11Ii111
  self . optimizer = optimizer
  if 58 - 58: I1Ii1I1 - I1Ii1I1 % Oo * oOo0O00 - IIiIIiIi11I1
  self . optimizerParams = optimizerParams
  if 62 - 62: i1 / iI1iII1I1I1i - i1i1i1111I - IIiIIiIi11I1 . i1I
  if 90 - 90: Ooo0Ooo . iI1iII1I1I1i * ooo000 - IIiIIiIi11I1
  self . crossValidationType = crossValidationType
  if 89 - 89: IiIIii11Ii
  self . crossValidationProp = crossValidationProportion
  if 61 - 61: I11iiIi11i1I
  self . crossValidationCount = crossValidationCount
  if 59 - 59: oOO
  if 19 - 19: Oo
  self . _cvCount = 0
  if 57 - 57: i1 % i1iiIII111 - IIiIIiIi11I1 % oOo0O00 + i1iiIII111
  self . output = None
  if 76 - 76: i1I . I1Ii1I1 . IIiIIiIi11I1 / IiI11Ii111
 @ property
 def validationRuns ( self ) -> int :
  if 32 - 32: Ooo0Ooo * oOo0O00 - I11iiIi11i1I
  if 89 - 89: Oo + I11iiIi11i1I % i1i1i1111I + ooo000 / i1
  if 54 - 54: I1I . IIiIIiIi11I1
  if 80 - 80: I1I % Oo . IIiIIiIi11I1 - I1I
  if 41 - 41: Ooo0Ooo + ooo000 / i1I
  if 27 - 27: i1I - ooOOO * ooOOO
  if 7 - 7: I1I / Ooo0Ooo / Ii - ooo000 / I1I . IIiIIiIi11I1
  if 51 - 51: Ii
  if 29 - 29: I1I / I1I * i1i1i1111I
  if 77 - 77: IIiIIiIi11I1
  return ( int ( ( 1 / self . crossValidationProp ) * self . crossValidationCount ) if self . crossValidationType == "fold" else self . crossValidationCount ) if self . crossValidationType is not None else 1
  if 90 - 90: iI1iII1I1I1i % Iii1i
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 15 - 15: i1
  if 99 - 99: I11iiIi11i1I / oOo0O00 % Iii1i % IIiIIiIi11I1 / ooo000 / i1i1i1111I
  if 1 - 1: oOO
  if 7 - 7: IiI11Ii111
  if 90 - 90: OooOoo / Iii1i - oOO * i1i1i1111I
  if 90 - 90: i1I + oOO * Oo + Ooo0Ooo % iI1iII1I1I1i
  if 98 - 98: IIiIIiIi11I1 - i1I + i1iiIII111 * Oo
  if 28 - 28: IiI11Ii111 * i1iiIII111 % IiI11Ii111
  if 69 - 69: i1 - OooOoo
  if 27 - 27: Ooo0Ooo - oOO * I1Ii1I1 / ooo000
  if 69 - 69: I1Ii1I1 - i1I . ooOOO * Oo - i1i1i1111I
  for Ii1I , iiiiIi1IiiIi in obj . items ( ) :
   setattr ( self , Ii1I , iiiiIi1IiiIi )
   if 3 - 3: i1iiIII111 * oOO . IiIIii11Ii / iI1iII1I1I1i
   if 22 - 22: IiI11Ii111 - iI1iII1I1I1i - oOo0O00 - Ooo0Ooo + I11iiIi11i1I + i1I
  if self . crossValidationType == "None" :
   self . crossValidationType = None
   if 73 - 73: i1 . I1I * Ooo0Ooo + I1I
   if 97 - 97: I1I % IiI11Ii111 - IiIIii11Ii
  if ( self . crossValidationType is not None ) and ( self . crossValidationType not in [ "fold" , "rand" ] ) :
   raise ValueError ( "Validation Type (" + str ( self . crossValidationType ) + ") is not supported." )
   if 22 - 22: Ooo0Ooo / i1I
   if 91 - 91: i1i1i1111I - oOo0O00 - Iii1i + i1 / i1iiIII111
  if self . crossValidationCount < 0 or self . crossValidationProp < 0 :
   raise ValueError ( "Validation Count and Proportion should be positive numbers." )
   if 63 - 63: IIiIIiIi11I1 . OooOoo - ooo000 - Oo % oOo0O00 - ooo000
   if 24 - 24: i1iiIII111 . Ooo0Ooo
  if self . crossValidationProp == 1 or self . crossValidationProp == 0 or self . crossValidationCount == 0 :
   self . crossValidationType = None
   self . crossValidationProp = 0
   self . crossValidationCount = 0
  else :
   if self . crossValidationProp > 1 :
    if 98 - 98: IiIIii11Ii
    self . crossValidationProp = 1 / self . crossValidationProp
    self . crossValidationCount = int ( self . crossValidationCount )
   else :
    self . crossValidationProp = self . crossValidationProp
    self . crossValidationCount = int ( self . crossValidationCount )
    if 78 - 78: Ii % i1 * IiIIii11Ii - i1 / Ii
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'Train.BuildConfig' :
  if 92 - 92: IiI11Ii111 * I1I
  if 97 - 97: Oo
  if 4 - 4: ooOOO - I1I
  if 14 - 14: IiIIii11Ii % oOO * IiIIii11Ii / OooOoo
  if 24 - 24: i1I % i1i1i1111I
  if 95 - 95: oOO
  if 88 - 88: Iii1i . IiIIii11Ii / OooOoo
  if 5 - 5: I1I + oOo0O00 * ooOOO - oOO
  if 84 - 84: I11iiIi11i1I
  if 52 - 52: ooOOO % IiIIii11Ii / I1I - i1I - iI1iII1I1I1i % i1
  if 69 - 69: IiIIii11Ii . oOO / Iii1i + Ooo0Ooo % IiIIii11Ii
  if 51 - 51: i1iiIII111 - oOO . Iii1i % oOo0O00 / iI1iII1I1I1i
  if 22 - 22: i1 / I11iiIi11i1I
  O0o000oO = iII11 . BuildConfig ( )
  O0o000oO . parseJSON ( obj )
  return O0o000oO
  if 67 - 67: I1I . OooOoo
class iII11 :
 if 47 - 47: iI1iII1I1I1i . i1I . Oo
 if 47 - 47: I1I * ooo000 . IiI11Ii111 + I1I * iI1iII1I1I1i
 if 70 - 70: I11iiIi11i1I
 if 46 - 46: IIiIIiIi11I1
 if 77 - 77: Iii1i
 if 68 - 68: ooOOO % i1i1i1111I * IIiIIiIi11I1 + OooOoo / IiI11Ii111 . Ooo0Ooo
 if 79 - 79: Oo % Iii1i
 BuildConfig = iii11I
 Variable = i11i111iI
 if 22 - 22: Iii1i
 if 21 - 21: I11iiIi11i1I . I11iiIi11i1I + I1Ii1I1
 Version = 1908
 if 96 - 96: IiI11Ii111 - Oo
 class UsingData :
  if 71 - 71: ooOOO % iI1iII1I1I1i - I11iiIi11i1I
  if 35 - 35: I1Ii1I1 - i1i1i1111I
  if 81 - 81: IiI11Ii111 * OooOoo % Ii + iI1iII1I1I1i
  if 43 - 43: Iii1i / oOO
  if 11 - 11: i1 % IIiIIiIi11I1 * I1I
  if 35 - 35: Oo
  if 85 - 85: i1 * IiIIii11Ii
  def __init__ ( self , train : 'Train' , rootData : 'Train.RootData' ) :
   if 60 - 60: Ooo0Ooo * I1I + Ooo0Ooo
   if 48 - 48: Ii * i1iiIII111
   if 96 - 96: Ii % IiIIii11Ii
   if 6 - 6: i1iiIII111 * Iii1i % oOo0O00
   if 59 - 59: i1I
   if 21 - 21: i1I % Ii / i1I + iI1iII1I1I1i % IiIIii11Ii
   if 41 - 41: i1i1i1111I + i1i1i1111I / I11iiIi11i1I / i1I - oOO
   if 20 - 20: I1Ii1I1 . oOo0O00 + Ii / i1 . i1iiIII111 . Iii1i
   if 64 - 64: i1i1i1111I . ooo000 + ooo000 . ooOOO * Oo
   if 27 - 27: oOO
   if 36 - 36: Ii * OooOoo / OooOoo % oOo0O00 . OooOoo
   if 63 - 63: i1i1i1111I % I11iiIi11i1I . Ooo0Ooo + oOO
   if len ( rootData . sources ) < len ( train . rootSources . sources ) or len ( rootData . dppNodes ) < len ( train . rootSources . dppNodes ) :
    raise ValueError ( "The structure does not match with the root data of the Train object." )
    if 33 - 33: i1iiIII111 / ooo000 . I1I % Oo * oOO . oOo0O00
    if 51 - 51: ooOOO - I1Ii1I1 * I1I
   self . _data = { dppKey : dppNode . getProcessedData ( rootData ) for dppKey , dppNode in train . dppNodes . items ( ) }
   if 23 - 23: IiIIii11Ii * i1iiIII111 + ooOOO
  def __len__ ( self ) -> int :
   if 12 - 12: i1i1i1111I % i1iiIII111 / IiIIii11Ii + oOo0O00 * I1Ii1I1 / iI1iII1I1I1i
   if 19 - 19: oOO . OooOoo / oOo0O00 % oOO
   if 73 - 73: i1I + i1I
   if 84 - 84: Oo + i1i1i1111I . IIiIIiIi11I1 - Oo . ooOOO
   if 56 - 56: ooo000 / IIiIIiIi11I1 + I1I % IIiIIiIi11I1
   if 23 - 23: Oo * IIiIIiIi11I1 % IIiIIiIi11I1 * i1 * IiI11Ii111 + IiIIii11Ii
   if 88 - 88: I11iiIi11i1I
   if 36 - 36: IiI11Ii111 * ooo000 / Ooo0Ooo + IiI11Ii111 - Ii - Oo
   if 62 - 62: i1I . ooo000 - Ooo0Ooo
   if 24 - 24: ooOOO / Ooo0Ooo
   return len ( self . _data )
   if 17 - 17: iI1iII1I1I1i * Oo % Oo + ooOOO * I1I
  def getCount ( self ) -> int :
   if 4 - 4: i1i1i1111I * iI1iII1I1I1i - oOO * Ooo0Ooo % Iii1i
   if 1 - 1: IiI11Ii111 / Ooo0Ooo . IIiIIiIi11I1 . Ooo0Ooo % Oo
   if 5 - 5: ooOOO * IiIIii11Ii % ooOOO + i1i1i1111I
   if 55 - 55: I1I / I11iiIi11i1I * OooOoo . Ii % ooOOO
   if 18 - 18: oOo0O00 . Ii * Iii1i % iI1iII1I1I1i . I11iiIi11i1I + I1I
   if 68 - 68: i1i1i1111I - OooOoo
   if 89 - 89: i1 . iI1iII1I1I1i / oOo0O00 * I11iiIi11i1I * Ii
   if 64 - 64: Iii1i * oOo0O00
   if 54 - 54: IIiIIiIi11I1 / iI1iII1I1I1i + I1I + I1I + IIiIIiIi11I1 + Ooo0Ooo
   if 1 - 1: Ii + IiIIii11Ii . Iii1i
   return len ( [ * self . _data . values ( ) ] [ 0 ] )
   if 27 - 27: IiI11Ii111 / I1I + I1I
  def __iter__ ( self ) -> Iterable [ 'np.ndarray' ] :
   if 67 - 67: Oo + oOo0O00 % i1iiIII111 % I1I - oOO - Ii
   if 59 - 59: i1i1i1111I + IiI11Ii111 + oOO
   if 52 - 52: iI1iII1I1I1i + i1i1i1111I / i1I - oOO % IiIIii11Ii * Oo
   if 38 - 38: OooOoo - I1Ii1I1 . oOO / ooo000
   if 52 - 52: Ooo0Ooo . Ooo0Ooo . Ooo0Ooo
   if 8 - 8: IiI11Ii111
   if 90 - 90: ooo000 . i1
   if 51 - 51: I1I
   if 7 - 7: OooOoo % Iii1i . OooOoo
   if 29 - 29: i1I % i1i1i1111I % i1I % I1Ii1I1
   return self . _data . __iter__ ( )
   if 81 - 81: IIiIIiIi11I1 * iI1iII1I1I1i + Iii1i % ooo000
  def __getitem__ ( self , idx : str ) -> 'np.ndarray' :
   if 1 - 1: OooOoo * Iii1i
   if 73 - 73: i1iiIII111 . i1i1i1111I / i1I + ooo000 + ooOOO
   if 49 - 49: i1I
   if 19 - 19: i1iiIII111 % IiIIii11Ii
   if 25 - 25: I1Ii1I1 % I1Ii1I1
   if 65 - 65: ooOOO + Oo * Oo + oOO
   if 26 - 26: ooOOO * Ooo0Ooo - i1iiIII111 % Iii1i * I11iiIi11i1I
   if 37 - 37: oOO
   if 40 - 40: ooo000 / Ii * oOo0O00 - oOO / IiI11Ii111 . I1I
   if 17 - 17: I1I + Iii1i + I1I % oOo0O00
   if 3 - 3: i1
   if 97 - 97: oOO
   if 32 - 32: Ii
   return self . _data [ idx ]
   if 99 - 99: Ii * oOO % IiI11Ii111
  def values ( self ) -> Iterable [ Union [ 'np.ndarray' , 'tf.Tensor' ] ] :
   if 96 - 96: OooOoo - I11iiIi11i1I + IiI11Ii111
   if 33 - 33: i1iiIII111 + I1I + i1i1i1111I
   if 80 - 80: IiIIii11Ii
   if 45 - 45: IiI11Ii111 * i1i1i1111I % I11iiIi11i1I % i1 + oOo0O00
   if 33 - 33: oOO + IiI11Ii111 + Iii1i . OooOoo - ooOOO - i1I
   if 45 - 45: Ooo0Ooo . Ooo0Ooo % I11iiIi11i1I . Oo + i1i1i1111I
   if 14 - 14: Ii + IIiIIiIi11I1 * oOo0O00
   if 4 - 4: OooOoo / iI1iII1I1I1i + OooOoo
   if 46 - 46: i1 . Iii1i . I1I . iI1iII1I1I1i * i1iiIII111
   if 23 - 23: IiI11Ii111 % i1iiIII111 + I11iiIi11i1I + iI1iII1I1I1i / i1 + OooOoo
   return self . _data . values ( )
   if 99 - 99: i1 / iI1iII1I1I1i * i1i1i1111I * I1Ii1I1
  def items ( self ) -> Iterable [ Tuple [ str , Union [ 'np.ndarray' , 'tf.Tensor' ] ] ] :
   if 60 - 60: Oo + i1I % i1 % IiI11Ii111 - I11iiIi11i1I + oOo0O00
   if 13 - 13: i1iiIII111 / Ooo0Ooo % i1I - IiIIii11Ii
   if 52 - 52: IiIIii11Ii
   if 11 - 11: IiI11Ii111
   if 2 - 2: Ii
   if 19 - 19: ooOOO % oOO
   if 57 - 57: Iii1i / ooOOO - I1I % iI1iII1I1I1i - ooo000
   if 71 - 71: Ii
   if 31 - 31: IIiIIiIi11I1 + i1i1i1111I
   if 58 - 58: ooo000 + i1iiIII111
   return self . _data . items ( )
   if 69 - 69: I11iiIi11i1I . oOO * OooOoo / I1I
  def keys ( self ) -> Iterable [ str ] :
   if 43 - 43: Ooo0Ooo
   if 64 - 64: i1I
   if 21 - 21: iI1iII1I1I1i * i1 - oOo0O00
   if 64 - 64: IiI11Ii111 % ooo000 . Oo
   if 94 - 94: I1Ii1I1 - IIiIIiIi11I1 / I11iiIi11i1I . I1I / i1iiIII111
   if 24 - 24: i1I . IIiIIiIi11I1 % i1I - iI1iII1I1I1i . ooOOO
   if 77 - 77: ooo000 . I1Ii1I1 + IiI11Ii111 - Ooo0Ooo
   if 14 - 14: I1Ii1I1 + OooOoo
   if 92 - 92: I1I
   if 92 - 92: i1i1i1111I / Oo . ooo000 * oOo0O00 . I11iiIi11i1I
   return self . _data . keys ( )
   if 97 - 97: Oo
 class UsingShowData :
  if 61 - 61: ooOOO % I1Ii1I1 + ooo000 - I1I
  if 2 - 2: IiIIii11Ii - Ii . Ii + i1i1i1111I . Ooo0Ooo
  if 38 - 38: Oo % IiI11Ii111 - iI1iII1I1I1i
  if 100 - 100: OooOoo / ooOOO % Oo * Iii1i + Ooo0Ooo
  if 11 - 11: I1I * i1i1i1111I
  if 35 - 35: ooOOO / i1 . i1 . i1I % iI1iII1I1I1i - i1
  if 14 - 14: IiIIii11Ii - Iii1i
  def __init__ ( self , train : 'Train' , rootData : 'Train.RootData' ) :
   if 8 - 8: i1iiIII111 * Ii + i1 - Oo
   if 17 - 17: IiIIii11Ii + i1iiIII111
   if 13 - 13: i1I
   if 60 - 60: I1I - Oo
   if 57 - 57: iI1iII1I1I1i / Iii1i / IiIIii11Ii - IiIIii11Ii * IiI11Ii111 . oOo0O00
   if 75 - 75: I11iiIi11i1I / I1I - OooOoo - Ii
   if 21 - 21: I1I . ooo000 % OooOoo - i1iiIII111
   if 24 - 24: I1I % oOO . Ii - oOo0O00 * Ii + I1I
   if 64 - 64: Ii + ooOOO / ooo000 - I1I / oOo0O00 * iI1iII1I1I1i
   if 45 - 45: oOo0O00 % IiI11Ii111 * I1I / i1i1i1111I / IiI11Ii111 - Ooo0Ooo
   if 47 - 47: i1
   if 72 - 72: Iii1i * i1iiIII111
   if len ( rootData . sources ) < len ( train . rootSources . sources ) or len ( rootData . dppNodes ) < len ( train . rootSources . dppNodes ) :
    raise ValueError ( "The structure does not match with the root data of the Train object." )
    if 20 - 20: Iii1i . Ii * ooo000 % iI1iII1I1I1i
    if 52 - 52: i1 + IiI11Ii111 - ooOOO * I11iiIi11i1I * I1Ii1I1 % i1iiIII111
   self . _data = { dppKey : dppNode . getProcessedDataToShow ( rootData ) for dppKey , dppNode in train . dppNodes . items ( ) }
   if 73 - 73: i1I . i1i1i1111I . Iii1i
  def __len__ ( self ) -> int :
   if 52 - 52: i1I * Oo * Ii . i1iiIII111 * i1I
   if 32 - 32: IIiIIiIi11I1
   if 66 - 66: Iii1i * Oo
   if 52 - 52: I11iiIi11i1I % I11iiIi11i1I
   if 42 - 42: IIiIIiIi11I1 - oOo0O00 + I1I % iI1iII1I1I1i . IiIIii11Ii + I11iiIi11i1I
   if 90 - 90: I11iiIi11i1I * i1I + I1Ii1I1
   if 94 - 94: i1 . oOO
   if 60 - 60: ooOOO
   if 82 - 82: Oo + i1iiIII111
   if 69 - 69: IiI11Ii111 . I11iiIi11i1I - OooOoo - OooOoo
   return len ( self . _data )
   if 28 - 28: i1I % oOo0O00 . Ii
  def getCount ( self ) -> int :
   if 80 - 80: Ooo0Ooo * IiIIii11Ii
   if 11 - 11: IiI11Ii111
   if 18 - 18: oOo0O00
   if 47 - 47: i1iiIII111 . iI1iII1I1I1i
   if 83 - 83: I1I
   if 99 - 99: Iii1i % Ii
   if 35 - 35: ooOOO * Ooo0Ooo + oOO - IiI11Ii111
   if 99 - 99: oOo0O00 + oOo0O00 - I1I . Iii1i
   if 32 - 32: I1Ii1I1 * Ooo0Ooo - I1I - i1I
   if 58 - 58: i1I % oOo0O00 % i1
   return len ( [ * self . _data . values ( ) ] [ 0 ] )
   if 24 - 24: Ii * oOO - oOo0O00 % IiI11Ii111 - I11iiIi11i1I . oOo0O00
  def __iter__ ( self ) -> Iterable [ 'np.ndarray' ] :
   if 2 - 2: IIiIIiIi11I1 % I1I - iI1iII1I1I1i
   if 40 - 40: i1iiIII111 * Oo % Ii / OooOoo * Iii1i . i1I
   if 16 - 16: i1i1i1111I % oOO - IIiIIiIi11I1
   if 42 - 42: iI1iII1I1I1i * i1I + OooOoo / Ii / oOO . ooOOO
   if 34 - 34: ooo000
   if 72 - 72: ooOOO - iI1iII1I1I1i + ooo000 + IIiIIiIi11I1 - i1I / i1i1i1111I
   if 97 - 97: ooOOO + IIiIIiIi11I1 % OooOoo
   if 93 - 93: I1Ii1I1 % Ooo0Ooo + i1 - iI1iII1I1I1i * IiIIii11Ii
   if 96 - 96: IiI11Ii111 - ooOOO % i1iiIII111 - Iii1i
   if 65 - 65: ooOOO / I1Ii1I1 - Ooo0Ooo . IIiIIiIi11I1 + Ii
   return self . _data . __iter__ ( )
   if 7 - 7: I1I % i1i1i1111I . i1 % IIiIIiIi11I1 / I1Ii1I1 / i1
  def __getitem__ ( self , idx : str ) -> 'np.ndarray' :
   if 9 - 9: i1iiIII111 - Oo + oOo0O00 / I1Ii1I1 % ooo000 - iI1iII1I1I1i
   if 85 - 85: i1I % i1i1i1111I + Iii1i - IIiIIiIi11I1
   if 7 - 7: I1I - iI1iII1I1I1i % ooOOO - IIiIIiIi11I1 . I11iiIi11i1I
   if 18 - 18: i1I % ooo000 / iI1iII1I1I1i - i1 . oOo0O00 * Ii
   if 80 - 80: OooOoo . ooOOO - i1i1i1111I
   if 99 - 99: I1Ii1I1 - oOO / ooo000 % i1I * Ooo0Ooo
   if 86 - 86: i1i1i1111I - IiI11Ii111 + Iii1i / oOo0O00 - I1Ii1I1
   if 25 - 25: oOO . Ii
   if 71 - 71: Oo
   if 52 - 52: Iii1i % Ooo0Ooo % oOo0O00 * I11iiIi11i1I
   if 52 - 52: i1
   if 97 - 97: I1I * OooOoo / oOo0O00 / iI1iII1I1I1i % I1Ii1I1
   if 58 - 58: I11iiIi11i1I . i1 * IIiIIiIi11I1 + I11iiIi11i1I . Iii1i
   return self . _data [ idx ]
   if 37 - 37: oOO % ooo000
  def values ( self ) -> Iterable [ Union [ 'np.ndarray' , 'tf.Tensor' ] ] :
   if 6 - 6: i1 . ooOOO
   if 97 - 97: oOo0O00 / i1 / I1I * i1iiIII111 . ooo000
   if 65 - 65: Oo / Oo * I1Ii1I1 . i1i1i1111I / i1 . oOO
   if 1 - 1: ooo000 * i1i1i1111I % I1I % oOo0O00 - i1I
   if 16 - 16: ooo000 / oOo0O00
   if 7 - 7: I1Ii1I1 / I11iiIi11i1I . i1iiIII111 / IiI11Ii111 - Ii . Ii
   if 83 - 83: I1Ii1I1 - i1
   if 12 - 12: IIiIIiIi11I1 - i1iiIII111
   if 82 - 82: OooOoo - oOo0O00
   if 68 - 68: I11iiIi11i1I - I11iiIi11i1I + ooo000 + I1Ii1I1 . iI1iII1I1I1i % oOo0O00
   return self . _data . values ( )
   if 75 - 75: IIiIIiIi11I1 . Ii - Ooo0Ooo - i1iiIII111 / IiIIii11Ii
  def items ( self ) -> Iterable [ Tuple [ str , Union [ 'np.ndarray' , 'tf.Tensor' ] ] ] :
   if 34 - 34: Oo . Oo
   if 61 - 61: oOO / IiI11Ii111 % i1i1i1111I / Ooo0Ooo + i1i1i1111I . i1I
   if 16 - 16: I1I % Oo % oOo0O00 / i1 / Oo
   if 42 - 42: Ooo0Ooo . Oo
   if 1 - 1: I1I + i1 / Oo * I1Ii1I1 * Ii
   if 11 - 11: iI1iII1I1I1i % IiIIii11Ii / oOo0O00
   if 37 - 37: IiIIii11Ii / iI1iII1I1I1i % ooOOO * Iii1i
   if 16 - 16: Oo + Oo - I1I + ooo000 + I11iiIi11i1I / I1Ii1I1
   if 45 - 45: IiIIii11Ii
   if 36 - 36: oOO
   return self . _data . items ( )
   if 31 - 31: I1I - Oo . oOo0O00
  def keys ( self ) -> Iterable [ str ] :
   if 81 - 81: Oo + ooOOO - oOO % IIiIIiIi11I1 * iI1iII1I1I1i - ooOOO
   if 56 - 56: iI1iII1I1I1i + IiI11Ii111 * Ii % OooOoo - IiIIii11Ii
   if 92 - 92: oOo0O00
   if 47 - 47: Iii1i / i1i1i1111I % oOo0O00 % oOO * I11iiIi11i1I
   if 21 - 21: i1i1i1111I / Iii1i . IIiIIiIi11I1
   if 5 - 5: I11iiIi11i1I % i1
   if 54 - 54: i1I
   if 41 - 41: i1 / ooo000 * i1iiIII111 + ooOOO
   if 80 - 80: i1I . oOo0O00 / I1I
   if 13 - 13: oOO * oOO . Ooo0Ooo
   return self . _data . keys ( )
   if 34 - 34: i1i1i1111I * ooo000 * I1Ii1I1
   if 48 - 48: Iii1i
 def __init__ ( self , trainName : str = "train" , folder : str = "D:/tmp/" , restorePath : Optional [ str ] = None , device : str = '/cpu:0' ,
 logFreq : int = 0 , saveFreq : int = 0 , testFreq : int = 0 , traceFreq : int = 0 , weightLogFreq : int = 0 , filterFreq : int = 0 ,
 source : Optional [ Union [ 'Source.Config' , List [ 'Source.Config' ] ] ] = None , testSource : Optional [ Union [ 'Source.Config' , List [ 'Source.Config' ] ] ] = None ,
 runCount : Optional [ int ] = None , buildConfig : Optional [ Union [ 'Train.BuildConfig' , List [ 'Train.BuildConfig' ] ] ] = None , traceRecord : int = 0 ,
 visualTestFreq : int = 0 , visualRecord : int = 0 ) :
  if 34 - 34: I1Ii1I1
  if 19 - 19: oOo0O00 - oOo0O00 . Iii1i + I1Ii1I1
  if 22 - 22: Oo
  if 88 - 88: I11iiIi11i1I
  if 14 - 14: Oo
  if 75 - 75: Oo * IiIIii11Ii
  if 20 - 20: Iii1i
  if 2 - 2: i1I . IiIIii11Ii - I11iiIi11i1I - ooOOO + ooo000
  if 94 - 94: oOo0O00 / IIiIIiIi11I1 + IiI11Ii111 % Oo - I1Ii1I1
  if 62 - 62: ooo000 * I1Ii1I1 - i1i1i1111I - Ii
  if 81 - 81: I11iiIi11i1I - i1iiIII111 % iI1iII1I1I1i / Ooo0Ooo
  if 70 - 70: i1i1i1111I - ooo000
  if 68 - 68: ooo000 + I1Ii1I1 / IIiIIiIi11I1 . Ooo0Ooo * i1I
  if 27 - 27: iI1iII1I1I1i - i1iiIII111 + OooOoo + Iii1i * i1I % IIiIIiIi11I1
  if 23 - 23: Ooo0Ooo * i1iiIII111
  if 65 - 65: ooOOO % iI1iII1I1I1i - ooo000 % i1I
  if 14 - 14: Ii + oOO
  if 81 - 81: oOo0O00 / Oo
  if 4 - 4: OooOoo . i1i1i1111I . Ooo0Ooo / Ii * Ii
  if 44 - 44: I11iiIi11i1I - i1 % oOO * Ii + iI1iII1I1I1i / oOo0O00
  if 85 - 85: i1I
  if 88 - 88: oOO . OooOoo - Ii
  if 40 - 40: IiIIii11Ii - Iii1i % oOO % oOO
  if 23 - 23: Ooo0Ooo . Ii - IiI11Ii111
  if 55 - 55: IIiIIiIi11I1 - OooOoo % ooo000
  if 65 - 65: I1I
  self . trainName = trainName
  if 90 - 90: i1I * Oo + ooOOO - i1iiIII111
  self . trainTime = oo0OO00oOoo . getDateTimeStr ( timeExpr = "hhmmss" )
  if 60 - 60: IiIIii11Ii . iI1iII1I1I1i * OooOoo
  self . folder = folder if folder is not None else ""
  if 68 - 68: I1Ii1I1
  if 19 - 19: iI1iII1I1I1i + iI1iII1I1I1i % I11iiIi11i1I + iI1iII1I1I1i
  self . testDatasetType = I111II1II111I . Dataset . TestSource . Split
  if 49 - 49: IiI11Ii111 / ooOOO
  self . testRatio = 0.2
  if 100 - 100: ooOOO * IIiIIiIi11I1
  self . testShuffle = True
  if 39 - 39: oOO / OooOoo % i1I - I1I - i1i1i1111I
  self . restorePath = restorePath
  if 1 - 1: I1Ii1I1
  if 29 - 29: IiIIii11Ii / I1Ii1I1 + ooOOO
  if 80 - 80: IiI11Ii111 + ooo000 / i1I
  self . logFreq = math . inf if logFreq == - 1 else logFreq
  if 39 - 39: ooOOO % oOO - i1 / i1I
  self . saveFreq = saveFreq
  if 64 - 64: I1I . i1i1i1111I . IiI11Ii111 - i1 . oOO + oOO
  self . testFreq = math . inf if testFreq == - 1 else testFreq
  if 11 - 11: IiIIii11Ii - oOO % I11iiIi11i1I . oOo0O00
  self . testLogger = None
  if 59 - 59: IIiIIiIi11I1
  self . traceFreq = math . inf if traceFreq == - 1 else traceFreq
  if 10 - 10: I11iiIi11i1I
  self . visualTestFreq = math . inf if visualTestFreq == - 1 else visualTestFreq
  if 48 - 48: ooOOO + iI1iII1I1I1i . ooOOO
  self . weightLogFreq = math . inf if weightLogFreq == - 1 else weightLogFreq
  if 25 - 25: Ooo0Ooo % IiI11Ii111 - i1i1i1111I
  self . filterFreq = math . inf if filterFreq == - 1 else filterFreq
  if 72 - 72: ooo000 % i1
  self . _printTensors = [ ]
  if 99 - 99: ooOOO * ooo000 . iI1iII1I1I1i / ooo000 * OooOoo / ooo000
  if 64 - 64: IiI11Ii111 % Oo . ooo000 * i1i1i1111I - i1I % oOO
  if 31 - 31: i1i1i1111I . ooOOO - Iii1i . oOo0O00 * I1I / i1I
  self . device = device
  if 17 - 17: I11iiIi11i1I . I1Ii1I1 - Ooo0Ooo / IIiIIiIi11I1
  self . dppNodes = { }
  if 70 - 70: Iii1i - Iii1i % Ii . i1i1i1111I % ooo000
  self . modelNodes = { }
  self . visualData = None
  self . visualInput = None
  self . visualOutput = None
  if 100 - 100: Ooo0Ooo / Iii1i . I1Ii1I1 + i1I + oOO / I1I
  if 47 - 47: IiI11Ii111
  self . line_notify = None
  if 1 - 1: I1Ii1I1 % i1i1i1111I
  if 47 - 47: Ooo0Ooo * i1iiIII111 / Ii . i1 . I1Ii1I1
  if buildConfig is not None and ( ( O0oO ( buildConfig ) != "list" and ( not issubclass ( buildConfig . __class__ , iII11 . BuildConfig ) ) ) or ( O0oO ( buildConfig ) == "list" and any ( [ ( not issubclass ( tp . __class__ , iII11 . BuildConfig ) ) for tp in buildConfig ] ) ) ) :
   raise ValueError ( "`buildConfig` parameters should be a `Train.BuildConfig` object." )
  self . buildConfigs = [ buildConfig or iII11 . BuildConfig ( ) ] if O0oO ( buildConfig ) != "list" else buildConfig
  if 13 - 13: IiIIii11Ii * IIiIIiIi11I1 + I1I * IIiIIiIi11I1 / Ii % IIiIIiIi11I1
  if 7 - 7: ooOOO . I11iiIi11i1I + I1Ii1I1 / I1I
  if source is not None and ( ( O0oO ( source ) != "list" and ( not isinstance ( source , I1ii11II11 . Config ) ) ) or ( O0oO ( source ) == "list" and any ( [ ( not isinstance ( s , I1ii11II11 . Config ) ) for s in source ] ) ) ) :
   raise ValueError ( "`source` parameters should be a `Source.Config` object." )
   if 28 - 28: I1I . Iii1i % IiIIii11Ii % Ii
  self . sources = [ ]
  if isinstance ( source , list ) :
   self . setDataSources ( * source )
  elif source is not None :
   self . addDataSource ( source )
   if 91 - 91: IIiIIiIi11I1 . Iii1i . IiIIii11Ii . i1iiIII111 % i1iiIII111
  self . _rootSources = None
  if 79 - 79: i1I
  self . _sourceTensors = { }
  if 71 - 71: IIiIIiIi11I1 % I1I . iI1iII1I1I1i
  self . _editingBuild = 0
  if 21 - 21: ooOOO
  self . _evalSources = None
  if 2 - 2: IiI11Ii111 / IiI11Ii111 + Ooo0Ooo + ooo000 . oOo0O00
  self . _version = iII11 . Version
  if 15 - 15: i1 * iI1iII1I1I1i / i1iiIII111 * I1Ii1I1 + i1i1i1111I
  self . _oldVersion = 0
  if 47 - 47: I1Ii1I1 . iI1iII1I1I1i - Oo
  if 25 - 25: IIiIIiIi11I1 % i1I . ooOOO % IiI11Ii111
  if 41 - 41: I1I
  self . traceRecord = traceRecord
  if 35 - 35: i1
  self . traceItems = None
  if 5 - 5: I1I / oOO - I1I % IiI11Ii111
  if 26 - 26: ooo000 * i1 * ooOOO . ooo000 + i1i1i1111I
  if 48 - 48: ooo000 * IIiIIiIi11I1 / Ii
  self . visualRecord = visualRecord
  if 22 - 22: Ii - i1iiIII111 / I11iiIi11i1I / Oo
  self . visualItems = None
  if 45 - 45: i1I % iI1iII1I1I1i
  if 55 - 55: I11iiIi11i1I
  if runCount is not None and runCount <= 0 :
   raise ValueError ( "The given value of runCount is inappropriate." )
   if 36 - 36: ooo000 + I1Ii1I1 . i1iiIII111 - Iii1i
  self . runCount = runCount if runCount is not None else 1
  if 44 - 44: I1I
  self . _graph = None
  if 54 - 54: IiI11Ii111
  self . _sess = None
  if 25 - 25: I1Ii1I1 . Ii / IIiIIiIi11I1 . Ooo0Ooo
  self . _built = False
  if 47 - 47: Oo
  self . _buildNo = - 1
  if 23 - 23: Ii * iI1iII1I1I1i * iI1iII1I1I1i * i1i1i1111I / OooOoo
  self . _runNo = - 1
  if 11 - 11: IIiIIiIi11I1 / Ooo0Ooo
  self . _cvNo = - 1
  if 36 - 36: i1i1i1111I + I1Ii1I1
  self . _currentSourceDataset = I111II1II111I . Dataset . Types . Train
  if 40 - 40: iI1iII1I1I1i - i1
  self . localStep = 0
  if 73 - 73: ooOOO
  self . globalStep = 0
  if 15 - 15: Oo * I1Ii1I1
  self . localStepTensor = 0
  if 18 - 18: ooo000 + IIiIIiIi11I1 . ooo000 + IiI11Ii111 * Ooo0Ooo * IIiIIiIi11I1
  self . globalStepTensor = 0
  if 12 - 12: I1I . i1iiIII111 * i1I - Ooo0Ooo
  self . _bnTensor = None
  if 52 - 52: i1iiIII111
  self . _layerIDInc = 0
  if 38 - 38: I1Ii1I1 / oOO % Oo + oOo0O00
  self . _version = 190400
  if 100 - 100: I1Ii1I1
  self . _eventFtns = { eType : [ ] for eType in [ "buildstart" , "buildend" , "stepprepare" , "stepstart" , "stepend" , "epochstart" , "epochend" , "trainbuild" , "trainstart" , "trainend" ] }
  if 78 - 78: iI1iII1I1I1i / ooo000 + iI1iII1I1I1i + i1i1i1111I . IiI11Ii111 % IiIIii11Ii
  self . userConfigs = None
 def assignCurrentSourceDataset ( self , v : 'DataGenerator.Dataset.Types' ) :
  if 69 - 69: i1I * i1i1i1111I . I1I / IiIIii11Ii
  if 82 - 82: ooo000
  if 61 - 61: ooo000 * I1Ii1I1 + IiIIii11Ii / i1i1i1111I % I1I
  if 92 - 92: iI1iII1I1I1i - IIiIIiIi11I1 % IIiIIiIi11I1
  if 10 - 10: iI1iII1I1I1i / IIiIIiIi11I1 % i1
  if 7 - 7: i1iiIII111 . ooOOO - Ooo0Ooo / IiI11Ii111
  if 87 - 87: I1I % oOo0O00 + I1I + ooo000
  if 94 - 94: Iii1i
  if 41 - 41: I1I
  if 70 - 70: Iii1i
  self . _currentSourceDataset = v
  self . rootSources . sourceDataset = v
  if 14 - 14: IiIIii11Ii * ooo000 . i1
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  if 40 - 40: i1iiIII111
  if 45 - 45: OooOoo . oOo0O00 / I1Ii1I1
  if 24 - 24: Ooo0Ooo * I1Ii1I1 + IiI11Ii111 % Oo / Ooo0Ooo
  if 43 - 43: Ooo0Ooo
  if 3 - 3: iI1iII1I1I1i . i1i1i1111I + IiIIii11Ii
  if 1 - 1: i1 / i1I % oOo0O00 + I1Ii1I1
  if 70 - 70: I11iiIi11i1I + i1I / i1 * Iii1i
  if 88 - 88: OooOoo + Ii * i1i1i1111I - i1 . ooOOO . OooOoo
  if 16 - 16: ooo000
  if 45 - 45: Ii % i1
  if 77 - 77: i1iiIII111
  for Ii1I in Oooo0OooOOOo0 ( obj , [ "weightConfigs" , "_version" , "testDatasetType" , "buildConfigs" , "trainingProfiles" , "sources" , "dppNodes" , "modelNodes" , "userConfigs" ] ) :
   if Ii1I == "sources" :
    if 77 - 77: ooo000 % i1 . oOO
    self . sources = [ I1ii11II11 . createFromJSON ( sObj , self ) for sObj in obj [ Ii1I ] ]
    if 37 - 37: IIiIIiIi11I1 + Ii * i1iiIII111
    if 41 - 41: IiI11Ii111 * i1 * IiIIii11Ii * Ooo0Ooo . iI1iII1I1I1i
    if any ( [ "_testRatio" in sObj for sObj in obj [ Ii1I ] ] ) :
     for oOOOO in self . buildConfigs :
      oOOOO . batchSize = obj [ Ii1I ] [ 0 ] . batchSize
      oOOOO . shuffle = obj [ Ii1I ] [ 0 ] . shuffle
     self . testRatio = obj [ Ii1I ] [ 0 ] . _testRatio / 100
     self . testDatasetType = I111II1II111I . Dataset . TestSource . Split if all ( [ sObj . splittable for sObj in obj [ Ii1I ] ] ) else I111II1II111I . Dataset . TestSource . Assign
     if 36 - 36: I1I - ooOOO * I1I * oOo0O00 / IiI11Ii111
   elif Ii1I == "trainingProfiles" or Ii1I == "buildConfigs" :
    if 24 - 24: oOO / IiI11Ii111 % IiIIii11Ii / Iii1i . Iii1i * Iii1i
    if 39 - 39: Ooo0Ooo / iI1iII1I1I1i * ooOOO . i1iiIII111
    self . buildConfigs = [ iII11 . BuildConfig . createFromJSON ( v ) for v in obj [ Ii1I ] ]
   elif Ii1I == "layerProfiles" or Ii1I == "modelNodes" :
    if 84 - 84: i1I % i1 - Ii / Ooo0Ooo
    for ( OOoo0oO0ooo , O00oo ) in obj [ Ii1I ] :
     oOOoooO = O00oOo0O . updateNodeName ( OOoo0oO0ooo )
     O00oOo0O . createFromJSON ( oOOoooO , O00oo , self )
     try :
      if self . modelNodes [ oOOoooO ] . _type == 'Group' :
       if self . modelNodes [ oOOoooO ] . refLayerName is None :
        I1II = [ ]
        II11II1 = { }
        for ( oo0oo00 , iiI11i ) in self . modelNodes [ oOOoooO ] . subModelNodes :
         oOooOo0O0oo0 = O00oOo0O . updateNodeName ( oo0oo00 )
         iII1ii = O00oOo0O . returnLayer ( oOooOo0O0oo0 , iiI11i , self )
         II11II1 [ oOooOo0O0oo0 ] = iII1ii
         I1II . append ( iII1ii )
         if 96 - 96: IIiIIiIi11I1 % Iii1i % i1 / ooOOO . IiI11Ii111 % IiIIii11Ii
        self . modelNodes [ oOOoooO ] . subModelNodes = I1II
        self . modelNodes [ oOOoooO ] . sub_layer_dict = II11II1
       else :
        II1III1ii = O00oOo0O . updateNodeName ( self . modelNodes [ oOOoooO ] . refLayerName )
        for ii1i1i11 in self . modelNodes . values ( ) :
         if ii1i1i11 . name == II1III1ii :
          II1III1ii = ii1i1i11 . key . replace ( ' ' , '' )
        self . modelNodes [ oOOoooO ] . subModelNodes = self . modelNodes [ II1III1ii ] . subModelNodes
        self . modelNodes [ oOOoooO ] . sub_layer_dict = self . modelNodes [ II1III1ii ] . sub_layer_dict
     except :
      pass
      if 85 - 85: I1Ii1I1 . i1
      if 44 - 44: IiIIii11Ii * Ii / i1i1i1111I % i1I . iI1iII1I1I1i
    for OOoO000OoO00 in self . modelNodes . values ( ) :
     if OOoO000OoO00 . type == "Group" :
      if OOoO000OoO00 . key . replace ( ' ' , '' ) in self . modelNodes . keys ( ) :
       self . modelNodes [ OOoO000OoO00 . name ] = self . modelNodes . pop ( OOoO000OoO00 . key . replace ( ' ' , '' ) )
       if 86 - 86: ooOOO * oOo0O00
       if 83 - 83: Ooo0Ooo
    for OOoO000OoO00 in self . modelNodes . values ( ) :
     try :
      OOoO000OoO00 . fromNode = OOoO000OoO00 . fromNodes
      OOoO000OoO00 . toNode = OOoO000OoO00 . toNodes
     except :
      pass
      if 62 - 62: i1I / I11iiIi11i1I * i1i1i1111I * IiI11Ii111 / Ii + i1iiIII111
     OOoO000OoO00 . toNode = ( [ [ self . modelNodes [ O00oOo0O . updateNodeName ( ln ) ] for ln in build ] for build in OOoO000OoO00 . toNode ] if isinstance ( OOoO000OoO00 . toNode [ 0 ] , list ) else [ [ self . modelNodes [ O00oOo0O . updateNodeName ( ln ) ] for ln in OOoO000OoO00 . toNode ] ] ) if len ( OOoO000OoO00 . toNode ) else [ [ ] ]
     OOoO000OoO00 . fromNode = ( [ [ self . modelNodes [ O00oOo0O . updateNodeName ( ln ) ] for ln in build ] for build in OOoO000OoO00 . fromNode ] if isinstance ( OOoO000OoO00 . fromNode [ 0 ] , list ) else [ [ self . modelNodes [ O00oOo0O . updateNodeName ( ln ) ] for ln in OOoO000OoO00 . fromNode ] ] ) if len ( OOoO000OoO00 . fromNode ) else [ [ ] ]
     if isinstance ( OOoO000OoO00 . fromSource , list ) :
      if any ( [ ( isinstance ( build , list ) and any ( [ not isinstance ( ele , list ) for ele in build ] ) and any ( [ ( not isinstance ( ele , str ) ) for ele in build ] ) ) for build in OOoO000OoO00 . fromSource ] ) :
       if 30 - 30: I1Ii1I1 - i1iiIII111 / iI1iII1I1I1i
       OOoO000OoO00 . fromSource = [ [ ooOO00o for ( sourceID , ooOO00o ) in OOoO000OoO00 . fromSource ] ]
      elif any ( [ ( isinstance ( build , list ) and any ( [ isinstance ( ele , list ) for ele in build ] ) ) for build in OOoO000OoO00 . fromSource ] ) :
       if 37 - 37: ooo000 / iI1iII1I1I1i
       OOoO000OoO00 . fromSource = [ [ ooOO00o for ( sourceID , ooOO00o ) in build ] for build in OOoO000OoO00 . fromSource ]
     else :
      OOoO000OoO00 . fromSource = [ [ ] ]
      if 47 - 47: I11iiIi11i1I * Iii1i * i1iiIII111 + Ii / ooOOO * Oo
      if 75 - 75: IIiIIiIi11I1 % iI1iII1I1I1i + Iii1i - Oo
     if isinstance ( OOoO000OoO00 , oOOoo . Config ) :
      if 10 - 10: I11iiIi11i1I . OooOoo + i1i1i1111I % oOo0O00 % i1iiIII111 - IiI11Ii111
      if OOoO000OoO00 . incomingConfig . coreNode :
       OOoO000OoO00 . incomingConfig . coreNode = self . modelNodes [ O00oOo0O . updateNodeName ( OOoO000OoO00 . incomingConfig . coreNode ) ]
       if 40 - 40: OooOoo
       if 94 - 94: ooo000
      if isinstance ( OOoO000OoO00 . incomingConfig , oOOoo . Incoming . ElementWiseConfig ) and OOoO000OoO00 . incomingConfig . transformGate :
       OOoO000OoO00 . incomingConfig . transformGate = self . modelNodes [ OOoO000OoO00 . incomingConfig . transformGate ]
       if 10 - 10: i1 * IIiIIiIi11I1 * Iii1i
   elif Ii1I == "dppNodes" :
    if 74 - 74: I1Ii1I1
    self . dppNodes . clear ( )
    if 48 - 48: IiIIii11Ii % i1iiIII111 / Ooo0Ooo % I1I
    if 87 - 87: IIiIIiIi11I1
    oOOo0O0o = obj [ "dppNodes" ]
    oOOo0O0o . sort ( key = lambda I1i1I1iIi : I1i1I1iIi [ 1 ] [ "_order" ] )
    if 51 - 51: IiI11Ii111 + Ii . i1
    for ( ooOO00o , I1 ) in oOOo0O0o :
     if 71 - 71: Ii . IiI11Ii111 - ooOOO + iI1iII1I1I1i - IiI11Ii111
     self . dppNodes [ ooOO00o ] = OO0O0 . createFromJSON ( I1 , self )
     if 47 - 47: Ooo0Ooo % oOo0O00 . iI1iII1I1I1i - i1i1i1111I % oOo0O00 * Ooo0Ooo
   elif Ii1I == "_version" :
    if 99 - 99: Iii1i % i1 / Iii1i / I1Ii1I1 + IIiIIiIi11I1 . i1I
    self . _oldVersion = obj [ Ii1I ]
    if 100 - 100: oOO * OooOoo / OooOoo
   elif Ii1I in [ "logFreq" , "testFreq" , "traceFreq" , "visualTestFreq" , "weightLogFreq" , "filterFreq" ] :
    setattr ( self , Ii1I , math . inf if obj [ Ii1I ] == - 1 else obj [ Ii1I ] )
    if 2 - 2: IIiIIiIi11I1 * oOo0O00 - OooOoo % i1i1i1111I
   elif Ii1I == "testDatasetType" :
    setattr ( self , Ii1I , I111II1II111I . Dataset . TestSource . parse ( obj [ Ii1I ] ) )
    if 87 - 87: IIiIIiIi11I1 + Ii
   elif Ii1I == "weightConfigs" :
    setattr ( self , Ii1I , ooOO0Oo0o . createFromJSON ( obj [ Ii1I ] ) )
    if 21 - 21: oOO + Oo . oOo0O00 - oOO
   elif Ii1I == "userConfigs" :
    setattr ( self , Ii1I , oO0Oo000oO . createFromJSON ( obj [ Ii1I ] ) )
    if 60 - 60: ooOOO / Oo % Ooo0Ooo % oOO - oOo0O00
   elif Ii1I not in [ "_project" , "testSources" , "_editingProfile" , "_editingSource" , "_editingDppNode" , "traceItems" , "visualItems" , "_editingModelNode" , "_layerIDInc" , "_buildNo" , "_runNo" , "_cvNo" , "_localStep" , "_globalStep" , "_rootSources" , "_currentSourceDataset" ] :
    if not hasattr ( self , Ii1I ) :
     print ( Ii1I )
    setattr ( self , Ii1I , obj [ Ii1I ] )
    if 92 - 92: OooOoo % i1
 @ property
 def currentSourceDataset ( self ) :
  if 73 - 73: I1Ii1I1
  if 22 - 22: ooo000 + I1I
  if 8 - 8: IiIIii11Ii - IiIIii11Ii * IIiIIiIi11I1 % Iii1i % ooo000
  if 27 - 27: Ii * ooo000 * i1i1i1111I * i1 - I1I
  if 74 - 74: Oo
  if 74 - 74: I1I * I1Ii1I1 / I11iiIi11i1I + OooOoo * i1
  if 56 - 56: I1I % OooOoo . I11iiIi11i1I % i1I / I11iiIi11i1I
  if 32 - 32: Iii1i / ooOOO + I11iiIi11i1I . oOo0O00 / IIiIIiIi11I1 + oOo0O00
  if 33 - 33: oOO - Ooo0Ooo % i1 % I1Ii1I1 % i1I
  if 19 - 19: IIiIIiIi11I1 * I1I . ooOOO * I11iiIi11i1I
  return self . _currentSourceDataset
  if 71 - 71: oOo0O00
 @ property
 def currentBuildConfig ( self ) -> "Train.BuildConfig" :
  if 100 - 100: oOo0O00 * I1Ii1I1 + ooOOO / I1Ii1I1 * OooOoo
  if 96 - 96: i1I % I1I
  if 54 - 54: Iii1i . Ooo0Ooo / Iii1i % ooOOO
  if 92 - 92: Ii - i1iiIII111
  if 5 - 5: I1Ii1I1 - i1i1i1111I + Ooo0Ooo
  if 65 - 65: iI1iII1I1I1i + i1 * i1i1i1111I
  if 33 - 33: I1Ii1I1 % IIiIIiIi11I1 + Ii * Ooo0Ooo
  if 42 - 42: I1Ii1I1 / Iii1i . iI1iII1I1I1i / oOo0O00
  if 46 - 46: IiI11Ii111 . Oo
  if 99 - 99: i1I - oOO . i1i1i1111I
  return self . buildConfigs [ self . _buildNo ]
  if 45 - 45: IiI11Ii111 * i1I / Ii / I1Ii1I1 % I1Ii1I1
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'Train' :
  if 96 - 96: i1i1i1111I - I1Ii1I1 - ooOOO + OooOoo / OooOoo / i1
  if 48 - 48: I1Ii1I1 % i1I - ooo000 . Ii . I1I + I1I
  if 8 - 8: IiIIii11Ii . ooo000 + Ii / I1I / i1iiIII111 % Ii
  if 76 - 76: i1I / i1i1i1111I . i1iiIII111 . Ooo0Ooo % iI1iII1I1I1i
  if 69 - 69: Ooo0Ooo . i1iiIII111 / i1I / I11iiIi11i1I . iI1iII1I1I1i
  if 90 - 90: ooOOO / OooOoo / I1I . IIiIIiIi11I1
  if 64 - 64: i1
  if 19 - 19: i1i1i1111I + Iii1i - IIiIIiIi11I1 * Ooo0Ooo * iI1iII1I1I1i
  if 91 - 91: i1I + IIiIIiIi11I1 + Iii1i - oOo0O00
  if 68 - 68: I1Ii1I1 / IiIIii11Ii . Ooo0Ooo * OooOoo / i1 * iI1iII1I1I1i
  if 32 - 32: i1i1i1111I % ooo000 / OooOoo - IiI11Ii111 - IIiIIiIi11I1 . I1Ii1I1
  if 49 - 49: Ii . Ooo0Ooo
  if 65 - 65: i1iiIII111
  if 96 - 96: oOo0O00 + ooOOO * ooOOO
  o0000oO0OOO0 = iII11 ( )
  o0000oO0OOO0 . parseJSON ( obj )
  return o0000oO0OOO0
  if 30 - 30: oOO
 @ staticmethod
 def createFromJSONString ( jsonString : str ) -> 'Train' :
  if 76 - 76: OooOoo . Oo + IiIIii11Ii - Ooo0Ooo
  if 45 - 45: ooOOO + ooOOO
  if 6 - 6: I1I / Oo . I1Ii1I1 / IIiIIiIi11I1 * Iii1i
  if 65 - 65: I1I % Ii . i1i1i1111I - OooOoo + oOo0O00 + iI1iII1I1I1i
  if 51 - 51: iI1iII1I1I1i
  if 60 - 60: ooOOO
  if 41 - 41: IiIIii11Ii - I1Ii1I1 % ooOOO + Ii - OooOoo
  if 52 - 52: i1I
  if 98 - 98: ooOOO . I11iiIi11i1I
  if 22 - 22: I1I
  if 27 - 27: Iii1i - oOo0O00 % IIiIIiIi11I1
  if 36 - 36: oOo0O00 / Oo % oOO % ooOOO - iI1iII1I1I1i
  if 36 - 36: i1I + Ooo0Ooo / iI1iII1I1I1i * Oo
  if 83 - 83: IiI11Ii111 / Ii
  return iII11 . createFromJSON ( json . loads ( jsonString ) )
  if 68 - 68: oOO * ooOOO * IiIIii11Ii . i1i1i1111I - I11iiIi11i1I
 @ property
 def version ( self ) -> int :
  if 29 - 29: oOo0O00 / i1i1i1111I . Ii
  if 100 - 100: I11iiIi11i1I % oOO % I1Ii1I1
  if 66 - 66: OooOoo - oOO + Ooo0Ooo . IiIIii11Ii * ooo000
  if 85 - 85: Ooo0Ooo - oOo0O00 % Iii1i * i1I
  if 29 - 29: i1i1i1111I . I1Ii1I1 * Ooo0Ooo - Oo . I11iiIi11i1I
  if 28 - 28: Ii + I1I % I1Ii1I1
  if 46 - 46: oOo0O00
  if 47 - 47: Iii1i * Ii / Iii1i % IiIIii11Ii * I1Ii1I1 + ooOOO
  if 31 - 31: Iii1i
  if 59 - 59: Oo
  return self . _version
  if 34 - 34: OooOoo . iI1iII1I1I1i * Iii1i % i1I * I1Ii1I1 - I11iiIi11i1I
 @ property
 def oldVersion ( self ) -> int :
  if 13 - 13: IiI11Ii111
  if 7 - 7: Iii1i / I1Ii1I1 / I1I - Ii
  if 56 - 56: ooOOO + i1
  if 55 - 55: i1I % Ii
  if 25 - 25: oOo0O00 % Oo % i1i1i1111I . i1I / Ooo0Ooo - ooOOO
  if 1 - 1: Ii / i1iiIII111 * i1iiIII111 . oOO
  if 48 - 48: i1i1i1111I / i1iiIII111
  if 37 - 37: i1I
  if 33 - 33: oOO - i1i1i1111I % I1I
  if 5 - 5: Iii1i
  return self . _oldVersion
  if 6 - 6: Ii / Ooo0Ooo % IiI11Ii111 % i1I * Ii
 @ property
 def editingBuild ( self ) -> int :
  if 31 - 31: iI1iII1I1I1i / I1I . Ooo0Ooo * i1i1i1111I
  if 56 - 56: i1 / i1iiIII111
  if 74 - 74: ooo000 - OooOoo
  if 74 - 74: IiI11Ii111 % oOO
  if 64 - 64: oOO . OooOoo . Ii
  if 66 - 66: I1Ii1I1 * oOo0O00 + i1iiIII111
  if 55 - 55: iI1iII1I1I1i + IiI11Ii111 % IIiIIiIi11I1 . iI1iII1I1I1i / I11iiIi11i1I
  if 91 - 91: I1Ii1I1
  if 100 - 100: I1Ii1I1 - i1i1i1111I + I11iiIi11i1I % iI1iII1I1I1i * ooo000 + OooOoo
  if 100 - 100: Ooo0Ooo + IIiIIiIi11I1
  return self . _editingBuild
  if 32 - 32: i1i1i1111I / OooOoo + ooo000
 @ property
 def rootSources ( self ) -> 'Train.RootSources' :
  if 62 - 62: I11iiIi11i1I + iI1iII1I1I1i * i1i1i1111I . Iii1i
  if 41 - 41: i1 - I11iiIi11i1I . IiIIii11Ii * oOO
  if 22 - 22: Ii / IiIIii11Ii + I11iiIi11i1I
  if 11 - 11: I1I - OooOoo % oOo0O00 + ooo000 / IiIIii11Ii
  if 73 - 73: Oo + IIiIIiIi11I1 . ooo000 + OooOoo
  if 51 - 51: OooOoo / oOO - OooOoo + IiI11Ii111 . OooOoo
  if 23 - 23: i1 . Ii - IIiIIiIi11I1 + IiI11Ii111 * IiI11Ii111 - I1Ii1I1
  if 62 - 62: OooOoo
  if 30 - 30: OooOoo * i1iiIII111 % ooOOO / I1I
  if 100 - 100: OooOoo / Iii1i * iI1iII1I1I1i + i1 - ooOOO % ooOOO
  return self . _rootSources
  if 48 - 48: oOO / ooo000 / I11iiIi11i1I . Ooo0Ooo
 @ property
 def layerProfiles ( self ) -> Dict [ str , 'ModelNode.Config' ] :
  if 61 - 61: IIiIIiIi11I1 - I1Ii1I1 % OooOoo - i1I + i1I
  if 65 - 65: oOO % Iii1i - i1i1i1111I
  if 64 - 64: IiIIii11Ii + OooOoo - Oo / iI1iII1I1I1i
  if 10 - 10: IIiIIiIi11I1 - Oo + oOO
  if 70 - 70: i1iiIII111
  if 4 - 4: I1I % IiI11Ii111 % Oo
  if 36 - 36: Oo / I11iiIi11i1I * oOo0O00 % Oo
  if 62 - 62: IIiIIiIi11I1 + I11iiIi11i1I + Oo . ooo000 % i1
  if 55 - 55: Iii1i * ooo000 - i1I - I1I % Ooo0Ooo
  if 15 - 15: I1I * IIiIIiIi11I1 / oOo0O00 . IiIIii11Ii
  print ( "Using Deprecated API: Train.layerProfiles ." )
  return self . modelNodes
  if 70 - 70: i1I / oOO . iI1iII1I1I1i * OooOoo / i1i1i1111I + ooOOO
 def __repr__ ( self ) :
  if 42 - 42: Iii1i - Ii - iI1iII1I1I1i
  if 56 - 56: IiI11Ii111 * i1 . IIiIIiIi11I1
  if 73 - 73: I11iiIi11i1I
  if 78 - 78: IiI11Ii111 + IIiIIiIi11I1 % Ii
  if 59 - 59: oOo0O00
  if 99 - 99: ooOOO * I1Ii1I1 % Oo
  if 31 - 31: oOo0O00 * i1I * IIiIIiIi11I1
  if 100 - 100: i1I + i1I * IiIIii11Ii / I11iiIi11i1I / i1I + Ooo0Ooo
  if 98 - 98: I1Ii1I1
  if 99 - 99: i1iiIII111 * i1iiIII111 + IiI11Ii111 * I1Ii1I1 / oOo0O00 . ooo000
  return "<Train: name: \"" + self . trainName + "\", run times: " + self . runCount + ", no. of layers: " + str ( self . size ) + ">"
  if 26 - 26: OooOoo * IIiIIiIi11I1 % Oo % Ooo0Ooo . i1iiIII111 / IiI11Ii111
 def __len__ ( self ) :
  if 70 - 70: i1I / I1I . Ii + i1 % I1I / OooOoo
  if 30 - 30: i1I + Ooo0Ooo . ooo000 * Oo * iI1iII1I1I1i . oOo0O00
  if 50 - 50: I1I + IiI11Ii111 % OooOoo
  if 2 - 2: i1i1i1111I . ooOOO . oOO * ooo000
  if 42 - 42: I1Ii1I1 % i1iiIII111 % oOO - IIiIIiIi11I1
  if 62 - 62: Iii1i + Oo - I11iiIi11i1I
  if 10 - 10: I1Ii1I1 . i1iiIII111 + Ii * oOo0O00 % I1Ii1I1 / I1I
  return len ( self . buildConfigs ) * self . runCount
  if 38 - 38: iI1iII1I1I1i % IIiIIiIi11I1 / IiIIii11Ii
 @ staticmethod
 def optimizers ( string ) :
  if 83 - 83: Ooo0Ooo + Ii - IIiIIiIi11I1
  if 8 - 8: Ooo0Ooo . IIiIIiIi11I1 . oOO . ooOOO * Ooo0Ooo
  if 4 - 4: IiIIii11Ii + IIiIIiIi11I1 - oOO + i1I . oOo0O00
  if 70 - 70: Iii1i * i1i1i1111I
  if 26 - 26: i1iiIII111 % i1I
  if 6 - 6: i1iiIII111 * i1i1i1111I + oOO . I1I
  if 20 - 20: Iii1i . OooOoo * ooOOO
  if 55 - 55: ooo000 . oOo0O00 / IiI11Ii111
  if 68 - 68: IiI11Ii111 * ooOOO . IiI11Ii111 . OooOoo . i1i1i1111I + Oo
  if 73 - 73: OooOoo
  return { "rmsprop" : tf . compat . v1 . train . RMSPropOptimizer , "adam" : tf . compat . v1 . train . AdamOptimizer ,
 "grad" : tf . compat . v1 . train . GradientDescentOptimizer , "momentum" : tf . compat . v1 . train . MomentumOptimizer ,
 "adagrad" : tf . compat . v1 . train . AdagradOptimizer , "ftrl" : tf . compat . v1 . train . FtrlOptimizer ,
 "nadam" : tf . compat . v1 . keras . optimizers . Nadam , "adamax" : tf . compat . v1 . keras . optimizers . Adamax ,
 "adadelta" : tf . compat . v1 . train . AdadeltaOptimizer , "sgd" : tf . compat . v1 . keras . optimizers . SGD } [ string . lower ( ) ]
  if 38 - 38: I1I . i1i1i1111I - Ooo0Ooo
 @ property
 def buildNo ( self ) :
  if 60 - 60: I11iiIi11i1I - IIiIIiIi11I1
  if 61 - 61: IIiIIiIi11I1 . oOO
  if 32 - 32: oOo0O00 / I1I % Ooo0Ooo + Oo . Oo - iI1iII1I1I1i
  if 29 - 29: I11iiIi11i1I * iI1iII1I1I1i
  if 89 - 89: i1I
  if 16 - 16: I11iiIi11i1I / oOO - I1I / Ooo0Ooo / I11iiIi11i1I
  if 61 - 61: I1I - iI1iII1I1I1i - Ii / Ii - I1I * ooo000
  if 90 - 90: IIiIIiIi11I1
  if 73 - 73: Ooo0Ooo % Iii1i
  if 88 - 88: iI1iII1I1I1i - OooOoo / IIiIIiIi11I1
  return self . _buildNo
  if 91 - 91: I11iiIi11i1I / I11iiIi11i1I * OooOoo
 @ property
 def size ( self ) :
  if 99 - 99: i1I
  if 45 - 45: IiI11Ii111
  if 60 - 60: IiI11Ii111 % Iii1i * i1iiIII111
  if 65 - 65: i1I
  if 72 - 72: Ii - iI1iII1I1I1i * i1i1i1111I % i1i1i1111I % IiIIii11Ii * I11iiIi11i1I
  if 71 - 71: IiIIii11Ii + I1Ii1I1
  if 34 - 34: Ooo0Ooo + IIiIIiIi11I1 - i1iiIII111
  if 20 - 20: Iii1i
  if 68 - 68: i1I . Oo
  if 37 - 37: oOO * Iii1i
  return len ( self . modelNodes )
  if 23 - 23: oOO
 @ property
 def length ( self ) :
  if 79 - 79: Oo - Oo % i1I * Oo
  if 53 - 53: i1I
  if 15 - 15: oOO - i1I
  if 57 - 57: i1I / i1iiIII111 * I1I
  if 17 - 17: Iii1i - oOO
  if 56 - 56: I1Ii1I1 % i1i1i1111I - I1I
  if 92 - 92: IIiIIiIi11I1 - Ooo0Ooo
  return len ( self )
  if 75 - 75: i1I . IiI11Ii111 + Oo
 def getNewLayerID ( self ) :
  if 74 - 74: Ooo0Ooo % oOo0O00 * I11iiIi11i1I * IiI11Ii111 . Oo
  if 82 - 82: IIiIIiIi11I1 % I11iiIi11i1I - i1i1i1111I
  if 93 - 93: IiIIii11Ii - IiI11Ii111 % iI1iII1I1I1i
  if 98 - 98: IiIIii11Ii - Ii
  if 59 - 59: Iii1i
  if 62 - 62: I1Ii1I1 % Oo % IIiIIiIi11I1 % IiI11Ii111 + OooOoo % I1I
  if 94 - 94: ooOOO
  if 53 - 53: oOO * Ooo0Ooo % I1I
  if 74 - 74: I1Ii1I1 . oOo0O00
  if 70 - 70: Iii1i * IiI11Ii111 * I1Ii1I1 - Ii
  if 99 - 99: oOO % i1i1i1111I * oOo0O00 * iI1iII1I1I1i
  o0oOo00O00o0 = self . _layerIDInc
  self . _layerIDInc += 1
  if 14 - 14: i1i1i1111I - I11iiIi11i1I
  if 86 - 86: iI1iII1I1I1i
  return o0oOo00O00o0
  if 73 - 73: Ii
 def dispatchEvent ( self , event ) :
  if 57 - 57: I11iiIi11i1I + Oo + Ii * i1i1i1111I
  if 58 - 58: Oo + iI1iII1I1I1i - oOO - oOo0O00 / ooo000 / IiI11Ii111
  if 93 - 93: i1 . i1I + i1i1i1111I . i1i1i1111I . i1i1i1111I + i1iiIII111
  if 22 - 22: i1
  if 66 - 66: i1I / Ooo0Ooo / iI1iII1I1I1i + ooo000 . OooOoo
  if 10 - 10: ooOOO . oOo0O00
  if 8 - 8: oOO % iI1iII1I1I1i * oOo0O00
  if 51 - 51: Oo - i1iiIII111 . IiI11Ii111 % I1Ii1I1 . i1
  if 63 - 63: IIiIIiIi11I1 - IIiIIiIi11I1 / Ii * i1iiIII111
  if 59 - 59: Ooo0Ooo * i1iiIII111 + OooOoo * i1iiIII111 . ooOOO
  for II111i in self . _eventFtns [ event . type ] :
   II111i ( event )
   if 55 - 55: Ooo0Ooo - Ii + IiIIii11Ii
 @ staticmethod
 def createVar ( name : str , shape : List [ int ] , initializer : 'Train.Variable.Initializer.Config|tf.initializers' , device : str = None , dtype : 'tf.DType' = tf . float32 , l1loss : bool = False , l2loss : bool = False , weightDecayRate : float = None ) :
  if 79 - 79: oOo0O00
  if 34 - 34: oOO
  if 32 - 32: ooo000 * i1I
  if 19 - 19: i1iiIII111
  if 87 - 87: Ii - ooo000
  if 39 - 39: Oo * OooOoo - I1Ii1I1
  if 2 - 2: ooo000 + oOO
  if 82 - 82: I11iiIi11i1I / i1I * i1iiIII111
  if 33 - 33: i1i1i1111I - ooo000 * ooOOO . I11iiIi11i1I
  if 4 - 4: i1 - oOO + I11iiIi11i1I
  if 34 - 34: ooOOO + Oo % OooOoo
  if 40 - 40: i1iiIII111 . Ii - oOO % OooOoo
  if 61 - 61: Iii1i % I11iiIi11i1I
  if 73 - 73: Iii1i % I1I
  if 16 - 16: Oo % IiIIii11Ii / oOO + Oo * Iii1i
  if 88 - 88: i1I / i1I . I11iiIi11i1I % i1 . IiIIii11Ii / oOo0O00
  if 22 - 22: oOo0O00 - ooOOO * IiI11Ii111 + IIiIIiIi11I1 + ooo000
  ooO0OO = iII11 . Variable . Config ( l1Loss = l1loss , l2Loss = l2loss , l2Decay = weightDecayRate , initializer = initializer , device = device )
  return ooO0OO . create ( name , shape , dtype )
  if 79 - 79: iI1iII1I1I1i + Ii
 @ staticmethod
 def creatVarFromConfig ( name : str , shape : List [ int ] , dtype : 'tf.DType' = tf . float32 , config : 'Train.Variable.Config' = None ) :
  if 74 - 74: i1i1i1111I + ooOOO / iI1iII1I1I1i . IiI11Ii111
  if 40 - 40: i1iiIII111 + Ii
  if 76 - 76: i1 . Ii
  if 12 - 12: I1Ii1I1 + oOO / Iii1i + OooOoo * oOo0O00
  if 59 - 59: IiIIii11Ii
  if 22 - 22: i1 - ooo000 * I11iiIi11i1I - IIiIIiIi11I1
  if 4 - 4: i1I % oOo0O00 . Ii + I1I % IiI11Ii111
  if 33 - 33: Ii / Ooo0Ooo - IiIIii11Ii % I1I
  if 52 - 52: OooOoo % I1Ii1I1 / i1I % I11iiIi11i1I * iI1iII1I1I1i
  if 67 - 67: ooo000 / i1I
  if 62 - 62: i1
  if 52 - 52: I11iiIi11i1I + i1i1i1111I % IiIIii11Ii / I1Ii1I1
  if 71 - 71: IiI11Ii111 + IIiIIiIi11I1 . IiIIii11Ii - IiIIii11Ii % i1I + Ii
  return config . create ( name , shape , dtype )
  if 8 - 8: I1I + I11iiIi11i1I % IiI11Ii111 + Iii1i - oOo0O00
 @ staticmethod
 def createNormDistVar ( name , shape , mean = 0 , stdDev = 5e-2 , l1loss = False , l2loss = False , weightDecayRate = None , dtype = tf . float32 ) :
  if 61 - 61: i1
  if 93 - 93: i1iiIII111 . i1I / ooOOO
  if 9 - 9: oOo0O00 . oOO + I1Ii1I1 % iI1iII1I1I1i % Iii1i
  if 83 - 83: Ii / oOO - I11iiIi11i1I . I1I - ooo000
  if 55 - 55: Oo * i1
  if 91 - 91: i1
  if 6 - 6: Ooo0Ooo . IiIIii11Ii % i1i1i1111I / IiIIii11Ii
  if 51 - 51: IiIIii11Ii . i1I - IIiIIiIi11I1 % i1iiIII111 / OooOoo * Ooo0Ooo
  if 73 - 73: i1I
  if 6 - 6: oOo0O00
  if 65 - 65: IIiIIiIi11I1 * oOo0O00 + ooOOO % Oo . i1I
  if 74 - 74: i1iiIII111 - i1 - i1
  if 66 - 66: i1 % I1Ii1I1 / IiIIii11Ii / ooo000
  if 79 - 79: Ii . Oo - IIiIIiIi11I1 . Ooo0Ooo / ooOOO
  if 48 - 48: IiI11Ii111 / Oo / OooOoo / i1i1i1111I
  if 8 - 8: oOo0O00 % iI1iII1I1I1i / ooo000 % OooOoo
  if 57 - 57: ooOOO
  if 53 - 53: IIiIIiIi11I1 % OooOoo % iI1iII1I1I1i
  return iII11 . createVar ( name , shape , iII11 . Variable . Initializer . TruncatedNormal ( mean = mean , stddev = stdDev ) , l1loss = l1loss , l2loss = l2loss , weightDecayRate = weightDecayRate , dtype = dtype )
  if 84 - 84: i1 - oOO + Ooo0Ooo * oOO + I1Ii1I1
 def setSequentialTraining ( self , * buildConfigs : 'Train.BuildConfig' ) :
  if 27 - 27: I1I - Ooo0Ooo . iI1iII1I1I1i / iI1iII1I1I1i - I11iiIi11i1I * IiI11Ii111
  if 24 - 24: oOO / Oo % IiI11Ii111 / i1iiIII111 % ooo000
  if 18 - 18: i1i1i1111I . ooo000
  if 48 - 48: IiIIii11Ii % OooOoo . Ooo0Ooo / IIiIIiIi11I1
  if 73 - 73: i1I * i1i1i1111I % i1I - i1i1i1111I
  if 100 - 100: ooOOO * IiI11Ii111 - oOO + IIiIIiIi11I1
  if 13 - 13: I1Ii1I1
  if 42 - 42: i1 - oOO * OooOoo - iI1iII1I1I1i
  if 63 - 63: IiIIii11Ii / Ooo0Ooo - i1iiIII111
  if 79 - 79: Ooo0Ooo % OooOoo
  if 11 - 11: i1iiIII111 / OooOoo % ooOOO * i1i1i1111I % ooo000
  if self . _built :
   raise ValueError ( "Training Profile cannot be modified during training processes. Please consider to close this training before update the training profile." )
   if 88 - 88: ooo000
   if 12 - 12: ooo000 / I11iiIi11i1I - I11iiIi11i1I . i1 / I1Ii1I1 % ooOOO
  if any ( [ ( buildConfig is not None and ( ( O0oO ( buildConfig ) != "list" and ( not issubclass ( buildConfig . __class__ , iII11 . BuildConfig ) ) ) or ( O0oO ( buildConfig ) == "list" and any ( [ ( not issubclass ( tp . __class__ , iII11 . BuildConfig ) ) for tp in buildConfig ] ) ) ) ) for buildConfig in buildConfigs ] ) :
   raise ValueError ( "`buildConfig` parameters should be a `Train.BuildConfig` object." )
   if 46 - 46: oOo0O00 - I1Ii1I1 % I1Ii1I1 * IiI11Ii111
   if 23 - 23: ooo000
  self . buildConfigs = buildConfigs
  if 57 - 57: oOO / IIiIIiIi11I1 + IiIIii11Ii / oOo0O00 % Ii
 def __next__ ( self ) :
  if 41 - 41: oOO % Ooo0Ooo
  if 99 - 99: i1iiIII111 + Iii1i . ooo000
  if 13 - 13: Ooo0Ooo
  if 31 - 31: oOo0O00 % ooOOO * oOo0O00 % i1 . Iii1i
  if 23 - 23: I1I % OooOoo - Ooo0Ooo
  if 13 - 13: oOO * I11iiIi11i1I
  if 18 - 18: i1iiIII111 - I1I
  if 22 - 22: Ooo0Ooo * I1Ii1I1 * i1i1i1111I - Ii / Ooo0Ooo + i1I
  if 7 - 7: iI1iII1I1I1i * oOo0O00 - ooo000 - iI1iII1I1I1i * I1Ii1I1 / oOo0O00
  if 45 - 45: oOo0O00 % Ooo0Ooo - I1I
  if 3 - 3: I11iiIi11i1I + Ii / i1i1i1111I * OooOoo / i1i1i1111I
  iiI1iIi = next ( self . rootSources )
  if 35 - 35: I1I * i1
  if 34 - 34: i1 * IIiIIiIi11I1 * IiIIii11Ii
  return { dppKey : dppNode . getProcessedData ( iiI1iIi ) for dppKey , dppNode in self . dppNodes . items ( ) }
  if 2 - 2: Oo * IiI11Ii111
 def _build ( self , buildNo : int = 0 ) :
  if 1 - 1: ooOOO / ooOOO
  if 13 - 13: OooOoo / I1Ii1I1
  if 34 - 34: IIiIIiIi11I1 + oOO - I1I / i1I - IIiIIiIi11I1 / Iii1i
  if 69 - 69: I11iiIi11i1I / OooOoo * oOO % oOO
  if 45 - 45: i1I + ooo000
  if 59 - 59: i1i1i1111I / Oo . I1Ii1I1 / oOO . i1iiIII111 . ooOOO
  if 20 - 20: IiIIii11Ii % Iii1i . IiI11Ii111 . Ooo0Ooo
  if 66 - 66: oOO - i1 - iI1iII1I1I1i
  if 97 - 97: i1i1i1111I - oOO - Oo
  if 40 - 40: iI1iII1I1I1i / IiIIii11Ii * iI1iII1I1I1i + Iii1i + oOo0O00 . Ii
  if 48 - 48: OooOoo * ooOOO + OooOoo / i1 - Ii + IiI11Ii111
  tf . compat . v1 . reset_default_graph ( )
  self . _graph = II1ii = tf . Graph ( )
  self . _buildNo = buildNo
  if 49 - 49: iI1iII1I1I1i . ooo000 - Iii1i / i1 * I1Ii1I1
  if 64 - 64: I11iiIi11i1I
  o0ooOO0o0O = IIoOOooOOo0oO ( "buildstart" , { "target" : self , "buildno" : self . _buildNo } )
  self . dispatchEvent ( o0ooOO0o0O )
  if 32 - 32: I1I - IiIIii11Ii * Ooo0Ooo + Oo / IiIIii11Ii
  if 41 - 41: I1I % oOo0O00 . I11iiIi11i1I . i1i1i1111I - IIiIIiIi11I1 . ooo000
  if not o0ooOO0o0O . defaultPrevented :
   with II1ii . as_default ( ) :
    if 60 - 60: Ii % IiI11Ii111
    self . globalStepTensor = o0oOoo = tf . compat . v1 . train . get_or_create_global_step ( )
    iIiiI1I1iIi1I = o0oOoo . assign ( self . globalStep )
    self . localStepTensor = tf . Variable ( self . localStep , trainable = False , dtype = tf . int64 )
    if 19 - 19: IIiIIiIi11I1 * IiIIii11Ii - i1i1i1111I
    if 28 - 28: I1Ii1I1 * oOo0O00 * oOo0O00 + IiI11Ii111 / i1
    self . _sourceTensors = { dppKey : dppNode . getTensor ( ) for dppKey , dppNode in self . dppNodes . items ( ) }
    if len ( self . _sourceTensors ) == 0 :
     raise ValueError ( "There is no training data sources." )
     if 33 - 33: Ooo0Ooo + Ooo0Ooo / Ooo0Ooo
     if 48 - 48: oOo0O00 + i1i1i1111I . I1Ii1I1 - Ii
    if len ( self . getFinalNodes ( buildNo = buildNo ) ) == 0 :
     if "target" in self . dppNodes :
      if 78 - 78: Iii1i + Ii / OooOoo
      OoOOO0 = self . _sourceTensors [ "target" ]
      if OoOOO0 . dtype in [ tf . int32 , tf . int64 ] :
       self . appendNode ( oOOoo . Task . Classifier ( lossDppKey = "target" ) , buildNo = buildNo )
      elif OoOOO0 . dtype in [ tf . float32 , tf . float64 ] :
       self . appendNode ( oOOoo . Task . Regressor ( lossDppKey = "target" ) , buildNo = buildNo )
      else :
       raise ValueError ( "The dtype of the target tensor (" + str ( OoOOO0 . dtype ) + ") is not supported for auto trainning task assignment." )
       if 3 - 3: IiI11Ii111 + OooOoo + Oo
     elif "input" in self . dppNodes :
      oOOoooo = self . _sourceTensors [ "input" ]
      if oOOoooo . dtype in [ tf . float32 , tf . float64 ] :
       self . appendNode ( oOOoo . Task . Regressor ( lossDppKey = "input" ) , buildNo = buildNo )
      else :
       raise ValueError ( "The dtype of the input tensor (" + str ( oOOoooo . dtype ) + ") is not supported for auto trainning task assignment." )
     else :
      raise ValueError ( "There is default input/target data preprocessing nodes for auto task assignment." )
      if 16 - 16: Iii1i . ooo000 * i1iiIII111 * I1I / i1i1i1111I / Oo
      if 30 - 30: Iii1i / oOo0O00
    self . _bnTensor = tf . compat . v1 . placeholder ( tf . bool )
    if 95 - 95: oOo0O00 + i1i1i1111I
    if 36 - 36: iI1iII1I1I1i . IIiIIiIi11I1 . I1Ii1I1 % I1I * i1
    for OOoo00ooOo00O in [ l for l in self . modelNodes . values ( ) if len ( l . fromSource [ buildNo ] ) > 0 and len ( l . fromNode [ buildNo ] ) == 0 ] :
     OOoo00ooOo00O . _build ( buildNo )
     if 84 - 84: i1 * i1I % IiIIii11Ii / IiIIii11Ii / oOO
     if 14 - 14: i1I . Iii1i / Ooo0Ooo / IiIIii11Ii
  self . _built = True
  if 72 - 72: Ii . IiIIii11Ii - OooOoo
  if 67 - 67: i1i1i1111I . Ooo0Ooo * ooo000 / Oo . IIiIIiIi11I1
  ii1i = IIoOOooOOo0oO ( "buildend" , { "target" : self , "buildno" : self . _buildNo } )
  self . dispatchEvent ( ii1i )
  if 26 - 26: Ooo0Ooo . oOO % IiIIii11Ii % Oo . I1I - OooOoo
 def _initTraceItems ( self , traceLogger , buildNo : int = 0 ) :
  if 60 - 60: IiIIii11Ii
  if 39 - 39: OooOoo % Ooo0Ooo - i1iiIII111 * ooo000 . I1I . IiIIii11Ii
  if 4 - 4: I11iiIi11i1I
  if 97 - 97: i1I - oOo0O00 - Ooo0Ooo + IiIIii11Ii / i1iiIII111 - I1I
  if 18 - 18: I1I . ooOOO % i1iiIII111 / Iii1i + iI1iII1I1I1i % ooOOO
  if 31 - 31: i1i1i1111I + oOO - I11iiIi11i1I
  if 96 - 96: Ii . i1i1i1111I - IiI11Ii111 * i1i1i1111I / iI1iII1I1I1i . Oo
  if 33 - 33: oOO . I1I / Ooo0Ooo % Ii * ooOOO
  if 20 - 20: i1i1i1111I . i1I * Iii1i . IiI11Ii111 - oOo0O00 + IIiIIiIi11I1
  if 31 - 31: Ii + i1i1i1111I - oOo0O00 - Oo % I11iiIi11i1I
  if 66 - 66: iI1iII1I1I1i % i1 + i1iiIII111 . iI1iII1I1I1i - I1Ii1I1
  if 26 - 26: OooOoo + I1I . IiI11Ii111 / Ii . ooo000
  if self . traceRecord > 0 and self . traceItems is None :
   OO0o0OO0O = self . rootSources . getRandItems ( self . traceRecord )
   self . traceItems_log = self . createUsingDataByShow ( OO0o0OO0O )
   self . traceItems = self . createUsingData ( OO0o0OO0O )
   if 45 - 45: Ii / i1I + OooOoo - i1i1i1111I
   if 89 - 89: ooOOO
  OO0o0oooO0o = 0
  ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
  for I1 in self . getDataPreprocessingNodesUsedByLayers ( buildNo = buildNo , inputOnly = True ) :
   traceLogger . log ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Input" , I1 . key , - 1 , "Table" , json . dumps ( I1 . getHeader ( step = OO0O0 . Columns . StepEnum . Input ) ) ] )
   traceLogger . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Input" , I1 . key , sii , * pi ] for sii , pi in enumerate ( I1 . getPrintableItems ( self . traceItems_log [ I1 . key ] , recovered = False ) ) ] )
  traceLogger . flush ( )
  if 41 - 41: IiI11Ii111 . I1I
  if 39 - 39: oOo0O00 - IIiIIiIi11I1 * ooo000 * IiI11Ii111 * ooo000
  for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
   IiIii1iI1I11i = oO0OOOOOOoo . getTraceTarget ( )
   traceLogger . log ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Target" , oO0OOOOOOoo . lossDppKey , - 1 , "Table" , json . dumps ( self . dppNodes [ oO0OOOOOOoo . lossDppKey ] . getHeader ( ) ) ] )
   traceLogger . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Target" , * ti ] for ti in IiIii1iI1I11i ] )
  traceLogger . flush ( )
  if 1 - 1: oOO
 def _initVisualItems ( self , visualLogger , buildNo : int = 0 ) :
  if 56 - 56: I1Ii1I1 - ooOOO - IiI11Ii111 . ooOOO * Oo
  if self . visualRecord > 0 and self . visualItems is None :
   OO0oO = self . rootSources . getVisualRandItems ( self . visualRecord )
   self . visualItems_log = self . createUsingDataByShow ( OO0oO )
   self . visualItems = self . createUsingData ( OO0oO )
   if 11 - 11: i1 . IIiIIiIi11I1
  OO0o0oooO0o = 0
  ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
  for I1 in self . getDataPreprocessingNodesUsedByLayers ( buildNo = buildNo , inputOnly = True ) :
   visualLogger . log ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Input" , I1 . key , - 1 , "Table" , json . dumps ( I1 . getHeader ( step = OO0O0 . Columns . StepEnum . Input ) ) ] )
   visualLogger . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Input" , I1 . key , sii , * pi ] for sii , pi in enumerate ( I1 . getPrintableItems ( self . visualItems_log [ I1 . key ] , recovered = False ) ) ] )
   self . visualInput = self . visualItems_log [ I1 . key ]
  visualLogger . flush ( )
  if 14 - 14: IiI11Ii111 + i1i1i1111I * IiI11Ii111
  if 26 - 26: iI1iII1I1I1i / i1I
  for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
   IiIii1iI1I11i = oO0OOOOOOoo . getVisualTarget ( )
   visualLogger . log ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Target" , oO0OOOOOOoo . lossDppKey , - 1 , "Table" , json . dumps ( self . dppNodes [ oO0OOOOOOoo . lossDppKey ] . getHeader ( ) ) ] )
   visualLogger . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , OO0o0oooO0o , OO0o0oooO0o , "" , "Target" , * ti ] for ti in IiIii1iI1I11i ] )
   for OOOi1I in IiIii1iI1I11i :
    o0oo0OO0O0O0OO = [ int ( OOOi1I [ - 1 ] ) ]
    o0oo0OO0O0O0OO = np . array ( [ o0oo0OO0O0O0OO ] )
    if self . visualOutput is None :
     self . visualOutput = o0oo0OO0O0O0OO
    else :
     self . visualOutput = np . vstack ( ( self . visualOutput , o0oo0OO0O0O0OO ) )
  visualLogger . flush ( )
  self . visualData = { 'input' : self . visualInput , 'target' : self . visualOutput }
  if 16 - 16: i1I
 def _train ( self , buildNo = 0 ) :
  if 54 - 54: oOo0O00
  if 5 - 5: oOo0O00 . ooo000 + i1i1i1111I % iI1iII1I1I1i + oOo0O00 * i1
  if 83 - 83: Oo - OooOoo + I1I % OooOoo
  if 55 - 55: I1Ii1I1 * IiI11Ii111 - OooOoo
  if 24 - 24: oOo0O00 - Ii . i1i1i1111I % ooOOO
  if 14 - 14: I1Ii1I1 - Ooo0Ooo + I1I * OooOoo
  if 1 - 1: i1I
  if 3 - 3: i1I
  if 6 - 6: ooOOO * IiI11Ii111 + IIiIIiIi11I1 - IiIIii11Ii - i1I
  if 20 - 20: ooo000 - Oo - IiI11Ii111 + ooo000 * I1I
  if 78 - 78: I11iiIi11i1I - i1iiIII111 + oOo0O00 - i1I
  os . makedirs ( self . folder + "outputLogs/" + self . trainTime + "/" , exist_ok = True )
  os . makedirs ( self . folder + "builds/" + self . trainTime + "/" , exist_ok = True )
  os . makedirs ( self . folder + "tmpLogs/" + self . trainTime + "/" , exist_ok = True )
  if 34 - 34: OooOoo
  if 90 - 90: iI1iII1I1I1i . Iii1i / IIiIIiIi11I1
  I11IiI1Iii : iII11 . BuildConfig = self . currentBuildConfig
  if 2 - 2: Ii % I1Ii1I1 . IiIIii11Ii - i1i1i1111I . oOO
  if 5 - 5: i1I * i1iiIII111 . i1iiIII111 * IiI11Ii111 % i1iiIII111
  if 80 - 80: i1 - IiIIii11Ii * I1I + iI1iII1I1I1i % I1Ii1I1 * Oo
  Ooo00o00O : List [ OO0O0 . Config ] = self . getDataPreprocessingNodesUsedByLayers ( )
  if 28 - 28: Iii1i . I1I . Ooo0Ooo - iI1iII1I1I1i + ooOOO
  if 56 - 56: i1i1i1111I / OooOoo / i1I - iI1iII1I1I1i * Ooo0Ooo
  ooOo : set ( I1ii11II11 . Config ) = set ( )
  for I1 in Ooo00o00O :
   for O0oo0 in I1 . getRootSources ( rawGraph = False ) :
    ooOo . add ( O0oo0 )
  self . _rootSources = o0o ( self , [ * ooOo ] )
  if 88 - 88: i1 * IiIIii11Ii + IIiIIiIi11I1 * Ooo0Ooo + i1iiIII111
  if 22 - 22: I1Ii1I1 / oOO . I1Ii1I1 . IiIIii11Ii * Oo - i1
  if self . testDatasetType == I111II1II111I . Dataset . TestSource . Split and self . testRatio > 0 :
   self . rootSources . splitTestDataset ( self . testRatio , self . testShuffle )
   self . testRatio = 0
   if 29 - 29: ooo000 / IiIIii11Ii
   if 62 - 62: Ii . Iii1i + i1iiIII111 * oOO
  o0oo00o : str = I11IiI1Iii . crossValidationType
  I1IOoOO0o : bool = o0oo00o is not None and self . _cvNo >= 0
  OOoO0OoOOo0O : int = I11IiI1Iii . validationRuns
  if I1IOoOO0o :
   if I11IiI1Iii . _cvCount < OOoO0OoOOo0O :
    self . rootSources . nextCrossValidation ( I11IiI1Iii )
    I11IiI1Iii . _cvCount += 1
    self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . ValidationTrain )
   elif I11IiI1Iii . _cvCount == OOoO0OoOOo0O :
    I11IiI1Iii . _cvCount = 0
    self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Train )
  else :
   self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Train )
   if 29 - 29: I11iiIi11i1I + I1Ii1I1 / i1iiIII111 / ooOOO
   if 44 - 44: Iii1i % Iii1i
  OOOO0oOo : I1ii11II11 . Config = self . sources [ 0 ]
  O00O0o0OO00Oo : int = OOOO0oOo . batchCountPerEpoch
  oo0oooO : int = int ( O00O0o0OO00Oo * I11IiI1Iii . numEpochsPerDecay ) if ( I11IiI1Iii . numEpochsPerDecay is not None ) else None
  if 55 - 55: i1I
  if 13 - 13: OooOoo / Ooo0Ooo % IiI11Ii111 - oOO % Ooo0Ooo / ooOOO
  iiiIiiI11iiI : int = I11IiI1Iii . noOfEpoch * O00O0o0OO00Oo
  if 31 - 31: ooOOO - iI1iII1I1I1i
  if 21 - 21: i1iiIII111 / I1I
  if self . localStep >= iiiIiiI11iiI :
   self . localStep -= iiiIiiI11iiI
   if 29 - 29: IiI11Ii111 * oOO / I11iiIi11i1I / oOO * oOo0O00 / i1I
   if 42 - 42: oOO / ooo000 - i1 . IiI11Ii111 / Oo % ooOOO
  else :
   if 65 - 65: OooOoo . ooOOO * I1I / IiI11Ii111 * i1iiIII111
   if not self . _built :
    self . _build ( buildNo )
    if 24 - 24: ooo000 % i1I - IiI11Ii111 % IiIIii11Ii + I11iiIi11i1I
    if 90 - 90: I1I
   Ii1II : o0Ooo0oo = o0Ooo0oo ( "trainbuild" , { "target" : self , "buildNo" : self . _buildNo , "buildConfig" : I11IiI1Iii } )
   self . dispatchEvent ( Ii1II )
   if 63 - 63: i1i1i1111I / iI1iII1I1I1i
   with self . _graph . as_default ( ) :
    if 69 - 69: i1i1i1111I + oOO * ooo000 / oOo0O00 . I11iiIi11i1I * i1iiIII111
    ( iii ) : tf . Tensor
    if I11IiI1Iii . learningRateDecayFactor is not None and ( I11IiI1Iii . learningRateDecayFactor != 1 and I11IiI1Iii . learningRateDecayFactor > 0 ) :
     iii = tf . compat . v1 . train . exponential_decay ( I11IiI1Iii . initialLearningRate , self . localStepTensor , oo0oooO , I11IiI1Iii . learningRateDecayFactor , staircase = True )
    else :
     iii = tf . constant ( I11IiI1Iii . initialLearningRate )
     if 28 - 28: IiI11Ii111 % Ooo0Ooo % IiIIii11Ii + i1I % iI1iII1I1I1i
     if 53 - 53: Oo % ooo000 . Iii1i / i1
    Ooo000OO : tf . Tensor = tf . add_n ( tf . compat . v1 . get_collection ( 'losses' ) , name = 'totalLoss' )
    oOOOO0O00O00 : tf . Tensor = tf . compat . v1 . get_collection ( 'losses' )
    if 70 - 70: IiI11Ii111 % I11iiIi11i1I + I11iiIi11i1I * Ii - i1
    if 74 - 74: iI1iII1I1I1i * Ii % ooOOO - IiIIii11Ii * ooOOO * ooo000
    ( oOO0OOOOoOO ) : tf . Tensor
    ( o0o0O00OO0oO0 ) : tf . Tensor
    if I11IiI1Iii . exponentialLossDecay is not None :
     o0o0O00OO0oO0 = tf . train . ExponentialMovingAverage ( I11IiI1Iii . exponentialLossDecay , name = 'lossAvgs' )
     oOO0OOOOoOO = o0o0O00OO0oO0 . apply ( oOOOO0O00O00 + [ Ooo000OO ] )
    else :
     oOO0OOOOoOO = Ooo000OO
     if 32 - 32: I1I % Ii + i1iiIII111 * oOO - ooo000
     if 85 - 85: Oo % IIiIIiIi11I1 . I1I
    O00O0 : tf . Tensor = tf . compat . v1 . get_collection ( tf . compat . v1 . GraphKeys . UPDATE_OPS )
    iIO0oO0O : List [ tf . Tensor ] = [ ]
    with tf . control_dependencies ( [ oOO0OOOOoOO , * O00O0 ] ) :
     iiiIII : tf . Tensor = iII11 . optimizers ( I11IiI1Iii . optimizer ) ( iii , ** I11IiI1Iii . optimizerParams )
     iIO0oO0O . append ( iiiIII . minimize ( Ooo000OO , global_step = self . localStepTensor ) )
     if 55 - 55: i1I * Ooo0Ooo . OooOoo - ooOOO / I1I
     if 79 - 79: I1Ii1I1 - i1 * IIiIIiIi11I1 % oOO
    iIO0oO0O . append ( self . globalStepTensor . assign_add ( 1 ) )
    if 32 - 32: i1i1i1111I
    if 15 - 15: OooOoo . I11iiIi11i1I / i1i1i1111I
    if I11IiI1Iii . exponentialVarDecay is not None :
     OOOOooOoOOooo : tf . Tensor = tf . train . ExponentialMovingAverage ( I11IiI1Iii . exponentialVarDecay , self . localStep )
     iIO0oO0O . append ( OOOOooOoOOooo . apply ( tf . compat . v1 . trainable_variables ( ) ) )
     if 22 - 22: i1iiIII111 % IIiIIiIi11I1 . ooo000 % i1i1i1111I % iI1iII1I1I1i + Ooo0Ooo
     if 4 - 4: i1I + oOO / oOo0O00 * i1i1i1111I - oOO - oOO
    with tf . control_dependencies ( iIO0oO0O ) :
     IiioOo : tf . Tensor = tf . add_n ( oOOOO0O00O00 , name = 'totalLoss' )
     Oo00OOO : tf . Tensor = IiioOo / len ( oOOOO0O00O00 )
     if 44 - 44: i1I % OooOoo + i1iiIII111
     if 75 - 75: oOo0O00 - i1I * OooOoo * ooOOO + IiI11Ii111
    ii1iIIIII111I : tf . compat . v1 . Session = tf . compat . v1 . Session ( graph = self . _graph )
    self . _sess = ii1iIIIII111I
    if 41 - 41: I1I . I1Ii1I1 * i1I + Oo + Ii + IiIIii11Ii
    if 61 - 61: i1I % i1iiIII111 + IiI11Ii111
    ii1iIIIII111I . run ( tf . compat . v1 . global_variables_initializer ( ) )
    if 51 - 51: I1I . I1Ii1I1 . I11iiIi11i1I
   print ( "Training Initialized.\n" )
   if self . restorePath :
    self . _restoreHistory ( self . restorePath )
   elif self . _buildNo > 0 :
    self . _restoreBuild ( )
    if 5 - 5: IiIIii11Ii
    if 93 - 93: Oo
   oOoOoo0OOO : oo0OO00oOoo . Recorder = oo0OO00oOoo . Recorder ( )
   O0o0oO : int = self . localStep - 1
   Ii1II : o0Ooo0oo = o0Ooo0oo ( "trainstart" , { "target" : self , "buildNo" : self . _buildNo , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildConfig" : I11IiI1Iii } )
   self . dispatchEvent ( Ii1II )
   if 49 - 49: ooOOO % i1iiIII111 . i1i1i1111I
   if 65 - 65: OooOoo
   i11i : bool = True if self . logFreq > 0 and self . logFreq <= math . inf else False
   if i11i :
    OoooOo0 : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "trainLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Total Loss" , "Average Loss" , "Learning Rate" , "Examples per Second" , "Seconds per Step" ] )
   iIII11Ii11 : bool = True if self . testFreq > 0 and self . testFreq <= math . inf else False
   if iIII11Ii11 :
    self . testLogger : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "testLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Test Type" , * [ ( oO0OOOOOOoo . name + ": " + oO0OOOOOOoo . measurement ) for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) ] ] )
   o0Oo : bool = True if self . weightLogFreq > 0 and self . weightLogFreq <= math . inf else False
   if o0Oo :
    OOooo00 : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "weightLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , * [ w . name for w in sum ( [ oO0OOOOOOoo . _weights for oO0OOOOOOoo in self . modelNodes . values ( ) if oO0OOOOOOoo . weightLogging ] , [ ] ) ] ] )
   oOooO0OO0oo : bool = True if self . traceFreq > 0 and self . traceRecord > 0 and self . traceFreq <= math . inf else False
   if oOooO0OO0oo :
    iIi1IIi1111II : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "traceLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Task Name" , "Task Type" , "Data Preprocessing Node Key" , "Item ID" , "Data Type" , "Data" ] )
    self . _initTraceItems ( iIi1IIi1111II , buildNo = buildNo )
   oO000oO : bool = True if self . visualTestFreq > 0 and self . visualRecord > 0 and self . visualTestFreq <= math . inf else False
   if oO000oO :
    oOO0 : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "visualLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Task Name" , "Task Type" , "Data Preprocessing Node Key" , "Item ID" , "Data Type" , "Data" ] )
    self . _initVisualItems ( oOO0 , buildNo = buildNo )
    if 19 - 19: i1i1i1111I * Ooo0Ooo % Oo + oOo0O00
    if 47 - 47: I1I - i1
   OoI1 : int = len ( self . _eventFtns [ "epochstart" ] )
   IiIO0OO000Oo00o0 : int = len ( self . _eventFtns [ "epochend" ] )
   oo0IiIiI11 : int = len ( self . _eventFtns [ "stepprepare" ] )
   IIiIi1IiII1I1 : int = len ( self . _eventFtns [ "stepstart" ] )
   iiOOO0oo0 : int = len ( self . _eventFtns [ "stepend" ] )
   if 74 - 74: I11iiIi11i1I + IiIIii11Ii
   for IiIIiiII in range ( self . localStep , iiiIiiI11iiI ) :
    self . localStep += 1
    self . globalStep += 1
    iIiIIIi11 : int = self . localStep
    if 77 - 77: OooOoo . I11iiIi11i1I
    if 9 - 9: I11iiIi11i1I * i1iiIII111 * i1i1i1111I - i1 - Ii . i1
    if OoI1 and ( ( IiIIiiII - 1 ) % O00O0o0OO00Oo == 0 ) :
     iiIi : oOO0Oo0 = oOO0Oo0 ( "epochstart" , { "target" : self , "buildNo" : self . _buildNo , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildConfig" : I11IiI1Iii , "i" : IiIIiiII , "localStep" : iIiIIIi11 , "globalStep" : self . globalStep , "inputSources" : self . sources } )
     self . dispatchEvent ( iiIi )
     if 52 - 52: OooOoo * I1I . IIiIIiIi11I1
     if 79 - 79: Oo
    if oo0IiIiI11 :
     O0OoOo0OoOO : O0oO0oOOO0O = O0oO0oOOO0O ( "stepprepare" , { "target" : self , "buildNo" : self . _buildNo , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildConfig" : I11IiI1Iii , "i" : IiIIiiII , "localStep" : iIiIIIi11 , "globalStep" : self . globalStep } )
     self . dispatchEvent ( O0OoOo0OoOO )
     if 32 - 32: Iii1i * Ooo0Ooo / iI1iII1I1I1i * OooOoo * I1I
     if 8 - 8: iI1iII1I1I1i
    II1iI1 : Dict [ tf . Tensor , Union [ tf . Tensor , np . ndarray ] ] = { }
    for ooOO00o , IIi11ii1IIi in next ( self ) . items ( ) :
     II1iI1 [ self . _sourceTensors [ ooOO00o ] ] = IIi11ii1IIi
    iI11iIi : Dict [ tf . Tensor , float ] = { oO0OOOOOOoo . _dropoutTensor : oO0OOOOOOoo . dropout for oO0OOOOOOoo in self . modelNodes . values ( ) if oO0OOOOOOoo . dropout < 1 }
    iIOO00000oo0 : Dict [ tf . Tensor , Union [ tf . Tensor , np . ndarray , float ] ] = { ** II1iI1 , ** iI11iIi , self . _bnTensor : True }
    if 86 - 86: ooo000 * Ooo0Ooo + IiIIii11Ii - oOO / Ii
    if 59 - 59: I1Ii1I1 + Oo . oOo0O00
    if IIiIi1IiII1I1 :
     I111II111i1 : O0oO0oOOO0O = O0oO0oOOO0O ( "stepstart" , { "target" : self , "buildNo" : self . _buildNo , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildConfig" : I11IiI1Iii , "i" : IiIIiiII , "localStep" : iIiIIIi11 , "globalStep" : self . globalStep , "feedDict" : iIOO00000oo0 } )
     self . dispatchEvent ( I111II111i1 )
     if 88 - 88: Oo + i1
    with self . _graph . as_default ( ) :
     if 72 - 72: i1
     if len ( self . _printTensors ) :
      print ( ii1iIIIII111I . run ( self . _printTensors , feed_dict = iIOO00000oo0 ) )
      if 79 - 79: oOo0O00
      if 4 - 4: IiIIii11Ii + oOO - Oo
     Ooo000OO : float
     I1Iii111111 : float
     Ooo000OO , I1Iii111111 = ii1iIIIII111I . run ( [ IiioOo , Oo00OOO ] , feed_dict = iIOO00000oo0 )
     if 3 - 3: I11iiIi11i1I / I11iiIi11i1I * OooOoo
     if 76 - 76: I1I / i1i1i1111I - oOO . i1iiIII111
     if i11i and ( iIiIIIi11 % self . logFreq == 0 or IiIIiiII == iiiIiiI11iiI - 1 ) :
      O0Ooo0OoO : float = oOoOoo0OOO . logAndRestart ( )
      ooOo0IiiIIIiiI1Ii1 : datetime . datetime = datetime . now ( )
      o000o : float = self . logFreq * self . sources [ 0 ] . batchSize / O0Ooo0OoO
      i1i1ii : float = float ( O0Ooo0OoO / ( self . localStep - O0o0oO ) )
      O0o0oO : int = self . localStep
      O0Ooo0Oo : float
      OoiII111ii : int
      O0Ooo0Oo , OoiII111ii = ii1iIIIII111I . run ( [ iii , self . localStepTensor ] )
      OoooOo0 . log ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , i111iIIiIIi ( Ooo000OO ) , i111iIIiIIi ( I1Iii111111 ) , O0Ooo0Oo , o000o , i1i1ii ] )
      if self . _cvNo == - 1 :
       print ( '%s: Run #%d, Step %d (%d) --- loss: %f; learning rate: %f; %.1f examples/s; %.3f s/step' % ( ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . globalStep , iIiIIIi11 , I1Iii111111 , O0Ooo0Oo , o000o , i1i1ii ) )
      else :
       print ( '%s: Run #%d - Cross Validation %d, Step %d (%d) --- loss: %f; learning rate: %f; %.1f examples/s; %.3f s/step' % ( ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , I1Iii111111 , O0Ooo0Oo , o000o , i1i1ii ) )
       if 55 - 55: iI1iII1I1I1i / ooOOO
       if 73 - 73: IiIIii11Ii * ooo000
     if o0Oo and ( iIiIIIi11 % self . weightLogFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
      ooOo0IiiIIIiiI1Ii1 : datetime . datetime = datetime . now ( )
      OOooo00 . logAndSave ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , * [ Ii1II11 ( ary ) . tolist ( ) for ary in ii1iIIIII111I . run ( functools . reduce ( lambda ooOoOO0O00o , OoOo0o0oooO : ooOoOO0O00o + OoOo0o0oooO , [ oO0OOOOOOoo . _weights for oO0OOOOOOoo in self . modelNodes . values ( ) if oO0OOOOOOoo . weightLogging ] , [ ] ) ) ] ] )
      if 16 - 16: i1iiIII111 % i1
      if 75 - 75: Oo / Oo
     if self . saveFreq > 0 and ( iIiIIIi11 % self . saveFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
      if 32 - 32: Ii . oOO
      self . _saveTempTrain ( )
      if 17 - 17: IiIIii11Ii
      if 71 - 71: Iii1i
      if i11i :
       OoooOo0 . flush ( )
       if 87 - 87: ooo000 - i1 % i1i1i1111I % i1 * Ii - OooOoo
       if 78 - 78: IiI11Ii111
     if oOooO0OO0oo and ( iIiIIIi11 % self . traceFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
      if 55 - 55: Ooo0Ooo
      iii111iI : np . ndarray = self . predict ( x = self . traceItems , buildNo = buildNo )
      ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
      for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
       IIiIIi11I : np . ndarray = oO0OOOOOOoo . getTraceItems ( iii111iI , buildNo = buildNo )
       if IIiIIi11I is not None :
        iIi1IIi1111II . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , oO0OOOOOOoo . name , oO0OOOOOOoo . __class__ . __name__ , * I1iiiiii ( pi ) ] for pi in IIiIIi11I ] )
      iIi1IIi1111II . flush ( )
      if 89 - 89: oOO * i1i1i1111I * IiI11Ii111
      if 5 - 5: i1i1i1111I * oOo0O00 + i1iiIII111 % Iii1i . I1I
     if oO000oO and ( iIiIIIi11 % self . visualFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
      if 10 - 10: oOO
      iii111iI : np . ndarray = self . predict ( x = self . visualItems , buildNo = buildNo )
      ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
      for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
       IIiIIi11I : np . ndarray = oO0OOOOOOoo . getvisualItems ( iii111iI , buildNo = buildNo )
       if IIiIIi11I is not None :
        oOO0 . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , oO0OOOOOOoo . name , oO0OOOOOOoo . __class__ . __name__ , * I1iiiiii ( pi ) ] for pi in IIiIIi11I ] )
      oOO0 . flush ( )
      if 21 - 21: iI1iII1I1I1i * Oo / oOo0O00 - Iii1i
    if iIII11Ii11 and ( iIiIIIi11 % self . testFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 75 - 75: IiIIii11Ii + I1I - Iii1i + Iii1i
     self . evaluate ( validation = I1IOoOO0o , event = "Test Log" , buildNo = buildNo )
     if 3 - 3: Iii1i + IiI11Ii111
     if 35 - 35: oOo0O00 % oOO + ooOOO % iI1iII1I1I1i * i1
    if iiOOO0oo0 :
     I1I1Iii1II : O0oO0oOOO0O = O0oO0oOOO0O ( "stepend" , { "target" : self , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildNo" : self . _buildNo , "buildConfig" : I11IiI1Iii , "i" : IiIIiiII , "localStep" : iIiIIIi11 , "globalStep" : self . globalStep , "feedDict" : iIOO00000oo0 , "totalLoss" : Ooo000OO , "avgLoss" : I1Iii111111 } )
     self . dispatchEvent ( I1I1Iii1II )
     if 67 - 67: iI1iII1I1I1i / i1i1i1111I
     if 10 - 10: IIiIIiIi11I1 * IIiIIiIi11I1 + i1 - i1I * I1I + OooOoo
    if IiIO0OO000Oo00o0 and ( IiIIiiII % O00O0o0OO00Oo == 0 ) :
     i111iii : oOO0Oo0 = oOO0Oo0 ( "epochend" , { "target" : self , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildNo" : self . _buildNo , "buildConfig" : I11IiI1Iii , "i" : IiIIiiII , "localStep" : iIiIIIi11 , "globalStep" : self . globalStep , "inputSources" : self . sources } )
     self . dispatchEvent ( i111iii )
     if 97 - 97: oOo0O00 - Ooo0Ooo
     if 51 - 51: i1I % i1I % i1iiIII111
   if i11i :
    OoooOo0 . flush ( )
    if 79 - 79: Ooo0Ooo + I11iiIi11i1I / IiIIii11Ii - ooOOO . ooOOO / OooOoo
    if 66 - 66: Ooo0Ooo - IiI11Ii111 . Oo / I1Ii1I1 . i1I % i1iiIII111
   with self . _graph . as_default ( ) :
    o0oO : tf . compat . v1 . train . Saver = tf . compat . v1 . train . Saver ( )
    o0oO . save ( ii1iIIIII111I , self . folder + 'tmpLogs/' + self . trainTime + '/tmpLog.ckpt' )
    o0oO . save ( ii1iIIIII111I , self . folder + 'builds/' + self . trainTime + '/build_' + str ( self . _buildNo ) + '/buildLog.ckpt' )
    if 43 - 43: Ooo0Ooo / Iii1i
    if 84 - 84: i1 + IiI11Ii111 - I11iiIi11i1I * IIiIIiIi11I1 + oOo0O00 . i1
   ii1IIIiI1i1i : o0Ooo0oo = o0Ooo0oo ( "trainend" , { "target" : self , "runNo" : self . _runNo , "cvNo" : self . _cvNo , "buildNo" : self . _buildNo , "buildConfig" : I11IiI1Iii } )
   self . dispatchEvent ( ii1IIIiI1i1i )
   if 37 - 37: i1I * OooOoo / Ooo0Ooo . Iii1i
   if 81 - 81: i1I
   self . close ( )
   if 6 - 6: Ii * I1I . IIiIIiIi11I1 - Iii1i / iI1iII1I1I1i % i1i1i1111I
 def _saveTempTrain ( self ) :
  if 11 - 11: I1Ii1I1 . i1 + oOO
  if 27 - 27: IIiIIiIi11I1 * Ooo0Ooo + i1I * IiI11Ii111 + Ooo0Ooo
  if 17 - 17: i1iiIII111 - IiIIii11Ii
  if 68 - 68: Ii / ooOOO
  if 25 - 25: ooo000 / oOO + i1
  if 3 - 3: oOo0O00 / IiI11Ii111 / i1I . I1I * IiIIii11Ii . OooOoo
  if 90 - 90: ooOOO / IiI11Ii111 - I11iiIi11i1I . i1I
  with self . _graph . as_default ( ) :
   o0oO = tf . compat . v1 . train . Saver ( )
   o0oO . save ( self . _sess , self . folder + 'tmpLogs/' + self . trainTime + '/tmpLog.ckpt' )
   if 4 - 4: oOo0O00 / oOO
  with open ( self . folder + 'tmpLogs/' + self . trainTime + '/tmpStep.txt' , "w" , encoding = "utf-8" , newline = "" ) as f :
   f . write ( str ( self . globalStep - 1 ) )
   if 38 - 38: IIiIIiIi11I1 / iI1iII1I1I1i . IIiIIiIi11I1 * ooOOO + OooOoo
 def _restoreHistory ( self , restorePath = None ) :
  if 86 - 86: oOO
  if 36 - 36: ooOOO + I1I . iI1iII1I1I1i
  if 11 - 11: i1
  if 99 - 99: i1iiIII111 % iI1iII1I1I1i * I1Ii1I1 . oOO
  if 20 - 20: IIiIIiIi11I1
  if 27 - 27: ooOOO / IiIIii11Ii * I11iiIi11i1I
  if 11 - 11: ooo000
  if 54 - 54: IiI11Ii111 - IIiIIiIi11I1 / Ii
  if 69 - 69: Iii1i
  if 49 - 49: i1I / IiI11Ii111 + i1iiIII111
  if 14 - 14: i1 * Ooo0Ooo
  oOOoO = ( ( self . folder + 'tmpLogs/' + self . trainTime + "/" ) if ( restorePath is None ) else self . restorePath )
  o0oO = tf . compat . v1 . train . Saver ( [ x for x in tf . compat . v1 . get_collection ( tf . compat . v1 . GraphKeys . GLOBAL_VARIABLES ) ] )
  if 5 - 5: i1I - oOo0O00 * IIiIIiIi11I1 + iI1iII1I1I1i + IiIIii11Ii . oOO
  if 84 - 84: Iii1i - Ii * i1I - I1I
  o0oO . restore ( self . _sess , oOOoO + "tmpLog.ckpt" )
  print ( "Training restored.\n" )
  if 45 - 45: iI1iII1I1I1i
 def _restoreBuild ( self ) :
  if 33 - 33: I1Ii1I1 . oOO - i1i1i1111I / I1Ii1I1 % i1 / IiI11Ii111
  if 73 - 73: I1Ii1I1 . oOO * I1I
  if 99 - 99: i1i1i1111I / i1iiIII111 % i1iiIII111
  if 64 - 64: i1i1i1111I + i1iiIII111 * iI1iII1I1I1i + I1I
  if 65 - 65: OooOoo * oOO + I1I + I11iiIi11i1I + Ii * IIiIIiIi11I1
  if 19 - 19: IIiIIiIi11I1 . IiIIii11Ii
  if 2 - 2: Oo . OooOoo * I11iiIi11i1I
  if 7 - 7: IIiIIiIi11I1 + i1 % ooOOO * Iii1i / IiIIii11Ii
  oOOoO = self . folder + 'builds/' + self . trainTime + '/build_' + str ( self . _buildNo ) + "/"
  I1IiIiIii = [ n for n , l in self . modelNodes if l . buildNo < self . _buildNo ]
  o0oO = tf . compat . v1 . train . Saver ( [ x for x in tf . compat . v1 . get_collection ( tf . compat . v1 . GraphKeys . GLOBAL_VARIABLES ) if any ( [ x . name . startswith ( n + "/" ) for n in I1IiIiIii ] ) ] )
  if 19 - 19: i1iiIII111 + I1I
  if 25 - 25: I1I / i1iiIII111 . Ii - I1Ii1I1
  o0oO . restore ( self . _sess , oOOoO + "buildLog.ckpt" )
  print ( "Build restored.\n" )
  if 77 - 77: i1i1i1111I + Iii1i + Oo % OooOoo * Ooo0Ooo
 def _nextCrossValidation ( self , buildConfig ) :
  if 13 - 13: i1
  if 27 - 27: i1I / OooOoo % Oo . Ooo0Ooo
  if 3 - 3: ooOOO
  if 98 - 98: oOo0O00
  if 29 - 29: ooOOO
  if 33 - 33: iI1iII1I1I1i * OooOoo - I1I
  if 93 - 93: I1I / ooo000 / Iii1i * i1i1i1111I % i1 - Oo
  if 8 - 8: i1I . IiIIii11Ii + OooOoo . ooOOO + oOO
  for O0oo0 in self . sources :
   if O0oo0 . splittable :
    if 22 - 22: IIiIIiIi11I1 * oOo0O00 * i1i1i1111I - i1iiIII111 + i1
    O0oo0 . splitValidationDataset ( validation = buildConfig . crossValidationProp , shuffle = buildConfig . crossValidationType == "rand" )
    if 57 - 57: Ii . Iii1i / Oo
 def _evaluate ( self , validation : bool = False , isPredict : bool = False , event : str = "" , saveOriginal : bool = False , saveResults : bool = False , buildNo : int = 0 ) -> Any :
  if 93 - 93: Oo * I1I * i1I + OooOoo % iI1iII1I1I1i / i1i1i1111I
  if 48 - 48: IIiIIiIi11I1 + ooo000 * Ooo0Ooo % i1iiIII111 / oOo0O00
  if 85 - 85: i1 . I1Ii1I1 - Ii + IiI11Ii111 % I1Ii1I1 - i1
  if 3 - 3: i1i1i1111I - ooOOO
  if 32 - 32: Ii
  if 5 - 5: OooOoo / IiIIii11Ii + I1Ii1I1 . i1iiIII111 * IiI11Ii111
  if 12 - 12: I11iiIi11i1I % IIiIIiIi11I1
  if 92 - 92: ooOOO % oOo0O00
  if 44 - 44: ooOOO
  if 77 - 77: oOO . I11iiIi11i1I
  if 44 - 44: ooo000 . IiI11Ii111 * IIiIIiIi11I1 * Oo
  if 88 - 88: oOo0O00 / oOo0O00 + i1 / OooOoo % i1iiIII111 % oOo0O00
  if 47 - 47: ooo000 / iI1iII1I1I1i / i1iiIII111 . oOO % OooOoo
  if 88 - 88: Ooo0Ooo * i1i1i1111I . IiIIii11Ii % I1Ii1I1 . Oo
  if 60 - 60: i1 . IiIIii11Ii . ooOOO + IiIIii11Ii
  if 84 - 84: Iii1i + oOo0O00 - Oo + i1iiIII111 / oOO
  if 14 - 14: oOo0O00 + ooOOO + I1Ii1I1 / i1 . Iii1i + oOo0O00
  if 1 - 1: i1i1i1111I
  if 81 - 81: IiI11Ii111 + IiI11Ii111
  I1II1ii11i1ii = self . currentSourceDataset
  if validation :
   self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Validation )
  else :
   self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Test )
   if 63 - 63: OooOoo / IiIIii11Ii + ooo000 * oOO
   if 96 - 96: Oo % Iii1i * oOo0O00 + Iii1i
  O0O0o0o0o0 = self . _evalSources
  Ii1IiiIIi1II = O0O0o0o0o0 is not None
  I1i111ii1ii = isinstance ( O0O0o0o0o0 , iII11 . UsingData )
  if I1i111ii1ii :
   if len ( O0O0o0o0o0 ) == 0 :
    raise ValueError ( "There is no test or validation data sources." )
   elif len ( self . dppNodes ) != len ( O0O0o0o0o0 ) :
    raise ValueError ( "Sources and test sources are not matched." )
    if 57 - 57: ooo000 / i1 * IIiIIiIi11I1 * I11iiIi11i1I
    if 80 - 80: Iii1i * Ii
  OOOO0oOo = self . sources [ 0 ]
  ii1Ii1i11I1 = math . ceil ( O0O0o0o0o0 . getCount ( ) / OOOO0oOo . batchSize ) if Ii1IiiIIi1II else OOOO0oOo . batchCountPerEpoch
  if 42 - 42: i1
  if 36 - 36: I1Ii1I1 % I1I - IiI11Ii111 + i1I / oOo0O00
  OO0o000OO000 = self . getFinalNodes ( buildNo = buildNo )
  o0oo0oOOOoOOo = { OOOO0O0oO0Oo . name : None for OOOO0O0oO0Oo in OO0o000OO000 }
  if self . _sess is None :
   ii1iIIIII111I = self . _sess = tf . compat . v1 . Session ( graph = self . _graph )
   ii1iIIIII111I . run ( tf . compat . v1 . global_variables_initializer ( ) )
   self . _restoreHistory ( )
   if 7 - 7: Iii1i - IIiIIiIi11I1 . Ii - i1i1i1111I
   if 66 - 66: I1Ii1I1
  OoooOo = 0
  for OOOO0O0oO0Oo in OO0o000OO000 :
   OOOO0O0oO0Oo . _clearEvalInfo ( )
   if 29 - 29: oOo0O00 * Ooo0Ooo * ooo000
  for IiIIiiII in range ( 0 , ii1Ii1i11I1 ) :
   if 43 - 43: i1i1i1111I % I1I / oOO * i1i1i1111I - i1I
   oO0OOO0Oo = O0O0o0o0o0 if I1i111ii1ii else { ooOO00o : dppData for ooOO00o , dppData in next ( self ) . items ( ) }
   II1iI1 = { }
   OoooOo += max ( [ len ( colData ) for colData in oO0OOO0Oo . values ( ) ] )
   if 86 - 86: Oo / i1iiIII111
   if 49 - 49: i1i1i1111I
   for ooOO00o , i1IIiI in self . _sourceTensors . items ( ) :
    II1iI1 [ i1IIiI ] = oO0OOO0Oo [ ooOO00o ]
    if 8 - 8: ooOOO . ooOOO * Ooo0Ooo * Oo + oOO % Iii1i
    if 68 - 68: IiIIii11Ii
   iI11iIi = { l . _dropoutTensor : 1 for l in self . modelNodes . values ( ) if l . dropout < 1 }
   iIOO00000oo0 = { ** II1iI1 , ** iI11iIi , self . _bnTensor : False }
   if 50 - 50: i1I / I1Ii1I1 * Oo
   if 14 - 14: Oo / i1 / IiI11Ii111 . IiI11Ii111 . Ii
   with self . _graph . as_default ( ) :
    OOO00oo0o = self . _sess . run ( { OOOO0O0oO0Oo . name : OOOO0O0oO0Oo . _predictionTensors for OOOO0O0oO0Oo in OO0o000OO000 } , feed_dict = iIOO00000oo0 )
    if 61 - 61: Ooo0Ooo + i1i1i1111I . I11iiIi11i1I / i1I * oOo0O00 . Ii
    if 53 - 53: IIiIIiIi11I1 - oOo0O00
   for OOOO0O0oO0Oo in OO0o000OO000 :
    OOO00oo0o [ OOOO0O0oO0Oo . name ] = OOOO0O0oO0Oo . recoverPredictedResults ( OOO00oo0o [ OOOO0O0oO0Oo . name ] )
    if 98 - 98: iI1iII1I1I1i . IiIIii11Ii + oOo0O00 + I11iiIi11i1I - i1i1i1111I
    if 44 - 44: iI1iII1I1I1i + IiI11Ii111 - I1Ii1I1 - I11iiIi11i1I + ooo000
   if not isPredict :
    if 54 - 54: I1I - Ii * i1I + ooo000 - Oo * oOO
    for OOOO0O0oO0Oo in OO0o000OO000 :
     OOOO0O0oO0Oo . partialEvaluate ( oO0OOO0Oo , OOO00oo0o [ OOOO0O0oO0Oo . name ] )
     if 82 - 82: i1
     if 20 - 20: IiIIii11Ii
   if isPredict :
    for OOOO0O0oO0Oo in OO0o000OO000 :
     if o0oo0oOOOoOOo [ OOOO0O0oO0Oo . name ] is None :
      if 28 - 28: ooo000 . i1I + I11iiIi11i1I . I11iiIi11i1I + iI1iII1I1I1i * i1I
      o0oo0oOOOoOOo [ OOOO0O0oO0Oo . name ] = OOO00oo0o [ OOOO0O0oO0Oo . name ]
     else :
      if 34 - 34: oOo0O00
      o0oo0oOOOoOOo [ OOOO0O0oO0Oo . name ] = np . concatenate ( ( o0oo0oOOOoOOo [ OOOO0O0oO0Oo . name ] , OOO00oo0o [ OOOO0O0oO0Oo . name ] ) , axis = 0 )
      if 66 - 66: Iii1i
  if isPredict :
   if 67 - 67: OooOoo . ooOOO
   self . assignCurrentSourceDataset ( I1II1ii11i1ii )
   if 71 - 71: iI1iII1I1I1i % oOo0O00 - i1i1i1111I - i1 . i1I / I11iiIi11i1I
   if 71 - 71: i1 / Ooo0Ooo
   return o0oo0oOOOoOOo
  else :
   if 16 - 16: i1I - Iii1i . i1i1i1111I - i1i1i1111I
   OO0oo0o00oOo0 = [ [ OOOO0O0oO0Oo . measurement , OOOO0O0oO0Oo . getTestScore ( ) ] for OOOO0O0oO0Oo in OO0o000OO000 ]
   if 73 - 73: I1I
   if 69 - 69: Ooo0Ooo
   ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
   oo00o = [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , event , * I1iiiiii ( [ ans [ 1 ] for ans in OO0oo0o00oOo0 ] ) ]
   if self . _cvNo == - 1 :
    print ( '\nTEST (Validation: %s - %s) Test Data Size: %d\n%s: Run #%d, Step %d (%d) --- \n' % ( validation , event , OoooOo , ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . globalStep , self . localStep ) , * [ ans [ 0 ] + ": " + ( '%f' % ans [ 1 ] ) for ans in OO0oo0o00oOo0 ] , "\n" )
   else :
    print ( '\nTEST (Validation: %s - %s) Test Data Size: %d\n%s: Run #%d - Cross Validation %d, Step %d (%d) --- \n' % ( validation , event , OoooOo , ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep ) , * [ ans [ 0 ] + ": " + ( '%f' % ans [ 1 ] ) for ans in OO0oo0o00oOo0 ] , "\n" )
   if self . testLogger is not None :
    self . testLogger . logAndSave ( oo00o )
    if 82 - 82: Iii1i
    if 22 - 22: IiI11Ii111 - I1I % iI1iII1I1I1i + Ii
   if not I1i111ii1ii :
    if O0O0o0o0o0 is not None :
     if 15 - 15: iI1iII1I1I1i * I1I - i1I . Ooo0Ooo - I1I . I11iiIi11i1I
     for O0oo0 in reversed ( O0O0o0o0o0 ) :
      if isinstance ( O0oo0 , I1ii11II11 . Config ) :
       O0oo0 . close ( )
    else :
     if 51 - 51: Ii % ooo000 * Oo . oOo0O00 - IiI11Ii111 / Ii
     self . rootSources . closeCurrentDatasets ( )
     if 93 - 93: i1I / i1i1i1111I % i1iiIII111 + i1i1i1111I
     if 6 - 6: ooo000 % IiIIii11Ii / ooOOO
   self . assignCurrentSourceDataset ( I1II1ii11i1ii )
   if 85 - 85: Iii1i % IIiIIiIi11I1 % oOO
 def close ( self ) :
  if 6 - 6: i1iiIII111
  if 65 - 65: oOO + Oo . Ii + Iii1i % i1I
  if 76 - 76: OooOoo
  if 86 - 86: i1 . i1iiIII111 - oOo0O00
  if 43 - 43: IiIIii11Ii
  if 71 - 71: oOO
  if 8 - 8: i1iiIII111
  if 48 - 48: i1iiIII111 + i1i1i1111I * IiI11Ii111 + I1I . IIiIIiIi11I1 + i1I
  for OOoo00ooOo00O in reversed ( self . sources ) :
   OOoo00ooOo00O . close ( )
   if 38 - 38: ooo000 - ooo000 + IIiIIiIi11I1 / IIiIIiIi11I1
   if 19 - 19: oOo0O00 - i1iiIII111
  self . _built = False
  for o0OoOOOOO00O in self . modelNodes . values ( ) :
   o0OoOOOOO00O . _built = False
  self . localStep = 0
  self . _printTensors = [ ]
  if 100 - 100: iI1iII1I1I1i
 def fit ( self ) :
  if 58 - 58: Ii / IiI11Ii111 + i1i1i1111I / i1iiIII111
  if 25 - 25: i1i1i1111I
  if 33 - 33: OooOoo
  if 83 - 83: Oo / IIiIIiIi11I1
  if 88 - 88: I1I % ooo000
  if 81 - 81: I11iiIi11i1I / i1iiIII111 + i1i1i1111I
  if 41 - 41: Ii * Ooo0Ooo
  if 25 - 25: IIiIIiIi11I1 * IIiIIiIi11I1
  self . fullModelTrain ( )
  if 31 - 31: oOO
 def evaluate ( self , x : Optional [ Union [ 'Source.Config' , 'np.ndarray' , List [ List [ Any ] ] , List [ 'Source.Config' ] , 'Source.Data' ] ] = None ,
 batchSize : int = - 1 , shuffle : bool = False , validation : bool = False , isPredict : bool = False , event : str = "" , saveOriginal : bool = False , saveResults : bool = False , buildNo : int = 0 ) :
  if 2 - 2: I1I / OooOoo * i1i1i1111I % i1 * I11iiIi11i1I
  if 88 - 88: I1I . I1I % Ooo0Ooo
  if 40 - 40: i1i1i1111I + i1i1i1111I
  if 58 - 58: Iii1i % I11iiIi11i1I * iI1iII1I1I1i * IIiIIiIi11I1 + IIiIIiIi11I1 - iI1iII1I1I1i
  if 39 - 39: I1Ii1I1 - Iii1i * ooo000
  if 1 - 1: Ii % Iii1i . IiI11Ii111 . IiIIii11Ii % IiIIii11Ii % Iii1i
  if 74 - 74: Oo
  if 42 - 42: OooOoo / OooOoo * ooo000 - Ii * oOo0O00 / oOO
  if 35 - 35: I11iiIi11i1I * I11iiIi11i1I * Iii1i . ooOOO
  if 59 - 59: ooOOO * IiIIii11Ii
  if 62 - 62: I1Ii1I1
  if 81 - 81: iI1iII1I1I1i - I11iiIi11i1I / iI1iII1I1I1i . I1Ii1I1
  if 7 - 7: IiI11Ii111
  if 7 - 7: IiIIii11Ii
  if 36 - 36: oOO - IIiIIiIi11I1 . iI1iII1I1I1i % oOO
  if 34 - 34: IiIIii11Ii * i1iiIII111
  if 27 - 27: ooo000 * i1i1i1111I . oOO - iI1iII1I1I1i + I11iiIi11i1I
  if 6 - 6: IiIIii11Ii . I1Ii1I1 - oOo0O00
  if 100 - 100: I11iiIi11i1I + IIiIIiIi11I1 % Oo + ooo000 % ooOOO * i1iiIII111
  if x is not None :
   if validation :
    raise ValueError ( "NSC Internal Error - Validation triggered with customized source data." )
    if 26 - 26: IIiIIiIi11I1 + IiI11Ii111 / OooOoo + ooo000
    if 49 - 49: Ii
    if 77 - 77: oOO + i1 / IiIIii11Ii . i1 * i1I
   if isinstance ( x , I1ii11II11 . Config ) :
    self . _evalSources = [ x ]
   elif isinstance ( x , iII11 . UsingData ) :
    self . _evalSources = x
   elif isinstance ( x , list ) and all ( [ isinstance ( x , I1ii11II11 . Config ) for t in x ] ) :
    self . _evalSources = x
   else :
    if 71 - 71: i1I
    if 26 - 26: IIiIIiIi11I1 . IiI11Ii111 + i1I * OooOoo
    raise ValueError ( "Evaluation source is not supported." )
    if 87 - 87: i1i1i1111I . iI1iII1I1I1i + I1I % oOo0O00
    if 40 - 40: I1I * ooo000
   if not isinstance ( x , iII11 . UsingData ) :
    if len ( self . _evalSources ) != len ( self . sources ) :
     raise ValueError ( "Evaluation sources length does not match originally desinged model." )
    elif any ( [ not isinstance ( s , self . _evalSources [ idx ] . __class__ ) for idx , s in enumerate ( self . sources ) ] ) :
     raise ValueError ( "Evaluation sources class does not match originally desinged model." )
     if 95 - 95: i1I + I1Ii1I1 + OooOoo / i1
     if 50 - 50: iI1iII1I1I1i
  if isPredict :
   if 96 - 96: ooo000 % i1i1i1111I * i1i1i1111I + ooOOO % oOo0O00
   OOOo0O = self . _evaluate ( validation , isPredict = isPredict , event = event , saveOriginal = saveOriginal , saveResults = saveResults , buildNo = buildNo )
   if 4 - 4: IiIIii11Ii - OooOoo / oOO . Ii + i1 % I1Ii1I1
   if 3 - 3: ooo000 + Iii1i - I1Ii1I1 * IIiIIiIi11I1
   self . _evalSources = None
   if 32 - 32: i1i1i1111I - IiI11Ii111 + I11iiIi11i1I % i1i1i1111I
   return OOOo0O
  else :
   if 21 - 21: IIiIIiIi11I1 . i1I % oOO % Ii % I11iiIi11i1I
   self . _evaluate ( validation , event = event , saveOriginal = saveOriginal , saveResults = saveResults , buildNo = buildNo )
   if 66 - 66: IiI11Ii111 * Ii
   if 54 - 54: Ooo0Ooo - I1Ii1I1 - Ii - I1Ii1I1 - i1I . oOO
   self . _evalSources = None
   if 58 - 58: i1i1i1111I * i1i1i1111I - OooOoo . i1i1i1111I . i1iiIII111 + Iii1i
 def predict ( self , x : Optional [ Union [ 'Source.Config' , 'np.ndarray' , List [ List [ Any ] ] , List [ 'Source.Config' ] , 'Source.Data' ] ] = None ,
 batchSize : int = - 1 , shuffle : bool = False , validation : bool = False , event : str = "" , saveOriginal : bool = False , saveResults : bool = False , buildNo : int = 0 ) :
  if 47 - 47: ooOOO
  if 78 - 78: OooOoo / oOO * OooOoo % ooOOO . i1i1i1111I
  if 47 - 47: oOo0O00 % Oo * IiIIii11Ii
  if 26 - 26: iI1iII1I1I1i
  if 35 - 35: IiIIii11Ii . Iii1i % IiIIii11Ii % Ooo0Ooo
  if 40 - 40: iI1iII1I1I1i
  if 45 - 45: oOo0O00
  if 56 - 56: ooOOO % i1iiIII111 - i1i1i1111I
  if 40 - 40: Iii1i / OooOoo
  if 13 - 13: i1I * i1I
  if 87 - 87: IIiIIiIi11I1
  if 91 - 91: Oo - I1Ii1I1 - Ooo0Ooo
  if 47 - 47: IIiIIiIi11I1 - OooOoo . IiI11Ii111 / IIiIIiIi11I1 . Iii1i * Ii
  if 24 - 24: i1iiIII111 + I11iiIi11i1I * i1 / i1 / I11iiIi11i1I
  if 44 - 44: ooo000
  if 8 - 8: i1I
  if 1 - 1: OooOoo / IIiIIiIi11I1
  return self . evaluate ( x = x , batchSize = batchSize , shuffle = shuffle , validation = validation , isPredict = True , event = event , saveOriginal = saveOriginal , saveResults = saveResults , buildNo = buildNo )
  if 12 - 12: ooo000 - ooo000 - i1i1i1111I + I1I - OooOoo + I1I
 def perBuildTrain ( self , buildNo = 0 ) :
  if 5 - 5: iI1iII1I1I1i % Oo % i1I . ooOOO * ooOOO + ooOOO
  if 66 - 66: oOO . IIiIIiIi11I1 * ooo000 / I1Ii1I1 . Ooo0Ooo
  if 14 - 14: ooo000 * I1I
  if 74 - 74: I1I / Ii + IiI11Ii111 + ooo000 / IIiIIiIi11I1
  if 58 - 58: I1I - IiI11Ii111 * i1iiIII111 % IIiIIiIi11I1
  if 17 - 17: Ooo0Ooo / IiIIii11Ii . i1i1i1111I - ooOOO
  if 16 - 16: OooOoo % oOo0O00 / i1i1i1111I . i1I . Ooo0Ooo
  if 92 - 92: i1I % I1Ii1I1
  if 68 - 68: OooOoo + Ii + IIiIIiIi11I1 % i1 - iI1iII1I1I1i % Oo
  if 79 - 79: Ii . i1 / i1I % oOO / IIiIIiIi11I1 . IiI11Ii111
  if 66 - 66: IiI11Ii111 . i1i1i1111I - Iii1i
  IIi11iIi1iiI1 = self . globalStep
  if 59 - 59: ooOOO * Ooo0Ooo * I1Ii1I1 * i1I - oOO % iI1iII1I1I1i
  if 60 - 60: Ii % i1i1i1111I % I11iiIi11i1I * I1Ii1I1 * i1I + Ii
  for O0OooOo0 in range ( 0 , self . runCount ) :
   self . _runNo += 1
   if 32 - 32: i1i1i1111I
   OOOooOo = self . buildConfigs [ buildNo ]
   OOoO0OoOOo0O = OOOooOo . validationRuns
   if OOOooOo . crossValidationType is None or OOoO0OoOOo0O == 1 :
    self . globalStep = IIi11iIi1iiI1
    self . _train ( buildNo = buildNo )
   else :
    if 74 - 74: Ooo0Ooo % iI1iII1I1I1i + oOo0O00 / iI1iII1I1I1i - ooo000 + I11iiIi11i1I
    for ooOo0Oo0O0oOo in range ( 0 , OOoO0OoOOo0O + 1 ) :
     self . globalStep = IIi11iIi1iiI1
     self . _cvNo += 1
     if self . _cvNo == OOoO0OoOOo0O :
      self . _cvNo = - 1
     self . _train ( buildNo = buildNo )
     if 91 - 91: i1
     if 67 - 67: I1Ii1I1
  self . _runNo = - 1
  if 23 - 23: i1i1i1111I * IiIIii11Ii - Ii
 def fullModelTrain ( self ) :
  if 79 - 79: OooOoo / i1iiIII111 . Iii1i
  if 44 - 44: ooOOO - i1iiIII111 + Iii1i + Ii * oOO % ooo000
  if 13 - 13: oOO . Ii % OooOoo * ooOOO + Iii1i
  if 43 - 43: IIiIIiIi11I1 - IiI11Ii111 * i1iiIII111 . i1iiIII111
  if 40 - 40: Ii - i1iiIII111 . i1I + i1I % I1Ii1I1
  if 64 - 64: IiIIii11Ii
  if 72 - 72: ooOOO - i1 / IiIIii11Ii / Ooo0Ooo * i1iiIII111
  if 87 - 87: oOo0O00 % I11iiIi11i1I * oOO
  if self . restorePath :
   if any ( [ tp . crossValidationType is not None for tp in self . buildConfigs ] ) :
    raise ValueError ( "Train Resuming is not allowed for cross-validating trainings." )
    if 36 - 36: i1iiIII111 + ooOOO + i1 . I1Ii1I1
   o0OoOo = 0
   try :
    with open ( self . restorePath + '/tmpStep.txt' , "r" , encoding = "utf-8" , newline = "" ) as f :
     o0OoOo = f . read ( ) . trim ( )
   except :
    raise ValueError ( "No model is restored from: " + str ( self . restorePath ) )
    if 80 - 80: Ii / i1iiIII111
   self . localStep = self . globalStep = int ( o0OoOo )
   if 52 - 52: Oo
   if 46 - 46: OooOoo - IIiIIiIi11I1
  for O0OooOo0 in range ( 0 , self . runCount ) :
   self . _runNo += 1
   self . globalStep = 0
   if 58 - 58: I1Ii1I1 % Iii1i
   if 19 - 19: ooOOO - iI1iII1I1I1i . IiIIii11Ii - IiIIii11Ii * Ii % i1
   for O0oo , OOoo00ooOo00O in enumerate ( self . buildConfigs ) :
    OOoO0OoOOo0O = OOoo00ooOo00O . validationRuns
    if OOoo00ooOo00O . crossValidationType is None or OOoO0OoOOo0O == 1 :
     self . _train ( buildNo = O0oo )
    else :
     if 2 - 2: I1Ii1I1
     IIi11iIi1iiI1 = self . globalStep
     if 27 - 27: i1i1i1111I + I1I + I1I / I1I + IiIIii11Ii + iI1iII1I1I1i
     if 47 - 47: oOo0O00 . OooOoo * Iii1i
     for ooOo0Oo0O0oOo in range ( 0 , OOoO0OoOOo0O + 1 ) :
      self . globalStep = IIi11iIi1iiI1
      self . _cvNo += 1
      if self . _cvNo == OOoO0OoOOo0O :
       self . _cvNo = - 1
      self . _train ( buildNo = O0oo )
      if 30 - 30: i1 % i1
      if 62 - 62: I11iiIi11i1I . ooo000 + i1I . i1 * Ooo0Ooo
  self . _runNo = - 1
  if 96 - 96: i1iiIII111 - I11iiIi11i1I * oOo0O00 * IIiIIiIi11I1 + i1I - oOo0O00
 def addDataSource ( self , source ) :
  if 11 - 11: Ooo0Ooo % Ooo0Ooo - IiIIii11Ii
  if 14 - 14: i1i1i1111I
  if 82 - 82: Oo . i1i1i1111I % IiI11Ii111 / I11iiIi11i1I
  if 64 - 64: ooo000
  if 78 - 78: i1iiIII111 + ooOOO + oOO
  if 13 - 13: oOo0O00 * oOo0O00
  if 32 - 32: I1Ii1I1 / Iii1i
  if 90 - 90: I11iiIi11i1I * iI1iII1I1I1i - IiIIii11Ii * ooo000 + OooOoo * i1I
  if 49 - 49: oOo0O00 / I1Ii1I1 - i1iiIII111 . I11iiIi11i1I . ooOOO
  if 19 - 19: ooOOO
  source . train = self
  if 45 - 45: Ii
 def setDataSources ( self , * sources ) :
  if 99 - 99: IiI11Ii111
  if 63 - 63: i1iiIII111 / Iii1i / Ii . I1I - i1 / oOO
  if 85 - 85: Iii1i - Ii . i1I - i1i1i1111I . I1I
  if 15 - 15: IiIIii11Ii % ooOOO . OooOoo + IiIIii11Ii . Ooo0Ooo
  if 13 - 13: oOo0O00 - oOO . Oo + IiIIii11Ii % oOo0O00
  if 64 - 64: I11iiIi11i1I - IIiIIiIi11I1 + i1
  if 99 - 99: IiIIii11Ii - Iii1i
  if 80 - 80: i1i1i1111I - oOo0O00 . I11iiIi11i1I / I11iiIi11i1I * I1I
  if 17 - 17: iI1iII1I1I1i / oOo0O00
  if 59 - 59: iI1iII1I1I1i * OooOoo * i1 . oOo0O00 / I1Ii1I1 % I11iiIi11i1I
  for O0oo0 in sources :
   O0oo0 . train = self
   if 79 - 79: Oo . oOO * IIiIIiIi11I1 / IiI11Ii111 - iI1iII1I1I1i
 def getDataSource ( self , sourceID = 0 , colConfigKey = "input" ) :
  if 23 - 23: Ooo0Ooo + Iii1i
  if 15 - 15: i1 % oOO . ooOOO + iI1iII1I1I1i * Iii1i * i1I
  if 39 - 39: OooOoo / i1 + Ooo0Ooo
  if 15 - 15: ooOOO * Ooo0Ooo - oOo0O00 % oOO / oOO / oOO
  if 71 - 71: i1i1i1111I . IiIIii11Ii
  if 38 - 38: oOo0O00 / iI1iII1I1I1i
  if 1 - 1: oOo0O00 / ooOOO / i1iiIII111
  if 86 - 86: i1I * I1Ii1I1
  if 61 - 61: i1 - i1i1i1111I / I11iiIi11i1I . i1i1i1111I + i1
  if 83 - 83: IiI11Ii111 * I1I
  if 73 - 73: ooOOO / IIiIIiIi11I1 / ooOOO % i1 + IIiIIiIi11I1
  if 39 - 39: oOo0O00 / I11iiIi11i1I + oOo0O00 / IiI11Ii111 + i1I
  if 82 - 82: IiI11Ii111 . Iii1i + I11iiIi11i1I / iI1iII1I1I1i
  if 95 - 95: Ii / OooOoo - Ii . Ooo0Ooo / I11iiIi11i1I % IiI11Ii111
  return self . sources [ sourceID ] [ colConfigKey ]
  if 33 - 33: ooo000 . IiIIii11Ii - i1iiIII111
 def getDataPreprocessingNodesUsedByLayers ( self , buildNo : int = 0 , inputOnly : bool = False ) -> List [ 'DataPreprocessing.Node.Conifg' ] :
  if 90 - 90: i1iiIII111
  if 59 - 59: i1iiIII111 % ooOOO / I1I + oOo0O00
  if 50 - 50: oOO + Ii % I1Ii1I1 / OooOoo
  if 45 - 45: I1Ii1I1 - ooo000 + oOo0O00 . ooo000 - I11iiIi11i1I
  if 50 - 50: ooOOO / oOO % Ooo0Ooo / IIiIIiIi11I1 - I1I + i1I
  if 26 - 26: Iii1i / Iii1i * oOo0O00 / ooo000 + ooOOO
  if 64 - 64: Oo . oOo0O00 * ooOOO / Ooo0Ooo * ooOOO
  if 60 - 60: Ii + Iii1i . Ooo0Ooo + ooo000 . I11iiIi11i1I . oOo0O00
  if 49 - 49: iI1iII1I1I1i % iI1iII1I1I1i . Ii
  if 60 - 60: i1I % Ii - IiIIii11Ii % OooOoo / i1
  if 17 - 17: I1Ii1I1 - i1 * Ii + IiI11Ii111 * Oo
  if 2 - 2: I1Ii1I1 - oOO / I11iiIi11i1I
  if 47 - 47: ooo000 . Ii + oOo0O00 % i1i1i1111I / ooo000 . Ii
  if 36 - 36: i1I - IiIIii11Ii / I1Ii1I1 - oOo0O00 / iI1iII1I1I1i
  if 74 - 74: oOo0O00 - i1I - Iii1i * IiI11Ii111 . IIiIIiIi11I1 + oOO
  ooOOO0o : List [ str ] = set ( )
  if 76 - 76: I1I * I1I
  if 14 - 14: ooo000 / I1Ii1I1 . IIiIIiIi11I1 / iI1iII1I1I1i
  for oO0OOOOOOoo in self . modelNodes . values ( ) :
   if 66 - 66: Ooo0Ooo + i1i1i1111I * I11iiIi11i1I * IIiIIiIi11I1
   if len ( oO0OOOOOOoo . fromSource [ buildNo ] ) > 0 :
    ooOOO0o |= set ( oO0OOOOOOoo . fromSource [ buildNo ] )
    if 18 - 18: ooOOO * i1I
    if 94 - 94: i1iiIII111 % oOo0O00 % i1 / I11iiIi11i1I
   if not inputOnly and isinstance ( oO0OOOOOOoo , oOOoo . Task . Config ) :
    oO0OOOOOOoo : oOOoo . Task . Config
    ooOOO0o . add ( oO0OOOOOOoo . lossDppKey )
    if 93 - 93: Ooo0Ooo / i1iiIII111
    if 52 - 52: i1iiIII111 * i1 + Iii1i . i1iiIII111
  return [ self . dppNodes [ dppKey ] for dppKey in ooOOO0o ]
  if 88 - 88: I11iiIi11i1I - IiIIii11Ii
 def getEpochSize ( self , refresh : bool = False ) -> int :
  if 99 - 99: IiIIii11Ii + I1Ii1I1 . i1I * IIiIIiIi11I1 * OooOoo - oOo0O00
  if 65 - 65: I1I . IIiIIiIi11I1
  if 44 - 44: i1iiIII111 - I1I + ooOOO * OooOoo . i1i1i1111I
  if 25 - 25: IiI11Ii111 * i1i1i1111I
  if 34 - 34: I1I
  if 58 - 58: i1I / i1i1i1111I
  if 90 - 90: iI1iII1I1I1i - i1iiIII111 . Ooo0Ooo
  if 44 - 44: IiIIii11Ii - i1 * ooo000 + i1 % OooOoo
  if 68 - 68: I1Ii1I1 % Oo % ooo000 / i1 % i1
  if 87 - 87: OooOoo + Iii1i % ooOOO % IIiIIiIi11I1
  if 48 - 48: Iii1i * IIiIIiIi11I1 . I1Ii1I1
  if 51 - 51: Iii1i - I1Ii1I1
  if 60 - 60: i1i1i1111I / Oo * iI1iII1I1I1i / i1I + IiI11Ii111 + ooo000
  if 52 - 52: oOo0O00 / OooOoo / ooOOO * IiI11Ii111 + IiIIii11Ii % i1I
  OoOo0 = set ( )
  if 51 - 51: Ooo0Ooo - Ooo0Ooo . IiIIii11Ii . Ii
  if 27 - 27: IiIIii11Ii
  for I1 in self . getDataPreprocessingNodesUsedByLayers ( ) :
   OoOo0 . add ( I1 . getEpochSize ( refresh ) )
   if 91 - 91: Oo * i1I
   if 63 - 63: IiIIii11Ii + ooo000
  if len ( OoOo0 ) > 1 :
   raise ValueError ( "Inconsistent epoch sizes of data preprocessing nodes." )
   if 60 - 60: Iii1i . oOO - IiIIii11Ii . I11iiIi11i1I . OooOoo % Oo
   if 60 - 60: Iii1i % Ii - i1I * Oo * ooo000
  return [ * OoOo0 ] [ 0 ]
  if 7 - 7: ooOOO * IIiIIiIi11I1 + ooOOO
 def getLayersUsingSource ( self , sourceID : int = 0 , colConfigKey : str = "input" , buildNo : int = 0 ) :
  if 54 - 54: Iii1i
  if 71 - 71: Iii1i % I11iiIi11i1I
  if 87 - 87: Iii1i
  if 18 - 18: I1Ii1I1 % ooo000 * Ooo0Ooo * IiI11Ii111
  if 73 - 73: IiIIii11Ii % Iii1i
  if 96 - 96: oOO % OooOoo
  if 2 - 2: I1Ii1I1
  if 68 - 68: i1 + i1 . OooOoo
  if 6 - 6: Oo - I1Ii1I1 / ooOOO
  if 30 - 30: ooo000 / Ooo0Ooo / IIiIIiIi11I1 + i1I - OooOoo
  if 58 - 58: ooo000
  if 7 - 7: OooOoo * IiIIii11Ii * ooo000
  if 9 - 9: ooOOO . IIiIIiIi11I1
  if 12 - 12: i1I - Iii1i - i1 / IiI11Ii111
  if 39 - 39: oOo0O00 + I1Ii1I1 . I1I
  return [ l for l in self . modelNodes . values ( ) if any ( [ ( s [ 0 ] == sourceID and s [ 1 ] == colConfigKey ) for s in l . fromSource [ buildNo ] ] ) ]
  if 62 - 62: I1I * i1I
 def createUsingData ( self , rootData : 'Train.RootData' ) -> 'Train.UsingData' :
  if 59 - 59: oOO * OooOoo
  if 10 - 10: Iii1i % IiI11Ii111 . OooOoo + IiI11Ii111 % oOO - I1Ii1I1
  if 56 - 56: Oo % IiIIii11Ii
  if 20 - 20: I11iiIi11i1I * oOO
  if 21 - 21: ooOOO
  if 83 - 83: IIiIIiIi11I1 - I1I - Ii % i1 . ooo000
  if 100 - 100: Ooo0Ooo + I11iiIi11i1I + ooOOO * Ii . ooo000
  if 80 - 80: iI1iII1I1I1i / ooo000
  if 33 - 33: i1I
  if 95 - 95: Oo . Ii % iI1iII1I1I1i % Oo % i1
  if 57 - 57: ooo000 . i1I . i1 - Ii * Oo + i1i1i1111I
  if 40 - 40: Iii1i - I11iiIi11i1I - Ooo0Ooo / i1i1i1111I * oOO
  if 41 - 41: i1I + I11iiIi11i1I - Oo / Oo + OooOoo
  return iII11 . UsingData ( self , rootData )
  if 62 - 62: OooOoo % iI1iII1I1I1i + Oo
 def createUsingDataByShow ( self , rootData : 'Train.RootData' ) -> 'Train.UsingData' :
  oOII1III = iII11 . UsingShowData ( self , rootData )
  if 32 - 32: i1i1i1111I + IiI11Ii111 * IIiIIiIi11I1 - i1 . i1i1i1111I
  if 17 - 17: IIiIIiIi11I1 / Ii . IIiIIiIi11I1 - IiI11Ii111
  if 45 - 45: IIiIIiIi11I1
  if 71 - 71: OooOoo . I11iiIi11i1I + i1i1i1111I . Ii
  if 7 - 7: Oo % IiIIii11Ii + ooo000 - iI1iII1I1I1i
  if 49 - 49: IiIIii11Ii + oOO / Oo . i1I + IiIIii11Ii
  if 88 - 88: iI1iII1I1I1i - Oo / Oo . Oo
  if 76 - 76: Iii1i / Ooo0Ooo * Iii1i + IiI11Ii111
  if 69 - 69: OooOoo . I11iiIi11i1I * ooOOO % IiI11Ii111
  if 51 - 51: i1iiIII111 . I1I + Oo
  if 46 - 46: ooo000
  if 66 - 66: Ooo0Ooo + i1I + IIiIIiIi11I1 . I1I - Oo
  if 86 - 86: Ii / OooOoo - oOo0O00 - i1
  return iII11 . UsingShowData ( self , rootData )
  if 20 - 20: OooOoo / i1i1i1111I . ooOOO * I1I + Ooo0Ooo
 def getOutputTensor ( self , name : str ) -> 'tf.Tensor' :
  if 34 - 34: i1i1i1111I * i1iiIII111 / oOo0O00
  if 27 - 27: oOo0O00 * ooOOO + IiI11Ii111 % Oo
  if 18 - 18: oOO - i1 + Ii
  if 18 - 18: i1I
  if 86 - 86: oOo0O00 - ooOOO
  if 78 - 78: Iii1i - Oo . oOo0O00 . Ooo0Ooo
  if 98 - 98: OooOoo - Iii1i * I1Ii1I1
  if 2 - 2: i1iiIII111 % i1iiIII111 * Oo % ooOOO
  if 73 - 73: I1I - I1Ii1I1 / Oo % ooo000 * i1iiIII111
  if 20 - 20: Iii1i
  if 95 - 95: ooOOO . IiI11Ii111 * iI1iII1I1I1i . Ooo0Ooo * Ooo0Ooo
  if 63 - 63: ooOOO
  if 20 - 20: IIiIIiIi11I1 + IiIIii11Ii . I11iiIi11i1I - Iii1i
  if name not in self . modelNodes :
   raise ValueError ( "Requested layer is not within this train object." )
   if 50 - 50: Iii1i + I1Ii1I1 . Oo * oOO
  return self . modelNodes [ name ] . _outputTensor
  if 52 - 52: I1I / oOo0O00 - IiIIii11Ii
 def getInputSources ( self , buildNo : int = 0 ) :
  if 47 - 47: IiIIii11Ii / OooOoo + ooo000 / IiIIii11Ii
  if 93 - 93: Ooo0Ooo
  if 29 - 29: oOo0O00
  if 33 - 33: ooo000
  if 60 - 60: I11iiIi11i1I / i1I + i1iiIII111 + IiIIii11Ii / OooOoo * i1iiIII111
  if 53 - 53: Oo * i1 . IiI11Ii111 - ooo000 . OooOoo * I11iiIi11i1I
  if 100 - 100: iI1iII1I1I1i * Ii + I11iiIi11i1I * IiIIii11Ii - Ii
  if 53 - 53: I11iiIi11i1I % i1iiIII111
  if 84 - 84: I1I / OooOoo * IiI11Ii111 * IiIIii11Ii - Iii1i
  if 18 - 18: Oo * ooo000 . IIiIIiIi11I1 % i1 + Ooo0Ooo
  if 38 - 38: iI1iII1I1I1i - I1I - i1iiIII111 . Ooo0Ooo % oOO
  if 26 - 26: Ii + oOO
  if 19 - 19: oOO
  return functools . reduce ( lambda OOoo00ooOo00O , oOO0OooooooO : OOoo00ooOo00O + oOO0OooooooO , [ l . fromSource [ buildNo ] for l in self . modelNodes . values ( ) if len ( l . fromSource [ buildNo ] ) > 0 ] )
  if 11 - 11: i1iiIII111 . i1i1i1111I
 def updateLayerOrder ( self , layerProfile : 'ModelNode.Layer.Config' , buildNo : int = 0 ) :
  if 47 - 47: i1I
  if 36 - 36: OooOoo + I11iiIi11i1I % Ii . Ii
  if 53 - 53: i1 % IiI11Ii111
  if 94 - 94: Ii / I1Ii1I1 . IIiIIiIi11I1 * Ooo0Ooo - Ii
  if 19 - 19: i1 + i1i1i1111I
  if 45 - 45: IiI11Ii111 + IiIIii11Ii + i1i1i1111I * i1i1i1111I
  if 30 - 30: ooo000 / ooo000 . Iii1i
  if 63 - 63: Oo * i1i1i1111I / i1i1i1111I / ooOOO
  if 26 - 26: I1I - i1iiIII111 / i1 - i1
  if 58 - 58: i1iiIII111 / IiI11Ii111 * ooo000 / iI1iII1I1I1i - Iii1i + I1I
  if 11 - 11: Iii1i . Ii / Iii1i
  layerProfile . _updateOrder ( buildNo = buildNo )
  if not layerProfile . _final :
   for o0OoOOOOO00O in [ o0OoOOOOO00O for o0OoOOOOO00O in self . modelNodes . values ( ) if o0OoOOOOO00O . _final ] :
    o0OoOOOOO00O . updateOrder ( buildNo = buildNo )
    if 96 - 96: iI1iII1I1I1i - Ii / Iii1i . iI1iII1I1I1i
 def getEndingNodes ( self , buildNo : int = 0 ) :
  if 25 - 25: I1Ii1I1 - i1
  if 93 - 93: Iii1i / Iii1i / IiI11Ii111
  if 44 - 44: OooOoo . iI1iII1I1I1i + i1i1i1111I + I1Ii1I1 * i1iiIII111 - ooOOO
  if 31 - 31: ooOOO + ooo000 / IiI11Ii111 % i1I
  if 65 - 65: Iii1i + I1I % iI1iII1I1I1i
  if 32 - 32: iI1iII1I1I1i * IiI11Ii111 - i1I % Ooo0Ooo + i1I . I1Ii1I1
  if 38 - 38: Ii + Iii1i . ooOOO . I1Ii1I1
  if 22 - 22: OooOoo
  if 16 - 16: IiIIii11Ii % Ooo0Ooo / i1iiIII111
  if 34 - 34: i1iiIII111 / I1Ii1I1 % IiI11Ii111
  if 49 - 49: IiI11Ii111 / Ooo0Ooo - oOo0O00
  if 19 - 19: i1 * ooOOO
  if 14 - 14: ooOOO - i1I / Oo - Ooo0Ooo . i1i1i1111I * Oo
  return [ l for l in self . modelNodes . values ( ) if len ( l . toNode [ buildNo ] ) == 0 ]
  if 93 - 93: oOo0O00 * I1I / IiI11Ii111 * i1i1i1111I / I1I + oOo0O00
 def getFinalNodes ( self , buildNo : int = 0 ) :
  if 28 - 28: I11iiIi11i1I * I11iiIi11i1I / i1iiIII111 % oOo0O00 / OooOoo
  if 54 - 54: i1i1i1111I . IiIIii11Ii
  if 57 - 57: ooOOO % i1I . Iii1i * i1iiIII111
  if 82 - 82: Ooo0Ooo * Iii1i % iI1iII1I1I1i / I1I . i1I
  if 1 - 1: I11iiIi11i1I - oOO / Oo + OooOoo
  if 89 - 89: Oo - i1i1i1111I
  if 15 - 15: IiI11Ii111 - IIiIIiIi11I1
  if 74 - 74: Iii1i % ooo000
  if 95 - 95: IiI11Ii111
  if 100 - 100: Oo
  if 96 - 96: OooOoo + Ooo0Ooo + oOo0O00
  if 77 - 77: IIiIIiIi11I1 * IIiIIiIi11I1 - I11iiIi11i1I + IiIIii11Ii % ooOOO
  if 33 - 33: I1I . i1i1i1111I
  return [ l for l in self . modelNodes . values ( ) if l . isFinal ( ) and len ( [ * l . fromSource [ buildNo ] , * l . fromNode [ buildNo ] ] ) > 0 ]
  if 59 - 59: IiIIii11Ii
 def getNewLayerName ( self , layerProfile : 'ModelNode.Layer.Config' ) :
  if 87 - 87: IiIIii11Ii % ooo000 / oOo0O00 - IIiIIiIi11I1 + iI1iII1I1I1i
  if 50 - 50: i1 / IiIIii11Ii . I1I . i1iiIII111 . Ii . Ii
  if 96 - 96: i1i1i1111I
  if 2 - 2: i1iiIII111 / I1Ii1I1 / oOO + i1 . Ooo0Ooo % I1I
  if 88 - 88: IIiIIiIi11I1 . IIiIIiIi11I1
  if 97 - 97: i1 / Ii . iI1iII1I1I1i * Oo
  if 86 - 86: I11iiIi11i1I - I11iiIi11i1I / oOO
  if 12 - 12: OooOoo . oOo0O00 + oOO + Ii / ooo000
  if 23 - 23: iI1iII1I1I1i . IiI11Ii111 / I1Ii1I1 * I1Ii1I1 * Ii / Ooo0Ooo
  if 48 - 48: IIiIIiIi11I1
  layerProfile . name = "Layer" + str ( self . getNewLayerID ( ) )
  if 59 - 59: oOo0O00 / i1i1i1111I . Ii - i1 * I11iiIi11i1I
 def switchOffWeightLogging ( self , * layerProfiles : Union [ str , 'ModelNode.Layer.Config' ] ) :
  if 100 - 100: oOO + I11iiIi11i1I - IIiIIiIi11I1 . IIiIIiIi11I1 + i1i1i1111I % ooOOO
  if 41 - 41: OooOoo + Ii
  if 86 - 86: i1I . i1
  if 87 - 87: i1i1i1111I * IiIIii11Ii / I11iiIi11i1I
  if 15 - 15: Ii % Oo * ooo000 - IIiIIiIi11I1 + Oo
  if 82 - 82: oOo0O00 % Ii + i1I + i1i1i1111I
  if 38 - 38: I11iiIi11i1I % IIiIIiIi11I1 * IiIIii11Ii / i1iiIII111 * I1Ii1I1 + OooOoo
  if 88 - 88: iI1iII1I1I1i / oOo0O00
  if 17 - 17: I1Ii1I1 / OooOoo + I1Ii1I1
  if 32 - 32: Ooo0Ooo . i1I
  for o0OoOOOOO00O in layerProfiles :
   if isinstance ( o0OoOOOOO00O , oOOoo . Config ) :
    o0OoOOOOO00O . switchOffWeightLogging ( )
   elif isinstance ( o0OoOOOOO00O , str ) or str ( o0OoOOOOO00O ) :
    self . modelNodes [ str ( o0OoOOOOO00O ) ] . switchOffWeightLogging ( )
   else :
    raise ValueError ( "Layer profiles in Train.switchOffWeightLogging() should be a string or LayerProject object." )
    if 7 - 7: Ooo0Ooo % Ii . i1iiIII111 % Ii
 def appendNode ( self , layerProfile : 'ModelNode.Layer.Config' , appendAt : Union [ int , str , 'ModelNode.Layer.Config' , 'DataPreprocessing.Node.Config' ] = None , buildNo : int = 0 ) :
  if 80 - 80: I1I
  if 86 - 86: Oo
  if 71 - 71: OooOoo * I1Ii1I1 . I11iiIi11i1I * oOo0O00
  if 10 - 10: ooOOO + I11iiIi11i1I / i1i1i1111I . oOO % iI1iII1I1I1i
  if 18 - 18: IiI11Ii111 % IIiIIiIi11I1 / iI1iII1I1I1i - I1Ii1I1
  if 51 - 51: oOo0O00 % I11iiIi11i1I . oOO
  if 25 - 25: i1iiIII111 % i1 - IIiIIiIi11I1 / Oo
  if 36 - 36: i1i1i1111I . I11iiIi11i1I * i1I
  if 42 - 42: IiI11Ii111 + Iii1i / Iii1i * IiIIii11Ii
  if 23 - 23: I1I * I11iiIi11i1I / ooOOO + I11iiIi11i1I / ooo000 % i1
  if 92 - 92: oOO + Oo
  if 35 - 35: ooo000
  if 97 - 97: oOo0O00 - Ii + oOO - Ooo0Ooo
  if 35 - 35: IiI11Ii111
  if 59 - 59: iI1iII1I1I1i - ooOOO - Oo - oOo0O00
  if 23 - 23: I1Ii1I1 - ooOOO
  if layerProfile . name in self . modelNodes :
   raise ValueError ( "This layer exists in the model already." )
   if 34 - 34: i1i1i1111I . oOO % ooo000 / I1I / Iii1i
  elif layerProfile . train is not None :
   raise ValueError ( "This layer is in another model." )
   if 65 - 65: i1
   if 52 - 52: oOo0O00 % iI1iII1I1I1i - i1iiIII111
  if layerProfile . name is None :
   self . getNewLayerName ( layerProfile )
   if 62 - 62: IiIIii11Ii % oOo0O00
   if 8 - 8: OooOoo * Ii - Oo + Oo + iI1iII1I1I1i
  if appendAt is None :
   I1iiiI11iI1iI = self . getEndingNodes ( buildNo = buildNo )
   if 8 - 8: OooOoo . I1Ii1I1 + ooOOO * IiI11Ii111 + i1I % oOo0O00
   if len ( I1iiiI11iI1iI ) == 1 :
    I1iiiI11iI1iI [ 0 ] . appendNode ( layerProfile , buildNo = buildNo )
    if 57 - 57: i1iiIII111 * ooo000 . Oo / IiIIii11Ii * oOO
   elif len ( I1iiiI11iI1iI ) == 0 and len ( self . dppNodes ) == 1 :
    layerProfile . addSources ( ( self . dppNodes [ "input" ] if "input" in self . dppNodes else [ * self . dppNodes . values ( ) ] [ 0 ] ) , clear = True , buildNo = buildNo )
    if 49 - 49: IiIIii11Ii % i1
   else :
    raise ValueError ( "Layer cannot be appended to multiple previous outputs." )
    if 22 - 22: I1I / i1I . ooo000 . ooOOO + IIiIIiIi11I1 - IIiIIiIi11I1
    if 51 - 51: I1Ii1I1 % OooOoo % Ii + i1iiIII111 - oOo0O00
  elif O0oO ( appendAt ) in [ "str" , "String" ] :
   if 22 - 22: OooOoo
   if str ( appendAt ) not in self . modelNodes :
    raise ValueError ( "The previous layer (" + str ( appendAt ) + ") is not in this training model." )
    if 5 - 5: i1iiIII111 % i1
    if 28 - 28: Iii1i % I1I
   self . modelNodes [ str ( appendAt ) ] . appendNode ( layerProfile , buildNo = buildNo )
   if 100 - 100: I1Ii1I1 % oOo0O00 + I1Ii1I1 * oOo0O00 + Ooo0Ooo * ooo000
   if 20 - 20: i1I % I11iiIi11i1I - I1I % ooo000 . Ooo0Ooo
  elif isinstance ( appendAt , oOOoo . Config ) :
   if 81 - 81: I1Ii1I1 * ooOOO
   if appendAt . name is None :
    raise ValueError ( "The previous layer is not in any training models." )
   elif appendAt . name not in self . modelNodes :
    raise ValueError ( "The previous layer " + appendAt . name + " is not in this training models." )
    if 45 - 45: Ooo0Ooo * Iii1i * I11iiIi11i1I + i1iiIII111 % IIiIIiIi11I1
    if 59 - 59: Iii1i + oOO * oOo0O00 % i1iiIII111 / Oo
   appendAt . appendNode ( layerProfile , buildNo = buildNo )
   if 11 - 11: IiI11Ii111
   if 82 - 82: i1I / IiI11Ii111 + IiI11Ii111 % ooo000 + IIiIIiIi11I1
  elif O0oO ( appendAt ) in [ "int" ] or isinstance ( appendAt , OO0O0 . Config ) :
   if 94 - 94: OooOoo / Ii - Iii1i % oOO * Ooo0Ooo
   if isinstance ( appendAt , OO0O0 . Config ) and ( appendAt . train != self ) :
    raise ValueError ( "The previous column config is not in this training models." )
    if 55 - 55: Ii
   layerProfile . addSources ( appendAt , clear = True , buildNo = buildNo )
   if 45 - 45: Iii1i + IiIIii11Ii - Ooo0Ooo - I1Ii1I1 * i1I - Ooo0Ooo
   if 84 - 84: Oo
  else :
   raise ValueError ( "`appendAt` parameter should be either a string (previous layer name), an integer (a data source index), a ModelNode.Layer.Config object (previous layer profile), or a DataPreprocessing.Node.Config object (a data source input data)." )
   if 22 - 22: i1I - OooOoo / I1Ii1I1 / IIiIIiIi11I1 . oOo0O00
   if 19 - 19: i1iiIII111 / IIiIIiIi11I1 - i1I % I1Ii1I1 % IIiIIiIi11I1
  layerProfile . train = self
  self . modelNodes [ layerProfile . name ] = layerProfile
  if 54 - 54: IIiIIiIi11I1 - iI1iII1I1I1i . Ii + I11iiIi11i1I - IIiIIiIi11I1 . ooOOO
  return self
  if 4 - 4: oOO / i1iiIII111 + oOo0O00 / i1iiIII111
 def appendRepeatedLayers ( self , layerProfile , appendAt = None , repeatedCount = 0 , buildNo : int = 0 ) :
  if 23 - 23: ooOOO . i1i1i1111I . iI1iII1I1I1i
  if 57 - 57: Ii * i1I + i1 . Ooo0Ooo * oOO . i1iiIII111
  if 50 - 50: Iii1i / oOO . Oo - oOo0O00 . i1iiIII111 * Oo
  if 96 - 96: OooOoo - OooOoo - IiIIii11Ii - IiI11Ii111
  if 49 - 49: Ooo0Ooo
  if 26 - 26: I1Ii1I1 . OooOoo / I1I
  if 9 - 9: OooOoo / IiIIii11Ii / oOo0O00
  if 69 - 69: i1i1i1111I
  if 35 - 35: Ii - Oo % oOo0O00 * iI1iII1I1I1i + I11iiIi11i1I
  if 46 - 46: Iii1i % i1iiIII111
  if 85 - 85: ooOOO % i1i1i1111I . i1 / OooOoo
  if 72 - 72: oOO + oOo0O00
  if 15 - 15: i1I
  if 26 - 26: oOO . I11iiIi11i1I + Iii1i / Oo
  if 69 - 69: i1iiIII111 - IiIIii11Ii + I1I
  if 40 - 40: OooOoo - IiIIii11Ii
  if 64 - 64: Iii1i * I1I * oOo0O00 * OooOoo - oOO * OooOoo
  if layerProfile . _final :
   raise ValueError ( "Task Layers cannot be repeated appended." )
   if 35 - 35: ooo000 - I1I % i1i1i1111I
  elif layerProfile . name in self . modelNodes or any ( [ re . search ( layerProfile . name + "R[0-9]+" , l . name ) for l in self . modelNodes ] ) :
   raise ValueError ( "This layer exists in the model already." )
   if 95 - 95: Oo * i1i1i1111I
  elif layerProfile . train is not None :
   raise ValueError ( "This layer is in another model." )
   if 85 - 85: i1I - i1
   if 16 - 16: OooOoo * IIiIIiIi11I1 - I1I
  if layerProfile . name is None :
   self . getNewLayerName ( layerProfile )
   if 87 - 87: Oo % i1iiIII111 . i1
   if 39 - 39: I1I . I1Ii1I1
  o0O0oOO0 = repeatedCount
  if 11 - 11: i1iiIII111 * i1 % Oo
  if 6 - 6: OooOoo
  while repeatedCount >= 0 :
   if 24 - 24: oOO * i1I / Iii1i - i1iiIII111 - Oo
   i1i11 = layerProfile . name + "R" + str ( o0O0oOO0 - repeatedCount + 1 )
   o0OoOOOOO00O = layerProfile . copy ( i1i11 )
   if 24 - 24: ooOOO + OooOoo % ooOOO * I1Ii1I1 + i1I + i1i1i1111I
   self . appendNode ( o0OoOOOOO00O , appendAt = appendAt , buildNo = buildNo )
   appendAt = o0OoOOOOO00O
   if 73 - 73: ooo000 + Ooo0Ooo / IIiIIiIi11I1 / i1iiIII111 * Ooo0Ooo
 def attachNode ( self , layerProfile : Union [ str , 'ModelNode.Layer.Config' ] , * layerOrSources : Union [ str , 'ModelNode.Layer.Config' , int , Tuple [ int , str ] , 'DataPreprocessing.Node.Config' ] , buildNo : int = 0 ) :
  if 21 - 21: i1i1i1111I * Oo / Ooo0Ooo / OooOoo
  if 81 - 81: i1i1i1111I
  if 63 - 63: oOo0O00 - I1I * ooOOO + iI1iII1I1I1i - OooOoo
  if 71 - 71: i1I - i1iiIII111 * OooOoo * OooOoo * iI1iII1I1I1i % i1
  if 49 - 49: iI1iII1I1I1i * i1I
  if 18 - 18: Iii1i / Oo * iI1iII1I1I1i / oOO - IiIIii11Ii % oOO
  if 17 - 17: IiIIii11Ii / i1
  if 37 - 37: ooo000 / oOo0O00
  if 38 - 38: i1i1i1111I . i1 . OooOoo * i1
  if 42 - 42: I1Ii1I1
  if 12 - 12: Oo + OooOoo
  if 39 - 39: IiIIii11Ii * IiI11Ii111 % Ii * iI1iII1I1I1i / i1
  if 85 - 85: Ooo0Ooo - Iii1i - Ooo0Ooo % i1I
  if len ( layerOrSources ) == 0 :
   raise ValueError ( "This layer must attach to at least one precedent source or layer." )
   if 84 - 84: Ii / oOO - Ii
  elif layerProfile . name in self . modelNodes :
   raise ValueError ( "This layer exists in the model already." )
   if 18 - 18: OooOoo % IIiIIiIi11I1 % Iii1i . i1 + I1I . i1i1i1111I
  elif layerProfile . train is not None :
   raise ValueError ( "This layer is in another model." )
   if 50 - 50: IiI11Ii111 / i1 / i1i1i1111I
   if 99 - 99: Ooo0Ooo . i1I
  if layerProfile . name == None :
   self . getNewLayerName ( layerProfile )
   if 9 - 9: I11iiIi11i1I * I11iiIi11i1I
   if 85 - 85: I1I + Iii1i / I11iiIi11i1I % ooOOO % IIiIIiIi11I1 + IiI11Ii111
  layerProfile . train = self
  if 37 - 37: ooo000 . Iii1i - Iii1i + Iii1i
  if 50 - 50: I1Ii1I1 - i1 - i1iiIII111 - OooOoo * Iii1i
  for Iii1II in layerOrSources :
   if 83 - 83: IIiIIiIi11I1 * oOo0O00 + IiIIii11Ii . i1i1i1111I / IiI11Ii111
   if isinstance ( Iii1II , oOOoo . Config ) :
    if 35 - 35: IiI11Ii111
    if Iii1II not in self . modelNodes :
     raise ValueError ( "The previous layer (" + Iii1II + ") is not in this training model." )
    elif isinstance ( Iii1II , oOOoo . Config ) :
     if Iii1II . name is None :
      raise ValueError ( "The previous layer is not in any training models." )
     elif Iii1II . name not in self . modelNodes :
      raise ValueError ( "The previous layer " + Iii1II . name + " is not in this training models." )
      if 49 - 49: ooOOO % IiIIii11Ii % i1 % ooo000
      if 66 - 66: ooOOO / i1 * I1I + I11iiIi11i1I . I1Ii1I1 . i1i1i1111I
    i1iIII1I1iiI = self . modelNodes [ Iii1II ] if O0oO ( Iii1II ) == "str" else Iii1II
    i1iIII1I1iiI . appendNode ( layerProfile , buildNo = buildNo )
    if 86 - 86: i1 + Ooo0Ooo % Ii
    if 62 - 62: I1I . Oo
   else :
    if 56 - 56: IiIIii11Ii % i1I
    if isinstance ( Iii1II , OO0O0 . Config ) and ( Iii1II . train != self ) :
     raise ValueError ( "The previous column config is not in this training models." )
     if 15 - 15: I11iiIi11i1I
     if 80 - 80: i1i1i1111I - oOo0O00 % I1I % I1Ii1I1 / IIiIIiIi11I1
    layerProfile . addSources ( Iii1II , buildNo = buildNo )
    if 76 - 76: IIiIIiIi11I1 . oOO
    if 25 - 25: Ii
  self . updateLayerOrder ( layerProfile , buildNo = buildNo )
  self . modelNodes [ layerProfile . name ] = layerProfile
  if 56 - 56: I1I + IiIIii11Ii / IIiIIiIi11I1 - OooOoo
 def appendNodes ( self , appendAt : Optional [ Union [ int , str , 'ModelNode.Layer.Config' , 'DataPreprocessing.Node.Config' ] ] = None , * layerProfiles : List [ 'ModelNode.Layer.Config' ] , buildNo : int = 0 ) :
  if 21 - 21: oOO / IiI11Ii111 / I11iiIi11i1I
  if 72 - 72: ooOOO / i1I . Oo . ooo000 . Iii1i
  if 80 - 80: oOo0O00
  if 45 - 45: IiI11Ii111 . i1I
  if 52 - 52: I1I + iI1iII1I1I1i . i1iiIII111
  if 30 - 30: i1iiIII111 . IIiIIiIi11I1 * ooo000 - oOO % Ii + Ii
  if 89 - 89: iI1iII1I1I1i
  if 26 - 26: IiI11Ii111 * Iii1i . IIiIIiIi11I1
  if 39 - 39: Oo
  if 82 - 82: Ooo0Ooo / ooo000
  if 49 - 49: OooOoo % i1iiIII111 - I11iiIi11i1I
  if 23 - 23: Ooo0Ooo
  if 32 - 32: i1i1i1111I - i1i1i1111I - iI1iII1I1I1i % I11iiIi11i1I
  if 74 - 74: IiIIii11Ii - i1I / i1I
  if 3 - 3: Ooo0Ooo / iI1iII1I1I1i * oOO
  if 93 - 93: ooo000 . i1i1i1111I
  O000O0O0 = [ * reversed ( [ appendAt , * [ oO0OOOOOOoo . name for oO0OOOOOOoo in layerProfiles ] ] [ : - 1 ] ) ]
  if 26 - 26: Ii - OooOoo - Oo + I1I
  if 84 - 84: ooOOO + i1iiIII111
  for oO0OOOOOOoo in enumerate ( layerProfiles ) :
   self . appendNode ( oO0OOOOOOoo , appendAt = O000O0O0 . pop ( ) , buildNo = buildNo )
   if 26 - 26: Ii - IIiIIiIi11I1 - i1iiIII111 + Ooo0Ooo
  return self
  if 20 - 20: I1Ii1I1 % I1I
 def appendBasicLayers ( self , hiddenUnitCounts : Tuple [ int ] = 100 , activation : 'Train.Activation' = iI11II1 . Relu , appendAt : Optional [ 'ModelNode.Layer.Config' ] = None , buildNo : int = 0 ) :
  if 61 - 61: I1Ii1I1 * IIiIIiIi11I1 - IiI11Ii111
  if 57 - 57: I11iiIi11i1I % Iii1i - Ooo0Ooo
  if 37 - 37: i1i1i1111I % i1 * I1Ii1I1
  if 7 - 7: i1 / i1iiIII111 - IiIIii11Ii * iI1iII1I1I1i % iI1iII1I1I1i - ooo000
  if 2 - 2: iI1iII1I1I1i
  if 22 - 22: i1i1i1111I * oOO % i1i1i1111I / I11iiIi11i1I % IiI11Ii111 / Ooo0Ooo
  if 17 - 17: Ooo0Ooo
  if 44 - 44: Ooo0Ooo - I11iiIi11i1I % I11iiIi11i1I % I1I % i1 * iI1iII1I1I1i
  if 46 - 46: ooo000 * i1i1i1111I * I11iiIi11i1I . I1Ii1I1
  if 81 - 81: Iii1i
  if 86 - 86: IIiIIiIi11I1 % i1i1i1111I % i1iiIII111
  if 29 - 29: I1Ii1I1 * i1iiIII111 + ooOOO / i1i1i1111I - Ooo0Ooo
  if 76 - 76: Ii . ooOOO + Iii1i
  IiII = appendAt
  for O0O00oOoO in hiddenUnitCounts :
   I1IIIII1I1i111 = "Basic" + str ( self . getNewLayerID ( ) )
   self . appendNode ( oOOoo . FullyConnected ( layerUnits = O0O00oOoO , name = I1IIIII1I1i111 , activation = activation ) , appendAt = IiII , buildNo = buildNo )
   IiII = I1IIIII1I1i111
  return self
  if 39 - 39: iI1iII1I1I1i + OooOoo - ooOOO
 def appendSymmetricLayers ( self , buildNo : int = 0 ) :
  if 31 - 31: ooOOO + ooOOO
  if 67 - 67: OooOoo + i1I / Iii1i
  if 89 - 89: IIiIIiIi11I1 % i1I
  if 65 - 65: Ooo0Ooo / IIiIIiIi11I1 * i1
  if 56 - 56: OooOoo % oOo0O00 % i1I / IiI11Ii111 % IIiIIiIi11I1
  if 10 - 10: Ii + i1
  if 25 - 25: IIiIIiIi11I1 % oOO * OooOoo
  if 85 - 85: ooOOO % IIiIIiIi11I1 / IiIIii11Ii + Oo - I11iiIi11i1I
  if 34 - 34: OooOoo - I1Ii1I1 . IiI11Ii111 % i1iiIII111 / i1I
  if 70 - 70: Ooo0Ooo + i1I
  if 50 - 50: oOO % i1i1i1111I + I1I
  if 73 - 73: I1Ii1I1 . iI1iII1I1I1i
  if 92 - 92: ooo000 % Iii1i
  if 18 - 18: I1I - i1iiIII111 . Ooo0Ooo + I1I
  I1iiiI11iI1iI = self . getEndingNodes ( buildNo = buildNo )
  if 77 - 77: oOO % Oo % i1i1i1111I - Ii % IiIIii11Ii
  if 68 - 68: Oo
  if len ( I1iiiI11iI1iI ) != 1 :
   raise ValueError ( "Symmetric Layer Creation only allows for a single final layer scenario." )
  elif isinstance ( I1iiiI11iI1iI [ 0 ] , oOOoo . Task . Config ) :
   raise ValueError ( "Symmetric Layer Creation can't be stacked on ModelNode.Layer.Task.Config objects." )
   if 25 - 25: i1I - IIiIIiIi11I1
   if 35 - 35: i1i1i1111I . Ii
  o00 = I1iiiI11iI1iI
  i1i111iI1I1Iii1 = [ oO0OOOOOOoo . name for oO0OOOOOOoo in o00 ]
  o0oOoOO = { ln : ( True if ln in i1i111iI1I1Iii1 else False ) for ln in self . modelNodes . keys ( ) }
  if 41 - 41: Oo
  if 27 - 27: I1I - IIiIIiIi11I1 * IIiIIiIi11I1 * ooOOO / oOO
  for oO0OOOOOOoo in o00 :
   oO0OOOOOOoo . setSymmetricLayer ( o0oOoOO , startFromThis = True , buildNo = buildNo )
   if 100 - 100: Ii + iI1iII1I1I1i * Ooo0Ooo / I1I
  return self
  if 54 - 54: ooOOO
 def addEventListener ( self , eventName , ftn ) :
  if 1 - 1: i1iiIII111 / ooOOO / Iii1i * oOO
  if 21 - 21: Ooo0Ooo . IiI11Ii111 % i1iiIII111
  if 13 - 13: IiIIii11Ii / i1 / oOO
  if 40 - 40: oOo0O00 - i1 . oOO
  if 81 - 81: i1i1i1111I + IIiIIiIi11I1 - Oo + oOO . I1Ii1I1 + I11iiIi11i1I
  if 59 - 59: oOO / oOo0O00 / iI1iII1I1I1i % iI1iII1I1I1i
  if 42 - 42: Iii1i / IiI11Ii111
  if 99 - 99: Iii1i
  if 57 - 57: IiI11Ii111
  if 60 - 60: oOo0O00 . Oo - oOO * IiIIii11Ii * Ii
  if 62 - 62: oOo0O00 / Ii % i1iiIII111 / Ii
  self . _eventFtns [ eventName ] . append ( ftn )
  if 54 - 54: I1I - iI1iII1I1I1i
 def removeEventListener ( self , eventName , ftn ) :
  if 7 - 7: IiIIii11Ii % Iii1i + ooOOO + oOo0O00
  if 90 - 90: IiIIii11Ii + iI1iII1I1I1i / I1I
  if 12 - 12: OooOoo / OooOoo
  if 67 - 67: i1i1i1111I + IiI11Ii111 / IIiIIiIi11I1 % Ooo0Ooo * IiIIii11Ii
  if 94 - 94: i1iiIII111 / IIiIIiIi11I1 + I11iiIi11i1I + oOo0O00 % iI1iII1I1I1i * Iii1i
  if 99 - 99: OooOoo % IIiIIiIi11I1 . Ooo0Ooo - I1Ii1I1 / IIiIIiIi11I1 * i1i1i1111I
  if 47 - 47: i1i1i1111I . Oo * IIiIIiIi11I1 / i1i1i1111I - Iii1i
  if 62 - 62: i1I
  if 47 - 47: Oo * ooo000 + I11iiIi11i1I / Oo
  if 85 - 85: i1i1i1111I . iI1iII1I1I1i % i1I * Oo - OooOoo % Iii1i
  if 69 - 69: Iii1i + Ii . Ooo0Ooo / oOo0O00 * IiI11Ii111 / Oo
  if 43 - 43: IiIIii11Ii * I11iiIi11i1I . Ii - iI1iII1I1I1i
  if ftn in self . _eventFtns [ eventName ] :
   self . _eventFtns [ eventName ] . pop ( self . _eventFtns [ eventName ] . index ( ftn ) )
   if 75 - 75: IIiIIiIi11I1 - I11iiIi11i1I + oOo0O00 + Iii1i + iI1iII1I1I1i . Ii
 def get_batch_data ( self ) :
  if 99 - 99: i1iiIII111 * I1I % IiI11Ii111 + oOo0O00
  if 84 - 84: I11iiIi11i1I * iI1iII1I1I1i / ooo000 - IiIIii11Ii
  if 34 - 34: Oo * i1 % Ii
  if 59 - 59: ooo000 / Oo + IIiIIiIi11I1 / i1I * IiI11Ii111
  if 34 - 34: oOo0O00 + Ooo0Ooo + OooOoo * IiIIii11Ii * IiIIii11Ii
  if 56 - 56: IiIIii11Ii / i1iiIII111 - oOO + oOo0O00 / Iii1i / IiIIii11Ii
  if 23 - 23: IiI11Ii111
  OoOooooo = [ ]
  for O0oOoOOO , O0oo0 in enumerate ( self . sources ) :
   O0iIiiIiiiIiiI = { }
   for oo00OOOO , IIi11ii1IIi in next ( O0oo0 . trainset ) . items ( ) :
    O0iIiiIiiiIiiI [ oo00OOOO ] = IIi11ii1IIi
   OoOooooo . append ( O0iIiiIiiiIiiI )
  return OoOooooo
  if 72 - 72: i1
 def create_model_file ( self , buildNo = 0 ) :
  if 43 - 43: i1iiIII111
  if 53 - 53: oOO * Ooo0Ooo / I1I * oOO / Ii / iI1iII1I1I1i
  if 2 - 2: I1Ii1I1 - Ii . iI1iII1I1I1i . oOO
  if 13 - 13: Oo * Iii1i . IiI11Ii111 * oOo0O00
  if 72 - 72: Iii1i - OooOoo
  if 74 - 74: Oo / I1Ii1I1 / Oo
  if 46 - 46: i1i1i1111I / ooo000 + IiIIii11Ii + I1Ii1I1 % Ooo0Ooo
  if 53 - 53: IiI11Ii111 % ooOOO
  if 58 - 58: i1
  if 9 - 9: oOO / OooOoo
  self . model_file = open ( 'keras_model.py' , 'w' )
  if 82 - 82: OooOoo % ooOOO
  self . model_file . write ( 'import tensorflow as tf\n' )
  self . model_file . write ( 'import numpy as np\n' )
  if self . import_hub :
   self . model_file . write ( 'import tensorflow_hub as hub\n' )
  self . model_file . write ( 'from NOMTrainer.NOMTrainer import NOMModel\n' )
  self . model_file . write ( 'from tensorflow.keras.layers import Dense, Conv2D, Reshape, Input, Flatten, BatchNormalization\n' )
  self . model_file . write ( 'from tensorflow import initializers\n' )
  self . model_file . write ( 'from tensorflow.keras import regularizers\n' )
  self . model_file . write ( 'from datetime import datetime\n' )
  self . model_file . write ( 'from tensorflow.python.training.tracking.data_structures import NoDependency\n' )
  if 3 - 3: i1iiIII111 % Oo * i1 + ooo000 . ooOOO
  try :
   for oo00OOOO , O0Oo00o0 in self . sub_model . items ( ) :
    self . model_file . write ( '\n\n' )
    self . model_file . write ( 'class %s(tf.keras.Model):\n' % oo00OOOO )
    self . model_file . write ( '\tdef __init__(self):\n' )
    self . model_file . write ( '\t\tsuper(%s, self).__init__()\n' % oo00OOOO )
    for iIIiI1IiIi11I in O0Oo00o0 [ 0 ] :
     self . model_file . write ( '\t\t%s\n' % iIIiI1IiIi11I )
    self . model_file . write ( '\n' )
    self . model_file . write ( '\tdef call(self, x, training=False):\n' )
    for iIIiI1IiIi11I in O0Oo00o0 [ 1 ] :
     self . model_file . write ( '\t\t%s\n' % iIIiI1IiIi11I )
  except :
   pass
   if 76 - 76: Ooo0Ooo % IIiIIiIi11I1 - i1 - ooOOO + I1Ii1I1 + oOO
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class eagerModel(tf.keras.Model):\n' )
  if 7 - 7: i1iiIII111 % ooOOO - I1Ii1I1 . iI1iII1I1I1i + I11iiIi11i1I - IIiIIiIi11I1
  self . model_file . write ( '\tdef __init__(self):\n' )
  self . model_file . write ( '\t\tsuper(eagerModel, self).__init__()\n' )
  if 9 - 9: IiI11Ii111 / Oo * i1I + IIiIIiIi11I1 . OooOoo - IiI11Ii111
  self . write_init ( )
  if 81 - 81: i1 - iI1iII1I1I1i - IIiIIiIi11I1
  Ii1i = [ ( l [ 0 ] + ": " + l [ 1 ] ) for l in self . learning_list ]
  self . model_file . write ( '\t\tself.learning_list = NoDependency({%s})\n\n' % ( ', ' . join ( Ii1i ) ) )
  if 53 - 53: IiI11Ii111 + ooo000 % I1I % I11iiIi11i1I . Iii1i + ooo000
  if 57 - 57: Ii * i1I
  self . model_file . write ( '\tdef call(self, batch_source, training=False):\n' )
  self . write_call ( )
  self . model_file . write ( '\n' )
  if 7 - 7: i1i1i1111I
  self . model_file . write ( '\tdef loss_value(self):\n' )
  self . write_loss ( )
  self . model_file . write ( '\n' )
  self . model_file . write ( '\tdef update(self, tape, task_order):\n' )
  self . write_optimizer ( )
  self . model_file . write ( '\n' )
  self . model_file . write ( '\tdef general_s2d(self, tensor, input_shape, final_shape, mul_list, trans_parm, block_size):\n' )
  self . model_file . write ( '\t\ttensor = tf.convert_to_tensor(tensor)\n' )
  self . model_file . write ( '\t\taxis = 1\n' )
  self . model_file . write ( '\t\tfor i in range(len(block_size)):\n' )
  self . model_file . write ( '\t\t\ttensor = tf.split(tensor, mul_list[i], axis = axis)\n' )
  self . model_file . write ( '\t\t\tif i != len(block_size)-1:\n' )
  self . model_file . write ( '\t\t\t\taxis += 1\n' )
  self . model_file . write ( '\t\t\t\ttensor = tf.concat(tensor, axis = axis)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\ttensor = tf.transpose(tensor, perm=trans_parm)\n' )
  self . model_file . write ( '\t\t\t\ttensor = tf.reshape(tensor, final_shape)\n' )
  self . model_file . write ( '\t\treturn tensor\n' )
  if 77 - 77: I1I
  if 91 - 91: oOo0O00 - I1I
  if 75 - 75: ooOOO / i1 % I1Ii1I1 . Oo * Iii1i
  if 68 - 68: iI1iII1I1I1i % oOo0O00 . oOO + IiIIii11Ii
  OOoo0o0OOO00 = [ False , False , False , False , False , False ]
  for iiIIiIIiIi1i in self . modelNodes . keys ( ) :
   if self . modelNodes [ iiIIiIIiIi1i ] . _nodeType . value == O00oOo0O . Types . Layer . value :
    if self . modelNodes [ iiIIiIIiIi1i ] . _layerType . value == O00oOo0O . Layer . Types . RNN . value :
     if self . modelNodes [ iiIIiIIiIi1i ] . isKerasLayer == False :
      OOoo0o0OOO00 [ 0 ] = True
    elif self . modelNodes [ iiIIiIIiIi1i ] . _layerType . value == O00oOo0O . Layer . Types . GRU . value :
     if self . modelNodes [ iiIIiIIiIi1i ] . isKerasLayer == False :
      OOoo0o0OOO00 [ 1 ] = True
    elif self . modelNodes [ iiIIiIIiIi1i ] . _layerType . value == O00oOo0O . Layer . Types . LSTM . value :
     if self . modelNodes [ iiIIiIIiIi1i ] . isKerasLayer == False :
      OOoo0o0OOO00 [ 2 ] = True
    elif self . modelNodes [ iiIIiIIiIi1i ] . _layerType . value == O00oOo0O . Layer . Types . BiRNN . value :
     if self . modelNodes [ iiIIiIIiIi1i ] . isKerasLayer == False :
      OOoo0o0OOO00 [ 3 ] = True
    elif self . modelNodes [ iiIIiIIiIi1i ] . _layerType . value == O00oOo0O . Layer . Types . BiGRU . value :
     if self . modelNodes [ iiIIiIIiIi1i ] . isKerasLayer == False :
      OOoo0o0OOO00 [ 4 ] = True
    elif self . modelNodes [ iiIIiIIiIi1i ] . _layerType . value == O00oOo0O . Layer . Types . BiLSTM . value :
     if self . modelNodes [ iiIIiIIiIi1i ] . isKerasLayer == False :
      OOoo0o0OOO00 [ 5 ] = True
      if 71 - 71: i1i1i1111I . i1iiIII111
  if OOoo0o0OOO00 [ 0 ] :
   self . write_RNN ( )
  if OOoo0o0OOO00 [ 1 ] :
   self . write_GRU ( )
  if OOoo0o0OOO00 [ 2 ] :
   self . write_LSTM ( )
  if OOoo0o0OOO00 [ 3 ] :
   self . write_BiRNN ( )
  if OOoo0o0OOO00 [ 4 ] :
   self . write_BiGRU ( )
  if OOoo0o0OOO00 [ 5 ] :
   self . write_BiLSTM ( )
  self . model_file . close ( )
  if 77 - 77: ooOOO / Ii - i1iiIII111 . I11iiIi11i1I % iI1iII1I1I1i . I1Ii1I1
 def connect_keras_layer ( self , buildNo : int = 0 ) :
  if 68 - 68: oOo0O00 * I11iiIi11i1I - IiI11Ii111
  if 40 - 40: Iii1i
  if 78 - 78: OooOoo - IIiIIiIi11I1 % i1 . Iii1i
  if 94 - 94: ooo000 * ooo000 * iI1iII1I1I1i - i1I * Oo % I1Ii1I1
  if 99 - 99: IiIIii11Ii - IiI11Ii111 % oOO % OooOoo
  if 87 - 87: IIiIIiIi11I1 % i1i1i1111I
  if 56 - 56: Ii * iI1iII1I1I1i % ooo000 - Ooo0Ooo % oOo0O00 + I11iiIi11i1I
  if 51 - 51: IiI11Ii111 / I11iiIi11i1I % I11iiIi11i1I . Oo
  if 43 - 43: I1Ii1I1 % IiI11Ii111 - oOo0O00 / IiI11Ii111 / i1 * i1iiIII111
  if 76 - 76: Ii . Ii % I11iiIi11i1I
  self . sub_model = { }
  self . call_obj = [ ]
  self . return_obj = [ ]
  self . layer_obj = [ ]
  self . loss_obj = [ ]
  self . loss_ret = [ ]
  self . update_obj = [ ]
  self . return_loss = [ ]
  self . learning_list = [ ]
  self . import_hub = False
  if 27 - 27: IIiIIiIi11I1 * iI1iII1I1I1i - i1iiIII111 + i1I - i1 % i1I
  iIiiII = O0oO00000000 ( )
  iiiI1iIi1IIi1 = { }
  I1ii111 = [ ]
  I11IiiiII1iI1 = { }
  if 98 - 98: I11iiIi11i1I - i1 / i1I . i1 / i1 + I1Ii1I1
  for oo00OOOO , O0Oo00o0 in self . modelNodes . items ( ) :
   o0II1iiIi11111 = O0Oo00o0 . toNode [ buildNo ]
   if isinstance ( O0Oo00o0 , I1IiiIiIi ) :
    self . import_hub = True
   if len ( o0II1iiIi11111 ) == 0 :
    I11IiiiII1iI1 [ oo00OOOO ] = - 1
   else :
    I11IiiiII1iI1 [ oo00OOOO ] = len ( o0II1iiIi11111 )
   try :
    iiiI1iIi1IIi1 [ O0Oo00o0 . _order [ buildNo ] ] . append ( oo00OOOO )
   except :
    iiiI1iIi1IIi1 [ O0Oo00o0 . _order [ buildNo ] ] = [ oo00OOOO ]
    if 94 - 94: i1 * I11iiIi11i1I . IIiIIiIi11I1 / ooOOO - i1i1i1111I
  for oo00OOOO , O0Oo00o0 in iiiI1iIi1IIi1 . items ( ) :
   I1ii111 . append ( oo00OOOO )
  I1ii111 . sort ( )
  if 24 - 24: I11iiIi11i1I - i1i1i1111I * i1iiIII111 * iI1iII1I1I1i
  if 91 - 91: I1Ii1I1 % i1I . I11iiIi11i1I
  for IiIii1i1II in I1ii111 :
   for Iii111iII in iiiI1iIi1IIi1 [ IiIii1i1II ] :
    O0Oo00o0 = self . modelNodes [ Iii111iII ]
    try :
     if O0Oo00o0 . _type == 'Task' :
      if 43 - 43: Ii / IIiIIiIi11I1 / Iii1i % I1I / i1I / ooo000
      self . learning_list . append ( ( O0Oo00o0 . name . replace ( 'Task' , '' ) , 'self.' + O0Oo00o0 . name + '_learningConfig' ) )
      oO00oOooO0O , iiiiiII , I11I1IIi111I11I = O0Oo00o0 . keras_call ( O0Oo00o0 . name . replace ( 'Task' , '' ) )
      if 84 - 84: IiIIii11Ii . ooOOO * IiIIii11Ii + Ii
      for string in oO00oOooO0O :
       self . layer_obj . append ( string )
       if 41 - 41: i1iiIII111 + i1i1i1111I . Ooo0Ooo - IIiIIiIi11I1 + I11iiIi11i1I
      self . loss_obj . append ( iiiiiII [ 0 ] )
      self . loss_ret . extend ( iiiiiII [ 1 ] )
      if 89 - 89: IiI11Ii111 * i1I - i1I
      for string in I11I1IIi111I11I :
       self . update_obj . append ( string )
      break
    except :
     pass
     if 58 - 58: i1 * ooo000 * IIiIIiIi11I1 % I11iiIi11i1I / iI1iII1I1I1i
    try :
     if O0Oo00o0 . _type == 'Group' :
      OOo0oOo0 , oOOOOOO = O0Oo00o0 . keras_group ( buildNo , self )
      if len ( OOo0oOo0 ) > 0 :
       self . sub_model [ Iii111iII ] = [ OOo0oOo0 , oOOOOOO ]
    except :
     pass
     if 9 - 9: i1i1i1111I - i1i1i1111I + I1I / IiI11Ii111 + ooOOO
    ooOoOOOo , O0o00 = [ ] , [ ]
    o0OIi1i1I1i1iiiI , o0OOOoOOoo0OOo0o = [ ] , [ ]
    if 51 - 51: ooo000 + I1Ii1I1 * i1iiIII111 + OooOoo
    for I1IIII1Ii1 in O0Oo00o0 . fromSource [ buildNo ] :
     Oo0ooOo0o = [ x if x != 'None' else None for x in self . dppNodes [ I1IIII1Ii1 ] . getShape ( False ) ]
     ooOoOOOo . append ( Oo0ooOo0o )
     if I1IIII1Ii1 in iIiiII . name_to_reg :
      OOO = iIiiII . name_to_reg [ I1IIII1Ii1 ]
     else :
      iIiiII . get_register ( I1IIII1Ii1 )
      OOO = iIiiII . name_to_reg [ I1IIII1Ii1 ]
      if isinstance ( self . dppNodes [ I1IIII1Ii1 ] , OO0O0 . BERT ) :
       self . call_obj . append ( '%s = batch_source[\'%s\']' % ( OOO , I1IIII1Ii1 ) )
       self . call_obj . append ( 'self.input_output = batch_source[\'input\']' )
       if 99 - 99: IIiIIiIi11I1 * I1Ii1I1 + I11iiIi11i1I * I11iiIi11i1I - IIiIIiIi11I1
       self . call_obj . append ( 'self.target_output = tf.cast(batch_source[\'target\'], tf.float32)' )
      else :
       self . call_obj . append ( '%s = tf.cast(batch_source[\'%s\'], tf.float32)' % ( OOO , I1IIII1Ii1 ) )
       self . call_obj . append ( 'self.input_output = tf.cast(batch_source[\'input\'], tf.float32)' )
       self . call_obj . append ( 'self.target_output = tf.cast(batch_source[\'target\'], tf.float32)' )
       if 36 - 36: OooOoo / ooOOO - IiIIii11Ii / i1
     o0OIi1i1I1i1iiiI . append ( OOO )
     if 39 - 39: i1 . IiI11Ii111 - i1iiIII111 . Oo
    for ooOoOOoo00 in O0Oo00o0 . fromNode [ buildNo ] :
     Oo0ooOo0o = [ x if x != 'None' else None for x in ooOoOOoo00 . _shape [ buildNo ] ]
     O0o00 . append ( Oo0ooOo0o )
     try :
      if 86 - 86: I1Ii1I1
      ooOoOOoo00 . name = ooOoOOoo00 . name . replace ( " " , "" )
     except :
      pass
     OOO = iIiiII . name_to_reg [ ooOoOOoo00 . name ]
     if len ( ooOoOOoo00 . toNode [ 0 ] ) > 0 :
      OO0ooO0 = ooOoOOoo00 . toNode [ 0 ] [ 0 ] . name
      if "Flatten" in OO0ooO0 :
       if ooOoOOoo00 . name in iIiiII . name_to_reg :
        oO00ooO0oooo = iIiiII . new_register ( ooOoOOoo00 . name )
     I11IiiiII1iI1 [ ooOoOOoo00 . name ] -= 1
     if I11IiiiII1iI1 [ ooOoOOoo00 . name ] == 0 :
      iIiiII . free_register ( ooOoOOoo00 . name )
     o0OOOoOOoo0OOo0o . append ( OOO )
     if 27 - 27: IiIIii11Ii . i1i1i1111I % Ooo0Ooo . oOO - oOo0O00
     if 37 - 37: i1i1i1111I % iI1iII1I1I1i . i1i1i1111I % OooOoo - I1Ii1I1 . i1I
    iIiiII . get_register ( Iii111iII )
    O0o0O0O0Oo00 = iIiiII . get_register ( Iii111iII )
    if 18 - 18: IiIIii11Ii * Ooo0Ooo % OooOoo . oOo0O00
    if 47 - 47: i1
    try :
     Oo0ooOo0o , Iii11iii , ooO0OOo0 , I11 = O0Oo00o0 . keras_call_combineIncomingTensors ( ooOoOOOo , O0o00 , o0OIi1i1I1i1iiiI , o0OOOoOOoo0OOo0o , O0o0O0O0Oo00 )
     for string in Iii11iii :
      self . layer_obj . append ( string )
     for string in ooO0OOo0 :
      self . call_obj . append ( string )
    except :
     pass
     if 81 - 81: IiIIii11Ii % Ii / I11iiIi11i1I - OooOoo . Ooo0Ooo
     if 95 - 95: I1I / IIiIIiIi11I1 + Ii
    try :
     OOOOooo , iI111IIi , OoO00ooOO , II = O0Oo00o0 . keras_call_auto_reshape_build ( Oo0ooOo0o , I11 , O0o0O0O0Oo00 )
     for string in OOOOooo :
      self . layer_obj . append ( string )
     for string in iI111IIi :
      self . call_obj . append ( string )
    except :
     pass
     if 42 - 42: oOO
     if 79 - 79: i1iiIII111
    try :
     oO00oOooO0O , OoO0O0oOoO , O0o0Ii , II = O0Oo00o0 . keras_call_layer_build ( OoO00ooOO , O0o0O0O0Oo00 , II )
     for string in OoO0O0oOoO :
      if string != '' :
       self . call_obj . append ( string )
     for string in oO00oOooO0O :
      self . layer_obj . append ( string )
    except :
     pass
     if 94 - 94: I1Ii1I1 % Oo / i1I * i1
     if 61 - 61: i1I / iI1iII1I1I1i . IiIIii11Ii . i1i1i1111I % Iii1i . Ooo0Ooo
    oO00oOooO0O , OoO0O0oOoO = O0Oo00o0 . keras_call_processOutputTensor ( II , O0o0Ii , O0o0O0O0Oo00 )
    for string in OoO0O0oOoO :
     if string != '' :
      self . call_obj . append ( string )
    for string in oO00oOooO0O :
     self . layer_obj . append ( string )
     if 81 - 81: oOO . i1I + Iii1i
     if 94 - 94: i1 * I1I * Ii / I1I / I11iiIi11i1I - Ooo0Ooo
    try :
     if O0Oo00o0 . forLoss :
      self . call_obj . append ( 'self.%s_output = %s' % ( O0Oo00o0 . name , O0o0O0O0Oo00 ) )
      self . call_obj . append ( 'self.visual_output = register_1' )
      self . return_obj . append ( 'self.%s_output' % O0Oo00o0 . name )
      self . output = '%s_output' % O0Oo00o0 . name
    except :
     pass
     if 32 - 32: Oo
 def write_RNN ( self ) :
  if 38 - 38: i1i1i1111I * Oo
  if 62 - 62: I1I * oOO + I11iiIi11i1I * ooOOO
  if 95 - 95: ooOOO + IiI11Ii111 . Iii1i % Oo - i1iiIII111
  if 22 - 22: Iii1i . Ii + ooOOO
  if 57 - 57: oOo0O00 + Oo * iI1iII1I1I1i . i1iiIII111 * i1I . OooOoo
  if 2 - 2: ooo000 % iI1iII1I1I1i . OooOoo + iI1iII1I1I1i
  if 60 - 60: ooo000 * Iii1i / i1I . Ii . ooo000 / Ooo0Ooo
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class RNN(tf.keras.layers.Layer):\n' )
  if 70 - 70: I1Ii1I1 . ooOOO - ooo000 * oOo0O00 + i1i1i1111I % I11iiIi11i1I
  self . model_file . write ( '\tdef __init__(self,units,activation = \'tanh\',kernelInitializer = \'glorot_uniform\',recurrentInitializer = \'orthogonal\',biasInitializer = \'zero\',\n' )
  self . model_file . write ( '\t\t\tkernelRegularizer = None,recurrentRegularizer = None,biasRegularizer = None,kernelConstraint = None,recurrentConstraint = None,biasConstraint = None,\n' )
  self . model_file . write ( '\t\t\tuseBias = True,dropout = 0.,recurrentDropout = 0.,stateClip = None,statefull = False,goBackwards = False,returnSequenceLen = 1,returnState = False,**kwargs):\n' )
  self . model_file . write ( '\t\tsuper(RNN, self).__init__(**kwargs)\n' )
  self . model_file . write ( '\t\tself.units = units\n' )
  self . model_file . write ( '\t\tself.activation =  tf.keras.activations.get(activation)\n' )
  self . model_file . write ( '\t\tself.kernelInitializer = tf.keras.initializers.get(kernelInitializer)\n' )
  self . model_file . write ( '\t\tself.recurrentInitializer = tf.keras.initializers.get(recurrentInitializer)\n' )
  self . model_file . write ( '\t\tself.biasInitializer = tf.keras.initializers.get(biasInitializer)\n' )
  self . model_file . write ( '\t\tself.kernelRegularizer = tf.keras.regularizers.get(kernelRegularizer)\n' )
  self . model_file . write ( '\t\tself.recurrentRegularizer =tf.keras.regularizers.get(recurrentRegularizer)\n' )
  self . model_file . write ( '\t\tself.biasRegularizer = tf.keras.regularizers.get(biasRegularizer)\n' )
  self . model_file . write ( '\t\tself.kernelConstraint = tf.keras.constraints.get(kernelConstraint)\n' )
  self . model_file . write ( '\t\tself.recurrentConstraint = tf.keras.constraints.get(recurrentConstraint)\n' )
  self . model_file . write ( '\t\tself.biasConstraint = tf.keras.constraints.get(biasConstraint)\n' )
  self . model_file . write ( '\t\tself.useBias = useBias\n' )
  self . model_file . write ( '\t\tself.dropout = dropout\n' )
  self . model_file . write ( '\t\tself.recurrentDropout = recurrentDropout\n' )
  self . model_file . write ( '\t\tself.stateClip = stateClip\n' )
  self . model_file . write ( '\t\tself.statefull = statefull\n' )
  self . model_file . write ( '\t\tself.goBackwards = goBackwards\n' )
  self . model_file . write ( '\t\tself.returnSequenceLen = returnSequenceLen\n' )
  self . model_file . write ( '\t\tself.returnState = returnState\n' )
  self . model_file . write ( '\t\tself._initialState = None\n\n' )
  if 64 - 64: iI1iII1I1I1i / Ooo0Ooo + oOO . I1I
  self . model_file . write ( '\tdef build(self, input_shape):\n' )
  self . model_file . write ( '\t\tinput_dim = int(input_shape[-1])\n' )
  self . model_file . write ( '\t\tself.kernel = self.add_weight(shape=(input_dim,self.units),name=\'kernel\',initializer=self.kernelInitializer,regularizer=self.kernelRegularizer,constraint=self.kernelConstraint)\n' )
  self . model_file . write ( '\t\tself.recurrentKernel = self.add_weight(shape=(self.units,self.units),name=\'recurrentKernel\',initializer=self.recurrentInitializer,regularizer=self.recurrentRegularizer,constraint=self.recurrentConstraint)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tself.bias = self.add_weight(shape=(self.units,),name=\'bias\',initializer=self.biasInitializer,regularizer=self.biasRegularizer,constraint=self.biasConstraint)\n' )
  self . model_file . write ( '\t\tself.built = True\n\n' )
  if 67 - 67: ooo000 + IIiIIiIi11I1 / Ooo0Ooo
  self . model_file . write ( '\tdef _stepFunction(self,inputs,state,training = None):\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout),inputs,training=training)\n' )
  self . model_file . write ( '\t\tif 0 < self.recurrentDropout < 1 : state = tf.keras.backend.in_train_phase(tf.nn.dropout(state,self.recurrentDropout),state,training=training)\n' )
  self . model_file . write ( '\t\tif self.useBias: output = self.activation(tf.matmul(state,self.recurrentKernel) + tf.matmul(inputs,self.kernel) + self.bias)\n' )
  self . model_file . write ( '\t\telse: output = self.activation(tf.matmul(state,self.recurrentKernel) + tf.matmul(inputs,self.kernel))\n' )
  self . model_file . write ( '\t\tif self.stateClip is not None:\n' )
  self . model_file . write ( '\t\t\tnewState = tf.clip_by_value(output,-1*self.stateClip,self.stateClip)\n' )
  self . model_file . write ( '\t\t\treturn output,newState\n' )
  self . model_file . write ( '\t\treturn output,output\n\n' )
  if 49 - 49: ooo000 % IiI11Ii111 / i1i1i1111I . Oo / ooOOO
  self . model_file . write ( '\tdef _switchBatchTime(self,inputs):\n' )
  self . model_file . write ( '\t\tperm = list(range(inputs.get_shape().rank))\n' )
  self . model_file . write ( '\t\tperm[0:2] = (1,0)\n' )
  self . model_file . write ( '\t\treturn tf.transpose(inputs,perm)\n\n' )
  if 84 - 84: iI1iII1I1I1i + IiIIii11Ii - Ii / iI1iII1I1I1i + oOo0O00 * iI1iII1I1I1i
  self . model_file . write ( '\tdef _getInitialState(self,inputs):\n' )
  self . model_file . write ( '\t\tinitialState = tf.zeros_like(inputs)\n' )
  self . model_file . write ( '\t\tinitialState = initialState[:,0,0:1]\n' )
  self . model_file . write ( '\t\tmultiples = tf.convert_to_tensor([1,self.units])\n' )
  self . model_file . write ( '\t\tinitialState = tf.tile(initialState,multiples)\n' )
  self . model_file . write ( '\t\treturn initialState\n\n' )
  if 7 - 7: oOo0O00 / OooOoo
  self . model_file . write ( '\tdef call(self, inputs ,state = None):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = inputs.shape.as_list()\n' )
  self . model_file . write ( '\t\ttimeStepsTensor = tf.shape(inputs)[1]\n' )
  self . model_file . write ( '\t\tinitialState = state if state is not None else self._initialState\n' )
  self . model_file . write ( '\t\tif initialState is None : initialState = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tinputs = self._switchBatchTime(inputs)\n' )
  self . model_file . write ( '\t\tinitialTime = tf.zeros_like(timeStepsTensor,name=\'time\')\n' )
  self . model_file . write ( '\t\tinputsTensorArray = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArray = inputsTensorArray.unstack(tf.reverse(inputs,tf.zeros(1, tf.int32))) if self.goBackwards else inputsTensorArray.unstack(inputs)\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArray = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tdef _cond(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\treturn time<timeStepsTensor\n\n' )
  self . model_file . write ( '\t\tdef _body(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArray.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,state = self._stepFunction(currentInput,state)\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,state)\n\n' )
  self . model_file . write ( '\t\tfinalOutputs = tf.while_loop(cond=_cond,body=_body,loop_vars=(initialTime,initialOutputTensorArray,initialState))\n' )
  self . model_file . write ( '\t\tnewState = finalOutputs[-1]\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArray = finalOutputs[1]\n' )
  self . model_file . write ( '\t\tfinalOutput = finalOutputTensorArray.stack()\n' )
  self . model_file . write ( '\t\tfinalOutput.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tif self.statefull : self._initialState = newState\n' )
  self . model_file . write ( '\t\tif self.returnSequenceLen is 1 : finalOutput = finalOutput[-1]\n' )
  self . model_file . write ( '\t\telif self.returnSequenceLen is not None:\n' )
  self . model_file . write ( '\t\t\tfinalOutput = finalOutput[-self.returnSequenceLen:]\n' )
  self . model_file . write ( '\t\t\tfinalOutput = self._switchBatchTime(finalOutput)\n' )
  self . model_file . write ( '\t\telse: finalOutput = self._switchBatchTime(finalOutput)\n' )
  self . model_file . write ( '\t\tif self.returnState : return [finalOutput,newState]\n' )
  self . model_file . write ( '\t\telse: return finalOutput\n\n' )
  if 55 - 55: ooOOO * I11iiIi11i1I * IIiIIiIi11I1
  self . model_file . write ( '\tdef compute_output_shape(self,input_shape):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = input_shape\n' )
  self . model_file . write ( '\t\tif self.returnSequenceLen in [1,None]:\n' )
  self . model_file . write ( '\t\t\toutputShape = tf.TensorShape([batchSize,self.units]) if self.returnSequenceLen == 1 else tf.TensorShape([batchSize,timeSteps,self.units])\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tif timeSteps is None or timeSteps < self.returnSequenceLen : raise ValueError(\'returnSequenceLen not match to timeSteps\')\n' )
  self . model_file . write ( '\t\t\telse: outputShape = tf.TensorShape([batchSize,self.returnSequenceLen,self.units])\n' )
  self . model_file . write ( '\t\tif not self.returnState : return outputShape\n' )
  self . model_file . write ( '\t\tstateShape = tf.TensorShape([batchSize,self.units])\n' )
  self . model_file . write ( '\t\treturn [outputShape,stateShape]\n\n' )
  if 83 - 83: i1I * ooo000 * IIiIIiIi11I1 + Ooo0Ooo
  self . model_file . write ( '\tdef get_config(self):\n' )
  self . model_file . write ( '\t\tconfig = {\'units\': self.units,\'activation\': tf.keras.activations.serialize(self.activation),\'kernelInitializer\': tf.keras.initializers.serialize(self.kernelInitializer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'recurrentInitializer\': tf.keras.initializers.serialize(self.recurrentInitializer),\'biasInitializer\': tf.keras.initializers.serialize(self.biasInitializer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'kernelRegularizer\': tf.keras.regularizers.serialize(self.kernelRegularizer),\'recurrentRegularizer\': tf.keras.regularizers.serialize(self.recurrentRegularizer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'biasRegularizer\': tf.keras.regularizers.serialize(self.biasRegularizer),\'useBias\': self.useBias,\'dropout\': self.dropout,\'recurrentDropout\': self.recurrentDropout,\n' )
  self . model_file . write ( '\t\t\t\t\t\'stateClip\': self.stateClip,\'statefull\': self.statefull,\'goBackwards\':self.goBackwards,\'returnSequenceLen\':self.returnSequenceLen,\'returnState\':self.returnState}\n' )
  self . model_file . write ( '\t\tbaseConfig = super(RNN, self).get_config()\n' )
  self . model_file . write ( '\t\treturn dict(list(baseConfig.items()) + list(config.items()))\n' )
  if 71 - 71: OooOoo - Ooo0Ooo
 def write_GRU ( self ) :
  if 100 - 100: oOo0O00 . I1Ii1I1 . ooOOO
  if 56 - 56: i1iiIII111 - IiIIii11Ii / i1I % I1I
  if 68 - 68: Iii1i % OooOoo * ooOOO + ooOOO . I1I
  if 63 - 63: i1I * I1Ii1I1 + iI1iII1I1I1i . Ii - ooOOO
  if 80 - 80: I1I % OooOoo - IIiIIiIi11I1 - ooOOO
  if 82 - 82: IiIIii11Ii * I1I * ooo000
  if 32 - 32: I11iiIi11i1I . ooOOO / IiIIii11Ii / Ii % IiIIii11Ii * i1iiIII111
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class GRU(tf.keras.layers.Layer):\n' )
  if 19 - 19: i1i1i1111I * ooOOO . i1 / IiI11Ii111
  self . model_file . write ( '\tclass Activation():\n' )
  self . model_file . write ( '\t\tdef __init__(self,resetGate,updateGate,stateCandidate):\n' )
  self . model_file . write ( '\t\t\tself.resetGate = tf.keras.activations.get(resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGate = tf.keras.activations.get(updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidate = tf.keras.activations.get(stateCandidate)\n\n' )
  if 61 - 61: IiIIii11Ii + I1Ii1I1
  self . model_file . write ( '\tclass Initializer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,resetGate,updateGate,stateCandidate):\n' )
  self . model_file . write ( '\t\t\tself.resetGate = tf.keras.initializers.get(resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGate = tf.keras.initializers.get(updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidate = tf.keras.initializers.get(stateCandidate)\n\n' )
  if 85 - 85: ooo000 . ooo000 . IIiIIiIi11I1 % OooOoo * i1iiIII111
  self . model_file . write ( '\tclass Regularizer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,resetGate,updateGate,stateCandidate):\n' )
  self . model_file . write ( '\t\t\tself.resetGate = tf.keras.regularizers.get(resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGate = tf.keras.regularizers.get(updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidate = tf.keras.regularizers.get(stateCandidate)\n\n' )
  if 69 - 69: i1 - ooOOO
  self . model_file . write ( '\t\t\n' )
  self . model_file . write ( '\tdef __init__(self,units,activation = Activation(\'sigmoid\',\'sigmoid\',\'tanh\'),kernelInitializer = Initializer(\'glorot_uniform\',\'glorot_uniform\',\'glorot_uniform\'),\n' )
  self . model_file . write ( '\t\t\trecurrentInitializer = Initializer(\'orthogonal\',\'orthogonal\',\'orthogonal\'),biasInitializer = Initializer(\'zeros\',\'zeros\',\'zeros\'),kernelRegularizer = Regularizer(None,None,None),\n' )
  self . model_file . write ( '\t\t\trecurrentRegularizer = Regularizer(None,None,None),biasRegularizer = Regularizer(None,None,None,),useBias = True,dropout = 0.,recurrentDropout = 0.,\n' )
  self . model_file . write ( '\t\tstateClip = None,statefull = False,goBackwards = False,returnSequenceLen = 1,returnState = False,**kwargs):\n' )
  self . model_file . write ( '\t\tsuper(GRU, self).__init__(**kwargs)\n' )
  self . model_file . write ( '\t\tself.units = units\n' )
  self . model_file . write ( '\t\tself.activation =  activation\n' )
  self . model_file . write ( '\t\tself.kernelInitializer = kernelInitializer\n' )
  self . model_file . write ( '\t\tself.recurrentInitializer = recurrentInitializer\n' )
  self . model_file . write ( '\t\tself.biasInitializer = biasInitializer\n' )
  self . model_file . write ( '\t\tself.kernelRegularizer = kernelRegularizer\n' )
  self . model_file . write ( '\t\tself.recurrentRegularizer =recurrentRegularizer\n' )
  self . model_file . write ( '\t\tself.biasRegularizer = biasRegularizer\n' )
  self . model_file . write ( '\t\tself.useBias = useBias\n' )
  self . model_file . write ( '\t\tself.dropout = dropout\n' )
  self . model_file . write ( '\t\tself.recurrentDropout = recurrentDropout\n' )
  self . model_file . write ( '\t\tself.stateClip = stateClip\n' )
  self . model_file . write ( '\t\tself.statefull = statefull\n' )
  self . model_file . write ( '\t\tself.goBackwards = goBackwards\n' )
  self . model_file . write ( '\t\tself.returnSequenceLen = returnSequenceLen\n' )
  self . model_file . write ( '\t\tself.returnState = returnState\n' )
  self . model_file . write ( '\t\tself._initialState = None\n\n' )
  if 4 - 4: IiI11Ii111
  self . model_file . write ( '\tdef build(self, input_shape):\n' )
  self . model_file . write ( '\t\tinput_dim = int(input_shape[-1])\n' )
  self . model_file . write ( '\t\tself.resetGateKernel = self.add_weight(shape=(input_dim, self.units),name=\'resetGateKernel\',initializer=self.kernelInitializer.resetGate,regularizer=self.kernelRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\tself.updateGateKernel = self.add_weight(shape=(input_dim, self.units),name=\'updateGateKernel\',initializer=self.kernelInitializer.updateGate,regularizer=self.kernelRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\tself.stateCandidateKernel = self.add_weight(shape=(input_dim, self.units),name=\'stateCandidateKernel\',initializer=self.kernelInitializer.stateCandidate,regularizer=self.kernelRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tself.resetGateRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'resetGateRecurrentKernel\',initializer=self.recurrentInitializer.resetGate,regularizer=self.recurrentRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\tself.updateGateRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'updateGateRecurrentKernel\',initializer=self.recurrentInitializer.updateGate,regularizer=self.recurrentRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\tself.stateCandidateRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'stateCandidateRecurrentKernel\',initializer=self.recurrentInitializer.stateCandidate,regularizer=self.recurrentRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tself.resetGateBias = self.add_weight(shape=(self.units,),name=\'resetGateBias\',initializer=self.biasInitializer.resetGate,regularizer=self.biasRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGateBias = self.add_weight(shape=(self.units,),name=\'updateGateBias\',initializer=self.biasInitializer.updateGate,regularizer=self.biasRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidateBias = self.add_weight(shape=(self.units,),name=\'stateCandidate\',initializer=self.biasInitializer.stateCandidate,regularizer=self.biasRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tself.built = True\n\n' )
  if 48 - 48: IiIIii11Ii . IiI11Ii111 . Oo
  self . model_file . write ( '\tdef _stepFunction(self,inputs,state,training = None):\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout), inputs, training=training)\n' )
  self . model_file . write ( '\t\tif  0 < self.recurrentDropout < 1 : state =   tf.keras.backend.in_train_phase(tf.nn.dropout(state,self.recurrentDropout), state, training=training)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tresetGateOutput = self.activation.resetGate(tf.matmul(state,self.resetGateRecurrentKernel) + tf.matmul(inputs,self.resetGateKernel)  + self.resetGateBias)\n' )
  self . model_file . write ( '\t\t\tupdateGateOutput = self.activation.updateGate(tf.matmul(state,self.updateGateRecurrentKernel) + tf.matmul(inputs,self.updateGateKernel) + self.updateGateBias)\n' )
  self . model_file . write ( '\t\t\tstateCandidate = self.activation.stateCandidate(tf.matmul(tf.multiply(resetGateOutput,state),self.stateCandidateRecurrentKernel) + tf.matmul(inputs,self.stateCandidateKernel) + self.stateCandidateBias)\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tresetGateOutput = self.activation.resetGate(tf.matmul(state,self.resetGateRecurrentKernel) + tf.matmul(inputs,self.resetGateKernel))\n' )
  self . model_file . write ( '\t\t\tupdateGateOutput = self.activation.updateGate(tf.matmul(state,self.updateGateRecurrentKernel) + tf.matmul(inputs,self.updateGateKernel))\n' )
  self . model_file . write ( '\t\t\tstateCandidate = self.activation.stateCandidate(tf.matmul(tf.multiply(resetGateOutput,state),self.stateCandidateRecurrentKernel) + tf.matmul(inputs,self.stateCandidateKernel))\n' )
  self . model_file . write ( '\t\toutput = tf.multiply(updateGateOutput,state) + tf.multiply(1-updateGateOutput,stateCandidate)\n' )
  self . model_file . write ( '\t\tif self.stateClip is not None:\n' )
  self . model_file . write ( '\t\t\tnewState = tf.clip_by_value(output,-1*self.stateClip,self.stateClip)\n' )
  self . model_file . write ( '\t\t\treturn output,newState\n' )
  self . model_file . write ( '\t\treturn output,output\n\n' )
  if 28 - 28: oOO
  self . model_file . write ( '\tdef _switchBatchTime(self,inputs):\n' )
  self . model_file . write ( '\t\tperm = list(range(inputs.get_shape().rank))\n' )
  self . model_file . write ( '\t\tperm[0:2] = (1,0)\n' )
  self . model_file . write ( '\t\treturn tf.transpose(inputs,perm)\n\n' )
  if 17 - 17: I11iiIi11i1I
  self . model_file . write ( '\tdef _getInitialState(self,inputs):\n' )
  self . model_file . write ( '\t\tinitialState = tf.zeros_like(inputs)\n' )
  self . model_file . write ( '\t\tinitialState = initialState[:,0,0:1]\n' )
  self . model_file . write ( '\t\tmultiples = tf.convert_to_tensor([1,self.units])\n' )
  self . model_file . write ( '\t\tinitialState = tf.tile(initialState,multiples)\n' )
  self . model_file . write ( '\t\treturn initialState\n\n' )
  if 10 - 10: Iii1i % i1iiIII111
  self . model_file . write ( '\tdef call(self, inputs ,state = None):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = inputs.shape.as_list()\n' )
  self . model_file . write ( '\t\ttimeStepsTensor = tf.shape(inputs)[1]\n' )
  self . model_file . write ( '\t\tinitialState = state if state is not None else self._initialState\n' )
  self . model_file . write ( '\t\tif initialState is None: initialState = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tinputs = self._switchBatchTime(inputs)\n' )
  self . model_file . write ( '\t\tinitialTime = tf.zeros_like(timeStepsTensor,name=\'time\')\n' )
  self . model_file . write ( '\t\tinputsTensorArray = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArray = inputsTensorArray.unstack(tf.reverse(inputs,tf.zeros(1, tf.int32))) if self.goBackwards else inputsTensorArray.unstack(inputs)\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArray = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tdef _cond(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\treturn time<timeStepsTensor\n\n' )
  self . model_file . write ( '\t\tdef _body(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArray.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,newState = self._stepFunction(currentInput,state)\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,newState)\n\n' )
  self . model_file . write ( '\t\tfinalOutputs = tf.while_loop(cond = _cond,body=_body,loop_vars=(initialTime,initialOutputTensorArray,initialState))\n' )
  self . model_file . write ( '\t\tnewState = finalOutputs[-1]\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArray = finalOutputs[1]\n' )
  self . model_file . write ( '\t\tfinalOutput = finalOutputTensorArray.stack()\n' )
  self . model_file . write ( '\t\tfinalOutput.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tif self.statefull: self._initialState = newState\n' )
  self . model_file . write ( '\t\tif self.returnSequenceLen is 1: finalOutput = finalOutput[-1]\n' )
  self . model_file . write ( '\t\telif self.returnSequenceLen is not None:\n' )
  self . model_file . write ( '\t\t\tfinalOutput = finalOutput[-self.returnSequenceLen:]\n' )
  self . model_file . write ( '\t\t\tfinalOutput = self._switchBatchTime(finalOutput)\n' )
  self . model_file . write ( '\t\telse: finalOutput = self._switchBatchTime(finalOutput)\n' )
  self . model_file . write ( '\t\tif self.returnState: return [finalOutput,newState]\n' )
  self . model_file . write ( '\t\telse: return finalOutput\n\n' )
  if 36 - 36: ooOOO + I1Ii1I1 / IiI11Ii111 - IiIIii11Ii
  self . model_file . write ( '\tdef compute_output_shape(self,input_shape):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = input_shape\n' )
  self . model_file . write ( '\t\tif self.returnSequenceLen in [1,None]:\n' )
  self . model_file . write ( '\t\t\tif self.returnSequenceLen == 1: outputShape = tf.TensorShape([batchSize,self.units])\n' )
  self . model_file . write ( '\t\t\telse: outputShape = tf.TensorShape([batchSize,timeSteps,self.units])\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tif timeSteps is None or timeSteps < self.returnSequenceLen : raise ValueError(\'returnSequenceLen not match to timeSteps\')\n' )
  self . model_file . write ( '\t\t\telse: outputShape = tf.TensorShape([batchSize,self.returnSequenceLen,self.units])\n' )
  self . model_file . write ( '\t\tif not self.returnState : return outputShape\n' )
  self . model_file . write ( '\t\tstateShape = tf.TensorShape([batchSize,self.units])\n' )
  self . model_file . write ( '\t\treturn [outputShape,stateShape]\n\n' )
  if 60 - 60: i1iiIII111 - i1iiIII111 - i1I
  self . model_file . write ( '\tdef get_config(self):\n' )
  self . model_file . write ( '\t\tconfig = {\'units\': self.units,\'activation\' : self.activation,\'kernelInitializer\' : self.kernelInitializer,\'recurrentInitializer\' : self.recurrentInitializer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'biasInitializer\' : self.biasInitializer,\'kernelRegularizer\' : self.kernelRegularizer,\'recurrentRegularizer\' : self.recurrentRegularizer,\'biasRegularizer\' : self.biasRegularizer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'useBias\': self.useBias,\'dropout\': self.dropout,\'recurrentDropout\': self.recurrentDropout,\'stateClip\' : self.stateClip,\'statefull\' : self.statefull,\n' )
  self . model_file . write ( '\t\t\t\t\t\'goBackwards\' : self.goBackwards,\'returnSequenceLen\':self.returnSequenceLen,\'returnState\':self.returnState,}\n' )
  self . model_file . write ( '\t\tbaseConfig = super(GRU, self).get_config()\n' )
  self . model_file . write ( '\t\treturn dict(list(baseConfig.items()) + list(config.items()))\n' )
  if 50 - 50: i1iiIII111 % Ii * i1i1i1111I
 def write_LSTM ( self ) :
  if 69 - 69: I11iiIi11i1I / I1I - IIiIIiIi11I1
  if 50 - 50: IiI11Ii111 - IIiIIiIi11I1
  if 42 - 42: I1I - IiIIii11Ii * iI1iII1I1I1i / oOo0O00 % Ii
  if 78 - 78: Iii1i - Iii1i % I1I % I1Ii1I1 - IiIIii11Ii - oOo0O00
  if 26 - 26: i1 + iI1iII1I1I1i % I1Ii1I1
  if 58 - 58: i1I % oOO + i1 % i1
  if 88 - 88: ooo000 / i1I . ooo000 + i1I
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class LSTM(tf.keras.layers.Layer):\n' )
  if 100 - 100: Oo % ooo000 + iI1iII1I1I1i / Ii
  self . model_file . write ( '\tclass Activation():\n' )
  self . model_file . write ( '\t\tdef __init__(self,inputGate,forgetGate,outputGate,memory,shadowGate):\n' )
  self . model_file . write ( '\t\t\tself.inputGate = tf.keras.activations.get(inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGate = tf.keras.activations.get(forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGate = tf.keras.activations.get(outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memory = tf.keras.activations.get(memory)\n' )
  self . model_file . write ( '\t\t\tself.shadowGate = tf.keras.activations.get(shadowGate)\n\n' )
  if 59 - 59: i1 * IiIIii11Ii . ooo000 . I11iiIi11i1I . Iii1i / i1I
  self . model_file . write ( '\tclass Initializer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,inputGate,forgetGate,outputGate,memory):\n' )
  self . model_file . write ( '\t\t\tself.inputGate = tf.keras.initializers.get(inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGate = tf.keras.initializers.get(forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGate = tf.keras.initializers.get(outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memory = tf.keras.initializers.get(memory)\n\n' )
  if 8 - 8: OooOoo % OooOoo + IIiIIiIi11I1 - oOO - i1i1i1111I
  self . model_file . write ( '\tclass Regularizer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,inputGate,forgetGate,outputGate,memory):\n' )
  self . model_file . write ( '\t\t\tself.inputGate = tf.keras.regularizers.get(inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGate = tf.keras.regularizers.get(forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGate = tf.keras.regularizers.get(outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memory = tf.keras.regularizers.get(memory)\n\n' )
  if 14 - 14: IIiIIiIi11I1 / I1Ii1I1 . oOO / i1
  self . model_file . write ( '\t\t\n' )
  self . model_file . write ( '\tdef __init__(self,units,activation = Activation(\'sigmoid\',\'sigmoid\',\'sigmoid\',\'tanh\',\'tanh\'),kernelInitializer = Initializer(\'glorot_uniform\',\'glorot_uniform\',\'glorot_uniform\',\'glorot_uniform\'),\n' )
  self . model_file . write ( '\t\t\trecurrentInitializer = Initializer(\'orthogonal\',\'orthogonal\',\'orthogonal\',\'orthogonal\'),peepholeInitializer = Initializer(\'orthogonal\',\'orthogonal\',\'orthogonal\',None),\n' )
  self . model_file . write ( '\t\t\tbiasInitializer = Initializer(\'zeros\',\'zeros\',\'zeros\',\'zeros\'),kernelRegularizer = Regularizer(None,None,None,None),recurrentRegularizer = Regularizer(None,None,None,None),\n' )
  self . model_file . write ( '\t\t\tpeepholeRegularizer = Regularizer(None,None,None,None),biasRegularizer = Regularizer(None,None,None,None),useBias = True,usePeephole = False,dropout = 0.,recurrentDropout = 0.,\n' )
  self . model_file . write ( '\t\t\tmemoryCellClip = None,shadowStateClip = None,statefull = False,goBackwards = False,returnSequenceLen = 1,returnState = False,**kwargs):\n' )
  self . model_file . write ( '\t\tsuper(LSTM, self).__init__(**kwargs)\n' )
  self . model_file . write ( '\t\tself.units = units\n' )
  self . model_file . write ( '\t\tself.activation =  activation\n' )
  self . model_file . write ( '\t\tself.kernelInitializer = kernelInitializer\n' )
  self . model_file . write ( '\t\tself.recurrentInitializer = recurrentInitializer\n' )
  self . model_file . write ( '\t\tself.peepholeInitializer = peepholeInitializer\n' )
  self . model_file . write ( '\t\tself.biasInitializer = biasInitializer\n' )
  self . model_file . write ( '\t\tself.kernelRegularizer = kernelRegularizer\n' )
  self . model_file . write ( '\t\tself.recurrentRegularizer =recurrentRegularizer\n' )
  self . model_file . write ( '\t\tself.peepholeRegularizer = peepholeRegularizer\n' )
  self . model_file . write ( '\t\tself.biasRegularizer = biasRegularizer\n' )
  self . model_file . write ( '\t\tself.useBias = useBias\n' )
  self . model_file . write ( '\t\tself.usePeephole = usePeephole\n' )
  self . model_file . write ( '\t\tself.dropout = dropout\n' )
  self . model_file . write ( '\t\tself.recurrentDropout = recurrentDropout\n' )
  self . model_file . write ( '\t\tself.memoryCellClip = memoryCellClip\n' )
  self . model_file . write ( '\t\tself.shadowStateClip = shadowStateClip\n' )
  self . model_file . write ( '\t\tself.statefull = statefull\n' )
  self . model_file . write ( '\t\tself.goBackwards = goBackwards\n' )
  self . model_file . write ( '\t\tself.returnSequenceLen = returnSequenceLen\n' )
  self . model_file . write ( '\t\tself.returnState = returnState\n' )
  self . model_file . write ( '\t\tself._initialMemoryCell = None\n' )
  self . model_file . write ( '\t\tself._initialShadowState = None\n\n' )
  if 75 - 75: I11iiIi11i1I
  self . model_file . write ( '\tdef build(self, input_shape):\n' )
  self . model_file . write ( '\t\tinput_dim = int(input_shape[-1])\n' )
  self . model_file . write ( '\t\tself.inputGateKernel = self.add_weight(shape=(input_dim, self.units),name=\'inputGateKernel\',initializer=self.kernelInitializer.inputGate,regularizer=self.kernelRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\tself.forgetGateKernel = self.add_weight(shape=(input_dim, self.units),name=\'forgetGateKernel\',initializer=self.kernelInitializer.forgetGate,regularizer=self.kernelRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\tself.outputGateKernel = self.add_weight(shape=(input_dim, self.units),name=\'outputGateKernel\',initializer=self.kernelInitializer.outputGate,regularizer=self.kernelRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tself.memoryKernel = self.add_weight(shape=(input_dim, self.units),name=\'memoryKernel\',initializer=self.kernelInitializer.memory,regularizer=self.kernelRegularizer.memory)\n' )
  self . model_file . write ( '\t\tself.inputGateRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'inputGateRecurrentKernel\',initializer=self.recurrentInitializer.inputGate,regularizer=self.recurrentRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\tself.forgetGateRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'forgetGateRecurrentKernel\',initializer=self.recurrentInitializer.forgetGate,regularizer=self.recurrentRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\tself.outputGateRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'outputGateRecurrentKernel\',initializer=self.recurrentInitializer.outputGate,regularizer=self.recurrentRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tself.memoryRecurrentKernel = self.add_weight(shape=(self.units, self.units),name=\'memoryRecurrentKernel\',initializer=self.recurrentInitializer.memory,regularizer=self.recurrentRegularizer.memory)\n' )
  self . model_file . write ( '\t\tif self.usePeephole:\n' )
  self . model_file . write ( '\t\t\tself.inputGatePeepholeKernel = self.add_weight(shape=(self.units, self.units),name=\'inputGatePeepholeKernel\',initializer=self.peepholeInitializer.inputGate,regularizer=self.peepholeRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGatePeepholeKernel = self.add_weight(shape=(self.units, self.units),name=\'forgetGatePeepholeKernel\',initializer=self.peepholeInitializer.forgetGate,regularizer=self.peepholeRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGatePeepholeKernel = self.add_weight(shape=(self.units, self.units),name=\'outputGatePeepholeKernel\',initializer=self.peepholeInitializer.outputGate,regularizer=self.peepholeRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tself.inputGateBias = self.add_weight(shape=(self.units,),name=\'inputGateBias\',initializer=self.biasInitializer.inputGate,regularizer=self.biasRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGateBias = self.add_weight(shape=(self.units,),name=\'forgetGateBias\',initializer=self.biasInitializer.forgetGate,regularizer=self.biasRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGateBias = self.add_weight(shape=(self.units,),name=\'outputGateBias\',initializer=self.biasInitializer.outputGate,regularizer=self.biasRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memoryBias = self.add_weight(shape=(self.units,),name=\'memoryBias\',initializer=self.biasInitializer.memory,regularizer=self.biasRegularizer.memory)\n' )
  self . model_file . write ( '\t\tself.built = True\n\n' )
  if 1 - 1: ooOOO . Oo - i1I % i1iiIII111 . Ii
  self . model_file . write ( '\tdef _stepFunction(self,inputs,states,training = None):\n' )
  self . model_file . write ( '\t\tmemoryCell,shadowState = states\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout), inputs, training=training)\n' )
  self . model_file . write ( '\t\tif  0 < self.recurrentDropout < 1 : shadowState =   tf.keras.backend.in_train_phase(tf.nn.dropout(shadowState,self.recurrentDropout), shadowState, training=training)\n' )
  self . model_file . write ( '\t\tif self.usePeephole:\n' )
  self . model_file . write ( '\t\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernel) + tf.matmul(inputs,self.inputGateKernel) + tf.matmul(memoryCell,self.inputGatePeepholeKernel)  + self.inputGateBias)\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernel) + tf.matmul(inputs,self.forgetGateKernel) + tf.matmul(memoryCell,self.forgetGatePeepholeKernel)  + self.forgetGateBias)\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernel) + tf.matmul(inputs,self.memoryKernel) + self.memoryBias)\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernel) + tf.matmul(inputs,self.outputGateKernel) + tf.matmul(newMemoryCell,self.outputGatePeepholeKernel) + self.outputGateBias)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernel) + tf.matmul(inputs,self.inputGateKernel) + tf.matmul(memoryCell,self.inputGatePeepholeKernel))\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernel) + tf.matmul(inputs,self.forgetGateKernel) + tf.matmul(memoryCell,self.forgetGatePeepholeKernel))\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernel) + tf.matmul(inputs,self.memoryKernel))\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernel) + tf.matmul(inputs,self.outputGateKernel) + tf.matmul(newMemoryCell,self.outputGatePeepholeKernel))\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernel) + tf.matmul(inputs,self.inputGateKernel)  + self.inputGateBias)\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernel) + tf.matmul(inputs,self.forgetGateKernel) + self.forgetGateBias)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernel) + tf.matmul(inputs,self.outputGateKernel) + self.outputGateBias)\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernel) + tf.matmul(inputs,self.memoryKernel) + self.memoryBias)\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernel) + tf.matmul(inputs,self.inputGateKernel))\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernel) + tf.matmul(inputs,self.forgetGateKernel))\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernel) + tf.matmul(inputs,self.outputGateKernel))\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernel) + tf.matmul(inputs,self.memoryKernel)) \n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\tnewShadowState = tf.multiply(outputGateOutput,self.activation.shadowGate(newMemoryCell))\n' )
  self . model_file . write ( '\t\toutput = newShadowState\n' )
  self . model_file . write ( '\t\tif self.shadowStateClip is not None: newShadowState = tf.clip_by_value(newShadowState,-1*self.shadowStateClip,self.shadowStateClip)\n' )
  self . model_file . write ( '\t\treturn output,(newMemoryCell,newShadowState)\n\n' )
  if 45 - 45: Ooo0Ooo * ooo000
  self . model_file . write ( '\tdef _switchBatchTime(self,inputs):\n' )
  self . model_file . write ( '\t\tperm = list(range(inputs.get_shape().rank))\n' )
  self . model_file . write ( '\t\tperm[0:2] = (1,0)\n' )
  self . model_file . write ( '\t\treturn tf.transpose(inputs,perm)\n\n' )
  if 40 - 40: IIiIIiIi11I1 - ooOOO
  self . model_file . write ( '\tdef _getInitialState(self,inputs):\n' )
  self . model_file . write ( '\t\tinitialState = tf.zeros_like(inputs)\n' )
  self . model_file . write ( '\t\tinitialState = initialState[:,0,0:1]\n' )
  self . model_file . write ( '\t\tmultiples = tf.convert_to_tensor([1,self.units])\n' )
  self . model_file . write ( '\t\tinitialState = tf.tile(initialState,multiples)\n' )
  self . model_file . write ( '\t\treturn initialState\n\n' )
  if 88 - 88: IiIIii11Ii . OooOoo
  self . model_file . write ( '\tdef call(self, inputs ,states = None):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = inputs.shape.as_list()\n' )
  self . model_file . write ( '\t\ttimeStepsTensor = tf.shape(inputs)[1]\n' )
  self . model_file . write ( '\t\tinitialMemoryCell,initialShadowState = states if states is not None else self._initialMemoryCell,self._initialShadowState\n' )
  self . model_file . write ( '\t\tif initialMemoryCell is None: initialMemoryCell = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tif initialShadowState is None: initialShadowState = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tinputs = self._switchBatchTime(inputs)\n' )
  self . model_file . write ( '\t\tinitialTime = tf.zeros_like(timeStepsTensor,name=\'time\')\n' )
  self . model_file . write ( '\t\tinputsTensorArray = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArray = inputsTensorArray.unstack(tf.reverse(inputs,tf.zeros(1, tf.int32))) if self.goBackwards else inputsTensorArray.unstack(inputs)\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArray = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tdef _cond(time,outputTensorArray,memoryCell,shadowState):\n' )
  self . model_file . write ( '\t\t\treturn time<timeStepsTensor\n\n' )
  self . model_file . write ( '\t\tdef _body(time,outputTensorArray,memoryCell,shadowState):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArray.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,(newMemoryCell,newShadowState) = self._stepFunction(currentInput,(memoryCell,shadowState))\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,newMemoryCell,newShadowState)\n\n' )
  self . model_file . write ( '\t\tfinalOutputs = tf.while_loop(cond = _cond,body=_body,loop_vars=(initialTime,initialOutputTensorArray,initialMemoryCell,initialShadowState))\n' )
  self . model_file . write ( '\t\tnewMemoryCell,newShadowState = finalOutputs[-2],finalOutputs[-1]\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArray = finalOutputs[1]\n' )
  self . model_file . write ( '\t\tfinalOutput = finalOutputTensorArray.stack()\n' )
  self . model_file . write ( '\t\tfinalOutput.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tif self.statefull: self._initialMemoryCell,self._initialShadowState = newMemoryCell,newShadowState\n' )
  self . model_file . write ( '\t\tif self.returnSequenceLen is 1: finalOutput = finalOutput[-1]\n' )
  self . model_file . write ( '\t\telif self.returnSequenceLen is not None:\n' )
  self . model_file . write ( '\t\t\tfinalOutput = finalOutput[-self.returnSequenceLen:]\n' )
  self . model_file . write ( '\t\t\tfinalOutput = self._switchBatchTime(finalOutput)\n' )
  self . model_file . write ( '\t\telse: finalOutput = self._switchBatchTime(finalOutput)\n' )
  self . model_file . write ( '\t\tif self.returnState: return [finalOutput,newMemoryCell,newShadowState]\n' )
  self . model_file . write ( '\t\telse: return finalOutput\n\n' )
  if 20 - 20: i1iiIII111 % I1Ii1I1 - ooo000 . i1i1i1111I . I11iiIi11i1I
  self . model_file . write ( '\tdef compute_output_shape(self,input_shape):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = input_shape\n' )
  self . model_file . write ( '\t\tif self.returnSequenceLen in [1,None]:\n' )
  self . model_file . write ( '\t\t\tif self.returnSequenceLen == 1: outputShape = tf.TensorShape([batchSize,self.units])\n' )
  self . model_file . write ( '\t\t\telse: outputShape = tf.TensorShape([batchSize,timeSteps,self.units])\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tif timeSteps is None or timeSteps < self.returnSequenceLen : raise ValueError(\'returnSequenceLen not match to timeSteps\')\n' )
  self . model_file . write ( '\t\t\telse: outputShape = tf.TensorShape([batchSize,self.returnSequenceLen,self.units])\n' )
  self . model_file . write ( '\t\tif not self.returnState : return outputShape\n' )
  self . model_file . write ( '\t\tmemoryCellShape = tf.TensorShape([batchSize,self.units])\n' )
  self . model_file . write ( '\t\tshadowStateShape = tf.TensorShape([batchSize,self.units])\n' )
  self . model_file . write ( '\t\treturn [outputShape,(memoryCellShape,shadowStateShape)]\n\n' )
  if 8 - 8: Oo . oOO
  self . model_file . write ( '\tdef get_config(self):\n' )
  self . model_file . write ( '\t\tconfig = {\'units\': self.units,\'activation\' : self.activation,\'kernelInitializer\' : self.kernelInitializer,\'recurrentInitializer\' : self.recurrentInitializer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'peepholeInitializer\' : self.peepholeInitializer,\'biasInitializer\' : self.biasInitializer,\'kernelRegularizer\' : self.kernelRegularizer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'recurrentRegularizer\' : self.recurrentRegularizer,\'peepholeRegularizer\' : self.peepholeRegularizer,\'biasRegularizer\' : self.biasRegularizer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'useBias\': self.useBias,\'usePeephole\' : self.usePeephole,\'dropout\': self.dropout,\'recurrentDropout\': self.recurrentDropout,\'memoryCellClip\' : self.memoryCellClip,\n' )
  self . model_file . write ( '\t\t\t\t\t\'shadowStateClip\' : self.shadowStateClip,\'statefull\' : self.statefull,\'goBackwards\' : self.goBackwards,\'returnSequenceLen\':self.returnSequenceLen,\'returnState\':self.returnState,}\n' )
  self . model_file . write ( '\t\tbaseConfig = super(LSTM, self).get_config()\n' )
  self . model_file . write ( '\t\treturn dict(list(baseConfig.items()) + list(config.items()))\n' )
  if 86 - 86: i1
 def write_BiRNN ( self ) :
  if 42 - 42: I11iiIi11i1I * I1I / Ooo0Ooo
  if 93 - 93: Oo . i1I
  if 52 - 52: IiIIii11Ii / I11iiIi11i1I % i1
  if 77 - 77: IIiIIiIi11I1 / i1iiIII111 - ooo000
  if 26 - 26: i1iiIII111 - Ii + I11iiIi11i1I - ooOOO / i1 - ooOOO
  if 48 - 48: Ooo0Ooo + i1i1i1111I + oOo0O00
  if 56 - 56: IiI11Ii111 / oOO % i1iiIII111 - IiIIii11Ii % i1
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class BiRNN(tf.keras.layers.Layer):\n' )
  if 26 - 26: oOo0O00 + Oo * i1iiIII111 / iI1iII1I1I1i - Oo % Oo
  self . model_file . write ( '\tdef __init__(self,units,activation = \'tanh\',kernelInitializer = \'glorot_uniform\',recurrentInitializer = \'orthogonal\',biasInitializer = \'zero\',\n' )
  self . model_file . write ( '\t\t\tkernelRegularizer = None,recurrentRegularizer = None,biasRegularizer = None,kernelConstraint = None,recurrentConstraint = None,biasConstraint = None,\n' )
  self . model_file . write ( '\t\t\tuseBias = True,dropout = 0.,recurrentDropout = 0.,stateClip = None,statefull = False,mergeMode = \'concat\',**kwargs):\n' )
  self . model_file . write ( '\t\tsuper(BiRNN, self).__init__(**kwargs)\n' )
  self . model_file . write ( '\t\tself.units = units\n' )
  self . model_file . write ( '\t\tself.activation =  tf.keras.activations.get(activation)\n' )
  self . model_file . write ( '\t\tself.kernelInitializer = tf.keras.initializers.get(kernelInitializer)\n' )
  self . model_file . write ( '\t\tself.recurrentInitializer = tf.keras.initializers.get(recurrentInitializer)\n' )
  self . model_file . write ( '\t\tself.biasInitializer = tf.keras.initializers.get(biasInitializer)\n' )
  self . model_file . write ( '\t\tself.kernelRegularizer = tf.keras.regularizers.get(kernelRegularizer)\n' )
  self . model_file . write ( '\t\tself.recurrentRegularizer =tf.keras.regularizers.get(recurrentRegularizer)\n' )
  self . model_file . write ( '\t\tself.biasRegularizer = tf.keras.regularizers.get(biasRegularizer)\n' )
  self . model_file . write ( '\t\tself.kernelConstraint = tf.keras.constraints.get(kernelConstraint)\n' )
  self . model_file . write ( '\t\tself.recurrentConstraint = tf.keras.constraints.get(recurrentConstraint)\n' )
  self . model_file . write ( '\t\tself.biasConstraint = tf.keras.constraints.get(biasConstraint)\n' )
  self . model_file . write ( '\t\tself.useBias = useBias\n' )
  self . model_file . write ( '\t\tself.dropout = dropout\n' )
  self . model_file . write ( '\t\tself.recurrentDropout = recurrentDropout\n' )
  self . model_file . write ( '\t\tself.stateClip = stateClip\n' )
  self . model_file . write ( '\t\tself.statefull = statefull\n' )
  self . model_file . write ( '\t\tself.mergeMode = mergeMode\n' )
  self . model_file . write ( '\t\tself._initialStateForward = None\n' )
  self . model_file . write ( '\t\tself._initialStateBackward = None\n\n' )
  if 73 - 73: I1I % Iii1i - ooo000 % Ii + i1iiIII111 / i1I
  self . model_file . write ( '\tdef build(self, input_shape):\n' )
  self . model_file . write ( '\t\tinput_dim = int(input_shape[-1])\n' )
  self . model_file . write ( '\t\tself.kernelForward = self.add_weight(shape=(input_dim,self.units),name=\'kernel\',initializer=self.kernelInitializer,regularizer=self.kernelRegularizer,constraint=self.kernelConstraint)\n' )
  self . model_file . write ( '\t\tself.recurrentKernelForward = self.add_weight(shape=(self.units,self.units),name=\'recurrentKernel\',initializer=self.recurrentInitializer,regularizer=self.recurrentRegularizer,constraint=self.recurrentConstraint)\n' )
  self . model_file . write ( '\t\tself.kernelBackward = self.add_weight(shape=(input_dim,self.units),name=\'kernel\',initializer=self.kernelInitializer,regularizer=self.kernelRegularizer,constraint=self.kernelConstraint)\n' )
  self . model_file . write ( '\t\tself.recurrentKernelBackward = self.add_weight(shape=(self.units,self.units),name=\'recurrentKernel\',initializer=self.recurrentInitializer,regularizer=self.recurrentRegularizer,constraint=self.recurrentConstraint)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tself.biasForward = self.add_weight(shape=(self.units,),name=\'bias\',initializer=self.biasInitializer,regularizer=self.biasRegularizer,constraint=self.biasConstraint)\n' )
  self . model_file . write ( '\t\t\tself.biasBackward = self.add_weight(shape=(self.units,),name=\'bias\',initializer=self.biasInitializer,regularizer=self.biasRegularizer,constraint=self.biasConstraint)\n' )
  self . model_file . write ( '\t\tself.built = True\n\n' )
  if 57 - 57: Ooo0Ooo . Iii1i + i1iiIII111 % i1I
  self . model_file . write ( '\tdef _stepFunctionForward(self,inputs,state,training = None):\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout),inputs,training=training)\n' )
  self . model_file . write ( '\t\tif 0 < self.recurrentDropout < 1 : state = tf.keras.backend.in_train_phase(tf.nn.dropout(state,self.recurrentDropout),state,training=training)\n' )
  self . model_file . write ( '\t\tif self.useBias: output = self.activation(tf.matmul(state,self.recurrentKernelForward) + tf.matmul(inputs,self.kernelForward) + self.biasForward)\n' )
  self . model_file . write ( '\t\telse: output = self.activation(tf.matmul(state,self.recurrentKernelForward) + tf.matmul(inputs,self.kernelForward))\n' )
  self . model_file . write ( '\t\tif self.stateClip is not None:\n' )
  self . model_file . write ( '\t\t\tnewState = tf.clip_by_value(output,-1*self.stateClip,self.stateClip)\n' )
  self . model_file . write ( '\t\t\treturn output,newState\n' )
  self . model_file . write ( '\t\treturn output,output\n\n' )
  if 85 - 85: i1iiIII111 * IiI11Ii111 * i1i1i1111I + i1i1i1111I % ooOOO
  self . model_file . write ( '\tdef _stepFunctionBackward(self,inputs,state,training = None):\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout),inputs,training=training)\n' )
  self . model_file . write ( '\t\tif 0 < self.recurrentDropout < 1 : state = tf.keras.backend.in_train_phase(tf.nn.dropout(state,self.recurrentDropout),state,training=training)\n' )
  self . model_file . write ( '\t\tif self.useBias: output = self.activation(tf.matmul(state,self.recurrentKernelBackward) + tf.matmul(inputs,self.kernelBackward) + self.biasBackward)\n' )
  self . model_file . write ( '\t\telse: output = self.activation(tf.matmul(state,self.recurrentKernelBackward) + tf.matmul(inputs,self.kernelBackward))\n' )
  self . model_file . write ( '\t\tif self.stateClip is not None:\n' )
  self . model_file . write ( '\t\t\tnewState = tf.clip_by_value(output,-1*self.stateClip,self.stateClip)\n' )
  self . model_file . write ( '\t\t\treturn output,newState\n' )
  self . model_file . write ( '\t\treturn output,output\n\n' )
  if 91 - 91: IIiIIiIi11I1 / i1i1i1111I / oOO
  self . model_file . write ( '\tdef _switchBatchTime(self,inputs):\n' )
  self . model_file . write ( '\t\tperm = list(range(inputs.get_shape().rank))\n' )
  self . model_file . write ( '\t\tperm[0:2] = (1,0)\n' )
  self . model_file . write ( '\t\treturn tf.transpose(inputs,perm)\n\n' )
  if 24 - 24: oOo0O00 * I11iiIi11i1I / ooOOO / ooOOO + Oo / i1i1i1111I
  self . model_file . write ( '\tdef _getInitialState(self,inputs):\n' )
  self . model_file . write ( '\t\tinitialState = tf.zeros_like(inputs)\n' )
  self . model_file . write ( '\t\tinitialState = initialState[:,0,0:1]\n' )
  self . model_file . write ( '\t\tmultiples = tf.convert_to_tensor([1,self.units])\n' )
  self . model_file . write ( '\t\tinitialState = tf.tile(initialState,multiples)\n' )
  self . model_file . write ( '\t\treturn initialState\n\n' )
  if 55 - 55: Ooo0Ooo + Oo % Ooo0Ooo
  self . model_file . write ( '\tdef call(self, inputs ,state = None):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = inputs.shape.as_list()\n' )
  self . model_file . write ( '\t\ttimeStepsTensor = tf.shape(inputs)[1]\n' )
  self . model_file . write ( '\t\tinitialStateForward,initialStateBackward = self._initialStateForward,self._initialStateBackward\n' )
  self . model_file . write ( '\t\tif initialStateForward is None: initialStateForward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tif initialStateBackward is None: initialStateBackward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tinputs = self._switchBatchTime(inputs)\n' )
  self . model_file . write ( '\t\tinitialTime = tf.zeros_like(timeStepsTensor,name=\'time\')\n' )
  self . model_file . write ( '\t\tinputsTensorArrayForward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayBackward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayForward = inputsTensorArrayForward.unstack(inputs)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayBackward = inputsTensorArrayBackward.unstack(tf.reverse(inputs,tf.zeros(1, tf.int32)))\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArrayForward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArrayBackward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tdef _cond(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\treturn time<timeStepsTensor\n\n' )
  self . model_file . write ( '\t\tdef _bodyForward(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArrayForward.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,state = self._stepFunctionForward(currentInput,state)\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,state)\n\n' )
  self . model_file . write ( '\t\tdef _bodyBackward(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArrayBackward.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,state = self._stepFunctionBackward(currentInput,state)\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,state)\n\n' )
  self . model_file . write ( '\t\tfinalOutputsForward = tf.while_loop(cond=_cond,body=_bodyForward,loop_vars=(initialTime,initialOutputTensorArrayForward,initialStateForward))\n' )
  self . model_file . write ( '\t\tfinalOutputsBackward = tf.while_loop(cond=_cond,body=_bodyBackward,loop_vars=(initialTime,initialOutputTensorArrayBackward,initialStateBackward))\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArrayForward = finalOutputsForward[1]\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArrayBackward = finalOutputsBackward[1]\n' )
  self . model_file . write ( '\t\tfinalOutputForward = finalOutputTensorArrayForward.stack()\n' )
  self . model_file . write ( '\t\tfinalOutputBackward = finalOutputTensorArrayBackward.stack()\n' )
  self . model_file . write ( '\t\tfinalOutputForward.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tfinalOutputBackward.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tif self.statefull : self._initialStatForwarde,self._initialStateBackward = finalOutputsForward[-1],finalOutputsBackward[-1]\n' )
  self . model_file . write ( '\t\tfinalOutputForward = self._switchBatchTime(finalOutputForward)\n' )
  self . model_file . write ( '\t\tfinalOutputBackward = self._switchBatchTime(finalOutputBackward)\n' )
  self . model_file . write ( '\t\tif self.mergeMode == \'concat\': mergeOutput = tf.concat([finalOutputForward, finalOutputBackward],-1)\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'sum\': mergeOutput = finalOutputForward + finalOutputBackward\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'ave\': mergeOutput = (finalOutputForward + finalOutputBackward) / 2\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'mul\': mergeOutput = finalOutputForward * finalOutputBackward\n' )
  self . model_file . write ( '\t\telif self.mergeMode is None: mergeOutput = [finalOutputForward, finalOutputBackward]\n' )
  self . model_file . write ( '\t\telse: raise ValueError(\'mergeMode wrong\')\n' )
  self . model_file . write ( '\t\treturn mergeOutput\n\n' )
  if 23 - 23: i1 / i1i1i1111I % OooOoo * ooo000
  self . model_file . write ( '\tdef compute_output_shape(self,input_shape):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,dim = input_shape\n' )
  self . model_file . write ( '\t\toutputShape = tf.TensorShape([batchSize,timeSteps,self.units*2]) if self.mergeMode == \'concat\' else tf.TensorShape([batchSize,timeSteps,self.units])\n' )
  self . model_file . write ( '\t\tif self.mergeMode is None : return [outputShape,outputShape]\n' )
  self . model_file . write ( '\t\treturn outputShape\n\n' )
  if 44 - 44: i1iiIII111 % i1iiIII111 / Oo / I1Ii1I1
  self . model_file . write ( '\tdef get_config(self):\n' )
  self . model_file . write ( '\t\tconfig = {\'units\': self.units,\'activation\': tf.keras.activations.serialize(self.activation),\'kernelInitializer\': tf.keras.initializers.serialize(self.kernelInitializer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'recurrentInitializer\': tf.keras.initializers.serialize(self.recurrentInitializer),\'biasInitializer\': tf.keras.initializers.serialize(self.biasInitializer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'kernelRegularizer\': tf.keras.regularizers.serialize(self.kernelRegularizer),\'recurrentRegularizer\': tf.keras.regularizers.serialize(self.recurrentRegularizer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'biasRegularizer\': tf.keras.regularizers.serialize(self.biasRegularizer),\'useBias\': self.useBias,\'dropout\': self.dropout,\'recurrentDropout\': self.recurrentDropout,\n' )
  self . model_file . write ( '\t\t\t\t\t\'stateClip\': self.stateClip,\'statefull\': self.statefull,\'mergeMode\':self.mergeMode}\n' )
  self . model_file . write ( '\t\tbaseConfig = super(BiRNN, self).get_config()\n' )
  self . model_file . write ( '\t\treturn dict(list(baseConfig.items()) + list(config.items()))\n' )
  if 98 - 98: Oo . Oo . IIiIIiIi11I1
 def write_BiGRU ( self ) :
  if 16 - 16: IIiIIiIi11I1 % IiI11Ii111 / OooOoo
  if 57 - 57: i1i1i1111I - IiI11Ii111 % iI1iII1I1I1i / i1iiIII111 - I11iiIi11i1I % I11iiIi11i1I
  if 52 - 52: I1Ii1I1 / Oo / OooOoo
  if 97 - 97: i1I % Ooo0Ooo / IiIIii11Ii - IiI11Ii111 - iI1iII1I1I1i
  if 26 - 26: ooo000
  if 28 - 28: Oo % Ii + I1Ii1I1 . iI1iII1I1I1i
  if 65 - 65: Ii . oOo0O00 * ooo000
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class BiGRU(tf.keras.layers.Layer):\n' )
  if 60 - 60: IiI11Ii111 * IiIIii11Ii + I1I - I1I . i1i1i1111I + IiI11Ii111
  self . model_file . write ( '\tclass Activation():\n' )
  self . model_file . write ( '\t\tdef __init__(self,resetGate,updateGate,stateCandidate):\n' )
  self . model_file . write ( '\t\t\tself.resetGate = tf.keras.activations.get(resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGate = tf.keras.activations.get(updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidate = tf.keras.activations.get(stateCandidate)\n\n' )
  if 9 - 9: i1 / ooo000
  self . model_file . write ( '\tclass Initializer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,resetGate,updateGate,stateCandidate):\n' )
  self . model_file . write ( '\t\t\tself.resetGate = tf.keras.initializers.get(resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGate = tf.keras.initializers.get(updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidate = tf.keras.initializers.get(stateCandidate)\n\n' )
  if 33 - 33: iI1iII1I1I1i . OooOoo
  self . model_file . write ( '\tclass Regularizer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,resetGate,updateGate,stateCandidate):\n' )
  self . model_file . write ( '\t\t\tself.resetGate = tf.keras.regularizers.get(resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGate = tf.keras.regularizers.get(updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidate = tf.keras.regularizers.get(stateCandidate)\n\n' )
  if 37 - 37: ooo000
  self . model_file . write ( '\t\t\n' )
  self . model_file . write ( '\tdef __init__(self,units,activation = Activation(\'sigmoid\',\'sigmoid\',\'tanh\'),kernelInitializer = Initializer(\'glorot_uniform\',\'glorot_uniform\',\'glorot_uniform\'),\n' )
  self . model_file . write ( '\t\t\trecurrentInitializer = Initializer(\'orthogonal\',\'orthogonal\',\'orthogonal\'),biasInitializer = Initializer(\'zeros\',\'zeros\',\'zeros\'),kernelRegularizer = Regularizer(None,None,None),\n' )
  self . model_file . write ( '\t\t\trecurrentRegularizer = Regularizer(None,None,None),biasRegularizer = Regularizer(None,None,None,),useBias = True,dropout = 0.,recurrentDropout = 0.,\n' )
  self . model_file . write ( '\t\t\tstateClip = None,statefull = False,mergeMode = \'concat\',**kwargs):\n' )
  self . model_file . write ( '\t\tsuper(BiGRU, self).__init__(**kwargs)\n' )
  self . model_file . write ( '\t\tself.units = units\n' )
  self . model_file . write ( '\t\tself.activation =  activation\n' )
  self . model_file . write ( '\t\tself.kernelInitializer = kernelInitializer\n' )
  self . model_file . write ( '\t\tself.recurrentInitializer = recurrentInitializer\n' )
  self . model_file . write ( '\t\tself.biasInitializer = biasInitializer\n' )
  self . model_file . write ( '\t\tself.kernelRegularizer = kernelRegularizer\n' )
  self . model_file . write ( '\t\tself.recurrentRegularizer =recurrentRegularizer\n' )
  self . model_file . write ( '\t\tself.biasRegularizer = biasRegularizer\n' )
  self . model_file . write ( '\t\tself.useBias = useBias\n' )
  self . model_file . write ( '\t\tself.dropout = dropout\n' )
  self . model_file . write ( '\t\tself.recurrentDropout = recurrentDropout\n' )
  self . model_file . write ( '\t\tself.stateClip = stateClip\n' )
  self . model_file . write ( '\t\tself.statefull = statefull\n' )
  self . model_file . write ( '\t\tself.mergeMode = mergeMode\n\n' )
  self . model_file . write ( '\t\tself._initialStateForward = None\n' )
  self . model_file . write ( '\t\tself._initialStateBackward = None\n\n' )
  if 34 - 34: ooo000 - IIiIIiIi11I1 + i1 - Oo * Oo
  self . model_file . write ( '\tdef build(self, input_shape):\n' )
  self . model_file . write ( '\t\tinput_dim = int(input_shape[-1])\n' )
  self . model_file . write ( '\t\tself.resetGateKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'resetGateKernelForward\',initializer=self.kernelInitializer.resetGate,regularizer=self.kernelRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\tself.updateGateKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'updateGateKernelForward\',initializer=self.kernelInitializer.updateGate,regularizer=self.kernelRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\tself.stateCandidateKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'stateCandidateKernelForward\',initializer=self.kernelInitializer.stateCandidate,regularizer=self.kernelRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tself.resetGateRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'resetGateRecurrentKernelForward\',initializer=self.recurrentInitializer.resetGate,regularizer=self.recurrentRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\tself.updateGateRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'updateGateRecurrentKernelForward\',initializer=self.recurrentInitializer.updateGate,regularizer=self.recurrentRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\tself.stateCandidateRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'stateCandidateRecurrentKernelForward\',initializer=self.recurrentInitializer.stateCandidate,regularizer=self.recurrentRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tself.resetGateKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'resetGateKernelBackward\',initializer=self.kernelInitializer.resetGate,regularizer=self.kernelRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\tself.updateGateKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'updateGateKernelBackward\',initializer=self.kernelInitializer.updateGate,regularizer=self.kernelRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\tself.stateCandidateKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'stateCandidateKernelBackward\',initializer=self.kernelInitializer.stateCandidate,regularizer=self.kernelRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tself.resetGateRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'resetGateRecurrentKernelBackward\',initializer=self.recurrentInitializer.resetGate,regularizer=self.recurrentRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\tself.updateGateRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'updateGateRecurrentKernelBackward\',initializer=self.recurrentInitializer.updateGate,regularizer=self.recurrentRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\tself.stateCandidateRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'stateCandidateRecurrentKernelBackward\',initializer=self.recurrentInitializer.stateCandidate,regularizer=self.recurrentRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tself.resetGateBiasForward = self.add_weight(shape=(self.units,),name=\'resetGateBiasForward\',initializer=self.biasInitializer.resetGate,regularizer=self.biasRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGateBiasForward = self.add_weight(shape=(self.units,),name=\'updateGateBiasForward\',initializer=self.biasInitializer.updateGate,regularizer=self.biasRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidateBiasForward = self.add_weight(shape=(self.units,),name=\'stateCandidate\',initializer=self.biasInitializer.stateCandidate,regularizer=self.biasRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\t\tself.resetGateBiasBackward = self.add_weight(shape=(self.units,),name=\'resetGateBiasBackward\',initializer=self.biasInitializer.resetGate,regularizer=self.biasRegularizer.resetGate)\n' )
  self . model_file . write ( '\t\t\tself.updateGateBiasBackward = self.add_weight(shape=(self.units,),name=\'updateGateBiasBackward\',initializer=self.biasInitializer.updateGate,regularizer=self.biasRegularizer.updateGate)\n' )
  self . model_file . write ( '\t\t\tself.stateCandidateBiasBackward = self.add_weight(shape=(self.units,),name=\'stateCandidate\',initializer=self.biasInitializer.stateCandidate,regularizer=self.biasRegularizer.stateCandidate)\n' )
  self . model_file . write ( '\t\tself.built = True\n\n' )
  if 58 - 58: I1Ii1I1
  self . model_file . write ( '\tdef _stepFunctionForward(self,inputs,state,training = None):\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout), inputs, training=training)\n' )
  self . model_file . write ( '\t\tif  0 < self.recurrentDropout < 1 : state =   tf.keras.backend.in_train_phase(tf.nn.dropout(state,self.recurrentDropout), state, training=training)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tresetGateOutput = self.activation.resetGate(tf.matmul(state,self.resetGateRecurrentKernelForward) + tf.matmul(inputs,self.resetGateKernelForward)  + self.resetGateBiasForward)\n' )
  self . model_file . write ( '\t\t\tupdateGateOutput = self.activation.updateGate(tf.matmul(state,self.updateGateRecurrentKernelForward) + tf.matmul(inputs,self.updateGateKernelForward) + self.updateGateBiasForward)\n' )
  self . model_file . write ( '\t\t\tstateCandidate = self.activation.stateCandidate(tf.matmul(tf.multiply(resetGateOutput,state),self.stateCandidateRecurrentKernelForward) + tf.matmul(inputs,self.stateCandidateKernelForward) + self.stateCandidateBiasForward)\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tresetGateOutput = self.activation.resetGate(tf.matmul(state,self.resetGateRecurrentKernelForward) + tf.matmul(inputs,self.resetGateKernelForward))\n' )
  self . model_file . write ( '\t\t\tupdateGateOutput = self.activation.updateGate(tf.matmul(state,self.updateGateRecurrentKernelForward) + tf.matmul(inputs,self.updateGateKernelForward))\n' )
  self . model_file . write ( '\t\t\tstateCandidate = self.activation.stateCandidate(tf.matmul(tf.multiply(resetGateOutput,state),self.stateCandidateRecurrentKernelForward) + tf.matmul(inputs,self.stateCandidateKernelForward))\n' )
  self . model_file . write ( '\t\toutput = tf.multiply(updateGateOutput,state) + tf.multiply(1-updateGateOutput,stateCandidate)\n' )
  self . model_file . write ( '\t\tif self.stateClip is not None:\n' )
  self . model_file . write ( '\t\t\tnewState = tf.clip_by_value(output,-1*self.stateClip,self.stateClip)\n' )
  self . model_file . write ( '\t\t\treturn output,newState\n' )
  self . model_file . write ( '\t\treturn output,output\n\n' )
  if 44 - 44: I11iiIi11i1I
  self . model_file . write ( '\tdef _stepFunctionBackward(self,inputs,state,training = None):\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout), inputs, training=training)\n' )
  self . model_file . write ( '\t\tif  0 < self.recurrentDropout < 1 : state =   tf.keras.backend.in_train_phase(tf.nn.dropout(state,self.recurrentDropout), state, training=training)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tresetGateOutput = self.activation.resetGate(tf.matmul(state,self.resetGateRecurrentKernelBackward) + tf.matmul(inputs,self.resetGateKernelBackward)  + self.resetGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\tupdateGateOutput = self.activation.updateGate(tf.matmul(state,self.updateGateRecurrentKernelBackward) + tf.matmul(inputs,self.updateGateKernelBackward) + self.updateGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\tstateCandidate = self.activation.stateCandidate(tf.matmul(tf.multiply(resetGateOutput,state),self.stateCandidateRecurrentKernelBackward) + tf.matmul(inputs,self.stateCandidateKernelBackward) + self.stateCandidateBiasBackward)\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tresetGateOutput = self.activation.resetGate(tf.matmul(state,self.resetGateRecurrentKernelBackward) + tf.matmul(inputs,self.resetGateKernelBackward))\n' )
  self . model_file . write ( '\t\t\tupdateGateOutput = self.activation.updateGate(tf.matmul(state,self.updateGateRecurrentKernelBackward) + tf.matmul(inputs,self.updateGateKernelBackward))\n' )
  self . model_file . write ( '\t\t\tstateCandidate = self.activation.stateCandidate(tf.matmul(tf.multiply(resetGateOutput,state),self.stateCandidateRecurrentKernelBackward) + tf.matmul(inputs,self.stateCandidateKernelBackward))\n' )
  self . model_file . write ( '\t\toutput = tf.multiply(updateGateOutput,state) + tf.multiply(1-updateGateOutput,stateCandidate)\n' )
  self . model_file . write ( '\t\tif self.stateClip is not None:\n' )
  self . model_file . write ( '\t\t\tnewState = tf.clip_by_value(output,-1*self.stateClip,self.stateClip)\n' )
  self . model_file . write ( '\t\t\treturn output,newState\n' )
  self . model_file . write ( '\t\treturn output,output\n\n' )
  if 15 - 15: IiI11Ii111 . oOO % IiI11Ii111 % Ooo0Ooo - IiI11Ii111 % i1I
  self . model_file . write ( '\tdef _switchBatchTime(self,inputs):\n' )
  self . model_file . write ( '\t\tperm = list(range(inputs.get_shape().rank))\n' )
  self . model_file . write ( '\t\tperm[0:2] = (1,0)\n' )
  self . model_file . write ( '\t\treturn tf.transpose(inputs,perm)\n\n' )
  if 14 - 14: OooOoo - oOo0O00 * i1i1i1111I / I11iiIi11i1I / iI1iII1I1I1i
  self . model_file . write ( '\tdef _getInitialState(self,inputs):\n' )
  self . model_file . write ( '\t\tinitialState = tf.zeros_like(inputs)\n' )
  self . model_file . write ( '\t\tinitialState = initialState[:,0,0:1]\n' )
  self . model_file . write ( '\t\tmultiples = tf.convert_to_tensor([1,self.units])\n' )
  self . model_file . write ( '\t\tinitialState = tf.tile(initialState,multiples)\n' )
  self . model_file . write ( '\t\treturn initialState\n\n' )
  if 22 - 22: ooo000
  self . model_file . write ( '\tdef call(self, inputs ,state = None):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = inputs.shape.as_list()\n' )
  self . model_file . write ( '\t\ttimeStepsTensor = tf.shape(inputs)[1]\n' )
  self . model_file . write ( '\t\tinitialStateForward,initialStateBackward = self._initialStateForward,self._initialStateBackward\n' )
  self . model_file . write ( '\t\tif initialStateForward is None: initialStateForward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tif initialStateBackward is None: initialStateBackward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tinputs = self._switchBatchTime(inputs)\n' )
  self . model_file . write ( '\t\tinitialTime = tf.zeros_like(timeStepsTensor,name=\'time\')\n' )
  self . model_file . write ( '\t\tinputsTensorArrayForward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayBackward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayForward = inputsTensorArrayForward.unstack(inputs)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayBackward = inputsTensorArrayBackward.unstack(tf.reverse(inputs,tf.zeros(1, tf.int32)))\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArrayForward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArrayBackward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tdef _cond(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\treturn time<timeStepsTensor\n\n' )
  self . model_file . write ( '\t\tdef _bodyForward(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArrayForward.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,state = self._stepFunctionForward(currentInput,state)\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,state)\n\n' )
  self . model_file . write ( '\t\tdef _bodyBackward(time,outputTensorArray,state):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArrayBackward.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,state = self._stepFunctionBackward(currentInput,state)\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,state)\n\n' )
  self . model_file . write ( '\t\tfinalOutputsForward = tf.while_loop(cond=_cond,body=_bodyForward,loop_vars=(initialTime,initialOutputTensorArrayForward,initialStateForward))\n' )
  self . model_file . write ( '\t\tfinalOutputsBackward = tf.while_loop(cond=_cond,body=_bodyBackward,loop_vars=(initialTime,initialOutputTensorArrayBackward,initialStateBackward))\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArrayForward = finalOutputsForward[1]\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArrayBackward = finalOutputsBackward[1]\n' )
  self . model_file . write ( '\t\tfinalOutputForward = finalOutputTensorArrayForward.stack()\n' )
  self . model_file . write ( '\t\tfinalOutputBackward = finalOutputTensorArrayBackward.stack()\n' )
  self . model_file . write ( '\t\tfinalOutputForward.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tfinalOutputBackward.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tif self.statefull : self._initialStatForwarde,self._initialStateBackward = finalOutputsForward[-1],finalOutputsBackward[-1]\n' )
  self . model_file . write ( '\t\tfinalOutputForward = self._switchBatchTime(finalOutputForward)\n' )
  self . model_file . write ( '\t\tfinalOutputBackward = self._switchBatchTime(finalOutputBackward)\n' )
  self . model_file . write ( '\t\tif self.mergeMode == \'concat\': mergeOutput = tf.concat([finalOutputForward, finalOutputBackward],-1)\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'sum\': mergeOutput = finalOutputForward + finalOutputBackward\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'ave\': mergeOutput = (finalOutputForward + finalOutputBackward) / 2\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'mul\': mergeOutput = finalOutputForward * finalOutputBackward\n' )
  self . model_file . write ( '\t\telif self.mergeMode is None: mergeOutput = [finalOutputForward, finalOutputBackward]\n' )
  self . model_file . write ( '\t\telse: raise ValueError(\'mergeMode wrong\')\n' )
  self . model_file . write ( '\t\treturn mergeOutput\n\n' )
  if 61 - 61: i1iiIII111 . Ii * Iii1i * IiI11Ii111
  self . model_file . write ( '\tdef compute_output_shape(self,input_shape):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,dim = input_shape\n' )
  self . model_file . write ( '\t\toutputShape = tf.TensorShape([batchSize,timeSteps,self.units*2]) if self.mergeMode == \'concat\' else tf.TensorShape([batchSize,timeSteps,self.units])\n' )
  self . model_file . write ( '\t\tif self.mergeMode is None : return [outputShape,outputShape]\n' )
  self . model_file . write ( '\t\treturn outputShape\n\n' )
  if 20 - 20: i1i1i1111I . i1i1i1111I . I1I % oOO * IiI11Ii111 / ooOOO
  self . model_file . write ( '\tdef get_config(self):\n' )
  self . model_file . write ( '\t\tconfig = {\'units\': self.units,\'activation\': tf.keras.activations.serialize(self.activation),\'kernelInitializer\': tf.keras.initializers.serialize(self.kernelInitializer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'recurrentInitializer\': tf.keras.initializers.serialize(self.recurrentInitializer),\'biasInitializer\': tf.keras.initializers.serialize(self.biasInitializer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'kernelRegularizer\': tf.keras.regularizers.serialize(self.kernelRegularizer),\'recurrentRegularizer\': tf.keras.regularizers.serialize(self.recurrentRegularizer),\n' )
  self . model_file . write ( '\t\t\t\t\t\'biasRegularizer\': tf.keras.regularizers.serialize(self.biasRegularizer),\'useBias\': self.useBias,\'dropout\': self.dropout,\'recurrentDropout\': self.recurrentDropout,\n' )
  self . model_file . write ( '\t\t\t\t\t\'stateClip\': self.stateClip,\'statefull\': self.statefull,\'mergeMode\':self.mergeMode}\n' )
  self . model_file . write ( '\t\tbaseConfig = super(BiGRU, self).get_config()\n' )
  self . model_file . write ( '\t\treturn dict(list(baseConfig.items()) + list(config.items()))\n' )
  if 83 - 83: I1I / I11iiIi11i1I * IiI11Ii111
 def write_BiLSTM ( self ) :
  if 53 - 53: ooOOO . i1iiIII111 / IIiIIiIi11I1 + Ii
  if 84 - 84: iI1iII1I1I1i - Ii - I11iiIi11i1I % oOO - Iii1i
  if 14 - 14: Iii1i . i1 - i1I - ooo000 % i1I + i1i1i1111I
  if 21 - 21: IiI11Ii111 + oOO - IiI11Ii111
  if 72 - 72: Ooo0Ooo % I1Ii1I1
  if 69 - 69: IiIIii11Ii % i1 - IiI11Ii111 / i1
  if 73 - 73: i1iiIII111 . I11iiIi11i1I % OooOoo . Oo . oOo0O00
  self . model_file . write ( '\n\n' )
  self . model_file . write ( 'class BiLSTM(tf.keras.layers.Layer):\n' )
  if 77 - 77: I1Ii1I1 * ooOOO
  self . model_file . write ( '\tclass Activation():\n' )
  self . model_file . write ( '\t\tdef __init__(self,inputGate,forgetGate,outputGate,memory,shadowGate):\n' )
  self . model_file . write ( '\t\t\tself.inputGate = tf.keras.activations.get(inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGate = tf.keras.activations.get(forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGate = tf.keras.activations.get(outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memory = tf.keras.activations.get(memory)\n' )
  self . model_file . write ( '\t\t\tself.shadowGate = tf.keras.activations.get(shadowGate)\n\n' )
  if 20 - 20: IiI11Ii111 * i1i1i1111I % i1I . ooOOO * oOo0O00
  self . model_file . write ( '\tclass Initializer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,inputGate,forgetGate,outputGate,memory):\n' )
  self . model_file . write ( '\t\t\tself.inputGate = tf.keras.initializers.get(inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGate = tf.keras.initializers.get(forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGate = tf.keras.initializers.get(outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memory = tf.keras.initializers.get(memory)\n\n' )
  if 11 - 11: I11iiIi11i1I * oOo0O00
  self . model_file . write ( '\tclass Regularizer():\n' )
  self . model_file . write ( '\t\tdef __init__(self,inputGate,forgetGate,outputGate,memory):\n' )
  self . model_file . write ( '\t\t\tself.inputGate = tf.keras.regularizers.get(inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGate = tf.keras.regularizers.get(forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGate = tf.keras.regularizers.get(outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memory = tf.keras.regularizers.get(memory)\n\n' )
  if 60 - 60: Ooo0Ooo . OooOoo
  self . model_file . write ( '\t\t\n' )
  self . model_file . write ( '\tdef __init__(self,units,activation = Activation(\'sigmoid\',\'sigmoid\',\'sigmoid\',\'tanh\',\'tanh\'),kernelInitializer = Initializer(\'glorot_uniform\',\'glorot_uniform\',\'glorot_uniform\',\'glorot_uniform\'),\n' )
  self . model_file . write ( '\t\t\trecurrentInitializer = Initializer(\'orthogonal\',\'orthogonal\',\'orthogonal\',\'orthogonal\'),peepholeInitializer = Initializer(\'orthogonal\',\'orthogonal\',\'orthogonal\',None),\n' )
  self . model_file . write ( '\t\t\tbiasInitializer = Initializer(\'zeros\',\'zeros\',\'zeros\',\'zeros\'),kernelRegularizer = Regularizer(None,None,None,None),recurrentRegularizer = Regularizer(None,None,None,None),\n' )
  self . model_file . write ( '\t\t\tpeepholeRegularizer = Regularizer(None,None,None,None),biasRegularizer = Regularizer(None,None,None,None),useBias = True,usePeephole = False,dropout = 0.,recurrentDropout = 0.,\n' )
  self . model_file . write ( '\t\t\tmemoryCellClip = None,shadowStateClip = None,statefull = False,mergeMode = \'concat\',**kwargs):\n' )
  self . model_file . write ( '\t\tsuper(BiLSTM, self).__init__(**kwargs)\n' )
  self . model_file . write ( '\t\tself.units = units\n' )
  self . model_file . write ( '\t\tself.activation =  activation\n' )
  self . model_file . write ( '\t\tself.kernelInitializer = kernelInitializer\n' )
  self . model_file . write ( '\t\tself.recurrentInitializer = recurrentInitializer\n' )
  self . model_file . write ( '\t\tself.peepholeInitializer = peepholeInitializer\n' )
  self . model_file . write ( '\t\tself.biasInitializer = biasInitializer\n' )
  self . model_file . write ( '\t\tself.kernelRegularizer = kernelRegularizer\n' )
  self . model_file . write ( '\t\tself.recurrentRegularizer =recurrentRegularizer\n' )
  self . model_file . write ( '\t\tself.peepholeRegularizer = peepholeRegularizer\n' )
  self . model_file . write ( '\t\tself.biasRegularizer = biasRegularizer\n' )
  self . model_file . write ( '\t\tself.useBias = useBias\n' )
  self . model_file . write ( '\t\tself.usePeephole = usePeephole\n' )
  self . model_file . write ( '\t\tself.dropout = dropout\n' )
  self . model_file . write ( '\t\tself.recurrentDropout = recurrentDropout\n' )
  self . model_file . write ( '\t\tself.memoryCellClip = memoryCellClip\n' )
  self . model_file . write ( '\t\tself.shadowStateClip = shadowStateClip\n' )
  self . model_file . write ( '\t\tself.statefull = statefull\n' )
  self . model_file . write ( '\t\tself.mergeMode = mergeMode\n\n' )
  self . model_file . write ( '\t\tself._initialMemoryCellForward = None\n' )
  self . model_file . write ( '\t\tself._initialShadowStateForward = None\n\n' )
  self . model_file . write ( '\t\tself._initialMemoryCellBackward = None\n' )
  self . model_file . write ( '\t\tself._initialShadowStateBackward = None\n\n' )
  if 3 - 3: I1Ii1I1 * i1i1i1111I + IIiIIiIi11I1
  self . model_file . write ( '\tdef build(self, input_shape):\n' )
  self . model_file . write ( '\t\tinput_dim = int(input_shape[-1])\n' )
  self . model_file . write ( '\t\tself.inputGateKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'inputGateKernelForward\',initializer=self.kernelInitializer.inputGate,regularizer=self.kernelRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\tself.forgetGateKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'forgetGateKernelForward\',initializer=self.kernelInitializer.forgetGate,regularizer=self.kernelRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\tself.outputGateKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'outputGateKernelForward\',initializer=self.kernelInitializer.outputGate,regularizer=self.kernelRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tself.memoryKernelForward = self.add_weight(shape=(input_dim, self.units),name=\'memoryKernelForward\',initializer=self.kernelInitializer.memory,regularizer=self.kernelRegularizer.memory)\n' )
  self . model_file . write ( '\t\tself.inputGateRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'inputGateRecurrentKernelForward\',initializer=self.recurrentInitializer.inputGate,regularizer=self.recurrentRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\tself.forgetGateRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'forgetGateRecurrentKernelForward\',initializer=self.recurrentInitializer.forgetGate,regularizer=self.recurrentRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\tself.outputGateRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'outputGateRecurrentKernelForward\',initializer=self.recurrentInitializer.outputGate,regularizer=self.recurrentRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tself.memoryRecurrentKernelForward = self.add_weight(shape=(self.units, self.units),name=\'memoryRecurrentKernelForward\',initializer=self.recurrentInitializer.memory,regularizer=self.recurrentRegularizer.memory)\n' )
  self . model_file . write ( '\t\tself.inputGateKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'inputGateKernelBackward\',initializer=self.kernelInitializer.inputGate,regularizer=self.kernelRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\tself.forgetGateKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'forgetGateKernelBackward\',initializer=self.kernelInitializer.forgetGate,regularizer=self.kernelRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\tself.outputGateKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'outputGateKernelBackward\',initializer=self.kernelInitializer.outputGate,regularizer=self.kernelRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tself.memoryKernelBackward = self.add_weight(shape=(input_dim, self.units),name=\'memoryKernelBackward\',initializer=self.kernelInitializer.memory,regularizer=self.kernelRegularizer.memory)\n' )
  self . model_file . write ( '\t\tself.inputGateRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'inputGateRecurrentKernelBackward\',initializer=self.recurrentInitializer.inputGate,regularizer=self.recurrentRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\tself.forgetGateRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'forgetGateRecurrentKernelBackward\',initializer=self.recurrentInitializer.forgetGate,regularizer=self.recurrentRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\tself.outputGateRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'outputGateRecurrentKernelBackward\',initializer=self.recurrentInitializer.outputGate,regularizer=self.recurrentRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tself.memoryRecurrentKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'memoryRecurrentKernelBackward\',initializer=self.recurrentInitializer.memory,regularizer=self.recurrentRegularizer.memory)\n' )
  self . model_file . write ( '\t\tif self.usePeephole:\n' )
  self . model_file . write ( '\t\t\tself.inputGatePeepholeKernelForward = self.add_weight(shape=(self.units, self.units),name=\'inputGatePeepholeKernelForward\',initializer=self.peepholeInitializer.inputGate,regularizer=self.peepholeRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGatePeepholeKernelForward = self.add_weight(shape=(self.units, self.units),name=\'forgetGatePeepholeKernelForward\',initializer=self.peepholeInitializer.forgetGate,regularizer=self.peepholeRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGatePeepholeKernelForward = self.add_weight(shape=(self.units, self.units),name=\'outputGatePeepholeKernelForward\',initializer=self.peepholeInitializer.outputGate,regularizer=self.peepholeRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\t\tself.inputGatePeepholeKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'inputGatePeepholeKernelBackward\',initializer=self.peepholeInitializer.inputGate,regularizer=self.peepholeRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGatePeepholeKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'forgetGatePeepholeKernelBackward\',initializer=self.peepholeInitializer.forgetGate,regularizer=self.peepholeRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGatePeepholeKernelBackward = self.add_weight(shape=(self.units, self.units),name=\'outputGatePeepholeKernelBackward\',initializer=self.peepholeInitializer.outputGate,regularizer=self.peepholeRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\tself.inputGateBiasForward = self.add_weight(shape=(self.units,),name=\'inputGateBiasForward\',initializer=self.biasInitializer.inputGate,regularizer=self.biasRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGateBiasForward = self.add_weight(shape=(self.units,),name=\'forgetGateBiasForward\',initializer=self.biasInitializer.forgetGate,regularizer=self.biasRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGateBiasForward = self.add_weight(shape=(self.units,),name=\'outputGateBiasForward\',initializer=self.biasInitializer.outputGate,regularizer=self.biasRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memoryBiasForward = self.add_weight(shape=(self.units,),name=\'memoryBiasForward\',initializer=self.biasInitializer.memory,regularizer=self.biasRegularizer.memory)\n' )
  self . model_file . write ( '\t\t\tself.inputGateBiasBackward = self.add_weight(shape=(self.units,),name=\'inputGateBiasBackward\',initializer=self.biasInitializer.inputGate,regularizer=self.biasRegularizer.inputGate)\n' )
  self . model_file . write ( '\t\t\tself.forgetGateBiasBackward = self.add_weight(shape=(self.units,),name=\'forgetGateBiasBackward\',initializer=self.biasInitializer.forgetGate,regularizer=self.biasRegularizer.forgetGate)\n' )
  self . model_file . write ( '\t\t\tself.outputGateBiasBackward = self.add_weight(shape=(self.units,),name=\'outputGateBiasBackward\',initializer=self.biasInitializer.outputGate,regularizer=self.biasRegularizer.outputGate)\n' )
  self . model_file . write ( '\t\t\tself.memoryBiasBackward = self.add_weight(shape=(self.units,),name=\'memoryBiasBackward\',initializer=self.biasInitializer.memory,regularizer=self.biasRegularizer.memory)\n' )
  self . model_file . write ( '\t\tself.built = True\n\n' )
  if 38 - 38: ooo000 + Ooo0Ooo / I11iiIi11i1I
  self . model_file . write ( '\tdef _stepFunctionForward(self,inputs,states,training = None):\n' )
  self . model_file . write ( '\t\tmemoryCell,shadowState = states\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout), inputs, training=training)\n' )
  self . model_file . write ( '\t\tif  0 < self.recurrentDropout < 1 : shadowState =   tf.keras.backend.in_train_phase(tf.nn.dropout(shadowState,self.recurrentDropout), shadowState, training=training)\n' )
  self . model_file . write ( '\t\tif self.usePeephole:\n' )
  self . model_file . write ( '\t\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelForward) + tf.matmul(inputs,self.inputGateKernelForward) + tf.matmul(memoryCell,self.inputGatePeepholeKernelForward)  + self.inputGateBiasForward)\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelForward) + tf.matmul(inputs,self.forgetGateKernelForward) + tf.matmul(memoryCell,self.forgetGatePeepholeKernelForward)  + self.forgetGateBiasForward)\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelForward) + tf.matmul(inputs,self.memoryKernelForward) + self.memoryBiasForward)\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelForward) + tf.matmul(inputs,self.outputGateKernelForward) + tf.matmul(newMemoryCell,self.outputGatePeepholeKernelForward) + self.outputGateBiasForward)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelForward) + tf.matmul(inputs,self.inputGateKernelForward) + tf.matmul(memoryCell,self.inputGatePeepholeKernelForward))\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelForward) + tf.matmul(inputs,self.forgetGateKernelForward) + tf.matmul(memoryCell,self.forgetGatePeepholeKernelForward))\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelForward) + tf.matmul(inputs,self.memoryKernelForward))\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelForward) + tf.matmul(inputs,self.outputGateKernelForward) + tf.matmul(newMemoryCell,self.outputGatePeepholeKernelForward))\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelForward) + tf.matmul(inputs,self.inputGateKernelForward)  + self.inputGateBiasForward)\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelForward) + tf.matmul(inputs,self.forgetGateKernelForward) + self.forgetGateBiasForward)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelForward) + tf.matmul(inputs,self.outputGateKernelForward) + self.outputGateBiasForward)\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelForward) + tf.matmul(inputs,self.memoryKernelForward) + self.memoryBiasForward)\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelForward) + tf.matmul(inputs,self.inputGateKernelForward))\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelForward) + tf.matmul(inputs,self.forgetGateKernelForward))\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelForward) + tf.matmul(inputs,self.outputGateKernelForward))\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelForward) + tf.matmul(inputs,self.memoryKernelForward)) \n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\tnewShadowState = tf.multiply(outputGateOutput,self.activation.shadowGate(newMemoryCell))\n' )
  self . model_file . write ( '\t\toutput = newShadowState\n' )
  self . model_file . write ( '\t\tif self.shadowStateClip is not None: newShadowState = tf.clip_by_value(newShadowState,-1*self.shadowStateClip,self.shadowStateClip)\n' )
  self . model_file . write ( '\t\treturn output,(newMemoryCell,newShadowState)\n\n' )
  if 82 - 82: ooOOO / oOo0O00 * I1Ii1I1 + IIiIIiIi11I1 - I11iiIi11i1I
  self . model_file . write ( '\tdef _stepFunctionBackward(self,inputs,states,training = None):\n' )
  self . model_file . write ( '\t\tmemoryCell,shadowState = states\n' )
  self . model_file . write ( '\t\tif 0 < self.dropout < 1 : inputs = tf.keras.backend.in_train_phase(tf.nn.dropout(inputs,self.dropout), inputs, training=training)\n' )
  self . model_file . write ( '\t\tif  0 < self.recurrentDropout < 1 : shadowState =   tf.keras.backend.in_train_phase(tf.nn.dropout(shadowState,self.recurrentDropout), shadowState, training=training)\n' )
  self . model_file . write ( '\t\tif self.usePeephole:\n' )
  self . model_file . write ( '\t\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelBackward) + tf.matmul(inputs,self.inputGateKernelBackward) + tf.matmul(memoryCell,self.inputGatePeepholeKernelBackward)  + self.inputGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelBackward) + tf.matmul(inputs,self.forgetGateKernelBackward) + tf.matmul(memoryCell,self.forgetGatePeepholeKernelBackward)  + self.forgetGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelBackward) + tf.matmul(inputs,self.memoryKernelBackward) + self.memoryBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelBackward) + tf.matmul(inputs,self.outputGateKernelBackward) + tf.matmul(newMemoryCell,self.outputGatePeepholeKernelBackward) + self.outputGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelBackward) + tf.matmul(inputs,self.inputGateKernelBackward) + tf.matmul(memoryCell,self.inputGatePeepholeKernelBackward))\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelBackward) + tf.matmul(inputs,self.forgetGateKernelBackward) + tf.matmul(memoryCell,self.forgetGatePeepholeKernelBackward))\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelBackward) + tf.matmul(inputs,self.memoryKernelBackward))\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelBackward) + tf.matmul(inputs,self.outputGateKernelBackward) + tf.matmul(newMemoryCell,self.outputGatePeepholeKernelBackward))\n' )
  self . model_file . write ( '\t\telse:\n' )
  self . model_file . write ( '\t\t\tif self.useBias:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelBackward) + tf.matmul(inputs,self.inputGateKernelBackward)  + self.inputGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelBackward) + tf.matmul(inputs,self.forgetGateKernelBackward) + self.forgetGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelBackward) + tf.matmul(inputs,self.outputGateKernelBackward) + self.outputGateBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelBackward) + tf.matmul(inputs,self.memoryKernelBackward) + self.memoryBiasBackward)\n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\telse:\n' )
  self . model_file . write ( '\t\t\t\tinputGateOutput = self.activation.inputGate(tf.matmul(shadowState,self.inputGateRecurrentKernelBackward) + tf.matmul(inputs,self.inputGateKernelBackward))\n' )
  self . model_file . write ( '\t\t\t\tforgetGateOutput = self.activation.forgetGate(tf.matmul(shadowState,self.forgetGateRecurrentKernelBackward) + tf.matmul(inputs,self.forgetGateKernelBackward))\n' )
  self . model_file . write ( '\t\t\t\toutputGateOutput = self.activation.outputGate(tf.matmul(shadowState,self.outputGateRecurrentKernelBackward) + tf.matmul(inputs,self.outputGateKernelBackward))\n' )
  self . model_file . write ( '\t\t\t\tmemoryCellCandidate = self.activation.memory(tf.matmul(shadowState,self.memoryRecurrentKernelBackward) + tf.matmul(inputs,self.memoryKernelBackward)) \n' )
  self . model_file . write ( '\t\t\t\tnewMemoryCell = tf.multiply(forgetGateOutput,memoryCell) + tf.multiply(inputGateOutput,memoryCellCandidate)\n' )
  self . model_file . write ( '\t\t\tif self.memoryCellClip is not None: newMemoryCell = tf.clip_by_value(newMemoryCell,-1*self.memoryCellClip,self.memoryCellClip)\n' )
  self . model_file . write ( '\t\tnewShadowState = tf.multiply(outputGateOutput,self.activation.shadowGate(newMemoryCell))\n' )
  self . model_file . write ( '\t\toutput = newShadowState\n' )
  self . model_file . write ( '\t\tif self.shadowStateClip is not None: newShadowState = tf.clip_by_value(newShadowState,-1*self.shadowStateClip,self.shadowStateClip)\n' )
  self . model_file . write ( '\t\treturn output,(newMemoryCell,newShadowState)\n\n' )
  if 72 - 72: i1iiIII111 + I11iiIi11i1I / i1 / I1Ii1I1 + I1Ii1I1
  self . model_file . write ( '\tdef _switchBatchTime(self,inputs):\n' )
  self . model_file . write ( '\t\tperm = list(range(inputs.get_shape().rank))\n' )
  self . model_file . write ( '\t\tperm[0:2] = (1,0)\n' )
  self . model_file . write ( '\t\treturn tf.transpose(inputs,perm)\n\n' )
  if 44 - 44: Ii / ooOOO
  self . model_file . write ( '\tdef _getInitialState(self,inputs):\n' )
  self . model_file . write ( '\t\tinitialState = tf.zeros_like(inputs)\n' )
  self . model_file . write ( '\t\tinitialState = initialState[:,0,0:1]\n' )
  self . model_file . write ( '\t\tmultiples = tf.convert_to_tensor([1,self.units])\n' )
  self . model_file . write ( '\t\tinitialState = tf.tile(initialState,multiples)\n' )
  self . model_file . write ( '\t\treturn initialState\n\n' )
  if 9 - 9: I11iiIi11i1I % Iii1i . I1Ii1I1 + oOo0O00
  self . model_file . write ( '\tdef call(self, inputs ,state = None):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,_ = inputs.shape.as_list()\n' )
  self . model_file . write ( '\t\ttimeStepsTensor = tf.shape(inputs)[1]\n' )
  self . model_file . write ( '\t\tinitialMemoryCellForward,initialShadowStateForward = self._initialMemoryCellForward, self._initialShadowStateForward\n' )
  self . model_file . write ( '\t\tinitialMemoryCellBackward,initialShadowStateBackward = self._initialMemoryCellBackward,self._initialShadowStateBackward\n' )
  self . model_file . write ( '\t\tif initialMemoryCellForward is None: initialMemoryCellForward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tif initialShadowStateForward is None: initialShadowStateForward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tif initialMemoryCellBackward is None: initialMemoryCellBackward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tif initialShadowStateBackward is None: initialShadowStateBackward = self._getInitialState(inputs)\n' )
  self . model_file . write ( '\t\tinputs = self._switchBatchTime(inputs)\n' )
  self . model_file . write ( '\t\tinitialTime = tf.zeros_like(timeStepsTensor,name=\'time\')\n' )
  self . model_file . write ( '\t\tinputsTensorArrayForward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayBackward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayForward = inputsTensorArrayForward.unstack(inputs)\n' )
  self . model_file . write ( '\t\tinputsTensorArrayBackward = inputsTensorArrayBackward.unstack(tf.reverse(inputs,tf.zeros(1, tf.int32)))\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArrayForward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tinitialOutputTensorArrayBackward = tf.TensorArray(dtype=inputs.dtype,size=timeStepsTensor)\n\n' )
  self . model_file . write ( '\t\tdef _cond(time,outputTensorArray,memoryCell,shadowState):\n' )
  self . model_file . write ( '\t\t\treturn time<timeStepsTensor\n\n' )
  self . model_file . write ( '\t\tdef _bodyForward(time,outputTensorArray,memoryCell,shadowState):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArrayForward.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,(newMemoryCell,newShadowState) = self._stepFunctionForward(currentInput,(memoryCell,shadowState))\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,newMemoryCell,newShadowState)\n\n' )
  self . model_file . write ( '\t\tdef _bodyBackward(time,outputTensorArray,memoryCell,shadowState):\n' )
  self . model_file . write ( '\t\t\tcurrentInput = inputsTensorArrayBackward.read(time)\n' )
  self . model_file . write ( '\t\t\toutput,(newMemoryCell,newShadowState) = self._stepFunctionBackward(currentInput,(memoryCell,shadowState))\n' )
  self . model_file . write ( '\t\t\toutputTensorArray = outputTensorArray.write(time,output)\n' )
  self . model_file . write ( '\t\t\treturn (time+1,outputTensorArray,newMemoryCell,newShadowState)\n\n' )
  self . model_file . write ( '\t\tfinalOutputsForward = tf.while_loop(cond = _cond,body=_bodyForward,loop_vars=(initialTime,initialOutputTensorArrayForward,initialMemoryCellForward,initialShadowStateForward))\n' )
  self . model_file . write ( '\t\tfinalOutputsBackward = tf.while_loop(cond = _cond,body=_bodyBackward,loop_vars=(initialTime,initialOutputTensorArrayBackward,initialMemoryCellBackward,initialShadowStateBackward))\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArrayForward = finalOutputsForward[1]\n' )
  self . model_file . write ( '\t\tfinalOutputTensorArrayBackward = finalOutputsBackward[1]\n' )
  self . model_file . write ( '\t\tfinalOutputForward = finalOutputTensorArrayForward.stack()\n' )
  self . model_file . write ( '\t\tfinalOutputBackward = finalOutputTensorArrayBackward.stack()\n' )
  self . model_file . write ( '\t\tfinalOutputForward.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tfinalOutputBackward.set_shape([timeSteps,batchSize,self.units])\n' )
  self . model_file . write ( '\t\tif self.statefull : self._initialStatForwarde,self._initialStateBackward = finalOutputsForward[-1],finalOutputsBackward[-1]\n' )
  self . model_file . write ( '\t\tfinalOutputForward = self._switchBatchTime(finalOutputForward)\n' )
  self . model_file . write ( '\t\tfinalOutputBackward = self._switchBatchTime(finalOutputBackward)\n' )
  self . model_file . write ( '\t\tif self.mergeMode == \'concat\': mergeOutput = tf.concat([finalOutputForward, finalOutputBackward],-1)\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'sum\': mergeOutput = finalOutputForward + finalOutputBackward\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'ave\': mergeOutput = (finalOutputForward + finalOutputBackward) / 2\n' )
  self . model_file . write ( '\t\telif self.mergeMode == \'mul\': mergeOutput = finalOutputForward * finalOutputBackward\n' )
  self . model_file . write ( '\t\telif self.mergeMode is None: mergeOutput = [finalOutputForward, finalOutputBackward]\n' )
  self . model_file . write ( '\t\telse: raise ValueError(\'mergeMode wrong\')\n' )
  self . model_file . write ( '\t\treturn mergeOutput\n\n' )
  if 74 - 74: ooOOO
  self . model_file . write ( '\tdef compute_output_shape(self,input_shape):\n' )
  self . model_file . write ( '\t\tbatchSize,timeSteps,dim = input_shape\n' )
  self . model_file . write ( '\t\toutputShape = tf.TensorShape([batchSize,timeSteps,self.units*2]) if self.mergeMode == \'concat\' else tf.TensorShape([batchSize,timeSteps,self.units])\n' )
  self . model_file . write ( '\t\tif self.mergeMode is None : return [outputShape,outputShape]\n' )
  self . model_file . write ( '\t\treturn outputShape\n\n' )
  if 28 - 28: oOo0O00 % IiI11Ii111 - oOO % oOO / ooo000 % oOO
  self . model_file . write ( '\tdef get_config(self):\n' )
  self . model_file . write ( '\t\tconfig = {\'units\': self.units,\'activation\' : self.activation,\'kernelInitializer\' : self.kernelInitializer,\'recurrentInitializer\' : self.recurrentInitializer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'peepholeInitializer\' : self.peepholeInitializer,\'biasInitializer\' : self.biasInitializer,\'kernelRegularizer\' : self.kernelRegularizer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'recurrentRegularizer\' : self.recurrentRegularizer,\'peepholeRegularizer\' : self.peepholeRegularizer,\'biasRegularizer\' : self.biasRegularizer,\n' )
  self . model_file . write ( '\t\t\t\t\t\'useBias\': self.useBias,\'usePeephole\' : self.usePeephole,\'dropout\': self.dropout,\'recurrentDropout\': self.recurrentDropout,\'memoryCellClip\' : self.memoryCellClip,\n' )
  self . model_file . write ( '\t\t\t\t\t\'shadowStateClip\' : self.shadowStateClip,\'statefull\' : self.statefull,\'mergeMode\' : self.mergeMode}\n' )
  self . model_file . write ( '\t\tbaseConfig = super(BiLSTM, self).get_config()\n' )
  self . model_file . write ( '\t\treturn dict(list(baseConfig.items()) + list(config.items()))\n' )
  if 83 - 83: IIiIIiIi11I1 + IIiIIiIi11I1 % ooOOO
 def write_init ( self , buildNo = 0 ) :
  if 23 - 23: oOO % Oo . ooOOO * Oo % IIiIIiIi11I1 / OooOoo
  if 80 - 80: OooOoo * i1I
  if 6 - 6: IIiIIiIi11I1
  if 18 - 18: I1I
  if 57 - 57: Ii - I1I * I1I . I11iiIi11i1I % Oo
  if 52 - 52: ooOOO / IiIIii11Ii / i1i1i1111I * oOO
  if 6 - 6: ooOOO + IIiIIiIi11I1 % Oo + Ooo0Ooo % i1iiIII111 * I1Ii1I1
  if 5 - 5: I1I * oOO + i1i1i1111I * IiI11Ii111 * I1Ii1I1
  if 17 - 17: oOO - I11iiIi11i1I
  if 4 - 4: oOO + Iii1i + ooo000 + ooo000 . I11iiIi11i1I
  for iIIiI1IiIi11I in self . layer_obj :
   self . model_file . write ( '\t\t%s\n' % iIIiI1IiIi11I )
  OoO0i1I1I = { 'adam' : 'tf.keras.optimizers.Adam' ,
 'rmsprop' : 'tf.keras.optimizers.RMSprop' ,
 'grad' : 'tf.keras.optimizers.SGD' ,
 'momentum' : 'tf.compat.v1.train.MomentumOptimizer' ,
 'adagrad' : 'tf.keras.optimizers.Adagrad' ,
 'adadelta' : 'tf.keras.optimizers.Adadelta' ,
 'ftrl' : 'tf.keras.optimizers.Ftrl' }
  if 51 - 51: oOo0O00 - I1I + oOo0O00 . I11iiIi11i1I . i1I . i1iiIII111
  self . model_file . write ( '\n' )
  if 94 - 94: Ooo0Ooo % IIiIIiIi11I1 - ooo000 - Ooo0Ooo * ooOOO
  if 15 - 15: IIiIIiIi11I1 - IIiIIiIi11I1
  if 97 - 97: oOO - I1Ii1I1
  if 73 - 73: i1 * IIiIIiIi11I1
  if 17 - 17: ooo000 . IiIIii11Ii + IiI11Ii111
  if 52 - 52: OooOoo - ooo000 - i1i1i1111I % I1Ii1I1 % i1I / IiI11Ii111
  if 46 - 46: oOO / i1I . I11iiIi11i1I
  if 67 - 67: i1I - IIiIIiIi11I1
  if 67 - 67: ooOOO + IiIIii11Ii + IiI11Ii111 . I1Ii1I1 / Ii / ooo000
 def write_call ( self ) :
  if 32 - 32: oOo0O00 . oOo0O00 . i1I + I1Ii1I1
  if 95 - 95: Ii
  if 39 - 39: IiIIii11Ii * IIiIIiIi11I1
  if 30 - 30: i1iiIII111 / Ooo0Ooo / I1I * I1Ii1I1 % I1Ii1I1
  if 67 - 67: oOO / i1iiIII111 % i1iiIII111 % i1
  if 35 - 35: oOo0O00 * ooOOO % I1I . OooOoo + i1I
  if 56 - 56: i1i1i1111I + ooo000 + oOo0O00 - Oo
  for iIIiI1IiIi11I in self . call_obj :
   self . model_file . write ( '\t\t%s\n' % iIIiI1IiIi11I )
  self . model_file . write ( '\t\treturn [' + ',' . join ( self . return_obj ) + ']' )
  self . model_file . write ( '\n' )
  if 13 - 13: IiIIii11Ii . oOO - Oo - I1I + oOo0O00
 def write_loss ( self ) :
  if 84 - 84: Oo * oOo0O00 * i1
  if 78 - 78: OooOoo - I1I % ooo000 + Ooo0Ooo - oOO
  if 36 - 36: I1I
  if 96 - 96: i1i1i1111I - i1i1i1111I + IIiIIiIi11I1 * Iii1i % I1I - ooOOO
  if 65 - 65: i1 / oOO / oOO % IIiIIiIi11I1
  if 6 - 6: Ooo0Ooo . Iii1i . I1Ii1I1
  if 78 - 78: I1Ii1I1 % IIiIIiIi11I1 . IIiIIiIi11I1 - Ooo0Ooo * i1iiIII111 % Ooo0Ooo
  for iIIiI1IiIi11I in self . loss_obj :
   self . model_file . write ( '\t\t' + iIIiI1IiIi11I + '\n' )
   if 36 - 36: IIiIIiIi11I1 + IiI11Ii111 * i1I / Iii1i - i1 - IiIIii11Ii
   if 50 - 50: Ooo0Ooo * Ooo0Ooo . ooOOO * ooOOO . IiIIii11Ii . I1I
   if 55 - 55: IiI11Ii111 * oOo0O00 . IiI11Ii111
   if 3 - 3: Oo % oOo0O00 + i1iiIII111 / i1i1i1111I
  self . model_file . write ( '\t\treturn ' + ' + ' . join ( self . loss_ret ) + '\n' )
  if 65 - 65: iI1iII1I1I1i % oOo0O00 . iI1iII1I1I1i % IIiIIiIi11I1 - OooOoo % i1I
  if 79 - 79: i1 . i1 . i1i1i1111I - Ii
  if 99 - 99: Ii . i1iiIII111 - OooOoo - I1Ii1I1 + iI1iII1I1I1i
  if 45 - 45: I1Ii1I1
 def write_optimizer ( self ) :
  if 38 - 38: IIiIIiIi11I1 % OooOoo . I11iiIi11i1I . I11iiIi11i1I + OooOoo
  if 57 - 57: ooOOO / i1iiIII111 - Ooo0Ooo * i1i1i1111I + OooOoo
  if 23 - 23: ooo000
  if 45 - 45: Ooo0Ooo / I1I
  if 7 - 7: IIiIIiIi11I1 + i1iiIII111 % Oo + I11iiIi11i1I / I11iiIi11i1I
  if 61 - 61: I1I
  if 6 - 6: i1 * I1I * i1
  for iIIiI1IiIi11I in self . update_obj :
   self . model_file . write ( '\t\t%s\n' % iIIiI1IiIi11I )
  if 72 - 72: i1I * OooOoo . i1i1i1111I * oOo0O00 . oOo0O00 % Iii1i
  if 31 - 31: ooOOO * oOO
  if 86 - 86: Iii1i * i1iiIII111 . I1Ii1I1 - IiIIii11Ii * Ooo0Ooo
  if 12 - 12: IiI11Ii111 . IIiIIiIi11I1
 def keras_fullModelTrain ( self ) :
  if 28 - 28: i1i1i1111I / iI1iII1I1I1i
  if 35 - 35: Ooo0Ooo
  if 97 - 97: i1iiIII111 - Oo - ooo000
  if 64 - 64: I1Ii1I1 / iI1iII1I1I1i
  if 94 - 94: i1iiIII111
  if 40 - 40: Oo + I1I . Iii1i * i1 / i1
  if 19 - 19: i1I + OooOoo * IIiIIiIi11I1 * I11iiIi11i1I % Oo
  if 80 - 80: Oo
  if self . restorePath :
   if any ( [ tp . crossValidationType is not None for tp in self . buildConfigs ] ) :
    raise ValueError ( "Train Resuming is not allowed for cross-validating trainings." )
    if 44 - 44: IiI11Ii111 . IiIIii11Ii / Ii
   o0OoOo = 0
   try :
    with open ( self . restorePath + '/tmpStep.txt' , "r" , encoding = "utf-8" , newline = "" ) as f :
     o0OoOo = f . read ( ) . trim ( )
   except :
    raise ValueError ( "No model is restored from: " + str ( self . restorePath ) )
    if 76 - 76: IIiIIiIi11I1 . IiIIii11Ii . iI1iII1I1I1i - i1iiIII111 % Oo
   self . localStep = self . globalStep = int ( o0OoOo )
   if 58 - 58: IiI11Ii111 + I1Ii1I1
   if 60 - 60: IIiIIiIi11I1 + I1I
  for O0OooOo0 in range ( 0 , self . runCount ) :
   self . _runNo += 1
   self . globalStep = 0
   if 14 - 14: Ii
   if 79 - 79: Ii + oOo0O00 / IiI11Ii111
   for O0oo , OOoo00ooOo00O in enumerate ( self . buildConfigs ) :
    if OOoo00ooOo00O . crossValidationType is None or OOoo00ooOo00O . validationRuns == 1 :
     if 3 - 3: Iii1i % IiI11Ii111
     self . _buildNo = O0oo
     self . keras_train ( buildNo = O0oo )
    else :
     if 78 - 78: iI1iII1I1I1i - Ooo0Ooo / OooOoo
     IIi11iIi1iiI1 = self . globalStep
     if 85 - 85: IIiIIiIi11I1 . i1I . i1i1i1111I / i1iiIII111
     if 97 - 97: Ooo0Ooo
     for ooOo0Oo0O0oOo in range ( 0 , OOoo00ooOo00O . validationRuns + 1 ) :
      self . globalStep = IIi11iIi1iiI1
      self . _cvNo += 1
      if self . _cvNo == OOoo00ooOo00O . validationRuns :
       self . _cvNo = - 1
      self . _buildNo = O0oo
      self . keras_train ( buildNo = O0oo )
      if 81 - 81: Iii1i + ooOOO - I1I . I1I
      if 54 - 54: iI1iII1I1I1i % IIiIIiIi11I1 / oOo0O00 * I1I
  self . _runNo = - 1
  if 46 - 46: i1i1i1111I
 def keras_fullModelTrain2 ( self ) :
  if 30 - 30: Oo * Iii1i % Ooo0Ooo * ooOOO / Iii1i + ooOOO
  if 31 - 31: i1 - Oo % I11iiIi11i1I - iI1iII1I1I1i / iI1iII1I1I1i / Ii
  if 37 - 37: OooOoo - Oo * Iii1i
  if 95 - 95: ooOOO
  if 80 - 80: Iii1i % Iii1i
  if 72 - 72: ooo000 . Iii1i - IiIIii11Ii - Iii1i - I11iiIi11i1I
  if 68 - 68: I1I . ooo000 * Oo
  if 7 - 7: Iii1i % I11iiIi11i1I / Iii1i
  if self . restorePath :
   if any ( [ tp . crossValidationType is not None for tp in self . buildConfigs ] ) :
    raise ValueError ( "Train Resuming is not allowed for cross-validating trainings." )
    if 20 - 20: Oo . i1iiIII111 % Oo
   o0OoOo = 0
   try :
    with open ( self . restorePath + '/tmpStep.txt' , "r" , encoding = "utf-8" , newline = "" ) as f :
     o0OoOo = f . read ( ) . trim ( )
   except :
    raise ValueError ( "No model is restored from: " + str ( self . restorePath ) )
    if 42 - 42: Oo % ooOOO % IIiIIiIi11I1 - ooo000 % i1iiIII111
   self . localStep = self . globalStep = int ( o0OoOo )
   if 8 - 8: IIiIIiIi11I1 / oOO * IiIIii11Ii % I1Ii1I1
   if 43 - 43: ooo000 - IiI11Ii111
  for O0OooOo0 in range ( 0 , self . runCount ) :
   self . _runNo += 1
   self . globalStep = 0
   if 64 - 64: Iii1i . ooo000
   if 85 - 85: i1 + I1Ii1I1 - oOo0O00
   for O0oo , OOoo00ooOo00O in enumerate ( self . buildConfigs ) :
    OOoO0OoOOo0O = OOoo00ooOo00O . validationRuns
    if OOoo00ooOo00O . crossValidationType is None or OOoO0OoOOo0O == 1 :
     if 61 - 61: i1iiIII111 + Iii1i
     self . keras_train2 ( buildNo = O0oo )
    else :
     if 34 - 34: Ii
     IIi11iIi1iiI1 = self . globalStep
     if 31 - 31: I1I % ooOOO
     if 100 - 100: i1 * I1I
     for ooOo0Oo0O0oOo in range ( 0 , OOoO0OoOOo0O + 1 ) :
      self . globalStep = IIi11iIi1iiI1
      self . _cvNo += 1
      if self . _cvNo == OOoO0OoOOo0O :
       self . _cvNo = - 1
      self . keras_train2 ( buildNo = O0oo )
      if 48 - 48: i1i1i1111I * iI1iII1I1I1i % Ooo0Ooo
  
 
 
    self . line_notify = None
    if 11 - 11: I1I + oOo0O00 + IiIIii11Ii
  self . _runNo = - 1
  if 66 - 66: i1i1i1111I - ooOOO . IiI11Ii111 + iI1iII1I1I1i
 def keras_train ( self , buildNo = 0 ) :
  if 73 - 73: i1I + OooOoo * IiIIii11Ii / IiIIii11Ii * IiIIii11Ii
  if 26 - 26: Ii % oOO
  if 88 - 88: ooo000 * IiI11Ii111 - Iii1i * I1Ii1I1 . i1iiIII111
  if 72 - 72: Ooo0Ooo
  if 2 - 2: ooOOO + iI1iII1I1I1i + ooOOO
  if 51 - 51: oOO + ooo000 % iI1iII1I1I1i
  if 75 - 75: iI1iII1I1I1i % IiIIii11Ii % I1I % ooOOO
  if 76 - 76: Ii / iI1iII1I1I1i % OooOoo % IiI11Ii111 + Ii * oOo0O00
  if 90 - 90: i1I + I1I
  if 41 - 41: I1Ii1I1
  if 22 - 22: i1I . ooOOO - I11iiIi11i1I . i1 - ooo000
  os . makedirs ( self . folder + "outputLogs/" + self . trainTime + "/" , exist_ok = True )
  os . makedirs ( self . folder + "builds/" + self . trainTime + "/" , exist_ok = True )
  os . makedirs ( self . folder + "tmpLogs/" + self . trainTime + "/" , exist_ok = True )
  if 58 - 58: iI1iII1I1I1i - i1I
  if 26 - 26: oOO + i1 % Iii1i
  oo0oO0ooOoo = self . buildConfigs [ buildNo ]
  I111II1iiI = oo0oO0ooOoo . optimizer
  if 76 - 76: OooOoo % i1 / IIiIIiIi11I1 . i1iiIII111
  if 20 - 20: I11iiIi11i1I + OooOoo / I11iiIi11i1I * Ii
  self . connect_keras_layer ( )
  self . create_model_file ( I111II1iiI , buildNo = 0 )
  from keras_model import eagerModel
  self . k_model = eagerModel ( )
  if 55 - 55: I1Ii1I1 + oOo0O00 . i1 / OooOoo - Oo / ooOOO
  if 79 - 79: Ii + i1I - I11iiIi11i1I % IiIIii11Ii / Iii1i / Iii1i
  OOOO0oOo = self . sources [ 0 ]
  OOoooooOo0 = OOOO0oOo . batchSize
  O00O0o0OO00Oo = max ( OOOO0oOo . epochSize // OOoooooOo0 , 1 )
  print ( O00O0o0OO00Oo )
  if oo0oO0ooOoo . numEpochsPerDecay is not None :
   oo0oooO = int ( O00O0o0OO00Oo * oo0oO0ooOoo . numEpochsPerDecay )
   if 47 - 47: i1iiIII111 + IiI11Ii111 . OooOoo % i1i1i1111I / Ooo0Ooo * IIiIIiIi11I1
   if 23 - 23: OooOoo / Ii + I1Ii1I1 / i1iiIII111
  o0oo00o = oo0oO0ooOoo . crossValidationType
  I1IOoOO0o = o0oo00o is not None and self . _cvNo >= 0
  if I1IOoOO0o :
   if oo0oO0ooOoo . _cvCount < oo0oO0ooOoo . validationRuns :
    self . _nextCrossValidation ( oo0oO0ooOoo )
    oo0oO0ooOoo . _cvCount += 1
  elif oo0oO0ooOoo . _cvCount == oo0oO0ooOoo . validationRuns :
   oo0oO0ooOoo . _cvCount = 0
   if 4 - 4: IIiIIiIi11I1 / I11iiIi11i1I . i1I . I11iiIi11i1I
   if 33 - 33: IiI11Ii111 * i1I * IiI11Ii111 - I1I
  iiiIiiI11iiI = oo0oO0ooOoo . noOfEpoch * O00O0o0OO00Oo
  if 79 - 79: I11iiIi11i1I / Ii * i1iiIII111 / OooOoo - ooo000
  if 17 - 17: iI1iII1I1I1i * ooo000
  if self . localStep >= iiiIiiI11iiI :
   self . localStep -= iiiIiiI11iiI
   if 21 - 21: ooo000 * i1iiIII111 + i1i1i1111I % oOo0O00 - OooOoo
   if 35 - 35: Oo + IiIIii11Ii - ooo000 % oOo0O00 / IIiIIiIi11I1 + oOO
  else :
   if 32 - 32: I1Ii1I1 - ooOOO
   if 78 - 78: oOo0O00 . I1I + i1i1i1111I . I1I + oOO
   if 64 - 64: ooo000 / iI1iII1I1I1i + oOo0O00 - i1
   if 100 - 100: i1iiIII111 . oOo0O00 - ooOOO * i1I + I1Ii1I1
   if 25 - 25: i1 / ooOOO - i1i1i1111I * Ii % I1I % iI1iII1I1I1i
   if 1 - 1: IiIIii11Ii . Iii1i
   if 11 - 11: ooo000 . Oo . oOO / i1iiIII111 % ooo000 . i1I
   if 59 - 59: Oo * I11iiIi11i1I - oOo0O00 - OooOoo - Ii
   if 70 - 70: iI1iII1I1I1i
   if 17 - 17: I1Ii1I1 * I1I
   if 12 - 12: ooo000 * IIiIIiIi11I1 % oOo0O00
   if 17 - 17: oOO / Oo
   if 17 - 17: Oo / ooOOO % i1iiIII111 + i1I - oOo0O00
   if 19 - 19: I1Ii1I1 % ooo000 / oOo0O00
   if 78 - 78: i1i1i1111I * iI1iII1I1I1i . oOo0O00 . I1Ii1I1
   if 15 - 15: Oo * Oo % OooOoo + Ii
   if 90 - 90: i1i1i1111I + oOO * I11iiIi11i1I . iI1iII1I1I1i + oOO
   if 55 - 55: I11iiIi11i1I . Iii1i
   if 27 - 27: Ii / oOO - I1Ii1I1
   if 48 - 48: i1 + Ooo0Ooo / oOO + oOO
   if 73 - 73: Ooo0Ooo - OooOoo * IiI11Ii111 . i1i1i1111I . ooOOO . I1Ii1I1
   if 63 - 63: IiI11Ii111 - IiI11Ii111 % Ooo0Ooo
   if 30 - 30: ooo000 - Iii1i * I1Ii1I1 * i1I + OooOoo / oOO
   if 19 - 19: IiI11Ii111 % oOO . IIiIIiIi11I1 + ooOOO + I1I
   if 5 - 5: i1i1i1111I % ooo000 + Ii
   if 66 - 66: i1iiIII111 / IiIIii11Ii - Iii1i + ooOOO
   print ( "Training Initialized.\n" )
   if 33 - 33: Ii
   if 35 - 35: oOo0O00 / iI1iII1I1I1i / I11iiIi11i1I
   if 38 - 38: i1I . I11iiIi11i1I / IiIIii11Ii * IiIIii11Ii * oOo0O00
   if 43 - 43: ooOOO * IiI11Ii111
   if 74 - 74: i1I / IIiIIiIi11I1 / i1I - IiI11Ii111
   if 47 - 47: Ii / IiIIii11Ii / i1I
   if 34 - 34: IiIIii11Ii + I1Ii1I1 - I1Ii1I1 / IiIIii11Ii + Iii1i
   oOoOoo0OOO = oo0OO00oOoo . Recorder ( )
   O0o0oO = self . localStep - 1
   if 84 - 84: i1iiIII111 - OooOoo / I1Ii1I1 + i1I + oOo0O00
   if 94 - 94: IiI11Ii111 . Ooo0Ooo
   if 21 - 21: IIiIIiIi11I1 - i1 * i1iiIII111
   if 21 - 21: I1I . i1i1i1111I * IiIIii11Ii
   self . localStep += 1
   self . globalStep += 1
   OOOO = self . get_batch_data ( )
   with tf . GradientTape ( ) as OOOO0o0O :
    self . k_model ( OOOO , training = True )
    oOoo0000OoO0 = self . k_model . loss_value ( )
    self . k_model . update ( OOOO0o0O )
   ooooOoOOoo00 = [ ]
   for oO00oOooO0O in self . k_model . layers :
    for iiI1iI11 in oO00oOooO0O . weights :
     ooooOoOOoo00 . append ( iiI1iI11 . name )
     if 99 - 99: iI1iII1I1I1i . oOo0O00 / Iii1i + ooOOO . IIiIIiIi11I1
     if 20 - 20: OooOoo / oOo0O00 / i1 % Iii1i * i1iiIII111 + IiI11Ii111
   i11i = True if self . logFreq > 0 and self . logFreq <= math . inf else False
   if 92 - 92: oOO . IiIIii11Ii . oOo0O00 . i1I * IIiIIiIi11I1
   if i11i :
    OoooOo0 = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "trainLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Total Loss" , "Average Loss" , "Learning Rate" , "Examples per Second" , "Seconds per Step" ] )
    if 85 - 85: i1 . ooo000 + i1i1i1111I * i1iiIII111 % IIiIIiIi11I1
   iIII11Ii11 = True if self . testFreq > 0 and self . testFreq <= math . inf else False
   if iIII11Ii11 :
    if 19 - 19: iI1iII1I1I1i % i1 / IiI11Ii111
    self . testLogger = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "testLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Test Type" , * [ ( oO0OOOOOOoo . name + ": " + oO0OOOOOOoo . measurement ) for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) ] ] )
    if 72 - 72: IiI11Ii111 - I1Ii1I1 + Iii1i
   o0Oo = True if self . weightLogFreq > 0 and self . weightLogFreq <= math . inf else False
   if o0Oo :
    OOooo00 = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "weightLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , * ooooOoOOoo00 ] )
   oOooO0OO0oo = True if self . traceFreq > 0 and self . traceFreq <= math . inf else False
   if oOooO0OO0oo :
    iIi1IIi1111II = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "traceLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Task Name" , "Task Type" , "Source ID" , "Source Config" , "Item ID" , "Data Type" , "Data" ] )
    self . _initTraceItems ( iIi1IIi1111II , buildNo = buildNo )
   oO000oO = True if self . visualTestFreq > 0 and self . visualTestFreq <= math . inf else False
   if oO000oO :
    oOO0 = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "visualLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Task Name" , "Task Type" , "Source ID" , "Source Config" , "Item ID" , "Data Type" , "Data" ] )
    self . _initVisualItems ( oOO0 , buildNo = buildNo )
    if 12 - 12: Oo / i1I + Oo % Ii
    if 5 - 5: i1 + oOO * ooo000 . iI1iII1I1I1i
   for IiIIiiII in range ( self . localStep , iiiIiiI11iiI ) :
    if 85 - 85: oOO / IIiIIiIi11I1 % IIiIIiIi11I1
    if 61 - 61: oOo0O00 % Oo + Ii . oOo0O00 - iI1iII1I1I1i
    if 13 - 13: iI1iII1I1I1i + Iii1i * oOo0O00 / i1i1i1111I
    if 37 - 37: oOo0O00 * iI1iII1I1I1i
    if 74 - 74: I1I * IiI11Ii111 * Ooo0Ooo + i1I . ooo000
    self . localStep += 1
    self . globalStep += 1
    iIiIIIi11 = self . localStep
    if 61 - 61: IiIIii11Ii + ooOOO % i1iiIII111 % oOO
    if 27 - 27: i1I * Iii1i
    if 79 - 79: ooOOO
    OOOO = self . get_batch_data ( )
    if 29 - 29: oOO . iI1iII1I1I1i
    if 44 - 44: IIiIIiIi11I1 + Iii1i
    if oo0oO0ooOoo . learningRateDecayFactor is None :
     O0Ooo0Oo = oo0oO0ooOoo . initialLearningRate
    else :
     O0Ooo0Oo = oo0oO0ooOoo . initialLearningRate * oo0oO0ooOoo . learningRateDecayFactor ** ( self . localStep // oo0oooO )
     self . k_model . lr = O0Ooo0Oo
     if 22 - 22: iI1iII1I1I1i - I11iiIi11i1I
    with tf . GradientTape ( ) as OOOO0o0O :
     self . k_model ( OOOO , training = True )
     oOoo0000OoO0 = self . k_model . loss_value ( )
     self . k_model . update ( OOOO0o0O )
     if 24 - 24: ooOOO * oOo0O00 / iI1iII1I1I1i
     if 3 - 3: iI1iII1I1I1i - IIiIIiIi11I1 + Ooo0Ooo . i1iiIII111 % oOO - Ooo0Ooo
    if i11i and ( iIiIIIi11 % self . logFreq == 0 or IiIIiiII == iiiIiiI11iiI - 1 ) :
     O0Ooo0OoO = oOoOoo0OOO . logAndRestart ( )
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     o000o = self . logFreq * self . sources [ 0 ] . batchSize / O0Ooo0OoO
     i1i1ii = float ( O0Ooo0OoO / ( self . localStep - O0o0oO ) )
     O0o0oO = self . localStep
     I1Iii111111 = oOoo0000OoO0 . numpy ( )
     Ooo000OO = I1Iii111111 * OOoooooOo0
     OoooOo0 . logAndSave ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , i111iIIiIIi ( Ooo000OO ) , i111iIIiIIi ( I1Iii111111 ) , O0Ooo0Oo , o000o , i1i1ii ] )
     if self . _cvNo == - 1 :
      print ( '%s: Run #%d, Step %d (%d) --- loss: %f; learning rate: %f; %.1f examples/s; %.3f s/step' % ( ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . globalStep , iIiIIIi11 , I1Iii111111 , O0Ooo0Oo , o000o , i1i1ii ) )
     else :
      print ( '%s: Run #%d - Cross Validation %d, Step %d (%d) --- loss: %f; learning rate: %f; %.1f examples/s; %.3f s/step' % ( ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , I1Iii111111 , O0Ooo0Oo , o000o , i1i1ii ) )
      if 7 - 7: IIiIIiIi11I1
      if 60 - 60: Iii1i + IIiIIiIi11I1 - OooOoo + i1iiIII111 . Ooo0Ooo
    if o0Oo and ( iIiIIIi11 % self . weightLogFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     o0OoOo0ooo0 = [ ]
     for oO00oOooO0O in self . k_model . layers :
      for iiI1iI11 in oO00oOooO0O . weights :
       iiI1iI11 = iiI1iI11 . numpy ( )
       iiI1iI11 [ np . isnan ( iiI1iI11 ) ] = None
       o0OoOo0ooo0 . append ( iiI1iI11 . tolist ( ) )
     OOooo00 . logAndSave ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , * o0OoOo0ooo0 ] )
     if 7 - 7: ooo000 + OooOoo * I1Ii1I1 % ooo000
     if 34 - 34: ooo000
    if self . saveFreq > 0 and ( iIiIIIi11 % self . saveFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 14 - 14: ooOOO / Oo / ooOOO
     if 52 - 52: Oo + oOO % OooOoo / I1Ii1I1
     if 98 - 98: i1i1i1111I - IiIIii11Ii
     if 82 - 82: Ooo0Ooo - ooo000 % oOo0O00 . i1I * IiIIii11Ii * OooOoo
     if i11i :
      OoooOo0 . flush ( )
      if 20 - 20: Oo + Iii1i - i1I
      if 100 - 100: Iii1i + ooOOO % OooOoo / IIiIIiIi11I1 / I1Ii1I1 + i1
    if oOooO0OO0oo and ( iIiIIIi11 % self . traceFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 10 - 10: I1I + IiI11Ii111 . I1Ii1I1 * Ii . Ooo0Ooo
     iii111iI = self . keras_predict ( x = self . traceItems , buildNo = buildNo )
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
      IIiIIi11I = oO0OOOOOOoo . getTraceItems ( iii111iI , buildNo = buildNo )
      if IIiIIi11I is not None :
       iIi1IIi1111II . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , oO0OOOOOOoo . name , oO0OOOOOOoo . __class__ . __name__ , * I1iiiiii ( pi ) ] for pi in IIiIIi11I ] )
     iIi1IIi1111II . flush ( )
     if 72 - 72: Ooo0Ooo / I11iiIi11i1I + i1i1i1111I
     if 87 - 87: i1I . iI1iII1I1I1i - oOO % Ii
    if oO000oO and ( iIiIIIi11 % self . visualTestFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 47 - 47: Ii / i1 + Iii1i . Oo + i1I . i1iiIII111
     iii111iI = self . keras_predict ( x = self . visualItems , buildNo = buildNo )
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
      IIiIIi11I = oO0OOOOOOoo . getVisualItems ( iii111iI , buildNo = buildNo )
      if IIiIIi11I is not None :
       oOO0 . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , oO0OOOOOOoo . name , oO0OOOOOOoo . __class__ . __name__ , * I1iiiiii ( pi ) ] for pi in IIiIIi11I ] )
     oOO0 . flush ( )
     if 56 - 56: I11iiIi11i1I + ooo000 . OooOoo + iI1iII1I1I1i - ooOOO
     if 73 - 73: Ii - oOo0O00 / ooo000 . Ooo0Ooo
    if iIII11Ii11 and ( iIiIIIi11 % self . testFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 91 - 91: Ii / IIiIIiIi11I1 . IIiIIiIi11I1 . Ooo0Ooo
     if 89 - 89: Oo
     self . keras_evaluate ( validation = I1IOoOO0o , event = "Test Log" , buildNo = buildNo )
   if 93 - 93: ooOOO / Ii . I11iiIi11i1I / IiIIii11Ii
   if 53 - 53: iI1iII1I1I1i . Oo
   if 30 - 30: oOO - i1iiIII111 / I11iiIi11i1I
   if 8 - 8: IiI11Ii111 . oOo0O00 * Ooo0Ooo . ooo000 * IIiIIiIi11I1 - I1Ii1I1
   if 6 - 6: i1I * I11iiIi11i1I / Iii1i
   if 17 - 17: IIiIIiIi11I1
   if 50 - 50: i1iiIII111
   if 49 - 49: i1i1i1111I
   if 61 - 61: ooOOO + I1I - ooOOO . oOo0O00
   if 65 - 65: oOO / IIiIIiIi11I1 + i1i1i1111I . i1iiIII111 . I11iiIi11i1I + i1I
   if 3 - 3: oOO * oOO * i1iiIII111 . iI1iII1I1I1i + Ii % Ii
   if 25 - 25: OooOoo + I11iiIi11i1I
   if 4 - 4: IiIIii11Ii - oOO * ooo000
   if 35 - 35: IiI11Ii111 . Ii + I1Ii1I1 + OooOoo / ooo000 + I1Ii1I1
   if 69 - 69: OooOoo - I1Ii1I1 + IIiIIiIi11I1 - I1I + oOo0O00
   if 97 - 97: IiI11Ii111 * I11iiIi11i1I . Ii - i1 . oOo0O00 - I1Ii1I1
   if 72 - 72: i1i1i1111I . I11iiIi11i1I . i1I % iI1iII1I1I1i
   self . close ( )
   if 14 - 14: iI1iII1I1I1i . i1I . i1I - Oo * ooOOO
 def getPrintableItems ( self , items , recovered = True ) :
  if 6 - 6: i1 + oOo0O00 - i1iiIII111 + iI1iII1I1I1i . I1I
  O0000000 = ( Ii1II11 ( items ) . tolist ( ) if isinstance ( items , np . ndarray ) else items ) if recovered else self . recoverToRawData ( items ) . tolist ( )
  if 95 - 95: I11iiIi11i1I % Oo
  return [ [ 'Value' , json . dumps ( i ) ] for i in O0000000 ]
  if 65 - 65: i1i1i1111I + I1I - OooOoo . iI1iII1I1I1i
 def getVisualItems ( self , visual_data : Optional [ Dict [ str , 'list' ] ] = None , buildNo : int = 0 ) -> List [ List [ Any ] ] :
  return [ [ "target" , pii , * pi ] for pii , pi in enumerate ( self . getPrintableItems ( visual_data ) ) ]
  if 39 - 39: I11iiIi11i1I % Oo
 def keras_train2 ( self , buildNo = 0 ) :
  if 6 - 6: oOo0O00 . ooOOO . IiI11Ii111 . I1I - Ii . i1i1i1111I
  if 13 - 13: I11iiIi11i1I % I1Ii1I1 + ooOOO
  if 50 - 50: i1i1i1111I . Ii / IiI11Ii111 / I1I / i1iiIII111
  if 96 - 96: oOo0O00 / I1Ii1I1 . IIiIIiIi11I1 . Oo + I1I . OooOoo
  if 67 - 67: oOO / Ooo0Ooo * ooOOO
  if 18 - 18: Iii1i
  if 75 - 75: IiI11Ii111 / IiI11Ii111 - OooOoo
  if 4 - 4: OooOoo % i1iiIII111 - ooOOO / oOO
  if 15 - 15: oOo0O00 * Iii1i
  if 38 - 38: ooOOO + IiIIii11Ii * Iii1i + I1Ii1I1 * IiIIii11Ii
  if 94 - 94: i1i1i1111I - ooo000 - Iii1i * ooOOO . OooOoo - i1i1i1111I
  os . makedirs ( self . folder + "outputLogs/" + self . trainTime + "/" , exist_ok = True )
  os . makedirs ( self . folder + "builds/" + self . trainTime + "/" , exist_ok = True )
  os . makedirs ( self . folder + "tmpLogs/" + self . trainTime + "/" , exist_ok = True )
  if 39 - 39: ooo000 + i1I * Ooo0Ooo
  if 76 - 76: i1iiIII111
  if 96 - 96: i1i1i1111I % Iii1i + i1I + I1Ii1I1 * ooo000 % iI1iII1I1I1i
  I11IiI1Iii : iII11 . BuildConfig = self . currentBuildConfig
  if 88 - 88: Ii + ooo000 . IiIIii11Ii / IiIIii11Ii + OooOoo
  Ooo00o00O : List [ OO0O0 . Config ] = self . getDataPreprocessingNodesUsedByLayers ( )
  if 46 - 46: I1Ii1I1 . i1i1i1111I
  if 70 - 70: i1I . IiI11Ii111
  ooOo : set ( I1ii11II11 . Config ) = set ( )
  for I1 in Ooo00o00O :
   for O0oo0 in I1 . getRootSources ( rawGraph = False ) :
    ooOo . add ( O0oo0 )
  self . _rootSources = o0o ( self , [ * ooOo ] )
  if 81 - 81: I1I + IIiIIiIi11I1 / oOO % i1i1i1111I
  if 23 - 23: ooo000 . Ii % IiIIii11Ii + IiIIii11Ii + IiI11Ii111
  if self . testDatasetType == I111II1II111I . Dataset . TestSource . Split and self . testRatio > 0 :
   self . rootSources . splitTestDataset ( self . testRatio , self . testShuffle )
   self . testRatio = 0
   if 90 - 90: I11iiIi11i1I . I11iiIi11i1I
   if 16 - 16: ooo000 + iI1iII1I1I1i * oOo0O00 * i1I + oOO
  self . connect_keras_layer ( )
  self . create_model_file ( buildNo = 0 )
  if 41 - 41: ooOOO % Iii1i . ooo000 - Ooo0Ooo % Ii
  from keras_model import eagerModel
  self . k_model = eagerModel ( )
  if 67 - 67: I11iiIi11i1I - ooo000 . ooo000 * Ooo0Ooo * Ooo0Ooo
  if 84 - 84: Ii / ooo000
  OOO0oOO0oOO = list ( self . k_model . learning_list . values ( ) )
  if 29 - 29: ooo000 / i1iiIII111 / i1I + oOO % Iii1i
  if 50 - 50: i1I - IiI11Ii111 - ooo000 / i1i1i1111I * Iii1i * Iii1i
  o0oo00o : str = I11IiI1Iii . crossValidationType
  I1IOoOO0o : bool = o0oo00o is not None and self . _cvNo >= 0
  OOoO0OoOOo0O : int = I11IiI1Iii . validationRuns
  if I1IOoOO0o :
   if I11IiI1Iii . _cvCount < OOoO0OoOOo0O :
    self . rootSources . nextCrossValidation ( I11IiI1Iii )
    I11IiI1Iii . _cvCount += 1
    self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . ValidationTrain )
   elif I11IiI1Iii . _cvCount == OOoO0OoOOo0O :
    I11IiI1Iii . _cvCount = 0
    self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Train )
  else :
   self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Train )
   if 12 - 12: OooOoo . Iii1i + ooo000 - Iii1i
   if 63 - 63: IIiIIiIi11I1 % i1iiIII111
  O00O0o0OO00Oo : int = self . rootSources . batchCountPerEpoch
  if 92 - 92: oOo0O00 + oOO * Iii1i / oOo0O00
  if 33 - 33: Ooo0Ooo % oOo0O00
  I11oOoo0o0 = [ ]
  for IiI , Ii1I1i in enumerate ( OOO0oOO0oOO ) :
   OOo00oOO00oo = 0 if ( Ii1I1i [ 'numEpochsPerDecay' ] is None ) else Ii1I1i [ 'numEpochsPerDecay' ]
   I11oOoo0o0 . append ( int ( O00O0o0OO00Oo * int ( OOo00oOO00oo ) ) if ( Ii1I1i [ 'learningRateDecay' ] == True ) else None )
   if 11 - 11: i1iiIII111 - i1I . Iii1i * Iii1i % ooo000 . Ii
   if 2 - 2: Ii . I1Ii1I1 * Ooo0Ooo
  iiiIiiI11iiI : int = I11IiI1Iii . noOfEpoch * O00O0o0OO00Oo
  if 80 - 80: i1 / I1I . I1Ii1I1
  if 24 - 24: iI1iII1I1I1i + ooo000 . IiIIii11Ii
  if self . localStep >= iiiIiiI11iiI :
   self . localStep -= iiiIiiI11iiI
   if 6 - 6: oOo0O00 * Iii1i * oOo0O00 % I11iiIi11i1I * IiI11Ii111
   if 44 - 44: IiI11Ii111 - ooo000 / oOo0O00
  else :
   if 37 - 37: i1 % i1 % I1I . ooo000 / IiI11Ii111 . I1Ii1I1
   self . _buildNo = buildNo
   if 45 - 45: i1I
   if 13 - 13: ooo000 + i1 + Oo * Ooo0Ooo
   if 17 - 17: I11iiIi11i1I + I1I / OooOoo % i1 + Iii1i
   if 93 - 93: Ooo0Ooo / IiI11Ii111 / oOo0O00 / oOo0O00 - i1I
   if 28 - 28: IiI11Ii111 / i1 % IiI11Ii111 + i1iiIII111 / oOO * I11iiIi11i1I
   if 59 - 59: Iii1i * ooOOO . iI1iII1I1I1i . oOO / iI1iII1I1I1i * I11iiIi11i1I
   if 84 - 84: i1I
   if 94 - 94: i1 . Oo * ooOOO - IIiIIiIi11I1
   if 89 - 89: oOo0O00 . ooo000 % IiI11Ii111 % Ii - Iii1i
   if 61 - 61: i1I
   if 39 - 39: iI1iII1I1I1i . OooOoo / IiI11Ii111 - oOO
   if 57 - 57: Ooo0Ooo - ooOOO * Oo % I1Ii1I1 * ooo000
   if 81 - 81: oOo0O00
   if 33 - 33: IiIIii11Ii / Ooo0Ooo
   if 74 - 74: oOo0O00 + Iii1i - I11iiIi11i1I / iI1iII1I1I1i % I11iiIi11i1I + Iii1i
   if 7 - 7: ooOOO
   if 40 - 40: iI1iII1I1I1i * I1Ii1I1 - I1Ii1I1 * oOO / i1I . i1
   if 60 - 60: IiIIii11Ii - I11iiIi11i1I . I11iiIi11i1I + i1i1i1111I . IiI11Ii111
   if 67 - 67: IiI11Ii111 % oOo0O00 + IiI11Ii111
   if 5 - 5: i1 * IiIIii11Ii * ooo000 % I1Ii1I1 / oOO
   if 44 - 44: Ooo0Ooo . oOO - OooOoo
   if 50 - 50: iI1iII1I1I1i / i1iiIII111 / iI1iII1I1I1i / oOo0O00 / i1 / ooOOO
   if 63 - 63: OooOoo * IiIIii11Ii + Ii - i1 * OooOoo . Iii1i
   if 69 - 69: IiIIii11Ii
   if 52 - 52: OooOoo . IiIIii11Ii % ooOOO / Oo - iI1iII1I1I1i
   print ( "Training Initialized.\n" )
   if 35 - 35: oOo0O00 + i1i1i1111I % I1Ii1I1
   if 88 - 88: Ii + Ii + i1i1i1111I - I11iiIi11i1I % Ii
   if 37 - 37: iI1iII1I1I1i . I11iiIi11i1I * Oo - IiIIii11Ii
   if 50 - 50: ooOOO * ooOOO
   if 20 - 20: ooOOO + Ooo0Ooo . ooOOO . IIiIIiIi11I1 / OooOoo % I1Ii1I1
   if 14 - 14: i1i1i1111I * I1Ii1I1 - i1I . I1I
   if 7 - 7: Iii1i % iI1iII1I1I1i - IiIIii11Ii
   oOoOoo0OOO = oo0OO00oOoo . Recorder ( )
   O0o0oO = self . localStep - 1
   if 73 - 73: OooOoo * ooo000 + iI1iII1I1I1i - oOo0O00 / Iii1i % IiI11Ii111
   if 91 - 91: Iii1i
   if 36 - 36: i1I - i1i1i1111I + i1I - ooo000
   if 62 - 62: oOO - IIiIIiIi11I1 . iI1iII1I1I1i - ooOOO
   self . localStep += 1
   self . globalStep += 1
   OOOO = next ( self )
   if 78 - 78: IiI11Ii111 * Ooo0Ooo - IiI11Ii111 - Ooo0Ooo - Oo % oOo0O00
   for IiIii1i1II in self . k_model . learning_list . keys ( ) :
    with tf . GradientTape ( ) as OOOO0o0O :
     self . k_model ( OOOO , training = True )
     oOoo0000OoO0 = self . k_model . loss_value ( )
     self . k_model . update ( OOOO0o0O , IiIii1i1II )
     if 90 - 90: iI1iII1I1I1i - i1
   ooooOoOOoo00 = [ ]
   if 56 - 56: i1 / i1
   if 37 - 37: oOO
   for oO00oOooO0O in self . k_model . layers :
    for iiI1iI11 in oO00oOooO0O . weights :
     ooooOoOOoo00 . append ( iiI1iI11 . name )
     if 73 - 73: IiI11Ii111 . i1i1i1111I
     if 38 - 38: oOO + IiI11Ii111 * IiIIii11Ii - I11iiIi11i1I % IIiIIiIi11I1 * Oo
   if self . line_notify is None and self . userConfigs is not None and self . userConfigs [ "notify" ] is not None and self . userConfigs [ "notify" ] [ IiiIIi11Iii . Types . line ] . isUse :
    self . line_notify = O00O0O0Oo0OO ( self . userConfigs , self . sources [ 0 ] . name )
    if 14 - 14: oOo0O00 % i1I . i1iiIII111
    if 43 - 43: IiIIii11Ii
   i11i : bool = True if self . logFreq > 0 and self . logFreq <= math . inf else False
   if i11i :
    OoooOo0 : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "trainLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Total Loss" , "Average Loss" , "Learning Rate" , "Examples per Second" , "Seconds per Step" ] )
   iIII11Ii11 : bool = True if self . testFreq > 0 and self . testFreq <= math . inf else False
   if iIII11Ii11 :
    Iiii = [ ]
    for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
     for o0Iii in oO0OOOOOOoo . comparisons :
      Iiii . append ( ( oO0OOOOOOoo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ] + ": " + o0Iii [ "metrics" ] ) )
    self . testLogger : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "testLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Test Type" , * Iiii ] )
   o0Oo : bool = True if self . weightLogFreq > 0 and self . weightLogFreq <= math . inf else False
   if o0Oo :
    OOooo00 : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "weightLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , * ooooOoOOoo00 ] )
   oOooO0OO0oo : bool = True if self . traceFreq > 0 and self . traceRecord > 0 and self . traceFreq <= math . inf else False
   if oOooO0OO0oo :
    iIi1IIi1111II : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "traceLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Task Name" , "Task Type" , "Data Preprocessing Node Key" , "Item ID" , "Data Type" , "Data" ] )
    self . _initTraceItems ( iIi1IIi1111II , buildNo = buildNo )
   oO000oO : bool = True if self . visualTestFreq > 0 and self . visualRecord > 0 and self . visualTestFreq <= math . inf else False
   if oO000oO :
    oOO0 : O0o0ooOO = O0o0ooOO ( self . folder + "outputLogs/" + self . trainTime + "/" , "visualLog_" + str ( self . _buildNo ) , [ "Timestamp" , "Run" , "Cross Validation Step" , "Global Step" , "Local Step" , "Task Name" , "Task Type" , "Data Preprocessing Node Key" , "Item ID" , "Data Type" , "Data" ] )
    self . _initVisualItems ( oOO0 , buildNo = buildNo )
    if 32 - 32: i1I
    if 36 - 36: I1Ii1I1 % IiI11Ii111 - Ooo0Ooo * I1Ii1I1
    if 3 - 3: OooOoo
    if 2 - 2: OooOoo % IiIIii11Ii
    if 4 - 4: i1iiIII111
    if 88 - 88: i1iiIII111 . IiI11Ii111 + ooo000 % iI1iII1I1I1i % IIiIIiIi11I1 / oOo0O00
    if 97 - 97: ooo000 . iI1iII1I1I1i
   for IiIIiiII in range ( self . localStep , iiiIiiI11iiI ) :
    if 92 - 92: i1i1i1111I + OooOoo
    if 87 - 87: i1i1i1111I - I11iiIi11i1I / i1 - i1iiIII111
    if 9 - 9: Oo * oOo0O00 * Ii * IiIIii11Ii
    if 46 - 46: oOo0O00 % I1Ii1I1 * ooo000 % I1Ii1I1
    if 67 - 67: IiIIii11Ii + IiIIii11Ii
    self . localStep += 1
    self . globalStep += 1
    iIiIIIi11 : int = self . localStep
    if 48 - 48: IiIIii11Ii / I1I + i1I
    if 52 - 52: iI1iII1I1I1i * I1Ii1I1 - I1Ii1I1 / ooo000 * oOo0O00
    if 11 - 11: i1i1i1111I * I1I % iI1iII1I1I1i + Ii * Iii1i
    OOOO = next ( self )
    if 17 - 17: i1I / Ooo0Ooo + oOO
    if 88 - 88: IiIIii11Ii % i1I * Ii - oOO * i1iiIII111 % I1I
    if 69 - 69: I1Ii1I1 - oOo0O00 / oOO / I11iiIi11i1I
    for IiI , Ii1I1i in enumerate ( OOO0oOO0oOO ) :
     if Ii1I1i [ 'learningRateDecay' ] == True :
      oo0ooOO0O = float ( Ii1I1i [ 'initialLearningRate' ] )
      ooOoO00 = float ( 0 ) if Ii1I1i [ 'learningRateDecayFactor' ] is None else float ( Ii1I1i [ 'learningRateDecayFactor' ] )
      O000oO = float ( self . localStep // I11oOoo0o0 [ IiI ] )
      O0Ooo0Oo = oo0ooOO0O * ooOoO00 ** O000oO
      Ii1I1i [ 'learningRate' ] = O0Ooo0Oo
      if 91 - 91: Ooo0Ooo % oOO
     else :
      O0Ooo0Oo = Ii1I1i [ 'learningRate' ]
      if 36 - 36: Ii - i1i1i1111I / I11iiIi11i1I . i1 . IiI11Ii111 . Oo
    for IiIii1i1II in self . k_model . learning_list . keys ( ) :
     with tf . GradientTape ( ) as OOOO0o0O :
      self . k_model ( OOOO , training = True )
      oOoo0000OoO0 = self . k_model . loss_value ( )
      self . k_model . update ( OOOO0o0O , IiIii1i1II )
      if 71 - 71: IiIIii11Ii * ooOOO . I1I
      if 1 - 1: i1i1i1111I % I11iiIi11i1I / IiI11Ii111 - I11iiIi11i1I / ooo000 - Oo
    if i11i and ( iIiIIIi11 % self . logFreq == 0 or IiIIiiII == iiiIiiI11iiI - 1 ) :
     O0Ooo0OoO = oOoOoo0OOO . logAndRestart ( )
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     o000o = self . logFreq * self . sources [ 0 ] . batchSize / O0Ooo0OoO
     i1i1ii = float ( O0Ooo0OoO / ( self . localStep - O0o0oO ) )
     O0o0oO = self . localStep
     I1Iii111111 = np . average ( oOoo0000OoO0 . numpy ( ) )
     Ooo000OO = I1Iii111111 * I11IiI1Iii . batchSize
     if 33 - 33: i1iiIII111 / Ii % IiIIii11Ii
     if 83 - 83: Ii + OooOoo + ooo000 + IIiIIiIi11I1 . I11iiIi11i1I % I1Ii1I1
     if 52 - 52: IiI11Ii111 * Ii - ooo000 / iI1iII1I1I1i % i1 - Ooo0Ooo
     OoooOo0 . logAndSave ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , i111iIIiIIi ( Ooo000OO ) , i111iIIiIIi ( I1Iii111111 ) , O0Ooo0Oo , o000o , i1i1ii ] )
     if 94 - 94: iI1iII1I1I1i - I1I / ooOOO - I11iiIi11i1I - I1I + OooOoo
     if self . line_notify is not None :
      self . line_notify . add_train_log ( self . globalStep , i111iIIiIIi ( Ooo000OO ) , i111iIIiIIi ( I1Iii111111 ) , O0Ooo0Oo )
     if self . _cvNo == - 1 :
      print ( '%s: Run #%d, Step %d (%d) --- loss: %f; learning rate: %f; %.1f examples/s; %.3f s/step' % ( ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . globalStep , iIiIIIi11 , I1Iii111111 , O0Ooo0Oo , o000o , i1i1ii ) )
     else :
      print ( '%s: Run #%d - Cross Validation %d, Step %d (%d) --- loss: %f; learning rate: %f; %.1f examples/s; %.3f s/step' % ( ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , I1Iii111111 , O0Ooo0Oo , o000o , i1i1ii ) )
      if 61 - 61: IIiIIiIi11I1 - Iii1i
      if 15 - 15: I11iiIi11i1I % Iii1i % I1Ii1I1
    if o0Oo and ( iIiIIIi11 % self . weightLogFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     o0OoOo0ooo0 = [ ]
     for oO00oOooO0O in self . k_model . layers :
      for iiI1iI11 in oO00oOooO0O . weights :
       iiI1iI11 = iiI1iI11 . numpy ( )
       iiI1iI11 [ np . isnan ( iiI1iI11 ) ] = None
       o0OoOo0ooo0 . append ( iiI1iI11 . tolist ( ) )
     OOooo00 . logAndSave ( [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , iIiIIIi11 , * o0OoOo0ooo0 ] )
     if 1 - 1: I1I . Ooo0Ooo * oOo0O00 + I11iiIi11i1I % IiIIii11Ii / i1I
     if 9 - 9: i1I + Ooo0Ooo * Ii / i1I % iI1iII1I1I1i + oOO
    if self . saveFreq > 0 and ( iIiIIIi11 % self . saveFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 60 - 60: I1I
     if 90 - 90: Ii * i1iiIII111 + I1Ii1I1
     if 2 - 2: I1I . Iii1i . IiIIii11Ii * ooOOO
     if 71 - 71: Ii * i1
     if i11i :
      OoooOo0 . flush ( )
      if 90 - 90: i1iiIII111
      if 19 - 19: OooOoo / I1I - ooo000 + oOo0O00 + I1I / ooo000
    if oOooO0OO0oo and ( iIiIIIi11 % self . traceFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 63 - 63: Ii
     iii111iI = self . keras_predict ( x = self . traceItems , buildNo = buildNo )
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     for oO0OOOOOOoo in self . getFinalNodes ( buildNo = buildNo ) :
      for o0Iii in oO0OOOOOOoo . comparisons :
       if o0Iii [ "target" ] in self . traceItems :
        IIiIIi11I = oO0OOOOOOoo . getTraceItems ( iii111iI , buildNo = buildNo , comparison = o0Iii )
        if IIiIIi11I is not None :
         iIi1IIi1111II . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , oO0OOOOOOoo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ] , oO0OOOOOOoo . __class__ . __name__ , * I1iiiiii ( pi ) ] for pi in IIiIIi11I ] )
     iIi1IIi1111II . flush ( )
     if 14 - 14: i1i1i1111I + i1i1i1111I + ooOOO % i1i1i1111I % OooOoo
     if 36 - 36: OooOoo . iI1iII1I1I1i
    if oO000oO and ( iIiIIIi11 % self . visualTestFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     from sklearn . manifold import TSNE
     if 42 - 42: iI1iII1I1I1i + ooo000 + iI1iII1I1I1i * i1I * iI1iII1I1I1i / IIiIIiIi11I1
     ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
     self . k_model . call ( self . visualData , training = False )
     IIIii111I111 = self . k_model . visual_output
     Oo0OO = TSNE ( n_components = 2 , perplexity = 5 , init = 'random' , random_state = 5 )
     O0O0OO0 = Oo0OO . fit_transform ( IIIii111I111 . numpy ( ) . reshape ( IIIii111I111 . shape [ 0 ] , - 1 ) )
     II11I1iiiII = getattr ( self . k_model , self . output )
     OOOo0o0 = tf . math . argmax ( II11I1iiiII , axis = 1 )
     OOOo0o0 = OOOo0o0 . numpy ( )
     if 75 - 75: I11iiIi11i1I / I1I
     i11I1I = [ [ ts [ 0 ] , ts [ 1 ] , int ( OOOo0o0 [ IiIIiiII ] ) ] for IiIIiiII , ts in enumerate ( O0O0OO0 . tolist ( ) ) ]
     oooOOo0 = self . getVisualItems ( i11I1I , buildNo = buildNo )
     oOO0 . log ( * [ [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , "" , oO0OOOOOOoo . __class__ . __name__ , * I1iiiiii ( pi ) ] for pi in oooOOo0 ] )
     oOO0 . flush ( )
     if 50 - 50: I11iiIi11i1I * oOO
     if 67 - 67: i1iiIII111
    if iIII11Ii11 and ( iIiIIIi11 % self . testFreq == 0 or iIiIIIi11 == iiiIiiI11iiI ) :
     if 1 - 1: oOO - i1iiIII111
     if 94 - 94: IIiIIiIi11I1 + I11iiIi11i1I / IiIIii11Ii + I1I + Oo
     self . keras_evaluate ( validation = I1IOoOO0o , event = "Test Log" , buildNo = buildNo )
   if 7 - 7: Ooo0Ooo - I1Ii1I1 - oOo0O00
   if 99 - 99: iI1iII1I1I1i / ooOOO
   if 9 - 9: ooo000 - I1Ii1I1 * oOO . i1I . I1Ii1I1 * Iii1i
   if 87 - 87: I11iiIi11i1I - oOo0O00 + OooOoo
   if 22 - 22: I1Ii1I1 + IiIIii11Ii
   if 3 - 3: i1
   if 40 - 40: IIiIIiIi11I1 % I1I - OooOoo / ooo000 % i1iiIII111
   if 17 - 17: oOo0O00
   if 15 - 15: oOO * IIiIIiIi11I1
   if 57 - 57: Ii + Iii1i / Oo + i1iiIII111 . Ii
   if 76 - 76: i1I * iI1iII1I1I1i - OooOoo
   if 48 - 48: Ii * i1I / IiI11Ii111
   if 69 - 69: i1 % I11iiIi11i1I
   if 88 - 88: I1Ii1I1 / Ii
   if 37 - 37: oOo0O00
   if 44 - 44: Iii1i . iI1iII1I1I1i / oOO + IiI11Ii111 * IIiIIiIi11I1
   if 48 - 48: I1I + Ooo0Ooo
   if 13 - 13: ooo000 % OooOoo - IiI11Ii111 % Iii1i
   if 53 - 53: I11iiIi11i1I - i1i1i1111I / Iii1i / i1I * i1I
   if 68 - 68: Ooo0Ooo % iI1iII1I1I1i / IiI11Ii111 * OooOoo
   self . close ( )
   if 21 - 21: I1I
 def keras_evaluate ( self , x : Optional [ Union [ 'Source.Config' , 'np.ndarray' , List [ List [ Any ] ] , List [ 'Source.Config' ] , 'Source.Data' ] ] = None ,
 batchSize : int = - 1 , shuffle : bool = False , validation : bool = False , isPredict : bool = False , event : str = "" , saveOriginal : bool = False , saveResults : bool = False , buildNo : int = 0 ) :
  if 4 - 4: IIiIIiIi11I1
  if 23 - 23: i1 - IiI11Ii111
  if 36 - 36: I1Ii1I1 + Oo
  if 94 - 94: Ooo0Ooo . I1Ii1I1
  if 82 - 82: I1Ii1I1 + Iii1i % Oo
  if 100 - 100: OooOoo / i1i1i1111I - Ii * Iii1i % i1iiIII111
  if 95 - 95: ooOOO * i1I + Oo
  if 35 - 35: I1I
  if 90 - 90: I11iiIi11i1I % iI1iII1I1I1i / OooOoo + iI1iII1I1I1i
  if 80 - 80: i1iiIII111
  if 29 - 29: i1iiIII111 / Ii / I1I / IiI11Ii111 + Ooo0Ooo % Ooo0Ooo
  if 3 - 3: IIiIIiIi11I1 % ooo000 + I1Ii1I1 - IiIIii11Ii + i1i1i1111I - I11iiIi11i1I
  if 2 - 2: i1iiIII111 . oOO
  if 87 - 87: Ii % ooOOO
  if 41 - 41: IiI11Ii111 * IIiIIiIi11I1 / IiI11Ii111 % oOO / I1I
  if 16 - 16: I1Ii1I1 . oOo0O00 * ooOOO * I11iiIi11i1I
  if 63 - 63: i1i1i1111I . Ooo0Ooo . IIiIIiIi11I1
  if 75 - 75: IiIIii11Ii - oOo0O00 / I1Ii1I1 / i1iiIII111 - I1I + oOo0O00
  if 54 - 54: Iii1i + I1I . I1Ii1I1 + oOO
  if x is not None :
   if validation :
    raise ValueError ( "NOM Trainer Internal Error - Validation triggered with customized source data." )
    if 64 - 64: I1Ii1I1 * Oo
    if 24 - 24: i1i1i1111I - Oo
    if 17 - 17: ooOOO % iI1iII1I1I1i
   if isinstance ( x , I1ii11II11 . Config ) :
    self . _evalSources = [ x ]
   elif isinstance ( x , iII11 . UsingData ) :
    self . _evalSources = x
   elif isinstance ( x , list ) and all ( [ isinstance ( x , I1ii11II11 . Config ) for t in x ] ) :
    self . _evalSources = x
   else :
    if 54 - 54: i1I % i1i1i1111I . IIiIIiIi11I1 / iI1iII1I1I1i + i1I
    if 32 - 32: I1I + i1iiIII111
    raise ValueError ( "Evaluation source is not supported." )
    if 23 - 23: i1 * ooOOO * oOO * I1Ii1I1 - IiI11Ii111 * iI1iII1I1I1i
    if 63 - 63: ooOOO * iI1iII1I1I1i
   if not isinstance ( x , iII11 . UsingData ) :
    if len ( self . _evalSources ) != len ( self . sources ) :
     raise ValueError ( "Evaluation sources length does not match originally desinged model." )
    elif any ( [ not isinstance ( s , self . _evalSources [ idx ] . __class__ ) for idx , s in enumerate ( self . sources ) ] ) :
     raise ValueError ( "Evaluation sources class does not match originally desinged model." )
     if 38 - 38: I11iiIi11i1I / Iii1i + I1I - Iii1i - ooo000
     if 68 - 68: I1Ii1I1 % Ii
  if isPredict :
   if 43 - 43: OooOoo / Ooo0Ooo
   OOOo0O = self . _keras_evaluate ( validation , isPredict = isPredict , event = event , saveOriginal = saveOriginal , saveResults = saveResults , buildNo = buildNo )
   if 46 - 46: IIiIIiIi11I1 - Iii1i - i1I - Ooo0Ooo * oOO + iI1iII1I1I1i
   if 26 - 26: IiI11Ii111 + I1Ii1I1
   self . _evalSources = None
   if 77 - 77: i1
   return OOOo0O
  else :
   if 66 - 66: i1i1i1111I + i1I % OooOoo + I11iiIi11i1I % IIiIIiIi11I1
   self . _keras_evaluate ( validation , event = event , saveOriginal = saveOriginal , saveResults = saveResults , buildNo = buildNo )
   if 4 - 4: Ooo0Ooo * I11iiIi11i1I
   if 52 - 52: i1iiIII111 * IIiIIiIi11I1 + IiI11Ii111 . IIiIIiIi11I1 . i1i1i1111I + IiI11Ii111
   self . _evalSources = None
   if 49 - 49: oOo0O00
 def _keras_evaluate ( self , validation : bool = False , isPredict : bool = False , event : str = "" , saveOriginal : bool = False , saveResults : bool = False , buildNo : int = 0 ) -> Any :
  if 82 - 82: ooOOO
  if 47 - 47: i1
  if 67 - 67: oOo0O00 / IiIIii11Ii - I11iiIi11i1I + I11iiIi11i1I
  if 79 - 79: Iii1i * ooo000
  if 15 - 15: IiIIii11Ii * i1
  if 20 - 20: iI1iII1I1I1i . I1I + ooo000
  if 11 - 11: oOo0O00 % Ooo0Ooo + oOo0O00
  if 55 - 55: i1i1i1111I - IIiIIiIi11I1
  if 19 - 19: iI1iII1I1I1i * I11iiIi11i1I % Ii - Ooo0Ooo
  if 99 - 99: IIiIIiIi11I1 . i1 . IiI11Ii111 * i1
  if 7 - 7: Ooo0Ooo * iI1iII1I1I1i / IIiIIiIi11I1 + Ooo0Ooo
  if 67 - 67: oOo0O00 - Oo . Iii1i
  if 93 - 93: oOO . ooo000
  if 11 - 11: i1 % I1I
  if 32 - 32: iI1iII1I1I1i + I11iiIi11i1I * IiIIii11Ii / I1I . Ii
  if 25 - 25: i1 * I1Ii1I1 - IIiIIiIi11I1 + oOo0O00 % i1I . Iii1i
  if 19 - 19: oOO / Iii1i * Oo . i1i1i1111I
  if 31 - 31: oOO . IIiIIiIi11I1 . I11iiIi11i1I % i1i1i1111I
  if 74 - 74: Ii . oOo0O00 . ooOOO / i1i1i1111I / i1 - ooOOO
  I1II1ii11i1ii = self . currentSourceDataset
  if validation :
   self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Validation )
  else :
   self . assignCurrentSourceDataset ( I111II1II111I . Dataset . Types . Test )
   if 7 - 7: Oo % IIiIIiIi11I1 % i1iiIII111 + Oo % I11iiIi11i1I
   if 47 - 47: ooOOO * oOo0O00 * OooOoo % i1i1i1111I
  O0O0o0o0o0 = self . _evalSources
  Ii1IiiIIi1II = O0O0o0o0o0 is not None
  I1i111ii1ii = isinstance ( O0O0o0o0o0 , iII11 . UsingData )
  if I1i111ii1ii :
   if len ( O0O0o0o0o0 ) == 0 :
    raise ValueError ( "There is no test or validation data sources." )
   elif len ( self . dppNodes ) != len ( O0O0o0o0o0 ) :
    raise ValueError ( "Sources and test sources are not matched." )
    if 33 - 33: I11iiIi11i1I + i1i1i1111I + I1I / I11iiIi11i1I
    if 3 - 3: iI1iII1I1I1i / Ii / i1iiIII111
  o0o0oooO0 = self . rootSources
  ii1Ii1i11I1 = math . ceil ( O0O0o0o0o0 . getCount ( ) / self . buildConfigs [ self . buildNo ] . batchSize ) if Ii1IiiIIi1II else o0o0oooO0 . batchCountPerEpoch
  if 2 - 2: IiI11Ii111 * ooOOO . OooOoo / Ooo0Ooo / ooo000 . I1I
  if 55 - 55: i1iiIII111 / IiIIii11Ii . i1
  OO0o000OO000 = self . getFinalNodes ( buildNo = buildNo )
  o0oo0oOOOoOOo = { }
  if 54 - 54: i1I * I1Ii1I1 / Oo . I1Ii1I1 + Ii * I11iiIi11i1I
  if 83 - 83: oOo0O00 - I11iiIi11i1I
  OoooOo = 0
  for OOOO0O0oO0Oo in OO0o000OO000 :
   OOOO0O0oO0Oo . _clearEvalInfo ( )
   if 11 - 11: ooOOO
  for IiIIiiII in range ( 0 , ii1Ii1i11I1 ) :
   if 38 - 38: Iii1i * IiI11Ii111
   oO0OOO0Oo = O0O0o0o0o0 if I1i111ii1ii else { dppKey : dppData for dppKey , dppData in next ( self ) . items ( ) }
   OoooOo += max ( [ len ( colData ) for colData in oO0OOO0Oo . values ( ) ] )
   if 38 - 38: oOo0O00 % IiIIii11Ii * i1I . I11iiIi11i1I
   if 34 - 34: i1iiIII111 / ooOOO % OooOoo
   self . k_model . call ( oO0OOO0Oo , training = False )
   if 61 - 61: Oo % ooOOO * IiI11Ii111
   OOO00oo0o = { }
   i1iI111i1 = { }
   for OOOO0O0oO0Oo in OO0o000OO000 :
    for o0Iii in OOOO0O0oO0Oo . comparisons :
     OOoO0Ooo = OOOO0O0oO0Oo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ]
     OOO00oo0o [ OOoO0Ooo ] = getattr ( self . k_model , o0Iii [ "input" ] . replace ( ' ' , '' ) + str ( '_output' ) )
     i1iI111i1 [ OOoO0Ooo ] = getattr ( self . k_model , o0Iii [ "target" ] . replace ( ' ' , '' ) + str ( '_output' ) )
     if 71 - 71: oOo0O00 / OooOoo . i1i1i1111I
     if 71 - 71: i1 * Ooo0Ooo - i1iiIII111 / Iii1i
   for OOOO0O0oO0Oo in OO0o000OO000 :
    if 96 - 96: iI1iII1I1I1i / i1i1i1111I
    if 64 - 64: I1Ii1I1 % iI1iII1I1I1i . IiIIii11Ii + I1I / ooOOO . IiIIii11Ii
    if 32 - 32: i1i1i1111I * IiIIii11Ii
    if 69 - 69: oOO
    if 12 - 12: I1I % Ii / OooOoo
    if 74 - 74: IIiIIiIi11I1 % oOo0O00 % Ooo0Ooo / Iii1i
    if 77 - 77: ooo000
    if 21 - 21: i1i1i1111I
    for o0Iii in OOOO0O0oO0Oo . comparisons :
     OOoO0Ooo = OOOO0O0oO0Oo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ]
     if o0Iii [ "metrics" ] == "accuracy" or o0Iii [ "metrics" ] == "sparse_categorical_crossentropy" :
      OOOo0O = np . reshape ( np . argmax ( OOO00oo0o [ OOoO0Ooo ] , axis = 1 ) , ( - 1 , 1 ) )
      i1iI111i1 [ OOoO0Ooo ] = np . reshape ( np . argmax ( i1iI111i1 [ OOoO0Ooo ] , axis = 1 ) , ( - 1 , 1 ) )
     else :
      OOOo0O = OOO00oo0o [ OOoO0Ooo ]
      if 30 - 30: IiIIii11Ii * iI1iII1I1I1i
     if o0Iii [ "target" ] == "input" or o0Iii [ "target" ] == "target" :
      if 58 - 58: i1i1i1111I . oOo0O00 - i1I
      OOO00oo0o [ OOoO0Ooo ] = OOOO0O0oO0Oo . recoverPredictedResults ( OOOo0O , o0Iii [ "target" ] )
      i1iI111i1 [ OOoO0Ooo ] = OOOO0O0oO0Oo . recoverPredictedResults ( np . array ( oO0OOO0Oo [ o0Iii [ "target" ] ] ) , o0Iii [ "target" ] )
      if 32 - 32: i1 % I1Ii1I1 % oOO - i1iiIII111
      if 85 - 85: I1I / i1 + Ii * oOO . i1 - i1i1i1111I
   if not isPredict :
    if 84 - 84: Ii % iI1iII1I1I1i
    for OOOO0O0oO0Oo in OO0o000OO000 :
     for o0Iii in OOOO0O0oO0Oo . comparisons :
      OOOO0O0oO0Oo . partialEvaluate ( i1iI111i1 [ OOOO0O0oO0Oo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ] ] , OOO00oo0o [ OOOO0O0oO0Oo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ] ] , o0Iii )
      if 19 - 19: Ooo0Ooo . i1 % Ii + OooOoo
      if 80 - 80: i1i1i1111I - IIiIIiIi11I1 - oOo0O00 . ooOOO * oOo0O00
   if isPredict :
    for OOOO0O0oO0Oo in OO0o000OO000 :
     for o0Iii in OOOO0O0oO0Oo . comparisons :
      ooOo0 = OOOO0O0oO0Oo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ]
      try :
       if 84 - 84: IiIIii11Ii + IiIIii11Ii . Oo - Iii1i - Ooo0Ooo + ooOOO
       o0oo0oOOOoOOo [ ooOo0 ] = np . concatenate ( ( o0oo0oOOOoOOo [ ooOo0 ] , OOO00oo0o [ ooOo0 ] ) , axis = 0 )
      except :
       if 1 - 1: I1Ii1I1 % ooo000 % Ii - Ii
       o0oo0oOOOoOOo [ ooOo0 ] = OOO00oo0o [ ooOo0 ]
       if 49 - 49: I1I - IiIIii11Ii
  if isPredict :
   if 50 - 50: Oo
   self . assignCurrentSourceDataset ( I1II1ii11i1ii )
   if 32 - 32: i1I
   if 93 - 93: oOo0O00 - iI1iII1I1I1i - I11iiIi11i1I % oOo0O00 - OooOoo / oOo0O00
   return o0oo0oOOOoOOo
  else :
   if 22 - 22: IiIIii11Ii / ooOOO / I11iiIi11i1I
   OO0oo0o00oOo0 = [ ]
   for OOOO0O0oO0Oo in OO0o000OO000 :
    for o0Iii in OOOO0O0oO0Oo . comparisons :
     if o0Iii [ "metrics" ] != "None" :
      OO0oo0o00oOo0 . append ( [ OOOO0O0oO0Oo . name + '_' + o0Iii [ "input" ] + '_' + o0Iii [ "target" ] + ' ' + o0Iii [ "metrics" ] , OOOO0O0oO0Oo . getTestScore ( o0Iii ) ] )
      if 51 - 51: i1I * iI1iII1I1I1i * i1i1i1111I % Oo
      if 72 - 72: Ii + Oo % ooo000 * IIiIIiIi11I1
   if OO0oo0o00oOo0 :
    ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
    oo00o = [ ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep , event , * I1iiiiii ( [ ans [ 1 ] for ans in OO0oo0o00oOo0 ] ) ]
    if self . _cvNo == - 1 :
     print ( '\nTEST (Validation: %s - %s) Test Data Size: %d\n%s: Run #%d, Step %d (%d) --- \n' % ( validation , event , OoooOo , ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . globalStep , self . localStep ) , * [ ans [ 0 ] + ": " + ( "%f\n" % ans [ 1 ] ) for ans in OO0oo0o00oOo0 ] , "\n" )
    else :
     print ( '\nTEST (Validation: %s - %s) Test Data Size: %d\n%s: Run #%d - Cross Validation %d, Step %d (%d) --- \n' % ( validation , event , OoooOo , ooOo0IiiIIIiiI1Ii1 , self . _runNo , self . _cvNo , self . globalStep , self . localStep ) , * [ ans [ 0 ] + ": " + ( "%f\n" % ans [ 1 ] ) for ans in OO0oo0o00oOo0 ] , "\n" )
    if self . testLogger is not None :
     if self . line_notify is not None :
      self . line_notify . add_test_log ( self . globalStep , OO0oo0o00oOo0 [ 0 ] )
      if 59 - 59: IiIIii11Ii * I1I . I1Ii1I1 / i1iiIII111 + I1I
     self . testLogger . logAndSave ( oo00o )
     if 80 - 80: I1I + I1Ii1I1 / I1Ii1I1 . Oo % IiI11Ii111 * IiI11Ii111
     if 70 - 70: i1 . i1iiIII111 % IiIIii11Ii / i1i1i1111I + Ooo0Ooo . Ii
   if not I1i111ii1ii :
    if O0O0o0o0o0 is not None :
     if 58 - 58: ooOOO - i1i1i1111I - I1I - OooOoo / ooo000 / I11iiIi11i1I
     for O0oo0 in reversed ( O0O0o0o0o0 ) :
      if isinstance ( O0oo0 , I1ii11II11 . Config ) :
       O0oo0 . close ( )
    else :
     if 47 - 47: i1iiIII111
     self . rootSources . closeCurrentDatasets ( )
     if 11 - 11: IiI11Ii111 + OooOoo * Oo . Ii
     if 36 - 36: Oo * OooOoo * Ii . ooOOO + IIiIIiIi11I1
   self . assignCurrentSourceDataset ( I1II1ii11i1ii )
   if 49 - 49: I1I % i1iiIII111 % oOO * i1iiIII111 . Ii % i1I
 def keras_predict ( self , x : Optional [ Union [ 'Source.Config' , 'np.ndarray' , List [ List [ Any ] ] , List [ 'Source.Config' ] , 'Source.Data' ] ] = None ,
 batchSize : int = - 1 , shuffle : bool = False , validation : bool = False , event : str = "" , saveOriginal : bool = False , saveResults : bool = False , buildNo : int = 0 ) :
  if 91 - 91: oOo0O00 / OooOoo
  if 62 - 62: Iii1i
  if 47 - 47: i1I
  if 6 - 6: iI1iII1I1I1i % iI1iII1I1I1i . I1I . i1iiIII111 * Ooo0Ooo
  if 91 - 91: IIiIIiIi11I1 / oOo0O00 + ooOOO / I1I * ooo000 . i1
  if 19 - 19: Ii + I1I + ooo000
  if 48 - 48: Oo
  if 83 - 83: I11iiIi11i1I / iI1iII1I1I1i
  if 5 - 5: IiIIii11Ii
  if 92 - 92: I1Ii1I1
  if 33 - 33: Ii + Ooo0Ooo
  if 58 - 58: i1i1i1111I % i1iiIII111 % i1 + oOO
  if 88 - 88: i1i1i1111I . IiIIii11Ii * IIiIIiIi11I1 . I1Ii1I1 + i1I . i1i1i1111I
  if 33 - 33: oOO
  if 75 - 75: OooOoo + Ooo0Ooo / IiI11Ii111 * ooo000
  if 31 - 31: oOo0O00
  if 58 - 58: i1 / oOO % oOO + i1
  return self . keras_evaluate ( x = x , batchSize = batchSize , shuffle = shuffle , validation = validation , isPredict = True , event = event , saveOriginal = saveOriginal , saveResults = saveResults , buildNo = buildNo )
  if 90 - 90: IIiIIiIi11I1 . ooo000 + ooo000
 def save_weight_model ( self , saveConfig ) :
  if 15 - 15: Oo * I1I
  if 61 - 61: i1 + ooo000 / Ii . ooOOO / OooOoo
  if 73 - 73: ooo000 % i1i1i1111I
  if 34 - 34: i1I / iI1iII1I1I1i . I1Ii1I1 + oOO % i1I
  if 56 - 56: i1i1i1111I - I11iiIi11i1I * IiIIii11Ii * Ii * I1Ii1I1
  if 68 - 68: Iii1i - I1I / I1I - I1I - Ooo0Ooo
  if 41 - 41: IiIIii11Ii * IiI11Ii111
  if 37 - 37: Ooo0Ooo % i1 . Oo / ooOOO
  if 7 - 7: ooOOO * oOo0O00 * i1 . I11iiIi11i1I - ooOOO
  if 14 - 14: i1 / I1I + IiIIii11Ii % i1 - i1I
  print ( "Now to save and compress the model weight!" )
  I1iIi1i = oo0OO00oOoo . getDateStr ( expression = "yyyymmdd" ) + "_" + oo0OO00oOoo . getTimeStr ( expression = "hhmmss" )
  if 62 - 62: Ooo0Ooo - oOO + Iii1i + i1
  if 32 - 32: ooo000 - I1I + ooOOO % ooOOO
  if self . runCount > 1 :
   os . makedirs ( saveConfig . weightPath + "model_weights/" , exist_ok = True )
   if saveConfig . weightNames == "" :
    I11i1iIIi1Ii = I1iIi1i + "_" + str ( self . _runNo )
    self . k_model . save ( saveConfig . weightPath + "model_weights/" + I11i1iIIi1Ii , save_format = "tf" )
    self . make_zip ( saveConfig . weightPath + "model_weights/" , I11i1iIIi1Ii )
   else :
    I11i1iIIi1Ii = saveConfig . weightNames + "_" + str ( self . _runNo )
    self . k_model . save ( saveConfig . weightPath + "model_weights/" + I11i1iIIi1Ii , save_format = "tf" )
    self . make_zip ( saveConfig . weightPath + "model_weights/" , I11i1iIIi1Ii )
  else :
   if saveConfig . weightNames == "" :
    I11i1iIIi1Ii = saveConfig . weightNames + "_" + I1iIi1i
    self . k_model . save ( saveConfig . weightPath + I11i1iIIi1Ii , save_format = "tf" )
    self . make_zip ( saveConfig . weightPath , I11i1iIIi1Ii )
   else :
    self . k_model . save ( saveConfig . weightPath + saveConfig . weightNames , save_format = "tf" )
    self . make_zip ( saveConfig . weightPath , saveConfig . weightNames )
    if 7 - 7: I11iiIi11i1I . I11iiIi11i1I * IIiIIiIi11I1
 def use_weight_model ( self , useConfig ) :
  if 10 - 10: iI1iII1I1I1i
  if 92 - 92: I1Ii1I1
  if 26 - 26: I1I * I1Ii1I1 % oOO . I1I + Ii - i1
  if 2 - 2: I1Ii1I1 + I1Ii1I1 - I1Ii1I1 * oOO
  if 66 - 66: IiI11Ii111
  if 81 - 81: I11iiIi11i1I * Ii * IiIIii11Ii - i1I
  if 25 - 25: IiI11Ii111 / ooo000 / I1Ii1I1 / Iii1i + i1
  if 71 - 71: OooOoo % ooo000 - IiI11Ii111 . i1
  if 98 - 98: Iii1i % oOo0O00 / I11iiIi11i1I % OooOoo + Ii
  if 48 - 48: Ooo0Ooo / IIiIIiIi11I1 + i1i1i1111I - IiIIii11Ii
  try :
   if 4 - 4: i1 - I1Ii1I1
   if os . path . isfile ( useConfig . weightPath + useConfig . weightNames + ".zip" ) :
    self . extract_zip ( useConfig . weightPath , useConfig . weightNames )
   if os . path . isdir ( useConfig . weightPath + useConfig . weightNames ) :
    print ( "Start using model weights now!" )
    if 20 - 20: i1 + Ii
   Ooo0O0O0oO = tf . keras . models . load_model ( useConfig . weightPath + useConfig . weightNames )
  except :
   raise ValueError ( "There is no model weight file specified for the current path!" )
   if 31 - 31: IIiIIiIi11I1 + oOO % oOO . iI1iII1I1I1i + oOO
  IiIIiiII , oO000oOOoOO0o = 0 , 0
  while ( IiIIiiII < len ( Ooo0O0O0oO . layers ) and oO000oOOoOO0o < len ( self . k_model . layers ) ) :
   O0o0O0 = Ooo0O0O0oO . layers [ IiIIiiII ]
   iiiIi11I111 = self . k_model . layers [ oO000oOOoOO0o ]
   if O0o0O0 . _keras_api_names [ 0 ] == iiiIi11I111 . _keras_api_names [ 0 ] :
    if len ( O0o0O0 . get_weights ( ) ) != 0 and len ( iiiIi11I111 . get_weights ( ) ) != 0 :
     if O0o0O0 . get_weights ( ) [ 0 ] . shape == iiiIi11I111 . get_weights ( ) [ 0 ] . shape :
      iiiIi11I111 . set_weights ( O0o0O0 . get_weights ( ) )
      oO000oOOoOO0o = oO000oOOoOO0o + 1
    else :
     oO000oOOoOO0o = oO000oOOoOO0o + 1
   else :
    O0O0OoO0ooO00 = self . k_model . layers [ oO000oOOoOO0o : ]
    Ii1I = 0
    while ( Ii1I < len ( O0O0OoO0ooO00 ) ) :
     if O0o0O0 . _keras_api_names [ 0 ] == O0O0OoO0ooO00 [ Ii1I ] . _keras_api_names [ 0 ] :
      oO000oOOoOO0o = oO000oOOoOO0o + Ii1I
      IiIIiiII = IiIIiiII - 1
      break
     else :
      Ii1I = Ii1I + 1
   IiIIiiII = IiIIiiII + 1
   if 99 - 99: I11iiIi11i1I - I1I * ooOOO . Iii1i
 def make_zip ( self , source_dir , output_filename ) :
  if 34 - 34: IiIIii11Ii % IiIIii11Ii * I1I % i1I . i1I / OooOoo
  if 59 - 59: OooOoo . IiI11Ii111
  if 36 - 36: oOO - IiI11Ii111 + i1
  if 6 - 6: ooOOO % i1i1i1111I / ooo000 * i1I + Oo / IiIIii11Ii
  if 81 - 81: IiI11Ii111 % Iii1i
  if 5 - 5: oOO
  if 93 - 93: Oo
  if 88 - 88: IIiIIiIi11I1 * ooo000 - Ii + Oo - IiI11Ii111
  if 91 - 91: Ooo0Ooo + I1Ii1I1 * ooOOO % OooOoo
  if 100 - 100: i1i1i1111I / i1iiIII111 - Ii % IiI11Ii111 / Ii
  if 16 - 16: ooOOO % i1i1i1111I
  import zipfile
  I1I1i11Ii1iIi = zipfile . ZipFile ( source_dir + '/' + output_filename + '.zip' , 'w' , zipfile . ZIP_DEFLATED )
  OOooo = os . getcwd ( )
  if 44 - 44: ooOOO + IIiIIiIi11I1 / IIiIIiIi11I1
  if 44 - 44: IiIIii11Ii * I1I + Iii1i - i1I - oOo0O00 + IiIIii11Ii
  if len ( source_dir . split ( "/" ) ) > 2 :
   OooOO000OooOo = source_dir . replace ( output_filename , "" )
   os . chdir ( OooOO000OooOo )
   if 7 - 7: I1Ii1I1 . IiIIii11Ii / i1iiIII111 % Ooo0Ooo - Ooo0Ooo + Iii1i
  for iIIiI1I1I1 , o0O0O00oO00 , o00oOO in os . walk ( "./" + output_filename ) :
   I1I1i11Ii1iIi . write ( iIIiI1I1I1 )
   for iIiII1iii in o00oOO :
    IiIi1iI1 = os . path . join ( iIIiI1I1I1 , iIiII1iii )
    I1I1i11Ii1iIi . write ( IiIi1iI1 )
  os . chdir ( OOooo )
  if 28 - 28: IiI11Ii111 % ooOOO + IiI11Ii111 . OooOoo - i1I - ooOOO
 def extract_zip ( self , source_dir , output_filename ) :
  if 54 - 54: oOo0O00 * i1iiIII111 % I1I / Ii . i1iiIII111
  if 3 - 3: OooOoo % Oo - i1 - IiIIii11Ii
  if 78 - 78: I1Ii1I1 / IIiIIiIi11I1
  if 63 - 63: iI1iII1I1I1i - iI1iII1I1I1i + i1 - Iii1i - I11iiIi11i1I . IIiIIiIi11I1
  if 18 - 18: i1i1i1111I % i1I / Oo - i1iiIII111 / IiI11Ii111 - IiI11Ii111
  if 50 - 50: Iii1i . i1 - i1
  if 47 - 47: oOO - Iii1i + i1
  if 99 - 99: oOo0O00 % i1I + i1I * I1Ii1I1 . Ooo0Ooo
  if 12 - 12: OooOoo
  if 48 - 48: I11iiIi11i1I % iI1iII1I1I1i + i1iiIII111
  if 20 - 20: i1i1i1111I - oOO
  import zipfile
  I1I1i11Ii1iIi = zipfile . ZipFile ( source_dir + output_filename + ".zip" )
  I1I1i11Ii1iIi . extractall ( source_dir )
  I1I1i11Ii1iIi . close ( )
  if 45 - 45: I11iiIi11i1I
class IiiIIi11Iii :
 class Types ( II1i1I ) :
  if 50 - 50: i1I . IIiIIiIi11I1 + ooOOO . oOo0O00 . i1I - ooOOO
  if 41 - 41: i1 + Oo
  if 17 - 17: OooOoo . OooOoo
  if 14 - 14: iI1iII1I1I1i . Oo + i1
  if 48 - 48: oOo0O00 / oOO - OooOoo . i1I . i1iiIII111
  if 17 - 17: i1iiIII111
  if 76 - 76: i1i1i1111I * iI1iII1I1I1i * oOo0O00 % oOO / ooOOO % I11iiIi11i1I
  if 63 - 63: i1iiIII111 - IiIIii11Ii + oOo0O00 % Oo - i1
  if 32 - 32: i1 . i1i1i1111I % IiIIii11Ii . IiIIii11Ii
  if 61 - 61: Iii1i / i1iiIII111 - Iii1i - I1I
  if 24 - 24: Ooo0Ooo * i1I . IiI11Ii111 % ooo000 . i1 - I11iiIi11i1I
  line = 0
  if 81 - 81: ooo000 * i1I - I1Ii1I1 / IiI11Ii111 - OooOoo * I11iiIi11i1I
  if 4 - 4: I1Ii1I1 / IiI11Ii111 / Oo % I1Ii1I1
  email = 1
  if 90 - 90: I11iiIi11i1I * oOo0O00 % oOo0O00
 def __init__ ( self , isUse = False , ID = "" ) :
  self . isUse = isUse
  if 6 - 6: i1iiIII111 / Ooo0Ooo / Ii
  if 33 - 33: i1iiIII111 % Ooo0Ooo + i1 - IiIIii11Ii % oOO / iI1iII1I1I1i
  if 35 - 35: ooOOO - i1i1i1111I + I1I . IiI11Ii111 / iI1iII1I1I1i * I1I
  if 56 - 56: Oo . iI1iII1I1I1i * IiIIii11Ii * iI1iII1I1I1i + ooOOO
  if 17 - 17: iI1iII1I1I1i
  if 29 - 29: oOO . Ooo0Ooo . Ooo0Ooo % Ii + i1iiIII111 / Ooo0Ooo
  if 90 - 90: Ii / IIiIIiIi11I1 * I1I - OooOoo % iI1iII1I1I1i + ooo000
  if 48 - 48: i1iiIII111 * I1I
  if 65 - 65: I1I * Ooo0Ooo . i1i1i1111I / IiIIii11Ii
  if 30 - 30: OooOoo % Oo * Oo . i1I % i1 - iI1iII1I1I1i
  self . ID = ID
  if 74 - 74: IiIIii11Ii
 def parseFromJSON ( self , obj : Dict [ str , Any ] ) :
  if 86 - 86: I11iiIi11i1I + I11iiIi11i1I * OooOoo * i1iiIII111
  if 88 - 88: ooo000 / I1I * oOO / IiIIii11Ii . OooOoo
  if 45 - 45: OooOoo - I1I / i1iiIII111 % i1 . oOO / IiI11Ii111
  if 76 - 76: i1 * iI1iII1I1I1i / i1I
  if 49 - 49: IIiIIiIi11I1 % iI1iII1I1I1i
  if 90 - 90: I1Ii1I1
  if 84 - 84: IIiIIiIi11I1 - OooOoo * OooOoo / I1I * Oo / ooo000
  if 96 - 96: IIiIIiIi11I1 % ooo000 - i1I % Ii
  if 22 - 22: Iii1i
  if 63 - 63: oOo0O00 + oOo0O00 . i1
  if 73 - 73: Oo * iI1iII1I1I1i * oOo0O00
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   setattr ( self , Ii1I , iiiiIi1IiiIi )
   if 56 - 56: IIiIIiIi11I1 * OooOoo
class O00O0O0Oo0OO :
 if 79 - 79: i1I
 if 85 - 85: Ii / i1i1i1111I * IiIIii11Ii - I1Ii1I1 % ooo000
 if 10 - 10: Iii1i * ooo000 + OooOoo - i1 % iI1iII1I1I1i . I1I
 if 30 - 30: iI1iII1I1I1i + IiIIii11Ii * ooOOO % Ii * Ooo0Ooo
 if 11 - 11: IiIIii11Ii / oOO / OooOoo / I1Ii1I1 + I11iiIi11i1I
 if 20 - 20: i1iiIII111 . oOO . Oo / ooOOO . OooOoo + i1
 if 72 - 72: i1 % ooOOO . I11iiIi11i1I
 def __init__ ( self , userConfigs : Dict [ str , str ] , task_name : str ) :
  if 34 - 34: IIiIIiIi11I1
  if 43 - 43: Ii % ooOOO / Ooo0Ooo + I1Ii1I1 - I1Ii1I1 . oOo0O00
  if 69 - 69: I11iiIi11i1I % i1I - Oo . Oo - I1I + oOO
  if 45 - 45: i1i1i1111I - I11iiIi11i1I + ooo000 * oOO % oOo0O00
  if 96 - 96: oOO + OooOoo . oOo0O00 . i1i1i1111I / oOO % Iii1i
  if 75 - 75: IIiIIiIi11I1 / oOO + i1iiIII111 % OooOoo + i1
  if 85 - 85: I1I * Oo - oOO * Ii
  if 19 - 19: OooOoo + IiI11Ii111 % I1I . I1Ii1I1 - I1Ii1I1 / Oo
  if 6 - 6: i1i1i1111I * Oo
  if 95 - 95: i1I % IiIIii11Ii
  if 47 - 47: Ooo0Ooo * IiIIii11Ii
  if 100 - 100: i1iiIII111 + Ii
  if 67 - 67: OooOoo * i1 - oOo0O00 % i1i1i1111I
  self . username = userConfigs [ "username" ]
  if 50 - 50: iI1iII1I1I1i * Ii / i1i1i1111I / OooOoo / i1I
  self . access_token = userConfigs [ "notify" ] [ IiiIIi11Iii . Types . line ] . ID
  if 19 - 19: IiIIii11Ii * IIiIIiIi11I1
  self . task_name = task_name
  if 46 - 46: OooOoo + IiIIii11Ii . i1I
  self . trainLog = { "step" : [ ] , "total_loss" : [ ] , "avg_loss" : [ ] , "learning_rate" : [ ] }
  self . weightLog = [ ]
  self . traceLog = { }
  if 58 - 58: oOO / i1iiIII111 + Iii1i + ooo000 % I1I
  self . testLog = { "step" : [ ] , "task_metric" : [ ] , "metric_name" : "" }
  if 57 - 57: IiI11Ii111 - IiI11Ii111 - oOo0O00 * i1i1i1111I
 def add_train_log ( self , step , total_loss , avg_loss , learning_rate ) :
  self . trainLog [ "step" ] . append ( step )
  if 11 - 11: i1 % i1I
  if 25 - 25: I1I . Iii1i % I1Ii1I1 / iI1iII1I1I1i . ooOOO
  if 74 - 74: Ii / Iii1i
  if 46 - 46: i1iiIII111 * i1i1i1111I
  if 39 - 39: ooOOO % OooOoo / i1I % Oo . i1I
  if 16 - 16: OooOoo * Iii1i
  if 62 - 62: IIiIIiIi11I1 . I1I % IIiIIiIi11I1 + Ooo0Ooo / ooOOO
  if 53 - 53: IIiIIiIi11I1 + ooo000
  if 76 - 76: I1Ii1I1 * OooOoo
  if 20 - 20: iI1iII1I1I1i . Ii + I1Ii1I1 / Ooo0Ooo + IiIIii11Ii
  if 91 - 91: oOO - Oo
  if 27 - 27: ooo000 + i1I
  self . trainLog [ "total_loss" ] . append ( total_loss )
  self . trainLog [ "avg_loss" ] . append ( avg_loss )
  self . trainLog [ "learning_rate" ] . append ( learning_rate )
  if 63 - 63: oOO + I11iiIi11i1I - ooOOO * ooOOO + I11iiIi11i1I % i1
 def add_test_log ( self , step , task_metric ) :
  if 71 - 71: iI1iII1I1I1i % Iii1i . OooOoo
  if 46 - 46: Ooo0Ooo / i1iiIII111 - iI1iII1I1I1i * i1i1i1111I / I1I
  if 83 - 83: oOo0O00 + IiI11Ii111
  if 92 - 92: i1i1i1111I - IiIIii11Ii
  if 17 - 17: I1I * Ooo0Ooo
  if 14 - 14: Ooo0Ooo / i1i1i1111I % i1iiIII111 + i1I + Oo
  if 17 - 17: i1 + i1
  if 45 - 45: i1I - i1i1i1111I - I1Ii1I1 * IIiIIiIi11I1 / IiIIii11Ii * i1i1i1111I
  if 29 - 29: i1iiIII111 + oOo0O00 / Iii1i * I11iiIi11i1I + OooOoo / ooo000
  if 10 - 10: IiIIii11Ii + i1I . IIiIIiIi11I1 * Oo - oOO / ooOOO
  if 32 - 32: OooOoo / i1iiIII111 . i1i1i1111I - Ooo0Ooo
  i1111ii1 = task_metric [ 0 ]
  oO00ooO0oo = task_metric [ 1 ]
  self . testLog [ "step" ] . append ( step )
  self . testLog [ "metric_name" ] = i1111ii1
  self . testLog [ "task_metric" ] . append ( oO00ooO0oo )
  if 40 - 40: i1iiIII111 - OooOoo * I1Ii1I1 . i1I
 def notification ( self , message ,
 image_thumbnail_url = None , image_fullsize_url = None ,
 image_filename = None ,
 sticker_package_id = None , sticker_id = None ,
 notification_disabled = False ) :
  if 51 - 51: IIiIIiIi11I1 . I1Ii1I1 % IIiIIiIi11I1 * iI1iII1I1I1i / OooOoo . i1
  if 78 - 78: I1I
  if 5 - 5: i1i1i1111I / i1i1i1111I * OooOoo
  if 21 - 21: Oo % I11iiIi11i1I * oOo0O00 + oOO - iI1iII1I1I1i / IiIIii11Ii
  if 16 - 16: i1 * iI1iII1I1I1i - iI1iII1I1I1i
  if 9 - 9: i1i1i1111I / ooOOO - IIiIIiIi11I1 . ooOOO * oOo0O00
  if 87 - 87: OooOoo - IIiIIiIi11I1 * i1i1i1111I . OooOoo * Ooo0Ooo
  if 96 - 96: Ii % Oo - i1 / IiIIii11Ii - IiIIii11Ii * Ii
  if 62 - 62: Ooo0Ooo . Ii * oOo0O00
  if 30 - 30: i1iiIII111 / I1Ii1I1 / I1I % OooOoo
  if 48 - 48: OooOoo . Ooo0Ooo / I1Ii1I1 % I1I
  if 71 - 71: i1I % Ooo0Ooo . iI1iII1I1I1i
  if 20 - 20: I11iiIi11i1I % I11iiIi11i1I % iI1iII1I1I1i + IiIIii11Ii * ooo000
  if 17 - 17: IIiIIiIi11I1 / Oo / i1i1i1111I . i1i1i1111I / ooOOO
  if 39 - 39: Ii * I1Ii1I1 + i1 - oOO + i1i1i1111I
  if 39 - 39: Oo . i1
  ooOOO0 = "https://notify-api.line.me/api/notify"
  o0OOo = {
 "authorization" : "Bearer " + self . access_token
 }
  if 84 - 84: OooOoo . IiI11Ii111 % oOO * i1i1i1111I % i1I
  IIi11ii1IIi = {
 "message" : message ,
 "notificationDisabled" : notification_disabled
 }
  if 51 - 51: I11iiIi11i1I * I1Ii1I1 . Iii1i
  if image_thumbnail_url is not None :
   IIi11ii1IIi [ "imageThumbnail" ] = image_thumbnail_url
   if 8 - 8: I1I
  if image_fullsize_url is not None :
   IIi11ii1IIi [ "imageFullsize" ] = image_fullsize_url
   if 28 - 28: i1 % OooOoo * ooo000 . I11iiIi11i1I . IIiIIiIi11I1
  if sticker_package_id is not None :
   IIi11ii1IIi [ "stickerPackageId" ] = sticker_package_id
   if 43 - 43: i1 / Oo
  if sticker_id is not None :
   IIi11ii1IIi [ "stickerId" ] = sticker_id
   if 40 - 40: I11iiIi11i1I
  try :
   import requests
   if image_filename is not None :
    i11I1I1II1i = {
 "imageFile" : open ( image_filename , "rb" )
 }
    O0o0O00oOo0 = requests . post ( ooOOO0 , headers = o0OOo , data = IIi11ii1IIi , files = i11I1I1II1i )
   else :
    O0o0O00oOo0 = requests . post ( ooOOO0 , headers = o0OOo , data = IIi11ii1IIi )
    if 49 - 49: i1iiIII111
   O0o0O00oOo0 . raise_for_status ( )
   return O0o0O00oOo0 . json ( )
  except Exception as i11ioO :
   print ( "Exception Error: " , i11ioO )
   return None
   if 48 - 48: i1iiIII111 * IIiIIiIi11I1 % i1 % IiIIii11Ii / I1Ii1I1
 def runNo_result_notification ( self , runNo , runCount ) :
  if runNo == 0 :
   if 68 - 68: ooOOO
   if 49 - 49: iI1iII1I1I1i * OooOoo + Oo
   if 95 - 95: IiI11Ii111 * I1I - ooOOO % i1 . Oo
   if 75 - 75: I1Ii1I1 + Ii % IIiIIiIi11I1 - oOO
   if 64 - 64: Oo . i1i1i1111I % I11iiIi11i1I - i1I % I1I + Ii
   if 96 - 96: I11iiIi11i1I
   if 10 - 10: ooo000 * ooo000 / IiIIii11Ii
   if 44 - 44: IiIIii11Ii % iI1iII1I1I1i . oOo0O00 / Ooo0Ooo - I1I
   if 32 - 32: i1I * Ooo0Ooo / i1 / i1 * oOo0O00
   if 35 - 35: IiIIii11Ii % oOo0O00
   iII1i1iIII = "Ladder Notify Dev:\n"
   iII1i1iIII += "Start training\n"
   iII1i1iIII += "User: %s\n" % ( self . username )
   self . notification ( message = iII1i1iIII )
   if 54 - 54: oOo0O00 + I1I
  ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
  iII1i1iIII = '%s: \n Run #%d\n --- Loss: %f\n --- Learning rate: %f\n' % ( ooOo0IiiIIIiiI1Ii1 , runNo , self . trainLog [ "total_loss" ] [ - 1 ] , self . trainLog [ "learning_rate" ] [ - 1 ] )
  self . notification ( message = iII1i1iIII )
  if 36 - 36: Ii
  self . image_metric ( runNo , self . testLog [ "step" ] , self . testLog [ "task_metric" ] , self . testLog [ "metric_name" ] )
  self . image_total_loss ( runNo , self . trainLog [ "step" ] , self . trainLog [ "total_loss" ] )
  self . image_learning_rate ( runNo , self . trainLog [ "step" ] , self . trainLog [ "learning_rate" ] )
  if 90 - 90: ooo000
  if runNo == runCount - 1 :
   iII1i1iIII = "Total training visual rate."
   self . image_combine_y ( runNo , max ( self . testLog [ "step" ] , self . trainLog [ "step" ] ) , self . trainLog [ "total_loss" ] , self . testLog [ "task_metric" ] , self . trainLog [ "learning_rate" ] , self . testLog [ "metric_name" ] , iII1i1iIII )
   iII1i1iIII = "Ladder Notify Dev:\n"
   iII1i1iIII += "Task {} run end.\n Please check your Logs.\n" . format ( self . task_name )
   self . notification ( message = iII1i1iIII )
   if 65 - 65: Ii + i1iiIII111
 def image_metric ( self , run , data_x , data_y , metric_name ) :
  from matplotlib import pyplot as plt
  if 77 - 77: I1Ii1I1
  if 44 - 44: I11iiIi11i1I * Ii . Ii - OooOoo - i1iiIII111 - I1Ii1I1
  if 36 - 36: Iii1i * IIiIIiIi11I1 . i1I
  if 63 - 63: IiI11Ii111 % I1Ii1I1 . IiIIii11Ii . oOo0O00 / i1i1i1111I / i1iiIII111
  if 10 - 10: Ooo0Ooo % oOo0O00 / ooo000 + ooo000 / OooOoo
  if 64 - 64: ooOOO * ooOOO % IiIIii11Ii / Iii1i
  if 97 - 97: Oo % Ooo0Ooo / i1i1i1111I . i1i1i1111I * oOO . Ooo0Ooo
  if 67 - 67: Ooo0Ooo
  if 59 - 59: I1Ii1I1 / i1I % I1I . oOO - I1I
  if 84 - 84: ooo000
  if 88 - 88: i1
  if 56 - 56: i1 % Ooo0Ooo * Ooo0Ooo
  plt . plot ( data_x , data_y )
  plt . title ( "{} - {} (Run #{})" . format ( self . task_name , metric_name . split ( " " ) [ - 1 ] , run ) )
  plt . xlabel ( "Step" )
  plt . ylabel ( "Metric Value" )
  iII1i1iIII = "\n{} (Run #{})\n{}: {}" . format ( self . task_name , run , metric_name , data_y [ - 1 ] )
  if 70 - 70: ooo000 * OooOoo / Ii
  self . saveImgAndSend ( iII1i1iIII )
  if 65 - 65: Ii / oOO % IiIIii11Ii + i1I - Ooo0Ooo + I11iiIi11i1I
 def image_total_loss ( self , run , data_x , data_y ) :
  from matplotlib import pyplot as plt
  if 74 - 74: Ooo0Ooo % ooOOO . Ooo0Ooo + I1Ii1I1 - I1Ii1I1 * IiI11Ii111
  if 19 - 19: IiI11Ii111 * I11iiIi11i1I - IiI11Ii111
  if 76 - 76: oOo0O00 / Iii1i % Ii
  if 16 - 16: i1iiIII111 . oOO . I1Ii1I1 . I1I * ooo000 - Oo
  if 41 - 41: Ii . ooo000 - Ii
  if 14 - 14: Oo * OooOoo
  if 39 - 39: i1I * IiIIii11Ii - oOO / I1I
  if 64 - 64: OooOoo % IIiIIiIi11I1 % Ooo0Ooo
  if 2 - 2: IiI11Ii111 / oOo0O00
  if 4 - 4: i1 % Oo / i1iiIII111
  if 24 - 24: i1iiIII111 + IiIIii11Ii + IiI11Ii111 - IiIIii11Ii - i1i1i1111I
  plt . plot ( data_x , data_y )
  plt . title ( "{} - Total Loss (Run #{})" . format ( self . task_name , run ) )
  plt . xlabel ( "Step" )
  plt . ylabel ( "Total Loss" )
  if 89 - 89: Iii1i / Ooo0Ooo . I1I / IiI11Ii111 * IiIIii11Ii / IiI11Ii111
  iII1i1iIII = "\n{} (Run #{})\nTotal Loss: {}" . format ( self . task_name , run , data_y [ - 1 ] )
  if 67 - 67: ooOOO / I11iiIi11i1I + i1i1i1111I * OooOoo
  self . saveImgAndSend ( iII1i1iIII )
  if 53 - 53: Oo % oOo0O00 - Iii1i . oOo0O00 - Iii1i + Ii
 def image_learning_rate ( self , run , data_x , data_y ) :
  from matplotlib import pyplot as plt
  if 44 - 44: i1i1i1111I
  if 77 - 77: oOo0O00
  if 65 - 65: i1iiIII111 % IIiIIiIi11I1
  if 4 - 4: ooOOO * i1i1i1111I / iI1iII1I1I1i
  if 4 - 4: i1iiIII111 * I11iiIi11i1I . IiIIii11Ii + ooo000 . Ii
  if 48 - 48: Ii . Ii
  if 96 - 96: Ii / oOo0O00 . i1iiIII111 * OooOoo / oOo0O00 * oOo0O00
  if 11 - 11: I1Ii1I1 + IiIIii11Ii + IiIIii11Ii . I11iiIi11i1I / IiIIii11Ii - IIiIIiIi11I1
  if 12 - 12: IiIIii11Ii - Ooo0Ooo
  if 92 - 92: ooo000 - Ooo0Ooo - Ii . IiIIii11Ii
  if 79 - 79: I11iiIi11i1I - i1 % Oo
  plt . plot ( data_x , data_y )
  plt . title ( "{} - Learning Rate (Run #{})" . format ( self . task_name , run ) )
  plt . xlabel ( "Step" )
  plt . ylabel ( "Learning Rate" )
  iII1i1iIII = "\n{} (Run #{})\nLearning Rate: {}" . format ( self . task_name , run , data_y [ - 1 ] )
  if 69 - 69: I11iiIi11i1I - ooOOO . Ooo0Ooo
  self . saveImgAndSend ( iII1i1iIII )
  if 36 - 36: oOo0O00 * IiI11Ii111 . i1i1i1111I - IIiIIiIi11I1
 def image_combine_y ( self , run , data_x , loss_y , metric_y , lr_y , metric_name , message ) :
  from matplotlib import pyplot as plt
  if 62 - 62: OooOoo - Ii
  if 61 - 61: i1i1i1111I + I1Ii1I1 * Iii1i / OooOoo + IiI11Ii111 + iI1iII1I1I1i
  if 95 - 95: i1i1i1111I % Oo + i1i1i1111I * IiI11Ii111
  if 90 - 90: Ii - oOO - i1i1i1111I / I1Ii1I1 . Oo
  if 6 - 6: i1i1i1111I % I11iiIi11i1I + IiIIii11Ii * I11iiIi11i1I * i1I
  if 88 - 88: I1Ii1I1 * iI1iII1I1I1i . i1 . IIiIIiIi11I1 - oOo0O00
  if 33 - 33: Ii * Iii1i
  if 46 - 46: OooOoo . IiI11Ii111
  if 17 - 17: IiIIii11Ii - i1iiIII111
  if 95 - 95: Oo . ooo000 - OooOoo % I11iiIi11i1I . IIiIIiIi11I1
  if 32 - 32: i1i1i1111I * I1I
  if 70 - 70: IIiIIiIi11I1 - Oo
  if 47 - 47: IiIIii11Ii * IiIIii11Ii
  if 18 - 18: I1I . IiI11Ii111 * I1Ii1I1 - i1iiIII111 + oOO * i1i1i1111I
  if 95 - 95: ooOOO * oOO . i1iiIII111
  if 24 - 24: oOO / I1Ii1I1 % Ooo0Ooo
  iIIi1 , IIIOO = plt . subplots ( figsize = ( 16 , 9 ) )
  ii1i1i1i1i1 = IIIOO . twinx ( )
  O0ii1I11I1 = IIIOO . twinx ( )
  O0OOo0O0 = [ "Total Loss" , metric_name , "Learning Rate" ]
  ii1i1i1i1i1 . spines [ 'right' ] . set_position ( ( 'outward' , 0 ) )
  O0ii1I11I1 . spines [ 'right' ] . set_position ( ( 'outward' , 50 ) )
  Ii1iii11I1 , = IIIOO . plot ( data_x , loss_y , c = 'tab:blue' , label = O0OOo0O0 [ 0 ] )
  II1III , = ii1i1i1i1i1 . plot ( data_x , metric_y , c = 'tab:orange' , label = O0OOo0O0 [ 1 ] )
  I1Oo00O00oO , = O0ii1I11I1 . plot ( data_x , lr_y , c = 'tab:green' , label = O0OOo0O0 [ 2 ] )
  oO00oOooO = [ IIIOO , ii1i1i1i1i1 , O0ii1I11I1 ]
  i1iii1 = [ Ii1iii11I1 , II1III , I1Oo00O00oO ]
  for IiIIiiII in range ( len ( oO00oOooO ) ) :
   if IiIIiiII < 1 :
    oO00oOooO [ IiIIiiII ] . spines [ 'right' ] . set_color ( i1iii1 [ IiIIiiII ] . get_color ( ) )
   else :
    oO00oOooO [ IiIIiiII ] . spines [ 'left' ] . set_color ( i1iii1 [ IiIIiiII ] . get_color ( ) )
   oO00oOooO [ IiIIiiII ] . set_ylabel ( O0OOo0O0 [ IiIIiiII ] , c = i1iii1 [ IiIIiiII ] . get_color ( ) )
   oO00oOooO [ IiIIiiII ] . tick_params ( axis = 'y' , color = i1iii1 [ IiIIiiII ] . get_color ( ) , labelcolor = i1iii1 [ IiIIiiII ] . get_color ( ) )
   oO00oOooO [ IiIIiiII ] . spines [ 'left' ] . set_color ( Ii1iii11I1 . get_color ( ) )
  IIIOO . set_xlabel ( 'step' )
  if 20 - 20: I11iiIi11i1I + ooOOO - Ii - I1I / IiIIii11Ii
  self . saveImgAndSend ( message )
  if 3 - 3: I1Ii1I1
 def saveImgAndSend ( self , message ) :
  from matplotlib import pyplot as plt
  if 80 - 80: IiI11Ii111 % ooo000 * OooOoo % oOO
  if 34 - 34: iI1iII1I1I1i % ooOOO / i1 - Oo % oOO
  if 25 - 25: I1I - ooo000 / Ooo0Ooo / I1I * Oo
  if 47 - 47: i1i1i1111I + Iii1i / ooo000
  if 78 - 78: ooo000 - IiIIii11Ii - I1Ii1I1 * Ooo0Ooo + Oo + Ii
  if 83 - 83: OooOoo % Iii1i * OooOoo / I1Ii1I1 . i1iiIII111
  if 42 - 42: I11iiIi11i1I - i1iiIII111 - i1 . I1Ii1I1 * oOo0O00
  if 38 - 38: Ooo0Ooo % I1Ii1I1 - I11iiIi11i1I - iI1iII1I1I1i - Ii / ooo000
  if 92 - 92: OooOoo - i1iiIII111 - ooOOO + IiIIii11Ii
  plt . grid ( )
  plt . savefig ( "tmp.png" )
  self . notification ( message = message , image_filename = "tmp.png" )
  os . remove ( "tmp.png" )
  plt . clf ( )
  if 70 - 70: I1Ii1I1 % IIiIIiIi11I1 + Ooo0Ooo
class oO0Oo000oO :
 def __init__ ( self , username : str = None , notify : 'User.Notify.Config' = None ) :
  if 67 - 67: oOO / Iii1i % I1Ii1I1
  if 86 - 86: i1I % IIiIIiIi11I1 + i1i1i1111I / ooo000 / OooOoo / i1I
  if 35 - 35: IiI11Ii111 + ooOOO . oOo0O00 . Ooo0Ooo / i1
  if 29 - 29: oOO - I1I + I1I / ooOOO
  if 25 - 25: oOo0O00 . I1I . Ii % i1i1i1111I
  if 3 - 3: I1I * i1I - IiIIii11Ii
  if 18 - 18: Oo
  if 46 - 46: oOO * IIiIIiIi11I1 % oOO . Iii1i % IiI11Ii111
  if 56 - 56: IIiIIiIi11I1 * i1 - I1I - ooo000
  if 88 - 88: i1iiIII111 / i1i1i1111I * ooo000 * Iii1i - Iii1i * Ooo0Ooo
  if 33 - 33: i1I * I1Ii1I1
  if 58 - 58: OooOoo / Iii1i
  if 50 - 50: iI1iII1I1I1i * oOO
  if 96 - 96: Iii1i / iI1iII1I1I1i * ooo000
  self . username = username
  self . notify = { }
  if 80 - 80: i1I / Iii1i . i1I
  for iiIiI1IIIII in IiiIIi11Iii . Types :
   self . notify [ iiIiI1IIIII ] = self . notifyType ( self )
   if 24 - 24: iI1iII1I1I1i % i1I / ooOOO + Ii - ooOOO + oOO
   if 28 - 28: IIiIIiIi11I1 . Ooo0Ooo / OooOoo / i1I % Ii
 @ staticmethod
 def createFromJSON ( obj : Dict [ str , Any ] ) -> 'Train.User' :
  IIII1ii = oO0Oo000oO ( )
  if 74 - 74: Ooo0Ooo * i1i1i1111I / Iii1i / i1 % Iii1i
  if 28 - 28: Ii . i1iiIII111 * ooOOO - I1I
  if 98 - 98: I11iiIi11i1I / ooOOO
  if 93 - 93: I1Ii1I1 / i1i1i1111I
  if 54 - 54: IiI11Ii111 / Iii1i . i1i1i1111I + OooOoo . i1i1i1111I / i1
  if 84 - 84: oOO - Ii * oOO
  if 60 - 60: Ii / I1I + OooOoo % IiI11Ii111 * i1 . I1Ii1I1
  if 58 - 58: ooOOO % Ooo0Ooo * Ooo0Ooo / I1I - I1I
  if 90 - 90: i1iiIII111 - i1I
  if 20 - 20: i1I * oOO
  if 15 - 15: Oo / oOO * iI1iII1I1I1i . Oo + Ii
  if 3 - 3: Ii / ooOOO % IiIIii11Ii / ooOOO % iI1iII1I1I1i % OooOoo
  if 3 - 3: I1Ii1I1 - IIiIIiIi11I1 + Iii1i
  IIII1ii . parseJSON ( obj )
  return IIII1ii
  if 71 - 71: ooo000 - oOO
 def parseJSON ( self , obj : Dict [ str , Any ] ) :
  for ( Ii1I , iiiiIi1IiiIi ) in obj . items ( ) :
   if 55 - 55: i1i1i1111I * oOo0O00
   if 8 - 8: oOO * Ii
   if 80 - 80: IIiIIiIi11I1
   if 56 - 56: i1iiIII111 * IiIIii11Ii
   if 44 - 44: ooOOO % i1I - IIiIIiIi11I1 - Oo + oOo0O00
   if 42 - 42: i1i1i1111I . Ooo0Ooo / I11iiIi11i1I . IIiIIiIi11I1
   if 58 - 58: I1Ii1I1
   if 76 - 76: i1I * Oo * IiIIii11Ii % i1 . I1I
   if 52 - 52: i1I - IIiIIiIi11I1 . i1i1i1111I
   if iiiiIi1IiiIi is None or iiiiIi1IiiIi == "null" or iiiiIi1IiiIi == False :
    setattr ( self , Ii1I , None )
   else :
    if Ii1I == "notify" :
     for I1Iii , i1iIii11II1Ii11 in iiiiIi1IiiIi . items ( ) :
      ooo0o0o = IiiIIi11Iii . Types . parse ( I1Iii )
      self . notify [ ooo0o0o ] . parseFromJSON ( i1iIii11II1Ii11 )
    else :
     setattr ( self , Ii1I , iiiiIi1IiiIi )
     if 42 - 42: i1i1i1111I / OooOoo * i1iiIII111 % Ii
 @ property
 def notifyType ( self ) -> Callable [ ... , 'User.Notify' ] :
  if 9 - 9: I1Ii1I1 * ooOOO % i1i1i1111I - Oo / IiI11Ii111
  if 62 - 62: oOo0O00 / OooOoo + Iii1i
  if 92 - 92: Iii1i - i1 / IIiIIiIi11I1
  if 42 - 42: Ii / Iii1i . I11iiIi11i1I / IiIIii11Ii
  if 12 - 12: IIiIIiIi11I1 / IiI11Ii111 % Ooo0Ooo . IiIIii11Ii + i1i1i1111I
  if 56 - 56: i1 + ooOOO * iI1iII1I1I1i
  if 35 - 35: i1i1i1111I + IiIIii11Ii * IIiIIiIi11I1 - oOO / oOo0O00
  if 38 - 38: IIiIIiIi11I1 - i1
  if 32 - 32: i1 + OooOoo
  if 3 - 3: I1Ii1I1 - ooOOO
  return IiiIIi11Iii
  if 71 - 71: Oo + Ooo0Ooo + ooOOO % IiI11Ii111 - OooOoo
 def __getitem__ ( self , key : 'str' ) -> 'Any' :
  if key == 'username' :
   if 49 - 49: OooOoo + OooOoo - i1I % ooOOO * I11iiIi11i1I / OooOoo
   if 8 - 8: oOO / OooOoo
   if 33 - 33: i1 + i1iiIII111
   if 66 - 66: Ooo0Ooo
   if 42 - 42: I11iiIi11i1I / IiI11Ii111
   if 38 - 38: iI1iII1I1I1i / i1 / i1I % IIiIIiIi11I1 - OooOoo
   if 33 - 33: Iii1i - oOo0O00 . Ii
   if 40 - 40: IiI11Ii111 % i1I % Ooo0Ooo
   if 40 - 40: IiI11Ii111 . i1i1i1111I % Ii - i1
   if 57 - 57: Iii1i % i1iiIII111 . Ii
   if 86 - 86: OooOoo - ooo000 . i1i1i1111I . IiIIii11Ii - ooo000 . i1
   if 29 - 29: IIiIIiIi11I1
   return self . username
  elif key == 'notify' :
   return self . notify
  else :
   raise KeyError ( "'{0}' is not a valid key." . format ( key ) )
   if 28 - 28: OooOoo / i1 + Ooo0Ooo
  return self . notify [ notifyType ]
  if 33 - 33: Iii1i * iI1iII1I1I1i
class O0o0ooOO :
 if 26 - 26: I11iiIi11i1I / Ooo0Ooo + i1I - IIiIIiIi11I1
 if 87 - 87: I11iiIi11i1I + Ooo0Ooo / Iii1i / Iii1i . i1iiIII111
 if 76 - 76: I11iiIi11i1I
 if 51 - 51: Iii1i * IiI11Ii111 + Ooo0Ooo * ooo000 % i1I
 if 54 - 54: i1i1i1111I * i1i1i1111I
 if 57 - 57: i1iiIII111 * Oo
 if 41 - 41: oOo0O00 - i1iiIII111 / oOo0O00 + iI1iII1I1I1i
 def __init__ ( self , location : str , fileName : str , header : List [ str ] = None ) :
  if 51 - 51: Iii1i + i1i1i1111I * i1i1i1111I * I1I - oOO . OooOoo
  if 85 - 85: IiIIii11Ii + i1i1i1111I
  if 88 - 88: i1 + Oo
  if 11 - 11: Iii1i . I11iiIi11i1I . Oo
  if 70 - 70: IiIIii11Ii
  if 80 - 80: Ii
  if 100 - 100: OooOoo . IIiIIiIi11I1 / i1iiIII111 % ooOOO
  if 39 - 39: iI1iII1I1I1i % i1iiIII111
  if 21 - 21: Oo . i1I * i1i1i1111I * Iii1i
  if 30 - 30: IiI11Ii111 % Ii . OooOoo * IiI11Ii111 . IIiIIiIi11I1
  if 63 - 63: i1I % I1Ii1I1 % i1
  if 84 - 84: i1
  if 6 - 6: I11iiIi11i1I . i1iiIII111 / IiI11Ii111 / ooOOO - Ooo0Ooo + ooOOO
  location = str ( location ) ; fileName = str ( fileName ) ;
  header = list ( header ) if header is not None else None
  if 15 - 15: iI1iII1I1I1i + oOO - IiI11Ii111 / Iii1i / oOo0O00
  if 92 - 92: Oo / IIiIIiIi11I1 + oOo0O00 . OooOoo / i1iiIII111
  if not os . path . isdir ( location ) :
   tf . io . gfile . makedirs ( location )
   if 57 - 57: i1i1i1111I % Ii + Oo / Oo / Ooo0Ooo
   if 94 - 94: i1i1i1111I . Ooo0Ooo
  self . _filename = iIiII1iii = location + fileName + ".csv"
  self . _header = header
  self . _logTable = [ ]
  if 75 - 75: iI1iII1I1I1i * i1 + ooOOO * ooOOO
  if 57 - 57: Oo - i1iiIII111 % I1I
  if not os . path . isfile ( iIiII1iii ) :
   with open ( iIiII1iii , 'w' , newline = '' , encoding = 'utf-8-sig' ) as IiI1 :
    II1i11i1 = csv . writer ( IiI1 )
    if header :
     II1i11i1 . writerow ( header )
     if 3 - 3: IiI11Ii111 / oOO / I1I * I11iiIi11i1I - ooOOO . Ii
 def __len__ ( self ) -> int :
  if 36 - 36: i1i1i1111I % Ooo0Ooo % I11iiIi11i1I / i1 % Ii . I1I
  if 70 - 70: iI1iII1I1I1i * i1I + IIiIIiIi11I1
  if 47 - 47: Ooo0Ooo - i1
  if 96 - 96: Ooo0Ooo % oOO - Iii1i
  if 29 - 29: ooo000 - IIiIIiIi11I1
  if 33 - 33: IIiIIiIi11I1 + OooOoo + IIiIIiIi11I1
  if 14 - 14: I1I
  if 2 - 2: IiI11Ii111 - i1i1i1111I
  if 82 - 82: oOo0O00 * IiI11Ii111 / Oo
  if 15 - 15: i1I % oOO . IIiIIiIi11I1
  return self . length
  if 38 - 38: i1i1i1111I
 @ property
 def length ( self ) -> int :
  if 55 - 55: I1I
  if 39 - 39: Ii - i1i1i1111I / iI1iII1I1I1i
  if 13 - 13: ooo000 - Iii1i
  if 22 - 22: I1Ii1I1 . ooOOO
  if 3 - 3: oOo0O00 - Ooo0Ooo * oOo0O00
  if 85 - 85: i1 / I11iiIi11i1I
  if 38 - 38: IiIIii11Ii % i1iiIII111 * iI1iII1I1I1i / I1I % i1i1i1111I
  if 4 - 4: OooOoo * i1i1i1111I * oOo0O00 * IiIIii11Ii * oOO . ooo000
  if 47 - 47: I1I * OooOoo + oOo0O00 . Ooo0Ooo
  if 98 - 98: I1I / Ii
  return len ( self . _logTable )
  if 56 - 56: OooOoo / IIiIIiIi11I1 . IiIIii11Ii
 @ property
 def size ( self ) -> int :
  if 99 - 99: oOo0O00 % IIiIIiIi11I1 / i1iiIII111
  if 82 - 82: IiI11Ii111 - I11iiIi11i1I / I11iiIi11i1I % OooOoo - I1I * oOo0O00
  if 43 - 43: iI1iII1I1I1i + IiI11Ii111 + Oo + IIiIIiIi11I1 % IiI11Ii111 * IiIIii11Ii
  if 55 - 55: Oo * i1I / Ii . iI1iII1I1I1i . iI1iII1I1I1i * oOo0O00
  if 65 - 65: I1Ii1I1
  if 72 - 72: oOO
  if 29 - 29: Oo + oOO . I1I
  if 19 - 19: IiIIii11Ii - OooOoo
  if 23 - 23: oOo0O00 * Ii
  if 82 - 82: Ooo0Ooo + i1i1i1111I / IIiIIiIi11I1 + oOo0O00 + ooo000 / IIiIIiIi11I1
  return 0 if self . length == 0 else len ( self . _logTable [ 0 ] )
  if 9 - 9: Oo . Ooo0Ooo - I1Ii1I1 . iI1iII1I1I1i . ooo000 . Ii
 def __repr__ ( self ) -> str :
  if 79 - 79: I11iiIi11i1I
  if 72 - 72: IIiIIiIi11I1 % I1Ii1I1 + i1iiIII111 % oOO * oOo0O00
  if 13 - 13: ooOOO + IIiIIiIi11I1 % i1i1i1111I % oOo0O00 - IIiIIiIi11I1
  if 13 - 13: ooo000
  if 14 - 14: I1Ii1I1 + oOo0O00
  if 81 - 81: iI1iII1I1I1i
  if 72 - 72: Ii + i1 + IiI11Ii111
  if 34 - 34: i1i1i1111I % I1Ii1I1 + Oo % IIiIIiIi11I1 - i1 * OooOoo
  if 36 - 36: I1Ii1I1 + i1iiIII111 % Iii1i
  if 78 - 78: ooo000 % i1i1i1111I - Ooo0Ooo
  return "<CSV Logger: " + self . length + " rows, " + self . size + " columns>"
  if 79 - 79: oOO . Ooo0Ooo + i1i1i1111I - I11iiIi11i1I / ooOOO + ooo000
 def __bool__ ( self ) -> bool :
  if 94 - 94: Iii1i
  if 56 - 56: i1iiIII111
  if 18 - 18: Ii / IiI11Ii111 - IiIIii11Ii % Oo
  if 24 - 24: Ooo0Ooo + oOo0O00 % I1I - Iii1i - IiIIii11Ii * oOO
  if 14 - 14: Oo / I1Ii1I1 / Ooo0Ooo / Iii1i
  if 96 - 96: Oo / IiI11Ii111 . i1i1i1111I . Iii1i / oOO
  if 64 - 64: ooo000 . I11iiIi11i1I - oOO
  if 50 - 50: oOO * Oo
  if 23 - 23: IiI11Ii111
  if 66 - 66: i1i1i1111I . Ooo0Ooo
  return self . length > 0
  if 74 - 74: Ooo0Ooo % iI1iII1I1I1i
 def log ( self , * rows : List [ Any ] ) :
  if 80 - 80: I1Ii1I1
  if 5 - 5: ooo000 + i1
  if 90 - 90: i1I - Ii * OooOoo + ooo000 % iI1iII1I1I1i % IIiIIiIi11I1
  if 6 - 6: iI1iII1I1I1i
  if 83 - 83: I1I * ooOOO . OooOoo - iI1iII1I1I1i . Oo
  if 62 - 62: i1iiIII111 * i1 - iI1iII1I1I1i
  if 68 - 68: I1I % ooo000 % ooo000 + IiIIii11Ii / oOo0O00 * IIiIIiIi11I1
  if 78 - 78: IiI11Ii111 . i1 / I1I % i1i1i1111I * i1I * Iii1i
  if 5 - 5: i1 * i1I - ooo000
  if 43 - 43: Iii1i + Ooo0Ooo . iI1iII1I1I1i
  for i11I1II11I11I in rows :
   self . _logTable . append ( [ * i11I1II11I11I ] )
   if 24 - 24: IIiIIiIi11I1 - i1 / IiI11Ii111
 def push ( self , * rows : List [ Any ] ) :
  if 9 - 9: IiI11Ii111
  if 59 - 59: i1I * oOo0O00 % i1iiIII111 * i1I
  if 74 - 74: ooo000 - IiIIii11Ii / i1I / Ii / oOO . i1
  if 53 - 53: I1Ii1I1 - Iii1i
  if 57 - 57: IIiIIiIi11I1 . i1I
  if 84 - 84: oOo0O00 - i1iiIII111 / i1iiIII111
  if 74 - 74: OooOoo . I11iiIi11i1I + Iii1i / I1I / I1I / i1iiIII111
  if 31 - 31: OooOoo % i1iiIII111 % i1 * ooOOO
  if 93 - 93: oOo0O00 + i1iiIII111
  if 48 - 48: I1Ii1I1
  self . log ( * rows )
  if 60 - 60: I11iiIi11i1I + ooo000 * IiI11Ii111 . Ooo0Ooo . i1i1i1111I * i1
 def append ( self , * rows : List [ Any ] ) :
  if 99 - 99: ooo000 - i1i1i1111I + I1I . Iii1i - i1 . Oo
  if 47 - 47: oOo0O00 % oOo0O00 . i1iiIII111
  if 40 - 40: oOO . oOo0O00 % ooOOO - Oo + iI1iII1I1I1i
  if 51 - 51: ooOOO % IiIIii11Ii % Ii - IIiIIiIi11I1 % Ii
  if 64 - 64: IiI11Ii111 - IIiIIiIi11I1 / Ii
  if 26 - 26: oOO
  if 35 - 35: Iii1i % IIiIIiIi11I1 % ooo000
  if 2 - 2: i1iiIII111 * i1I . ooo000 / i1 * Ooo0Ooo
  if 52 - 52: I1I * I1I * Ooo0Ooo + I11iiIi11i1I % I1I * i1I
  if 29 - 29: IiIIii11Ii + I1I / IiIIii11Ii
  self . log ( * rows )
  if 51 - 51: IIiIIiIi11I1 + i1I + iI1iII1I1I1i
 def flush ( self ) :
  if 90 - 90: I11iiIi11i1I + oOo0O00 % ooo000 / IIiIIiIi11I1 % I1I
  if 67 - 67: Ooo0Ooo * oOO
  if 64 - 64: oOO - OooOoo % ooOOO + OooOoo
  if 73 - 73: iI1iII1I1I1i + iI1iII1I1I1i
  if 29 - 29: Iii1i . ooOOO % ooo000
  if 48 - 48: oOo0O00 / i1 - Ii
  if 39 - 39: IIiIIiIi11I1
  if len ( self . _logTable ) :
   with open ( self . _filename , 'a' , newline = '' , encoding = 'utf-8-sig' ) as IiI1 :
    II1i11i1 = csv . writer ( IiI1 )
    if 36 - 36: IIiIIiIi11I1 - IiIIii11Ii / ooo000 - i1i1i1111I % IIiIIiIi11I1
    if 70 - 70: I1I
    for OOOo000 in self . _logTable :
     II1i11i1 . writerow ( [ str ( ele ) for ele in OOOo000 ] )
     if 1 - 1: ooo000 . i1i1i1111I + Iii1i
     if 82 - 82: oOo0O00
    self . _logTable = [ ]
    if 69 - 69: ooOOO + i1I * i1I
 def logAndSave ( self , * rows : List [ Any ] ) :
  if 32 - 32: oOO
  if 75 - 75: oOO - Ii / OooOoo * IiI11Ii111 . ooOOO . Ooo0Ooo
  if 89 - 89: ooo000 - iI1iII1I1I1i * oOo0O00
  if 59 - 59: iI1iII1I1I1i
  if 76 - 76: iI1iII1I1I1i . i1iiIII111 . i1i1i1111I . oOO
  if 69 - 69: OooOoo
  if 27 - 27: i1I + iI1iII1I1I1i
  if 27 - 27: I11iiIi11i1I - IiIIii11Ii - IiIIii11Ii + ooo000
  if 61 - 61: Ii
  if 95 - 95: I1Ii1I1 % i1 - ooOOO / Ii % I1Ii1I1 + ooOOO
  self . log ( * rows )
  self . flush ( )
  if 16 - 16: oOo0O00 / i1 * IiIIii11Ii + iI1iII1I1I1i
class Oo00o000 :
 if 14 - 14: Iii1i * OooOoo
 if 42 - 42: iI1iII1I1I1i + ooo000 + i1iiIII111
 if 5 - 5: I1Ii1I1 * oOo0O00
 if 69 - 69: oOO
 if 23 - 23: I1I
 if 73 - 73: i1iiIII111 / Iii1i + i1iiIII111 . ooOOO
 if 25 - 25: IIiIIiIi11I1 / IiI11Ii111 * OooOoo
 def __init__ ( self , typeArg : str , eventInit : Dict [ str , Any ] ) :
  if 77 - 77: ooo000 % Ii + I1Ii1I1 / oOo0O00 + IIiIIiIi11I1 * IiIIii11Ii
  if 89 - 89: Ooo0Ooo
  if 32 - 32: i1I
  if 89 - 89: oOO
  if 27 - 27: I11iiIi11i1I - I1I + OooOoo / i1iiIII111 / IiI11Ii111
  if 35 - 35: Oo / Iii1i
  if 66 - 66: oOO
  if 19 - 19: i1 % iI1iII1I1I1i % Ii * oOo0O00 / i1I . Ooo0Ooo
  if 20 - 20: I1I . ooo000 . I1I * oOo0O00 . Ii / IiIIii11Ii
  if 37 - 37: Ii
  if 48 - 48: I11iiIi11i1I / oOO + IiI11Ii111 - Ii . Ooo0Ooo
  self . _type = typeArg
  self . _defaultPrevented = False
  self . _target = eventInit [ "target" ] if "target" in eventInit else None
  if 70 - 70: IiI11Ii111 / Ii
 @ property
 def defaultPrevented ( self ) :
  if 38 - 38: i1I % I1I + i1I % Ooo0Ooo
  if 78 - 78: IiI11Ii111 . I11iiIi11i1I . IiIIii11Ii + OooOoo - i1i1i1111I
  if 11 - 11: Ooo0Ooo + Oo
  if 22 - 22: IiIIii11Ii
  if 34 - 34: IiI11Ii111 . I11iiIi11i1I
  if 95 - 95: oOo0O00 + ooOOO . i1i1i1111I
  if 26 - 26: IiIIii11Ii
  if 49 - 49: IiI11Ii111
  if 14 - 14: I1I * I11iiIi11i1I . i1iiIII111 / i1iiIII111 * i1i1i1111I . Ii
  if 25 - 25: IiI11Ii111 % IiIIii11Ii % Oo
  return self . _defaultPrevented
  if 75 - 75: OooOoo
 @ property
 def target ( self ) :
  if 10 - 10: I1Ii1I1 % ooo000 . I11iiIi11i1I . IiI11Ii111 - i1I % IiI11Ii111
  if 51 - 51: i1 . I1Ii1I1 * IiIIii11Ii + ooo000 / IiI11Ii111
  if 67 - 67: OooOoo % i1i1i1111I * IiI11Ii111 + I1Ii1I1 + i1
  if 57 - 57: I1Ii1I1 / Ooo0Ooo % i1i1i1111I + i1
  if 47 - 47: I1I + ooOOO . i1iiIII111 / OooOoo
  if 59 - 59: IiIIii11Ii . oOO
  if 71 - 71: i1i1i1111I - Ii % i1iiIII111 + i1 / ooo000 * IiIIii11Ii
  if 51 - 51: I11iiIi11i1I - IiI11Ii111 . IIiIIiIi11I1 + oOo0O00
  if 35 - 35: i1 / ooo000 - i1iiIII111 / iI1iII1I1I1i
  if 17 - 17: i1I
  return self . _target
  if 84 - 84: ooOOO + ooOOO % i1I . oOo0O00 * IiI11Ii111
 @ property
 def type ( self ) :
  if 83 - 83: OooOoo * ooo000
  if 83 - 83: ooo000 . Oo * i1i1i1111I . iI1iII1I1I1i / IiI11Ii111 - I1Ii1I1
  if 32 - 32: I1I . ooOOO * Ii % ooOOO + Oo
  if 3 - 3: i1I * I11iiIi11i1I / OooOoo / i1 - OooOoo
  if 70 - 70: I11iiIi11i1I
  if 47 - 47: i1iiIII111 + Oo + IIiIIiIi11I1 % IIiIIiIi11I1 . IIiIIiIi11I1
  if 81 - 81: i1iiIII111 % i1iiIII111
  if 12 - 12: ooo000 - OooOoo / ooOOO % iI1iII1I1I1i
  if 96 - 96: ooo000 / i1iiIII111 % I1I + OooOoo
  if 72 - 72: IIiIIiIi11I1 + IiI11Ii111 / i1
  return self . _type
  if 74 - 74: Iii1i % i1 % ooOOO + i1I
 def preventDefault ( self ) :
  if 5 - 5: IiI11Ii111 - i1 % I1I * oOO - i1iiIII111
  if 42 - 42: oOo0O00 . Ii / i1 + i1
  if 37 - 37: oOO
  if 97 - 97: I1I % i1 % oOO * I1I
  if 77 - 77: I1I % Iii1i + IiIIii11Ii * i1iiIII111 * Iii1i + Iii1i
  if 27 - 27: I1I / OooOoo . i1 - IiI11Ii111 * i1I + Ooo0Ooo
  if 70 - 70: iI1iII1I1I1i + OooOoo . ooo000
  self . _defaultPrevented = True
  if 96 - 96: Ii / Oo * IiIIii11Ii
class IIoOOooOOo0oO ( Oo00o000 ) :
 if 4 - 4: i1 * ooOOO
 if 29 - 29: oOo0O00
 if 28 - 28: IiIIii11Ii * Oo - IiIIii11Ii % I11iiIi11i1I % IIiIIiIi11I1
 if 26 - 26: OooOoo + OooOoo - I1Ii1I1
 if 82 - 82: Ii . I1I - IIiIIiIi11I1 . ooOOO . IiIIii11Ii * oOo0O00
 if 66 - 66: OooOoo - ooOOO - oOo0O00 * iI1iII1I1I1i
 if 56 - 56: iI1iII1I1I1i * iI1iII1I1I1i + ooo000 + OooOoo - Ooo0Ooo
 def __init__ ( self , typeArg : str , buildEventInit : Dict [ str , Any ] ) :
  if 76 - 76: i1I % Ii . I1I + i1
  if 86 - 86: i1I + iI1iII1I1I1i * IIiIIiIi11I1 / oOO
  if 13 - 13: I1I . oOO * Ii
  if 26 - 26: i1I
  if 81 - 81: iI1iII1I1I1i - ooOOO % oOo0O00 + ooOOO - ooo000 * i1I
  if 11 - 11: OooOoo - IIiIIiIi11I1
  if 48 - 48: oOo0O00 - Ooo0Ooo * oOo0O00 . Ii * ooo000 + Ooo0Ooo
  if 2 - 2: i1iiIII111 + Oo + I11iiIi11i1I + IiIIii11Ii . IiI11Ii111 + Ooo0Ooo
  if 16 - 16: I1I
  if 95 - 95: IiI11Ii111 - IIiIIiIi11I1 - ooo000 * OooOoo % oOO - i1I
  if 93 - 93: IiIIii11Ii + I1Ii1I1 / IiI11Ii111 * I11iiIi11i1I / i1i1i1111I - i1
  if 64 - 64: i1
  if typeArg not in [ "buildstart" , "buildend" ] :
   raise ValueError ( "BuildEvent can only have `buildstart` or `buildend`." )
   if 39 - 39: I1I - I11iiIi11i1I
   if 45 - 45: IiI11Ii111 + Oo / I1I - IIiIIiIi11I1
  super ( ) . __init__ ( typeArg , buildEventInit )
  self . buildNo = buildEventInit [ "buildNo" ] if "buildNo" in buildEventInit else - 1
  self . runNo = buildEventInit [ "runNo" ] if "runNo" in buildEventInit else - 1
  self . cvNo = buildEventInit [ "cvNo" ] if "cvNo" in buildEventInit else - 1
  if 6 - 6: oOo0O00 * i1iiIII111 % I1I % i1iiIII111
class o0Ooo0oo ( Oo00o000 ) :
 if 83 - 83: i1i1i1111I * i1iiIII111 . I1Ii1I1 + Ii + Ooo0Ooo
 if 99 - 99: I1I % i1i1i1111I * IIiIIiIi11I1 . Ooo0Ooo - i1iiIII111
 if 36 - 36: i1iiIII111 . OooOoo / oOO
 if 67 - 67: Oo * iI1iII1I1I1i + ooOOO + i1 + i1i1i1111I
 if 26 - 26: Ii . Oo + oOo0O00 / I11iiIi11i1I + I1I
 if 68 - 68: ooOOO / OooOoo - oOo0O00
 if 20 - 20: i1i1i1111I . iI1iII1I1I1i . I1I . IiIIii11Ii
 def __init__ ( self , typeArg : str , trainEventInit : Dict [ str , Any ] ) :
  if 77 - 77: Ooo0Ooo % I11iiIi11i1I * Ooo0Ooo
  if 12 - 12: IiI11Ii111 . oOo0O00 - i1I
  if 80 - 80: Ii * ooOOO + I1I
  if 90 - 90: oOo0O00 % Ii . I1I
  if 43 - 43: Ooo0Ooo % i1iiIII111 / IiIIii11Ii
  if 23 - 23: Ooo0Ooo / ooo000 / i1i1i1111I * ooOOO - IiI11Ii111
  if 97 - 97: i1iiIII111 % Ooo0Ooo % I1I * i1I
  if 7 - 7: Ooo0Ooo - OooOoo - Ii - I1Ii1I1
  if 23 - 23: Ii * IIiIIiIi11I1 - oOO / i1
  if 28 - 28: i1iiIII111 . Oo + i1 / ooOOO + OooOoo
  if 56 - 56: Ii . oOO
  if 23 - 23: IiI11Ii111 / oOO + I1I . IIiIIiIi11I1 . i1iiIII111
  if typeArg not in [ "trainbuild" , "trainstart" , "trainend" ] :
   raise ValueError ( "BuildEvent can only have `trainbuild`, `trainstart` or `trainend`." )
   if 1 - 1: Iii1i + iI1iII1I1I1i * i1i1i1111I / oOO . I1I - Oo
   if 94 - 94: Oo - oOO + IiI11Ii111
  super ( ) . __init__ ( typeArg , trainEventInit )
  self . buildNo = trainEventInit [ "buildNo" ] if "buildNo" in trainEventInit else - 1
  self . runNo = trainEventInit [ "runNo" ] if "runNo" in trainEventInit else - 1
  self . cvNo = trainEventInit [ "cvNo" ] if "cvNo" in trainEventInit else - 1
  self . buildConfig = trainEventInit [ "buildConfig" ] if "buildConfig" in trainEventInit else None
  if 18 - 18: Ooo0Ooo - i1I . Ii . I1Ii1I1 . IIiIIiIi11I1 / I1I
class O0oO0oOOO0O ( Oo00o000 ) :
 if 82 - 82: iI1iII1I1I1i + Iii1i % I11iiIi11i1I / i1i1i1111I . I1Ii1I1
 if 71 - 71: Oo * oOo0O00 / i1 - oOO % I11iiIi11i1I
 if 69 - 69: IIiIIiIi11I1 % I1I * iI1iII1I1I1i
 if 67 - 67: IIiIIiIi11I1 / I11iiIi11i1I
 if 7 - 7: Oo * ooo000 * oOO . Ooo0Ooo . i1i1i1111I / i1i1i1111I
 if 15 - 15: Ooo0Ooo * oOo0O00 - I1I
 if 6 - 6: I11iiIi11i1I + I11iiIi11i1I * i1i1i1111I
 def __init__ ( self , typeArg : str , stepEventInit : Dict [ str , Any ] ) :
  if 93 - 93: ooOOO
  if 54 - 54: i1iiIII111 - Oo
  if 100 - 100: i1I
  if 9 - 9: IIiIIiIi11I1 - oOo0O00 . i1 . Ooo0Ooo
  if 39 - 39: ooo000
  if 23 - 23: Iii1i - ooo000 / Ooo0Ooo
  if 67 - 67: Iii1i
  if 27 - 27: ooOOO
  if 74 - 74: ooo000 % Ooo0Ooo % IiIIii11Ii
  if 53 - 53: Ii . OooOoo + IiIIii11Ii / oOO
  if 27 - 27: I11iiIi11i1I * Oo / I1I + i1I
  if 21 - 21: IIiIIiIi11I1
  if typeArg not in [ "stepprepare" , "stepstart" , "stepend" ] :
   raise ValueError ( "StepEvent can only have `stepbuild`, `stepstart` or `stepend`." )
   if 92 - 92: Iii1i / IiIIii11Ii + IIiIIiIi11I1 % oOO - OooOoo
   if 12 - 12: I11iiIi11i1I / I1I
  super ( ) . __init__ ( typeArg , stepEventInit )
  self . buildNo = stepEventInit [ "buildNo" ] if "buildNo" in stepEventInit else - 1
  self . runNo = stepEventInit [ "runNo" ] if "runNo" in stepEventInit else - 1
  self . cvNo = stepEventInit [ "cvNo" ] if "cvNo" in stepEventInit else - 1
  self . buildConfig = stepEventInit [ "buildConfig" ] if "buildConfig" in stepEventInit else None
  self . i = stepEventInit [ "i" ] if "i" in stepEventInit else - 1
  self . localStep = stepEventInit [ "localStep" ] if "localStep" in stepEventInit else - 1
  self . globalStep = stepEventInit [ "globalStep" ] if "globalStep" in stepEventInit else - 1
  self . feedDict = stepEventInit [ "feedDict" ] if "feedDict" in stepEventInit else None
  self . totalLoss = stepEventInit [ "totalLoss" ] if "totalLoss" in stepEventInit else None
  self . avgLoss = stepEventInit [ "avgLoss" ] if "avgLoss" in stepEventInit else None
  if 19 - 19: Oo / Ooo0Ooo % IIiIIiIi11I1 + I1I
class oOO0Oo0 ( Oo00o000 ) :
 if 25 - 25: IiIIii11Ii / i1i1i1111I
 if 16 - 16: I1I - ooOOO + IIiIIiIi11I1
 if 36 - 36: I11iiIi11i1I * IiI11Ii111 - i1i1i1111I - ooOOO * Ii
 if 95 - 95: Ii * oOO
 if 42 - 42: I11iiIi11i1I % IiI11Ii111 / i1 % oOo0O00
 if 93 - 93: oOO % i1 * IIiIIiIi11I1
 if 45 - 45: oOO . iI1iII1I1I1i + IIiIIiIi11I1 - iI1iII1I1I1i - oOo0O00 + Oo
 def __init__ ( self , typeArg : str , epochEventInit : Dict [ str , Any ] ) :
  if 64 - 64: oOO % IiI11Ii111
  if 44 - 44: Ii - IIiIIiIi11I1 + iI1iII1I1I1i + OooOoo . oOo0O00
  if 88 - 88: ooOOO / IiIIii11Ii + i1i1i1111I / i1I . IiIIii11Ii
  if 27 - 27: I11iiIi11i1I - i1 . i1i1i1111I
  if 80 - 80: Ooo0Ooo
  if 68 - 68: Iii1i / iI1iII1I1I1i
  if 45 - 45: oOo0O00 + OooOoo + IiIIii11Ii . I1I * oOo0O00
  if 43 - 43: IiIIii11Ii + I1Ii1I1
  if 40 - 40: ooo000 % Iii1i / i1iiIII111 + i1i1i1111I - Iii1i
  if 25 - 25: iI1iII1I1I1i % I1Ii1I1 - oOo0O00 % Ooo0Ooo
  if 52 - 52: i1iiIII111
  if 76 - 76: IiIIii11Ii
  if typeArg not in [ "epochstart" , "epochend" ] :
   raise ValueError ( "EpochEvent can only have `epochstart` or `epochend`." )
   if 20 - 20: IiIIii11Ii + OooOoo - I11iiIi11i1I
   if 29 - 29: I11iiIi11i1I / ooo000 . i1I + i1iiIII111
  super ( ) . __init__ ( typeArg , epochEventInit )
  self . runNo = epochEventInit [ "runNo" ] if "runNo" in epochEventInit else - 1
  self . cvNo = epochEventInit [ "cvNo" ] if "cvNo" in epochEventInit else - 1
  self . buildNo = epochEventInit [ "buildNo" ] if "buildNo" in epochEventInit else - 1
  self . buildConfig = epochEventInit [ "buildConfig" ] if "buildConfig" in epochEventInit else None
  self . i = epochEventInit [ "i" ] if "i" in epochEventInit else - 1
  self . localStep = epochEventInit [ "localStep" ] if "localStep" in epochEventInit else - 1
  self . globalStep = epochEventInit [ "globalStep" ] if "globalStep" in epochEventInit else - 1
  self . inputSources = epochEventInit [ "inputSources" ] if "inputSources" in epochEventInit else None
  if 13 - 13: IiIIii11Ii / oOo0O00
class OoOo0000o :
 if 95 - 95: i1I + Ii - i1 - oOo0O00 * I1I - IiI11Ii111
 if 74 - 74: Oo * OooOoo % IiI11Ii111 * i1I . Iii1i
 if 48 - 48: i1I / IIiIIiIi11I1 . i1i1i1111I / I1I + ooo000
 if 42 - 42: i1 . Iii1i + i1I + ooo000 * IiI11Ii111 * I1Ii1I1
 if 73 - 73: I11iiIi11i1I / Ooo0Ooo * Ooo0Ooo
 if 44 - 44: Iii1i % I1I - IIiIIiIi11I1
 if 44 - 44: Ooo0Ooo - Iii1i * i1
 @ staticmethod
 def parse ( selectionLength : int , rangeStr : str , repeatable : bool = False ) -> 'list[int]' :
  if 69 - 69: Iii1i * ooOOO
  if 43 - 43: Ooo0Ooo * IiIIii11Ii * i1 / i1i1i1111I
  if 12 - 12: i1i1i1111I % i1I / oOO / i1 + OooOoo * Ii
  if 72 - 72: OooOoo
  if 12 - 12: IiIIii11Ii . I1I
  if 78 - 78: Oo + oOO % IiI11Ii111 % i1I
  if 1 - 1: i1i1i1111I + i1i1i1111I / Iii1i
  if 16 - 16: i1i1i1111I + iI1iII1I1I1i - Iii1i % i1iiIII111 % IiIIii11Ii + Iii1i
  if 60 - 60: Iii1i * IiI11Ii111 + I1I - IIiIIiIi11I1 * IiI11Ii111
  if 9 - 9: i1i1i1111I / Ii
  if 82 - 82: i1
  if 94 - 94: ooo000 * Ooo0Ooo / Oo * ooOOO . i1
  if 98 - 98: i1i1i1111I + Ooo0Ooo - i1iiIII111 - IiIIii11Ii * Ooo0Ooo / i1
  if 82 - 82: OooOoo * i1
  if 99 - 99: Oo - i1iiIII111 % Ooo0Ooo - ooo000 / IIiIIiIi11I1 * Ii
  if not OoOo0000o . validate ( selectionLength , rangeStr ) :
   raise ValueError ( "Index range string is not valid." )
   if 47 - 47: IiI11Ii111
  if rangeStr . startswith ( "[" ) and rangeStr . endswith ( "]" ) :
   iII1iiI1 = [ ( ( selectionLength + n ) if n < 0 else n ) for n in [ int ( string . strip ( ) ) for string in rangeStr [ 1 : - 1 ] . split ( "," ) ] if n < selectionLength and n >= - selectionLength ]
   return iII1iiI1 if repeatable else [ * ( set ( iII1iiI1 ) ) ]
  elif ":" in rangeStr :
   O0o0oO0 = [ string . strip ( ) for string in rangeStr . split ( ":" ) ]
   if O0o0oO0 [ 0 ] == "None" or O0o0oO0 [ 0 ] == "" :
    O0o0oO0 [ 0 ] = 0
   if O0o0oO0 [ 1 ] == "None" or O0o0oO0 [ 1 ] == "" :
    O0o0oO0 [ 1 ] = selectionLength
   O0o0oO0 = [ min ( max ( ( ( selectionLength + n ) if n < 0 else n ) , 0 ) , selectionLength ) for n in [ int ( n ) for n in O0o0oO0 ] ]
   o00ooo0 = [ ]
   for IiIIiiII in range ( O0o0oO0 [ 0 ] , O0o0oO0 [ 1 ] ) :
    o00ooo0 . append ( IiIIiiII )
   return o00ooo0
  else :
   iII1iiI1 = [ ( ( selectionLength + n ) if n < 0 else n ) for n in [ int ( string . strip ( ) ) for string in rangeStr . split ( "," ) ] if n < selectionLength and n >= - selectionLength ]
   return iII1iiI1 if repeatable else [ * ( set ( iII1iiI1 ) ) ]
   if 11 - 11: Ii % i1 % i1iiIII111 + IIiIIiIi11I1
 @ staticmethod
 def validate ( selectionLength : int , rangeStr : str ) -> bool :
  if 94 - 94: I1I . Ii . i1 - IiIIii11Ii % OooOoo
  if 2 - 2: I1I % ooOOO
  if 13 - 13: i1iiIII111 / oOO - Iii1i / OooOoo
  if 63 - 63: Iii1i * i1I * oOO - i1 * i1
  if 86 - 86: I11iiIi11i1I - IiIIii11Ii - iI1iII1I1I1i * OooOoo - i1
  if 46 - 46: i1iiIII111
  if 50 - 50: ooo000 + ooOOO - IiI11Ii111 % Ooo0Ooo
  if 3 - 3: IIiIIiIi11I1
  if 96 - 96: ooo000
  if 26 - 26: IiI11Ii111
  if 31 - 31: oOo0O00 . i1i1i1111I - Oo * Iii1i
  if 88 - 88: iI1iII1I1I1i . oOo0O00
  if 67 - 67: IIiIIiIi11I1 % IiIIii11Ii % IiI11Ii111
  if 38 - 38: Iii1i * Oo + I1I / i1 . i1iiIII111 / I1Ii1I1
  if rangeStr . startswith ( "[" ) and rangeStr . endswith ( "]" ) :
   o00ooo0 = [ string . strip ( ) for string in rangeStr [ 1 : - 1 ] . split ( "," ) ]
   return all ( [ re . match ( "[0-9\-]+" , num ) for num in o00ooo0 ] ) and all ( [ ( n < selectionLength and n >= - selectionLength ) for n in [ int ( n ) for n in o00ooo0 ] ] )
  elif ":" in rangeStr :
   o00ooo0 = [ string . strip ( ) for string in rangeStr . split ( ":" ) ]
   return len ( o00ooo0 ) == 2 and all ( [ ( num == "" or num == "None" or re . match ( "[0-9\-]+" , num ) ) for num in o00ooo0 ] )
  else :
   o00ooo0 = [ string . strip ( ) for string in rangeStr . split ( "," ) ]
   return all ( [ re . match ( "[0-9\-]+" , num ) for num in o00ooo0 ] ) and all ( [ ( n < selectionLength and n >= - selectionLength ) for n in [ int ( n ) for n in o00ooo0 ] ] )
   if 41 - 41: i1i1i1111I
 @ staticmethod
 def toIndexer ( rangeStr : str , repeatable : bool = False ) -> Union [ List [ int ] , slice ] :
  if 100 - 100: i1iiIII111 + Iii1i + I1I / I11iiIi11i1I % I11iiIi11i1I + I1Ii1I1
  if 39 - 39: i1iiIII111 % oOo0O00 - Iii1i
  if 2 - 2: oOo0O00
  if 16 - 16: i1iiIII111 * oOO * i1i1i1111I - iI1iII1I1I1i + Iii1i
  if 82 - 82: i1i1i1111I % I1I . IiI11Ii111 . I11iiIi11i1I % Ii / oOO
  if 93 - 93: iI1iII1I1I1i / OooOoo - I1I / i1 * Oo * i1
  if 92 - 92: I1I - oOo0O00 / Ooo0Ooo
  if 100 - 100: ooo000 * i1iiIII111 % IiIIii11Ii - I1I * Iii1i
  if 40 - 40: Ii . Oo + oOo0O00 * IIiIIiIi11I1 - Ii
  if 14 - 14: i1I
  if 7 - 7: ooo000 . IiI11Ii111 . IiIIii11Ii / oOO . I1Ii1I1 + IIiIIiIi11I1
  if 69 - 69: Ii + I1I + Oo % oOo0O00
  if 72 - 72: ooOOO * IIiIIiIi11I1 - IIiIIiIi11I1 / Ooo0Ooo * Ii
  if 6 - 6: Ii / IiI11Ii111
  if rangeStr . startswith ( "[" ) and rangeStr . endswith ( "]" ) :
   if 94 - 94: I1I + i1 % iI1iII1I1I1i % I1Ii1I1
   iII1iiI1 = [ n for n in [ int ( string . strip ( ) ) for string in rangeStr [ 1 : - 1 ] . split ( "," ) ] ]
   return iII1iiI1 if repeatable else [ * ( set ( iII1iiI1 ) ) ]
   if 40 - 40: Ooo0Ooo + I1Ii1I1
  elif ":" in rangeStr :
   if 68 - 68: iI1iII1I1I1i / iI1iII1I1I1i % oOo0O00
   O0o0oO0 = [ string . strip ( ) for string in rangeStr . split ( ":" ) ]
   if 94 - 94: IiIIii11Ii - ooo000 + oOO - Oo
   if 39 - 39: iI1iII1I1I1i . oOo0O00 . i1iiIII111 % oOo0O00
   if O0o0oO0 [ 0 ] == "None" or O0o0oO0 [ 0 ] == "" :
    O0o0oO0 [ 0 ] = None
   else :
    O0o0oO0 [ 0 ] = int ( O0o0oO0 [ 0 ] )
   if O0o0oO0 [ 1 ] == "None" or O0o0oO0 [ 1 ] == "" :
    O0o0oO0 [ 1 ] = None
   else :
    O0o0oO0 [ 1 ] = int ( O0o0oO0 [ 1 ] )
    if 28 - 28: Oo + IiIIii11Ii . IIiIIiIi11I1 % Oo % Ooo0Ooo * OooOoo
    if 62 - 62: Iii1i / I1Ii1I1 + IiIIii11Ii
   return slice ( * O0o0oO0 )
   if 70 - 70: OooOoo + oOo0O00 . i1I
  else :
   if 62 - 62: OooOoo - I1I - OooOoo * ooo000
   iII1iiI1 = [ n for n in [ int ( string . strip ( ) ) for string in rangeStr . split ( "," ) ] ]
   return iII1iiI1 if repeatable else [ * ( set ( iII1iiI1 ) ) ]
   if 11 - 11: IIiIIiIi11I1 % i1i1i1111I . i1 * ooOOO + i1i1i1111I
class O0oO00000000 :
 if 92 - 92: OooOoo * I1I - Oo . ooOOO
 if 97 - 97: Iii1i % ooOOO / i1i1i1111I . i1iiIII111 % IiIIii11Ii
 if 97 - 97: IIiIIiIi11I1 % i1I
 if 47 - 47: IiIIii11Ii + Ii * iI1iII1I1I1i
 if 89 - 89: I11iiIi11i1I % iI1iII1I1I1i / ooo000
 if 28 - 28: oOO
 if 41 - 41: Oo * IIiIIiIi11I1 . I11iiIi11i1I % ooOOO . Oo / ooOOO
 def __init__ ( self ) :
  if 44 - 44: oOo0O00 % IiIIii11Ii + Ii
  if 12 - 12: OooOoo . iI1iII1I1I1i + i1 % oOO
  if 72 - 72: IiI11Ii111 + Oo - I1Ii1I1 * I1I . iI1iII1I1I1i * Ooo0Ooo
  if 25 - 25: Ii - iI1iII1I1I1i / Ooo0Ooo % I1I
  if 34 - 34: IIiIIiIi11I1 / iI1iII1I1I1i * I1Ii1I1 + i1I
  if 46 - 46: Ooo0Ooo
  if 56 - 56: Iii1i * ooo000 - IiI11Ii111 - oOO % Oo
  self . counter = 0
  self . reg_list = [ ]
  self . name_to_reg = { }
  if 75 - 75: oOO . oOo0O00 % Oo + IiIIii11Ii + I1I
 def get_register ( self , layer_name : str ) :
  if 58 - 58: Iii1i + iI1iII1I1I1i . IiIIii11Ii - I1I % Oo + I1I
  if 83 - 83: I1I * i1I + Oo * OooOoo
  if 6 - 6: IIiIIiIi11I1 % IiI11Ii111 - ooOOO * I11iiIi11i1I . I1Ii1I1
  if 41 - 41: Oo + i1i1i1111I + ooo000 + i1i1i1111I % Oo % oOo0O00
  if 24 - 24: oOO / oOo0O00 * oOo0O00
  if 67 - 67: I11iiIi11i1I % oOO - ooo000
  if 27 - 27: i1 . iI1iII1I1I1i
  if 81 - 81: i1i1i1111I / oOO
  if 17 - 17: i1
  if 21 - 21: IIiIIiIi11I1 / i1i1i1111I
  try :
   return self . name_to_reg [ layer_name ]
  except :
   OOO = - 1
   for ooOoooO0OOo , i11I1II11I11I in enumerate ( self . reg_list ) :
    if i11I1II11I11I == 0 :
     OOO = ooOoooO0OOo
     self . name_to_reg [ layer_name ] = 'register_' + str ( OOO )
     self . reg_list [ OOO ] = 1
     break
   if OOO == - 1 :
    self . reg_list . append ( 0 )
    OOO = self . counter
    self . counter += 1
    self . name_to_reg [ layer_name ] = 'register_' + str ( OOO )
    self . reg_list [ OOO ] = 1
   return self . name_to_reg [ layer_name ]
   if 39 - 39: iI1iII1I1I1i % iI1iII1I1I1i
 def new_register ( self , layer_name : str ) :
  if layer_name in self . name_to_reg :
   ooo0oo0O = self . counter
   self . name_to_reg [ layer_name ] = 'register_' + str ( ooo0oo0O )
   return self . name_to_reg [ layer_name ]
   if 86 - 86: i1I % i1iiIII111
 def free_register ( self , layer_name : str ) :
  if 48 - 48: IiIIii11Ii % i1i1i1111I + i1i1i1111I / Oo . Oo - Ooo0Ooo
  if 66 - 66: ooo000 - ooOOO * IIiIIiIi11I1 / i1I / I11iiIi11i1I . oOo0O00
  if 80 - 80: Ooo0Ooo + i1I % i1I
  if 68 - 68: oOo0O00 % IiI11Ii111 - IiI11Ii111 * ooOOO + i1
  if 77 - 77: I11iiIi11i1I . Ooo0Ooo
  if 4 - 4: OooOoo / i1iiIII111 + oOO
  if 22 - 22: I11iiIi11i1I - I11iiIi11i1I + i1iiIII111 . i1 + i1i1i1111I + i1iiIII111
  if 8 - 8: Oo
  if 91 - 91: IIiIIiIi11I1 / IiI11Ii111
  if 19 - 19: IiIIii11Ii / I1Ii1I1 . i1i1i1111I + I1Ii1I1 - I11iiIi11i1I
  try :
   iI1IiI1 = self . name_to_reg . pop ( layer_name )
   OOO = int ( iI1IiI1 . split ( '_' ) [ 1 ] )
   self . reg_list [ OOO ] = 0
  except :
   pass
   if 60 - 60: IiIIii11Ii
class oo0OO00oOoo :
 if 84 - 84: Ooo0Ooo
 if 93 - 93: IIiIIiIi11I1
 if 10 - 10: i1 % IIiIIiIi11I1 % Ii
 if 41 - 41: oOO / Iii1i
 if 41 - 41: ooo000 / Ooo0Ooo / i1iiIII111 + i1iiIII111
 if 100 - 100: i1 / I11iiIi11i1I % i1 . i1iiIII111 - IiI11Ii111
 if 7 - 7: I11iiIi11i1I * i1iiIII111 + I11iiIi11i1I
 @ staticmethod
 def getDateStr ( nowDate : 'datetime.datetime' = datetime . now ( ) , expression : str = "mmdd" , delimiter : str = "" ) -> str :
  if 91 - 91: i1I % IiIIii11Ii % OooOoo + OooOoo
  if 91 - 91: i1i1i1111I - Ii % IIiIIiIi11I1
  if 75 - 75: oOo0O00 / I11iiIi11i1I - I11iiIi11i1I % oOo0O00
  if 98 - 98: oOo0O00
  if 63 - 63: I1Ii1I1 - i1I - Ii
  if 69 - 69: I1Ii1I1 / Oo . iI1iII1I1I1i / I1Ii1I1 . IiI11Ii111 * IIiIIiIi11I1
  if 58 - 58: i1iiIII111 * Oo - I1Ii1I1 . i1iiIII111 - iI1iII1I1I1i
  if 20 - 20: oOo0O00
  if 67 - 67: oOO / IIiIIiIi11I1
  if 80 - 80: I1I . Oo * iI1iII1I1I1i - Oo % i1I
  if 77 - 77: i1 . i1iiIII111 % ooo000
  if 8 - 8: ooo000 % IiIIii11Ii - Ooo0Ooo / Oo / I11iiIi11i1I . I11iiIi11i1I
  if 60 - 60: IiIIii11Ii
  if 98 - 98: IIiIIiIi11I1 . iI1iII1I1I1i . Oo % IIiIIiIi11I1
  if 25 - 25: IIiIIiIi11I1 * OooOoo - i1
  if expression == "mmdd" :
   return '{:%m{delim}%d}' . format ( nowDate , delim = delimiter )
  elif expression == "yyyymmdd" :
   return '{:%Y{delim}%m{delim}%d}' . format ( nowDate , delim = delimiter )
  elif expression == "yymmdd" :
   return '{:%y{delim}%m{delim}%d}' . format ( nowDate , delim = delimiter )
   if 76 - 76: i1I + oOo0O00 * I1I % oOO * ooOOO % Ii
 @ staticmethod
 def getTimeStr ( nowDate : 'datetime.datetime' = datetime . now ( ) , expression : str = "hhmm" , delimiter : str = "" ) -> str :
  if 43 - 43: ooo000
  if 70 - 70: oOo0O00 / IIiIIiIi11I1 * ooo000
  if 53 - 53: oOO % IIiIIiIi11I1
  if 12 - 12: oOO . ooo000 * OooOoo
  if 85 - 85: ooo000 - Ooo0Ooo . Ooo0Ooo % I1I + Iii1i . IiIIii11Ii
  if 34 - 34: I1I / I1I
  if 49 - 49: i1 + IiI11Ii111 - Oo - i1iiIII111
  if 30 - 30: I1Ii1I1 * i1I * IIiIIiIi11I1 . iI1iII1I1I1i
  if 26 - 26: IiIIii11Ii
  if 24 - 24: Ooo0Ooo . oOO
  if 86 - 86: ooOOO * OooOoo * iI1iII1I1I1i - i1iiIII111 % ooo000
  if 30 - 30: Ooo0Ooo + ooOOO - Iii1i
  if 33 - 33: OooOoo / IIiIIiIi11I1 / IiI11Ii111
  if 99 - 99: IiIIii11Ii + iI1iII1I1I1i
  if 36 - 36: i1I + Iii1i / ooo000 / oOo0O00 . ooOOO
  if expression == "mmss" :
   return '{:%M{delim}%S}' . format ( nowDate , delim = delimiter )
  elif expression == "hhmm" :
   return '{:%H{delim}%M}' . format ( nowDate , delim = delimiter )
  elif expression == "hhmmss" :
   return '{:%H{delim}%M{delim}%S}' . format ( nowDate , delim = delimiter )
  elif expression == "mmsstttttt" :
   return '{:%M{delim}%S{delim}%f}' . format ( nowDate , delim = delimiter )
  elif expression == "tttttt" :
   return '{:%f}' . format ( nowDate , delim = delimiter )
   if 87 - 87: Oo % i1i1i1111I + IiI11Ii111 * i1 . Ooo0Ooo * IiIIii11Ii
 @ staticmethod
 def getDateTimeStr ( nowDate : 'datetime.datetime' = datetime . now ( ) , dateExpr : str = "mmdd" , timeExpr : str = "hhmm" , dateDelimiter : str = "" , timeDelimiter : str = "" , dateTimeDelimiter : str = " " ) -> str :
  if 33 - 33: i1i1i1111I / ooOOO - Ii - ooOOO . Ooo0Ooo * I1Ii1I1
  if 35 - 35: IiI11Ii111 / i1I / I11iiIi11i1I - IIiIIiIi11I1 - i1I * I1I
  if 75 - 75: I1Ii1I1
  if 60 - 60: i1I * i1I
  if 67 - 67: i1 * ooo000
  if 14 - 14: iI1iII1I1I1i - IiI11Ii111 / iI1iII1I1I1i
  if 72 - 72: Ooo0Ooo % i1iiIII111 . Iii1i . IiI11Ii111
  if 14 - 14: i1iiIII111 / i1i1i1111I - I11iiIi11i1I / IiI11Ii111 / IiIIii11Ii
  if 42 - 42: OooOoo . ooo000 . i1I
  if 76 - 76: Ooo0Ooo
  if 60 - 60: Oo - IiI11Ii111
  if 57 - 57: IiIIii11Ii + ooo000 * IiI11Ii111
  if 64 - 64: IIiIIiIi11I1 * IiI11Ii111 . oOO / I1Ii1I1
  if 8 - 8: Ii / iI1iII1I1I1i * oOO . IiIIii11Ii / ooOOO / IiIIii11Ii
  if 72 - 72: ooOOO % IIiIIiIi11I1 * IiI11Ii111 * oOO - I1I
  if 55 - 55: I11iiIi11i1I
  if 24 - 24: Iii1i - ooo000 . I1Ii1I1
  if 1 - 1: Ii
  return oo0OO00oOoo . getDateStr ( nowDate , dateExpr , dateDelimiter ) + dateTimeDelimiter + oo0OO00oOoo . getTimeStr ( nowDate , timeExpr , timeDelimiter )
  if 35 - 35: I1I - IiI11Ii111 - Oo % ooo000
 class Recorder :
  if 90 - 90: i1iiIII111 . Oo + ooo000
  if 16 - 16: oOo0O00 % Iii1i . I1I / IIiIIiIi11I1
  if 72 - 72: i1i1i1111I . Ii + oOo0O00 . ooo000 - ooOOO
  if 72 - 72: Iii1i / I1Ii1I1
  if 58 - 58: I1I / IIiIIiIi11I1 - I11iiIi11i1I
  if 5 - 5: Oo
  if 73 - 73: i1I % i1iiIII111 - I11iiIi11i1I % IIiIIiIi11I1
  def __init__ ( self ) :
   if 94 - 94: OooOoo . Iii1i
   if 48 - 48: IIiIIiIi11I1 * iI1iII1I1I1i / Ii % Ii % i1I + Ooo0Ooo
   if 16 - 16: I11iiIi11i1I . i1I * iI1iII1I1I1i / ooOOO . Ooo0Ooo
   if 44 - 44: I11iiIi11i1I / i1 - ooOOO - oOo0O00 - IiI11Ii111 % i1i1i1111I
   if 58 - 58: Ooo0Ooo
   if 63 - 63: I1I + I1I % oOo0O00
   if 89 - 89: oOO % oOO / Iii1i . i1iiIII111
   if 87 - 87: Iii1i + I1Ii1I1 . IIiIIiIi11I1 % OooOoo
   self . _now = self . _initial = datetime . now ( )
   if 57 - 57: i1I * Ii % IiI11Ii111 . I1Ii1I1
  def log ( self ) -> float :
   if 75 - 75: ooo000 - ooo000 . i1iiIII111 * Ooo0Ooo + ooOOO / IiIIii11Ii
   if 8 - 8: ooOOO % I1Ii1I1
   if 94 - 94: i1I - IiIIii11Ii - I1Ii1I1
   if 95 - 95: iI1iII1I1I1i . Oo % I1Ii1I1 / oOO
   if 62 - 62: IiIIii11Ii * Ooo0Ooo - I1Ii1I1 % Oo
   if 33 - 33: Ii - i1iiIII111 + IiI11Ii111 . Ooo0Ooo
   if 86 - 86: ooo000 * I1I - Ooo0Ooo
   if 92 - 92: ooo000 % Oo + Ooo0Ooo % I1I * Oo % I11iiIi11i1I
   if 62 - 62: Iii1i * Oo
   if 28 - 28: Ii - IIiIIiIi11I1 / ooOOO % I1I + IIiIIiIi11I1
   self . _now = ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
   return ( ooOo0IiiIIIiiI1Ii1 - self . _initial ) . total_seconds ( )
   if 54 - 54: ooo000 / I11iiIi11i1I % Ooo0Ooo % iI1iII1I1I1i
  def logAndRestart ( self ) -> float :
   if 92 - 92: IiI11Ii111 / ooo000
   if 41 - 41: ooOOO
   if 67 - 67: oOO + oOO - ooo000 * OooOoo - oOo0O00
   if 95 - 95: I1Ii1I1
   if 9 - 9: Ii + ooOOO
   if 46 - 46: IiIIii11Ii + IiIIii11Ii + IIiIIiIi11I1
   if 11 - 11: Iii1i * i1 % Ooo0Ooo
   if 69 - 69: I1I * OooOoo - I1Ii1I1
   if 72 - 72: i1i1i1111I . ooOOO - i1 % Iii1i + I1Ii1I1
   if 34 - 34: ooOOO
   O0Oo0 = self . _initial
   self . _now = self . _initial = ooOo0IiiIIIiiI1Ii1 = datetime . now ( )
   return ( ooOo0IiiIIIiiI1Ii1 - O0Oo0 ) . total_seconds ( )
   if 6 - 6: OooOoo % I11iiIi11i1I - oOO / IiIIii11Ii . IiI11Ii111 + OooOoo
  @ property
  def now ( self ) -> 'datetime.datetime' :
   if 1 - 1: OooOoo - IiI11Ii111 + Oo / oOO + Oo * Ii
   if 7 - 7: i1 + I1I * oOO / IIiIIiIi11I1 * I1I + Oo
   if 65 - 65: IiI11Ii111 * I11iiIi11i1I - i1iiIII111 % i1i1i1111I - IiIIii11Ii * oOo0O00
   if 72 - 72: i1I
   if 92 - 92: i1iiIII111 / I1Ii1I1 - Iii1i % I11iiIi11i1I * i1i1i1111I . ooOOO
   if 20 - 20: IiIIii11Ii . OooOoo / ooOOO
   if 36 - 36: oOo0O00 * iI1iII1I1I1i
   if 97 - 97: OooOoo * ooo000 + OooOoo % IiI11Ii111 - oOO * IIiIIiIi11I1
   if 1 - 1: Iii1i
   if 67 - 67: oOo0O00 . I1Ii1I1 % Ii
   return self . _now
   if 99 - 99: i1 * Iii1i * I1I + OooOoo + i1i1i1111I
  @ property
  def initial ( self ) -> 'datetime.datetime' :
   if 26 - 26: IiIIii11Ii - ooo000 / iI1iII1I1I1i
   if 44 - 44: I1I / iI1iII1I1I1i % I11iiIi11i1I % i1iiIII111 / ooo000
   if 95 - 95: oOo0O00 . i1i1i1111I . oOO - I1Ii1I1
   if 44 - 44: I1Ii1I1
   if 55 - 55: i1iiIII111 * i1i1i1111I * IiIIii11Ii / Ii * ooOOO
   if 87 - 87: oOo0O00 - I11iiIi11i1I . Ii / i1i1i1111I % i1i1i1111I . I1I
   if 95 - 95: Oo + Oo
   if 79 - 79: ooOOO % I1Ii1I1 % Oo
   if 57 - 57: i1I + oOo0O00 * OooOoo
   if 4 - 4: i1i1i1111I + Oo * oOO - i1i1i1111I + I1Ii1I1 - Ii
   return self . _initial
   if 56 - 56: IiIIii11Ii * ooo000
def O0oO ( obj : Any ) -> str :
 if 99 - 99: I11iiIi11i1I
 if 56 - 56: Oo
 if 83 - 83: i1i1i1111I % IiI11Ii111 - OooOoo + Iii1i . i1I
 if 14 - 14: Ooo0Ooo * ooOOO + Ii
 if 99 - 99: IiI11Ii111 . ooOOO
 if 49 - 49: ooo000 * I11iiIi11i1I % Oo - Oo
 if 91 - 91: ooOOO . I11iiIi11i1I . Iii1i
 if 34 - 34: I1I
 if 57 - 57: ooOOO * ooOOO * I1Ii1I1
 if 30 - 30: Oo . ooOOO
 if 89 - 89: oOo0O00 / I1I
 if 3 - 3: i1iiIII111 / oOO / i1i1i1111I + ooOOO
 if 97 - 97: IiIIii11Ii
 return obj . __class__ . __name__
 if 26 - 26: IIiIIiIi11I1
def i111iIIiIIi ( obj : Any ) -> Any :
 if 88 - 88: I1I % Iii1i . Oo / IIiIIiIi11I1 + i1i1i1111I % Iii1i
 if 27 - 27: i1i1i1111I - oOO * ooOOO / ooo000 / Ooo0Ooo
 if 16 - 16: Oo * Iii1i / IiIIii11Ii
 if 55 - 55: Oo
 if 58 - 58: i1 / i1i1i1111I % ooo000 + Ii % IiIIii11Ii . IIiIIiIi11I1
 if 34 - 34: ooOOO * iI1iII1I1I1i . i1I - i1i1i1111I . Ooo0Ooo
 if 47 - 47: iI1iII1I1I1i . ooo000 - i1i1i1111I
 if 44 - 44: IiI11Ii111 + i1 / Iii1i
 if 25 - 25: I1I / i1i1i1111I / IiIIii11Ii - IIiIIiIi11I1 . IiIIii11Ii
 if 23 - 23: iI1iII1I1I1i . i1i1i1111I . oOO
 if 19 - 19: Iii1i - IiIIii11Ii % IiI11Ii111 + Iii1i
 if 7 - 7: iI1iII1I1I1i + Oo % OooOoo / IiIIii11Ii
 if 3 - 3: ooOOO + Iii1i - ooOOO + OooOoo + Ooo0Ooo % I1Ii1I1
 return "NaN" if ( obj is np . nan or obj != obj ) else obj
 if 47 - 47: oOO . IIiIIiIi11I1 + I11iiIi11i1I - Ooo0Ooo / I11iiIi11i1I
def I1iiiiii ( listObj : List [ Any ] ) -> List [ Any ] :
 if 73 - 73: Oo / i1I / oOO + Iii1i
 if 19 - 19: i1
 if 79 - 79: IiI11Ii111 % Ii . oOo0O00
 if 68 - 68: ooo000 * OooOoo + I1I . oOo0O00
 if 94 - 94: IiIIii11Ii - i1i1i1111I + IIiIIiIi11I1 * I1Ii1I1 * Ii / i1
 if 4 - 4: oOO
 if 91 - 91: I1I
 if 59 - 59: I11iiIi11i1I . oOO - IiI11Ii111 . IiI11Ii111
 if 38 - 38: ooOOO - Ooo0Ooo - IiI11Ii111 - Oo
 if 97 - 97: Iii1i % i1i1i1111I
 if 11 - 11: Oo % Oo + IiI11Ii111
 if 23 - 23: Iii1i * IIiIIiIi11I1 / OooOoo % IIiIIiIi11I1
 if 48 - 48: Iii1i - i1 % i1i1i1111I % IiI11Ii111 - I1Ii1I1 / IIiIIiIi11I1
 return [ ( "NaN" if ( obj is np . nan or obj != obj ) else obj ) for obj in listObj ]
 if 63 - 63: I11iiIi11i1I / IiIIii11Ii / IiI11Ii111 + iI1iII1I1I1i
def Ii1II11 ( nparray : Any ) -> Any :
 if 79 - 79: iI1iII1I1I1i
 if 15 - 15: Ii * Ooo0Ooo * i1iiIII111 + I1I . oOo0O00 . IIiIIiIi11I1
 if 85 - 85: Ooo0Ooo . Ooo0Ooo - i1iiIII111 / I11iiIi11i1I
 if 31 - 31: i1I * I1I
 if 6 - 6: IiIIii11Ii - I1I
 if 47 - 47: i1iiIII111 / iI1iII1I1I1i + IiIIii11Ii
 if 3 - 3: ooo000 / OooOoo % IiI11Ii111 - ooOOO * Iii1i
 if 71 - 71: Oo % IiIIii11Ii / i1i1i1111I * i1 + I11iiIi11i1I / i1
 if 10 - 10: i1i1i1111I
 if 6 - 6: i1iiIII111 . IIiIIiIi11I1 * Ii . Ii / Ii
 if 1 - 1: Oo
 if 65 - 65: IIiIIiIi11I1
 if 49 - 49: OooOoo * Ii + I11iiIi11i1I
 return np . where ( np . isnan ( nparray ) , None , nparray ) if np . issubdtype ( nparray . dtype , np . float64 ) else nparray
 if 82 - 82: i1iiIII111
def Oooo0OooOOOo0 ( obj : Dict [ str , Any ] , prioritizedKeys : List [ str ] ) -> List [ str ] :
 if 84 - 84: Oo * Ii / oOO % i1I . IIiIIiIi11I1 . iI1iII1I1I1i
 if 51 - 51: I1Ii1I1
 if 66 - 66: IiIIii11Ii . IiIIii11Ii + I11iiIi11i1I
 if 6 - 6: I11iiIi11i1I . OooOoo - i1 / i1I / oOo0O00
 if 55 - 55: ooo000 - I11iiIi11i1I * oOo0O00 - i1I
 if 51 - 51: i1i1i1111I * ooOOO + IiIIii11Ii . OooOoo - IIiIIiIi11I1 / oOo0O00
 if 71 - 71: i1i1i1111I / Iii1i / I11iiIi11i1I
 if 3 - 3: I1I / I11iiIi11i1I + i1 * I1I / IiI11Ii111 % I1I
 if 11 - 11: i1i1i1111I - iI1iII1I1I1i / oOo0O00 % IiI11Ii111
 if 67 - 67: Ii
 if 90 - 90: oOo0O00 / I1Ii1I1 / I1I * I11iiIi11i1I
 if 95 - 95: Ooo0Ooo % oOO . i1I
 if 15 - 15: i1i1i1111I - Ooo0Ooo
 if 7 - 7: I1I
 if 2 - 2: I11iiIi11i1I * ooOOO - I1I
 iiIIiIII1 : Set [ str ] = set ( obj . keys ( ) )
 if 72 - 72: oOo0O00
 if 72 - 72: Iii1i
 i11io000 : List [ str ] = [ ]
 for I11IO000 in prioritizedKeys :
  if I11IO000 in iiIIiIII1 :
   i11io000 . append ( I11IO000 )
   iiIIiIII1 . remove ( I11IO000 )
   if 68 - 68: oOO . I1Ii1I1 * ooo000 - oOo0O00 / oOo0O00 / Iii1i
   if 36 - 36: i1 % oOo0O00 + Ooo0Ooo
 return [ * i11io000 , * iiIIiIII1 ]
 if 93 - 93: i1i1i1111I
class NOMTrainer ( object ) :
 def __init__ ( self , config = { } ) :
  self . layerProfiles_obj = { }
  if 21 - 21: I11iiIi11i1I - i1iiIII111 % IIiIIiIi11I1 - i1 + i1iiIII111 % i1I
  if 15 - 15: Oo * I11iiIi11i1I / oOO . Ooo0Ooo . Iii1i
  if 4 - 4: iI1iII1I1I1i + ooOOO
  if 53 - 53: I1Ii1I1 % i1I * Iii1i
  if 32 - 32: IiIIii11Ii . iI1iII1I1I1i % i1
  if 98 - 98: oOO + Iii1i * I1Ii1I1 / Ooo0Ooo . OooOoo
  self . tp_idx = [ ]
  self . config = { }
  I111II1ii1iii = { 'layerProfiles' : 'modelNodes' , 'trainingProfiles' : 'buildConfigs' }
  for oo00OOOO , O0Oo00o0 in config . items ( ) :
   try :
    oo00OOOO = I111II1ii1iii [ oo00OOOO ]
   except :
    pass
   self . config [ oo00OOOO ] = O0Oo00o0
   if 33 - 33: i1I / i1i1i1111I
  del config
  if 3 - 3: i1I * I1Ii1I1 % ooOOO - I11iiIi11i1I * IIiIIiIi11I1
  self . sources_idx = 0
  self . sources_idx_list = [ ]
  self . input_idx = 0
  self . var = { }
  if 92 - 92: Iii1i
  self . train = None
  if 86 - 86: IiIIii11Ii % Ii - ooo000
 @ staticmethod
 def createFromFile ( fileName : str ) -> 'NOMTrainer' :
  if 86 - 86: ooo000 - I1I - i1i1i1111I
  if 68 - 68: IiI11Ii111 . OooOoo . I1Ii1I1 - Iii1i / ooOOO
  if 45 - 45: IiIIii11Ii + I1I
  if 19 - 19: oOo0O00 + IiI11Ii111 . Ii
  if 65 - 65: i1iiIII111 - IiIIii11Ii - ooOOO - i1 / i1I . Ii
  if 55 - 55: Oo . Oo - i1 + Iii1i % ooo000
  if 13 - 13: I11iiIi11i1I
  if 35 - 35: Iii1i . Ii - oOo0O00 + I1Ii1I1
  if 29 - 29: I1I . iI1iII1I1I1i * ooOOO * i1 * IIiIIiIi11I1 / i1iiIII111
  if 100 - 100: iI1iII1I1I1i . Oo
  if 60 - 60: IiIIii11Ii . iI1iII1I1I1i / oOo0O00 . IIiIIiIi11I1 % OooOoo + IIiIIiIi11I1
  if 4 - 4: i1iiIII111 - Oo + Ii * oOO * i1iiIII111 - oOo0O00
  if 63 - 63: IiIIii11Ii . IiI11Ii111 / i1iiIII111 % Ooo0Ooo / i1I + i1
  with open ( fileName , 'r' , encoding = "utf-8" ) as f :
   iIiI1IiI = f . read ( )
  IIIiiiii = NOMTrainer ( )
  IIIiiiii . train = iII11 . createFromJSONString ( iIiI1IiI )
  return IIIiiiii
  if 81 - 81: Ooo0Ooo - I1Ii1I1
 @ staticmethod
 def createFromJSONString_old ( jsonStr : str ) -> 'NOMTrainer' :
  if 5 - 5: iI1iII1I1I1i
  if 73 - 73: I11iiIi11i1I
  if 7 - 7: IiI11Ii111 . I1I * i1 * i1i1i1111I + ooo000
  if 65 - 65: Ooo0Ooo - iI1iII1I1I1i / I11iiIi11i1I + i1i1i1111I / I11iiIi11i1I
  if 66 - 66: oOo0O00 . i1
  if 98 - 98: iI1iII1I1I1i
  if 67 - 67: Iii1i / ooo000 - I1Ii1I1 . ooo000
  if 72 - 72: i1i1i1111I
  if 25 - 25: iI1iII1I1I1i - Oo / iI1iII1I1I1i * i1I
  if 25 - 25: oOo0O00 / IiI11Ii111 * Ii + IIiIIiIi11I1 / ooOOO + iI1iII1I1I1i
  if 56 - 56: i1I + Oo . oOO + IiIIii11Ii + I1Ii1I1
  if 15 - 15: Oo - I1Ii1I1 / OooOoo / Ooo0Ooo
  if 69 - 69: oOO - OooOoo - Ii / Oo - i1i1i1111I + I1I
  return NOMTrainer ( json . loads ( jsonStr ) )
  if 12 - 12: I1Ii1I1 + Ii / IiI11Ii111 - i1i1i1111I
 @ staticmethod
 def createFromJSONString ( jsonStr : str ) -> 'NOMTrainer' :
  if 63 - 63: Oo
  if 3 - 3: Ii / Iii1i + IiI11Ii111 - Ooo0Ooo
  if 29 - 29: oOO + oOO / oOO % I1I / I1I
  if 38 - 38: oOO
  if 57 - 57: oOo0O00 . IiIIii11Ii / IIiIIiIi11I1
  if 15 - 15: Oo . i1 - Oo
  if 4 - 4: Ii / Oo + oOo0O00 * Ooo0Ooo
  if 78 - 78: IiI11Ii111 * IiI11Ii111
  if 17 - 17: Iii1i + ooo000 . IIiIIiIi11I1
  if 33 - 33: I1Ii1I1
  if 18 - 18: oOO * ooOOO - Iii1i
  if 78 - 78: ooOOO % OooOoo
  if 43 - 43: IIiIIiIi11I1
  IIIiiiii = NOMTrainer ( )
  IIIiiiii . train = iII11 . createFromJSONString ( jsonStr )
  return IIIiiiii
  if 37 - 37: Ii / oOo0O00
 def run ( self , mode = 'execute2' ) :
  if 61 - 61: ooOOO / i1iiIII111 + I1I - oOO
  if 58 - 58: Oo / IiIIii11Ii - Ii
  if 6 - 6: Ooo0Ooo * i1I % Ooo0Ooo
  if 52 - 52: OooOoo - oOo0O00 * oOO % ooo000 . IiI11Ii111 / i1
  if 64 - 64: ooOOO - ooo000 + oOo0O00 * OooOoo . i1i1i1111I
  if 21 - 21: i1I % i1I
  if 58 - 58: IiI11Ii111
  if 70 - 70: iI1iII1I1I1i % I1I . oOo0O00 + I1I % i1i1i1111I - Oo
  if 99 - 99: IiI11Ii111 - IiI11Ii111 + i1i1i1111I + OooOoo / iI1iII1I1I1i
  if 93 - 93: IiI11Ii111 . I1I
  if mode == 'execute' :
   O0o0OOoOOOO = sys . argv [ 0 ]
   IIIIi = len ( O0o0OOoOOOO )
   O0O0oOo00oO0 = O0o0OOoOOOO [ 0 : ( max ( O0o0OOoOOOO . rfind ( '/' ) , 0 ) or IIIIi ) ] [ 0 : ( max ( O0o0OOoOOOO . rfind ( '\\' ) , 0 ) or 0 ) ]
   if len ( O0O0oOo00oO0 ) : os . chdir ( O0O0oOo00oO0 )
   self . get_sources ( )
   self . get_config ( )
   self . get_train_object ( )
   self . get_layerProfiles ( )
   self . var [ 'train' ] . keras_fullModelTrain ( )
  elif mode == "execute2" :
   self . train . keras_fullModelTrain2 ( )
   if 31 - 31: Oo . oOo0O00 * IiI11Ii111 - i1I
 def name_to_object ( self , name ) :
  if 38 - 38: IiI11Ii111 + i1iiIII111 + IiI11Ii111 * Ii + ooOOO % Oo
  if 68 - 68: Iii1i
  if 64 - 64: Iii1i
  if 14 - 14: I1Ii1I1 . ooo000
  if 8 - 8: oOo0O00 / i1 + OooOoo . i1i1i1111I
  if 12 - 12: I11iiIi11i1I - I11iiIi11i1I - i1
  if 72 - 72: Iii1i % i1i1i1111I % IiIIii11Ii
  if 72 - 72: Ooo0Ooo . Ooo0Ooo . Ooo0Ooo / iI1iII1I1I1i . IIiIIiIi11I1 - i1
  if 89 - 89: oOO + I1Ii1I1 / oOo0O00 . IIiIIiIi11I1 - oOo0O00 . IiIIii11Ii
  if 33 - 33: oOo0O00 * Ii + ooOOO % IiIIii11Ii % IIiIIiIi11I1 - oOO
  try :
   return self . obj_dict [ name ] ( )
  except :
   print ( 'Object name not exist' )
   exit ( )
   if 22 - 22: I1I - i1 + ooo000 . ooOOO / iI1iII1I1I1i . i1
 def get_sources ( self ) :
  if 85 - 85: Ii - IiIIii11Ii - i1I
  if 64 - 64: I11iiIi11i1I % I11iiIi11i1I
  if 84 - 84: iI1iII1I1I1i % oOO / Ooo0Ooo
  if 65 - 65: IiIIii11Ii + ooOOO
  if 68 - 68: I1Ii1I1 - i1i1i1111I
  if 21 - 21: IIiIIiIi11I1 / Iii1i - Iii1i
  if 29 - 29: Ii % i1i1i1111I . ooo000 * OooOoo * OooOoo
  for Iii1IiIiIII1 in self . config [ 'sources' ] :
   if Iii1IiIiIII1 [ '_instanceClass' ] in [ I1ooOoO0OooO . Table . value , I1ooOoO0OooO . CSV . value , I1ooOoO0OooO . CSV . TXT ] :
    if 44 - 44: i1iiIII111 / Ii / IiIIii11Ii / IiIIii11Ii + iI1iII1I1I1i * i1I
    if Iii1IiIiIII1 [ '_instanceClass' ] == I1ooOoO0OooO . Table . value :
     self . var [ 'source' + str ( self . sources_idx ) ] = I1ii11II11 . Table ( )
    else :
     if 82 - 82: oOo0O00 % OooOoo * oOo0O00
     self . var [ 'source' + str ( self . sources_idx ) ] = I1ii11II11 . CSV ( Iii1IiIiIII1 [ '_path' ] , encoding = Iii1IiIiIII1 [ 'encoding' ] )
     if 17 - 17: oOO + I11iiIi11i1I
     if 58 - 58: Ooo0Ooo / i1iiIII111
    oOo0O0oOoO = [ 'colConfigs' , 'dppNodes' , '_oriData' , 'ele' , 'epochSize' ]
    Ii1IiiiIi = { }
    for iIiI1IiI in ( Iii1IiIiIII1 [ 'colConfigs' ] if "colConfigs" in Iii1IiIiIII1 else Iii1IiIiIII1 [ 'dppNodes' ] ) :
     oo00OOOO , O0Oo00o0 = iIiI1IiI [ 0 ] , iIiI1IiI [ 1 ]
     iIIiI1IiIi11I = OO0O0 . createFromJSON ( O0Oo00o0 )
     Ii1IiiiIi [ oo00OOOO ] = iIIiI1IiIi11I
     if 66 - 66: IiIIii11Ii - Ooo0Ooo
    if Iii1IiIiIII1 [ '_instanceClass' ] == I1ooOoO0OooO . Table . value :
     ii1iI1i = np . array ( Iii1IiIiIII1 [ '_oriData' ] )
     setattr ( self . var [ 'source' + str ( self . sources_idx ) ] , '_oriData' , ii1iI1i )
     if 5 - 5: I11iiIi11i1I - Iii1i % IiIIii11Ii * iI1iII1I1I1i
     if 4 - 4: OooOoo
    setattr ( self . var [ 'source' + str ( self . sources_idx ) ] , 'dppNodes' , Ii1IiiiIi )
    for oo00OOOO , O0Oo00o0 in Iii1IiIiIII1 . items ( ) :
     if oo00OOOO not in oOo0O0oOoO :
      setattr ( self . var [ 'source' + str ( self . sources_idx ) ] , oo00OOOO , O0Oo00o0 )
      if 86 - 86: I11iiIi11i1I . i1i1i1111I % i1I - ooo000
      if 34 - 34: IiI11Ii111
    for ( ooOO00o , IiiiI11 ) in self . var [ 'source' + str ( self . sources_idx ) ] . colConfigs . items ( ) :
     if isinstance ( IiiiI11 , OO0O0 . Columns ) or isinstance ( IiiiI11 , OO0O0 . TXT ) :
      for iIiI1iIiiI in IiiiI11 . transformations :
       self . var [ 'source' + str ( self . sources_idx ) ] . setTransform ( sourceDppKey = ooOO00o , cols = iIiI1iIiiI [ "cols" ] , scaleType = iIiI1iIiiI [ "scaleType" ] )
      for i1iI1Iiiii in IiiiI11 . circular :
       self . var [ 'source' + str ( self . sources_idx ) ] . setCircularOutput ( sourceDppKey = ooOO00o , cols = i1iI1Iiiii [ "cols" ] , minV = i1iI1Iiiii [ "min" ] , maxV = i1iI1Iiiii [ "max" ] )
       if 58 - 58: OooOoo - iI1iII1I1I1i / oOO / IiI11Ii111 % oOO
    self . var [ 'source' + str ( self . sources_idx ) ] . _testRatio /= 100
   elif Iii1IiIiIII1 [ '_instanceClass' ] == I1ooOoO0OooO . Image . value :
    oOo0O0oOoO = [ 'colConfigs' , 'dppNodes' , '_sourceType' , 'coreDataDir' , 'ele' ]
    self . var [ 'source' + str ( self . sources_idx ) ] = I1ii11II11 . Image ( sourceType = Iii1IiIiIII1 [ '_sourceType' ] , coreDataDir = Iii1IiIiIII1 [ 'coreDataDir' ] )
    Ii1IiiiIi = { }
    if 92 - 92: IiIIii11Ii / Oo * IiI11Ii111 % IIiIIiIi11I1
    for iIiI1IiI in ( Iii1IiIiIII1 [ 'colConfigs' ] if "colConfigs" in Iii1IiIiIII1 else Iii1IiIiIII1 [ 'dppNodes' ] ) :
     oo00OOOO , O0Oo00o0 = iIiI1IiI [ 0 ] , iIiI1IiI [ 1 ]
     iIIiI1IiIi11I = OO0O0 . createFromJSON ( O0Oo00o0 )
     Ii1IiiiIi [ oo00OOOO ] = iIIiI1IiIi11I
    setattr ( self . var [ 'source' + str ( self . sources_idx ) ] , 'dppNodes' , Ii1IiiiIi )
    if 61 - 61: I1I - i1I - Oo
    for oo00OOOO , O0Oo00o0 in Iii1IiIiIII1 . items ( ) :
     if oo00OOOO not in oOo0O0oOoO :
      setattr ( self . var [ 'source' + str ( self . sources_idx ) ] , oo00OOOO , O0Oo00o0 )
      if 40 - 40: Iii1i / I1Ii1I1 * i1 - I1I / IiI11Ii111
    self . var [ 'source' + str ( self . sources_idx ) ] . _prepareItr ( )
   else :
    continue
    if 20 - 20: oOo0O00 % ooo000
   if Iii1IiIiIII1 [ '_instanceClass' ] in [ I1ooOoO0OooO . Table . value , I1ooOoO0OooO . CSV . value , I1ooOoO0OooO . TXT . value ] :
    self . var [ 'testSource' + str ( self . sources_idx ) ] = self . var [ 'source' + str ( self . sources_idx ) ] . splitTestDataset ( test = self . var [ 'source' + str ( self . sources_idx ) ] . _testRatio , shuffle = self . var [ 'source' + str ( self . sources_idx ) ] . shuffle )
    if 83 - 83: Iii1i * oOO
   else :
    self . var [ 'testSource' + str ( self . sources_idx ) ] = self . var [ 'source' + str ( self . sources_idx ) ] . copyConfigAsNewSource ( training = False )
    self . var [ 'testSource' + str ( self . sources_idx ) ] . _prepareItr ( )
   self . sources_idx_list . append ( self . sources_idx )
   self . sources_idx += 1
   if 26 - 26: ooo000 * ooOOO . I1Ii1I1 * Iii1i % Ii
 def get_config ( self ) :
  if 70 - 70: ooo000 . iI1iII1I1I1i + ooo000 % ooOOO . IiIIii11Ii + I1I
  if 42 - 42: I1Ii1I1 . ooOOO
  if 27 - 27: I1Ii1I1 + i1I
  if 41 - 41: iI1iII1I1I1i . IiI11Ii111 + oOo0O00 - IiIIii11Ii + i1
  if 67 - 67: IiI11Ii111 / Iii1i
  if 72 - 72: IIiIIiIi11I1 - I1I * oOo0O00 . I1Ii1I1 . ooOOO
  if 77 - 77: oOo0O00
  for ooOoooO0OOo , IIIi11iII1i in enumerate ( self . config [ 'buildConfigs' ] ) :
   self . tp_idx . append ( ooOoooO0OOo )
   self . var [ 'config' + str ( ooOoooO0OOo ) ] = iII11 . BuildConfig . createFromJSON ( IIIi11iII1i )
   if 69 - 69: Oo - IiIIii11Ii + IiI11Ii111 % i1 + I1I % I11iiIi11i1I
 def get_train_object ( self ) :
  if 41 - 41: Iii1i % oOO . i1i1i1111I - i1iiIII111 . Ooo0Ooo . oOo0O00
  if 42 - 42: I11iiIi11i1I . I1I
  if 44 - 44: Iii1i * IIiIIiIi11I1 % I11iiIi11i1I % Ii + I1Ii1I1
  if 10 - 10: Ii
  if 78 - 78: i1I
  if 73 - 73: OooOoo % OooOoo
  if 40 - 40: ooOOO / Ii . Ii * ooo000
  if len ( self . sources_idx_list ) :
   if len ( self . sources_idx_list ) == 1 :
    IIi11 = self . var [ 'source%d' % ( self . sources_idx_list [ 0 ] ) ]
    I1i1 = self . var [ 'testSource%d' % ( self . sources_idx_list [ 0 ] ) ]
    oOoO0 = self . var [ 'config0' ]
   else :
    IIi11 = [ self . var [ 'source%d' % x ] for x in self . sources_idx_list ]
    I1i1 = [ self . var [ 'testSource%d' % x ] for x in self . sources_idx_list ]
    oOoO0 = [ self . var [ 'config%d' % x ] for x in self . tp_idx ]
    if 22 - 22: Ooo0Ooo - IIiIIiIi11I1 / IIiIIiIi11I1 . ooo000
   self . var [ 'train' ] = iII11 ( oo0OO00oOoo . getDateTimeStr ( ) ,
 source = IIi11 ,
 testSource = I1i1 ,
 buildConfig = oOoO0 ,
 folder = self . config [ 'folder' ] ,
 restorePath = self . config [ 'restorePath' ] ,
 device = self . config [ 'device' ] ,
 logFreq = float ( self . config [ 'logFreq' ] ) ,
 saveFreq = float ( self . config [ 'saveFreq' ] ) ,
 testFreq = float ( self . config [ 'testFreq' ] ) ,
 traceFreq = float ( self . config [ 'traceFreq' ] ) ,
 visualTestFreq = float ( self . config [ 'visualTestFreq' ] ) ,
 weightLogFreq = float ( self . config [ 'weightLogFreq' ] ) ,
 filterFreq = float ( self . config [ 'filterFreq' ] ) ,
 traceRecord = self . config [ 'traceRecord' ] ,
 visualRecord = self . config [ 'visualRecord' ] )
   if 61 - 61: oOo0O00 * Ooo0Ooo / ooOOO % I11iiIi11i1I
   if 64 - 64: ooOOO
   if 71 - 71: i1 . I11iiIi11i1I + ooOOO % OooOoo
   if 19 - 19: oOo0O00 . I1I . i1i1i1111I
   if 30 - 30: i1 + I11iiIi11i1I * oOO
   if 65 - 65: i1I % Iii1i % iI1iII1I1I1i + i1 * i1 * iI1iII1I1I1i
   if 59 - 59: ooOOO - iI1iII1I1I1i * iI1iII1I1I1i - I1Ii1I1
   if 60 - 60: Oo + Ii
   if 58 - 58: oOO
   if 34 - 34: IiI11Ii111
   if 41 - 41: Ooo0Ooo + IiI11Ii111
   if 4 - 4: ooOOO / I11iiIi11i1I + i1i1i1111I - oOo0O00 * Ooo0Ooo * IiIIii11Ii
   if 96 - 96: I1Ii1I1 . i1i1i1111I
   if 65 - 65: Ooo0Ooo
   if 69 - 69: iI1iII1I1I1i * OooOoo / ooOOO
   if 93 - 93: oOO - Ooo0Ooo
   if 75 - 75: ooo000 . I1I / i1iiIII111 - I1Ii1I1 + oOO - i1
   if 32 - 32: iI1iII1I1I1i + i1i1i1111I / i1 % Oo
   if 53 - 53: IIiIIiIi11I1 / i1I . i1
   if 84 - 84: oOO
   if 62 - 62: OooOoo + Ooo0Ooo * IiIIii11Ii + Ooo0Ooo
   if 6 - 6: i1i1i1111I
   if 44 - 44: ooo000 / Ooo0Ooo + Oo + IiI11Ii111 + i1I % I11iiIi11i1I
   if 41 - 41: I1Ii1I1
   if 96 - 96: oOO + IiI11Ii111
   if 41 - 41: i1iiIII111
   if 5 - 5: I1Ii1I1 + I11iiIi11i1I % Ooo0Ooo
   if 8 - 8: IIiIIiIi11I1 . Ooo0Ooo
   if 93 - 93: OooOoo
   if 9 - 9: Oo / ooOOO / IIiIIiIi11I1 + Oo / ooo000
   if 5 - 5: Iii1i + Iii1i % i1 % Ooo0Ooo
   if 82 - 82: IiIIii11Ii % IIiIIiIi11I1 % i1iiIII111 . ooOOO - Ooo0Ooo + ooo000
   if 17 - 17: oOO - Iii1i . Iii1i + Ooo0Ooo % oOo0O00
   if 45 - 45: I11iiIi11i1I % i1i1i1111I
   if 81 - 81: OooOoo
   if 51 - 51: oOO % iI1iII1I1I1i
   if 45 - 45: OooOoo - I1Ii1I1
   if 76 - 76: iI1iII1I1I1i - iI1iII1I1I1i - I11iiIi11i1I * IiI11Ii111 + Oo
   if 87 - 87: Ooo0Ooo / I1Ii1I1 . IiI11Ii111 / ooo000 % i1i1i1111I
   if 27 - 27: Oo - Oo / i1i1i1111I * oOo0O00 - I1Ii1I1
   if 70 - 70: I11iiIi11i1I . Oo . ooOOO + i1 - oOo0O00 % oOO
   if 28 - 28: I1Ii1I1 * Ooo0Ooo
   if 79 - 79: i1 * i1i1i1111I
   if 47 - 47: oOo0O00
   if 81 - 81: Ooo0Ooo
   if 37 - 37: ooOOO % i1i1i1111I % i1i1i1111I - oOo0O00 + ooOOO
   if 34 - 34: i1iiIII111
   if 88 - 88: ooOOO - iI1iII1I1I1i - I1Ii1I1 % OooOoo / Iii1i
   if 15 - 15: OooOoo
   if 59 - 59: I1Ii1I1
   if 79 - 79: I1Ii1I1 + Ooo0Ooo - i1i1i1111I
   if 6 - 6: IiI11Ii111 - ooOOO - oOO * i1i1i1111I
   if 44 - 44: ooOOO + Ii * iI1iII1I1I1i / ooOOO
   if 83 - 83: I1Ii1I1 % IiIIii11Ii
   if 78 - 78: Oo + iI1iII1I1I1i % I1Ii1I1 / ooOOO - I1I
   if 18 - 18: oOO . i1I + ooo000 / I1I
   if 37 - 37: ooo000 + Oo - I11iiIi11i1I
   if 21 - 21: Ooo0Ooo
   if 2 - 2: Iii1i * oOo0O00 - ooo000 % IiI11Ii111 * IIiIIiIi11I1
   if 8 - 8: ooo000 * iI1iII1I1I1i
   if 82 - 82: i1iiIII111 . ooo000
   if 5 - 5: iI1iII1I1I1i . i1i1i1111I * I11iiIi11i1I . IiIIii11Ii + IIiIIiIi11I1
   if 72 - 72: oOo0O00 . iI1iII1I1I1i . Iii1i + Ooo0Ooo * IIiIIiIi11I1
   if 85 - 85: ooo000 * IIiIIiIi11I1 % I1I
   if 52 - 52: Ii * i1iiIII111 % i1I
   if 16 - 16: IiI11Ii111 % I11iiIi11i1I / i1
   if 92 - 92: OooOoo / IiI11Ii111 + I1I - Ooo0Ooo - oOO
   if 24 - 24: IIiIIiIi11I1 / Ooo0Ooo - ooo000 + IIiIIiIi11I1 - iI1iII1I1I1i * IiI11Ii111
   if 21 - 21: OooOoo
   if 69 - 69: OooOoo / oOO + Oo
   if 25 - 25: oOo0O00 % Iii1i + Ii . Iii1i - Iii1i + i1iiIII111
   if 10 - 10: Ii - Iii1i % I11iiIi11i1I . OooOoo
   if 60 - 60: i1iiIII111 * oOO . IiI11Ii111 - oOO - I1Ii1I1
   if 18 - 18: i1i1i1111I - Iii1i / Ii / i1 / I1I
   if 35 - 35: Iii1i % iI1iII1I1I1i * IIiIIiIi11I1 - I11iiIi11i1I + oOo0O00 - i1i1i1111I
   if 82 - 82: OooOoo
   if 27 - 27: ooOOO
   if 60 - 60: oOO - Ooo0Ooo - ooo000 - IiI11Ii111 * I1Ii1I1 / i1I
   if 45 - 45: Ooo0Ooo . OooOoo % I11iiIi11i1I
   if 27 - 27: ooOOO
   if 11 - 11: IIiIIiIi11I1 . ooOOO / i1iiIII111
   if 69 - 69: Iii1i % I1Ii1I1
   if 63 - 63: i1I + i1i1i1111I / i1 + ooo000 . ooo000
   if 74 - 74: I1I % i1iiIII111 % I1Ii1I1
   if 10 - 10: i1i1i1111I + Ii % OooOoo
   if 73 - 73: Ooo0Ooo + OooOoo - I1I % ooOOO - Ii . Ooo0Ooo
   if 39 - 39: iI1iII1I1I1i
   if 90 - 90: Iii1i % Ooo0Ooo - Ii % oOo0O00 / I1Ii1I1
   if 35 - 35: Ii % i1
   if 68 - 68: Oo - iI1iII1I1I1i - IIiIIiIi11I1 % Iii1i . Ooo0Ooo . IiI11Ii111
   if 2 - 2: i1iiIII111 % oOO + iI1iII1I1I1i - Oo
   if 24 - 24: IIiIIiIi11I1 - I1Ii1I1 % Iii1i - i1 + IIiIIiIi11I1 % Oo
   if 51 - 51: oOo0O00 / iI1iII1I1I1i
   if 31 - 31: Ii
   if 13 - 13: I11iiIi11i1I * i1
   if 82 - 82: oOo0O00 / Iii1i / IiI11Ii111
   if 90 - 90: OooOoo - IiI11Ii111 / IIiIIiIi11I1 - ooo000 . iI1iII1I1I1i
   if 41 - 41: i1 . I11iiIi11i1I - I11iiIi11i1I - ooo000 + Iii1i
   if 74 - 74: i1I . I1I - oOO
   if 24 - 24: i1I + I11iiIi11i1I
   if 39 - 39: ooo000 * I1I
   if 20 - 20: i1I - IiI11Ii111 % I1I % oOo0O00 % oOo0O00
   if 92 - 92: Oo
   if 98 - 98: iI1iII1I1I1i / I1Ii1I1 % IiIIii11Ii . i1iiIII111 + I1Ii1I1 . I1I
   if 56 - 56: ooOOO
   if 62 - 62: i1iiIII111 / i1iiIII111 + i1i1i1111I - i1iiIII111
   if 32 - 32: i1iiIII111 % I11iiIi11i1I + Oo / i1I / Ii
   if 53 - 53: IIiIIiIi11I1 . OooOoo
   if 17 - 17: i1iiIII111 . i1I - I1Ii1I1 / i1 * Oo
   if 92 - 92: I1I
   if 48 - 48: i1iiIII111 + OooOoo . I1I
   if 96 - 96: Iii1i
   if 52 - 52: Oo . i1i1i1111I % i1i1i1111I
   if 3 - 3: I11iiIi11i1I / IiI11Ii111
   if 69 - 69: I1Ii1I1 % I1Ii1I1
   if 26 - 26: i1iiIII111 - I1I * oOo0O00 / i1i1i1111I / I1Ii1I1 / i1i1i1111I
   if 53 - 53: i1 % ooo000
   if 83 - 83: i1iiIII111 + IiI11Ii111
   if 65 - 65: Oo
   if 3 - 3: i1i1i1111I - ooOOO
   if 86 - 86: Ooo0Ooo
   if 33 - 33: IiIIii11Ii * ooo000 . I11iiIi11i1I . I1Ii1I1
   if 58 - 58: i1iiIII111 % I1I - IiI11Ii111 / I11iiIi11i1I + IiIIii11Ii % i1I
   if 72 - 72: I1I + oOO * Oo
   if 19 - 19: Iii1i * I11iiIi11i1I + I11iiIi11i1I . ooo000 . Ii + Ii
   if 18 - 18: i1I . Iii1i - i1i1i1111I / oOO . I11iiIi11i1I % i1i1i1111I
   if 2 - 2: Ooo0Ooo
   if 29 - 29: i1iiIII111 + Ii % oOo0O00 + I1Ii1I1 * oOO + I1Ii1I1
   if 25 - 25: IiIIii11Ii + IiIIii11Ii
   if 49 - 49: I1Ii1I1 * oOo0O00 + iI1iII1I1I1i . I11iiIi11i1I + oOo0O00 * oOo0O00
   if 64 - 64: Oo / i1 * Ii - IiI11Ii111 / OooOoo
   if 4 - 4: ooOOO * oOO
   if 24 - 24: Oo
   if 79 - 79: Ooo0Ooo
   if 8 - 8: Iii1i * IIiIIiIi11I1 + Iii1i * i1I + i1 - Ooo0Ooo
   if 72 - 72: IiIIii11Ii . i1I . i1i1i1111I
   if 85 - 85: oOo0O00 . oOO - oOO
   if 28 - 28: ooo000 - i1 + oOo0O00 + I1I - i1 - IiI11Ii111
   if 11 - 11: i1iiIII111 . iI1iII1I1I1i / IiI11Ii111 + i1 - I11iiIi11i1I
   if 77 - 77: i1i1i1111I % IiIIii11Ii - OooOoo - iI1iII1I1I1i
   if 82 - 82: i1i1i1111I * Oo
   if 39 - 39: Ooo0Ooo / I11iiIi11i1I + iI1iII1I1I1i - ooOOO % Ooo0Ooo
   if 57 - 57: IiIIii11Ii * ooo000
   if 13 - 13: I11iiIi11i1I / oOO + Oo . IIiIIiIi11I1 / i1 * ooOOO
   if 90 - 90: oOO
   if 10 - 10: IiIIii11Ii / ooOOO . I1I * Ii
   if 76 - 76: i1I
   if 77 - 77: I11iiIi11i1I + I1I / ooo000 - Oo
   if 90 - 90: IiIIii11Ii - Oo
   if 49 - 49: i1iiIII111 + OooOoo / I1Ii1I1 . ooo000 . i1 % ooOOO
   if 44 - 44: ooOOO - Ooo0Ooo % IIiIIiIi11I1
   if 57 - 57: I11iiIi11i1I / Ooo0Ooo
   if 95 - 95: ooo000 * IiIIii11Ii / IiIIii11Ii + OooOoo * i1I / IiI11Ii111
   if 84 - 84: i1i1i1111I . oOO / IiIIii11Ii * i1iiIII111
   if 92 - 92: I1I % ooo000 % IiI11Ii111 . iI1iII1I1I1i / ooo000
   if 24 - 24: IIiIIiIi11I1 / IiI11Ii111
   if 74 - 74: I11iiIi11i1I . oOO % IiI11Ii111
   if 69 - 69: i1iiIII111 / OooOoo
   if 52 - 52: ooOOO . Ii * IiI11Ii111 . I11iiIi11i1I / iI1iII1I1I1i
   if 81 - 81: ooo000 + I1Ii1I1 - i1iiIII111 % oOO % i1
   if 38 - 38: OooOoo
   if 31 - 31: Ii - IIiIIiIi11I1
   if 57 - 57: i1 - IiI11Ii111
   if 62 - 62: IiIIii11Ii - oOO
   if 23 - 23: IIiIIiIi11I1 / i1iiIII111 * IIiIIiIi11I1 + Ii / ooOOO - OooOoo
   if 96 - 96: I1Ii1I1 + i1I / iI1iII1I1I1i + oOO - IiI11Ii111 + Oo
   if 18 - 18: i1i1i1111I + I1I
   if 92 - 92: ooOOO % IiIIii11Ii / i1iiIII111 . i1i1i1111I . ooOOO
   if 4 - 4: Ii / Ii . IiIIii11Ii
   if 14 - 14: i1 % i1iiIII111 * Iii1i / Oo
   if 99 - 99: I1I * iI1iII1I1I1i
   if 60 - 60: oOo0O00 + IiI11Ii111 % IiIIii11Ii * oOO / Ooo0Ooo
   if 88 - 88: I1Ii1I1 * Ii
   if 94 - 94: IiIIii11Ii / Iii1i * Iii1i + oOo0O00 . OooOoo % I1Ii1I1
# dd678faae9ac167bc83abf78e5cb2f3f0688d3a3
