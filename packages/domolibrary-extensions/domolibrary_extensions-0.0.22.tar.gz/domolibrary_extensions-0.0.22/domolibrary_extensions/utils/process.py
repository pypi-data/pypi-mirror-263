# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/utils/process.ipynb.

# %% auto 0
__all__ = ['ProcessMessage', 'ProcessResponse', 'ProcessLogs', 'ProcessFunction_Error', 'ProcessFunction_ResponseTypeError',
           'process_function_sync', 'process_function']

# %% ../../nbs/utils/process.ipynb 2
from dataclasses import dataclass, field
from typing import Any, Callable, List
from functools import wraps

import httpx

import domolibrary_extensions.client as dec

# %% ../../nbs/utils/process.ipynb 5
@dataclass
class ProcessMessage:
    stage: str  # description of the stage of a process
    message: str = "init"  # outcome
    is_success: bool = False

    """class for logging a stage of a process"""

    def to_json(self):
        return self.__dict__


@dataclass
class ProcessResponse:
    function_name: str
    id: str  # identify a set of log entries

    message: List[ProcessMessage] = field(
        default_factory=lambda: []
    )  # capture intermediate steps of the process_function
    response: Any = field(
        repr=False, default=None
    )  # final object to return from the process_function
    is_success: bool = False

    """Response class for handling logging of a process function.
    Accumulates messages as the process unfolds
    """

    def to_json(self) -> List[dict]:
        columns = ["function_name", "stage", "id", "is_success", "message", "response"]
        s = [{**self.__dict__, **msg.to_json()} for msg in self.message]

        return [{col: obj[col] for col in columns} for obj in s]

    def add_message(self, message: ProcessMessage):
        self.message.append(message)

    def __eq__(self, other):
        if not isinstance(other, ProcessResponse):
            return False

        return self.id == other.id


@dataclass
class ProcessLogs:
    """process logs are the complete logs of an entire process or script"""

    logs: List[ProcessResponse] = field(default_factory=lambda: [])

    def add_response(self, res: ProcessResponse):
        if res not in self.logs:
            self.logs.append(res)

        return self.logs

    def to_json(self) -> List[dict]:
        return [message for log in self.logs for message in log.to_json()]

# %% ../../nbs/utils/process.ipynb 6
class ProcessFunction_Error(Exception):
    """base class for capturing errors within a process function"""

    def __init__(
        self, process: ProcessResponse, message: ProcessMessage, location=None
    ):

        e = f"ðŸ’€ | {process.function_name } | {process.id} | {message.stage} - {message.message}"

        if location:
            e = f"{e} | in {location}"

        super().__init__(e)

# %% ../../nbs/utils/process.ipynb 7
class ProcessFunction_ResponseTypeError(TypeError):
    """a function wrapped in `process_function` must return ResponseProcess class"""

    def __init__(self, result):
        super().__init__(
            f"Expected function to return an instance of ResponseProcess got {type(result)} instead.  Refactor function to return ResponseGetData class"
        )


def process_function_sync(func: Callable[..., Any]) -> Callable[..., Any]:
    """
    Decorator for synchronous route functions to ensure they receive certain arguments.
    If these arguments are not provided, default values are used.

    Args:
        func (Callable[..., Any]): The function to decorate.

    Returns:
        Callable[..., Any]: The decorated function.

    The decorated function takes the following arguments:
        *args (Any): Positional arguments for the decorated function.
        auth : dec.Auth
        log: Logs
        debug_api (bool, optional): Whether to debug the API. Defaults to False.
        session (httpx.AsyncClient, optional): The HTTPX client session. Defaults to None.
        **kwargs (Any): Additional keyword arguments for the decorated function.

    The decorated function must return ResponseProcess
    """

    @wraps(func)
    def wrapper(
        *args: Any,
        auth: dec.Auth,
        session: httpx.AsyncClient,
        debug_api: bool,
        logs: ProcessLogs,
        **kwargs: Any,
    ) -> Any:
        result = func(
            *args,
            auth=auth,
            debug_api=debug_api,
            session=session,
            logs=logs,
            **kwargs,
        )

        if not isinstance(result, ProcessResponse):
            raise ProcessFunction_ResponseTypeError(result)

        return result

    return wrapper


def process_function(func: Callable[..., Any]) -> Callable[..., Any]:
    """
    Decorator for async route functions to ensure they receive certain arguments.
    If these arguments are not provided, default values are used.

    Args:
        func (Callable[..., Any]): The function to decorate.

    Returns:
        Callable[..., Any]: The decorated function.

    The decorated function takes the following arguments:
        *args (Any): Positional arguments for the decorated function
        auth : dec.Auth
        log: Logs
        debug_api (bool, optional): Whether to debug the API. Defaults to False.
        session (httpx.AsyncClient, optional): The HTTPX client session. Defaults to None.
        **kwargs (Any): Additional keyword arguments for the decorated function.

    The decorated function must return ResponseProcess
    """

    @wraps(func)
    async def wrapper(
        *args: Any,
        auth: dec.Auth,
        session: httpx.AsyncClient,
        debug_api: bool,
        logs: ProcessLogs,
        **kwargs: Any,
    ) -> Any:
        result = await func(
            *args,
            auth=auth,
            debug_api=debug_api,
            session=session,
            logs=logs,
            **kwargs,
        )

        if not isinstance(result, ProcessResponse):
            raise ProcessFunction_ResponseTypeError(result)

        return result

    return wrapper
