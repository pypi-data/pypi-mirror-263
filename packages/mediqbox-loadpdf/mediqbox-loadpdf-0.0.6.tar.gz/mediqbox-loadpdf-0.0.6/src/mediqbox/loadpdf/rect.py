from fitz import Rect, Matrix, Identity, Point
from typing import Optional

def manhattan_distance(
    r0: Rect,
    r1: Rect
) -> bool:
  """Calculate Manhattan distance between r1 and r2"""
  x_distance = max(0, max(r0.x0, r1.x0) - min(r0.x1, r1.x1))
  y_distance = max(0, max(r0.y0, r1.y0) - min(r0.y1, r1.y1))

  return x_distance + y_distance

def intersect(
    r0: Rect,
    r1: Rect
) -> bool:
  return not(r0.x1 <= r1.x0 or r1.x1 <= r0.x0 or
             r0.y1 <= r1.y0 or r1.y1 <= r0.y0)

def get_bounding_rect(
    rects: list[Rect]
) -> Optional[Rect]:
  if not len(rects):
    return None
  
  r0 = rects.pop(0)
  while len(rects):
    r1 = rects.pop(0)
    r0 = Rect(
      min(r0.x0, r1.x0), min(r0.y0, r1.y0),
      max(r0.x1, r1.x1), max(r0.y1, r1.y1))
    
  return r0
  
def find_least_bounding_rects(
    rects: list[Rect],
    merging_distance: float = 0.0
) -> list[Rect]:
  bounding_rects: list[Rect] = []

  for r in rects:
    no_intersection = False
    while not no_intersection:
      no_intersection = True
      for i in range(len(bounding_rects)):
        cr = bounding_rects[i]
        if manhattan_distance(r, cr) <= merging_distance:
          no_intersection = False
          r = get_bounding_rect([r, cr])
          bounding_rects.pop(i)
          break
    bounding_rects.append(r)

  return bounding_rects

def subtract_rect(
    free_rects: list[Rect],
    blocked: Rect,
    min_area: float = 10000.0
) -> None:  
  i = 0
  while i < len(free_rects):
    if free_rects[i].get_area() < min_area:
      free_rects.pop(i)
      continue

    if not intersect(free_rects[i], blocked):
      i += 1
      continue

    if blocked.contains(free_rects[i]):
      free_rects.pop(i)
      continue

    rect = free_rects.pop(i)
    new_free_rects = [r for r in [
      Rect(rect.x0, rect.y0, max(rect.x0, blocked.x0), rect.y1),  # left
      Rect(min(rect.x1, blocked.x1), rect.y0, rect.x1, rect.y1),  # right
      Rect(rect.x0, rect.y0, rect.x1, max(rect.y0, blocked.y0)),  # top
      Rect(rect.x0, min(rect.y1, blocked.y1), rect.x1, rect.y1)   # bottom
    ] if r.get_area() >= min_area]
    free_rects.extend(new_free_rects)

  return

def rotate_rect(
    rect: Rect,
    deg: int
) -> Rect:
  """TODO Don't trust this method for it's generated by ChatGPT without testing"""
  # Step 1: Determine the center of the rectangle
  center_x = (rect.x0 + rect.x1)/2
  center_y = (rect.y0 + rect.y1)/2

  # Step 2: Create a rotation matrix for the given angle
  rotation_matrix = Matrix(Identity)
  rotation_matrix.prerotate(deg)

  # Function to apply rotation to a point
  def rotate_point(x, y):
    # Translate point to origin (center of rotation)
    x -= center_x
    y -= center_y
    # Apply rotation
    pt = rotation_matrix @ Point(x, y)
    # Translate point back
    pt.x += center_x
    pt.y += center_y
    return pt
  
  # Step 3: Rotate each corner of the rectangle
  points = [
    rotate_point(rect.x0, rect.y0),
    rotate_point(rect.x0, rect.y1),
    rotate_point(rect.x1, rect.y1),
    rotate_point(rect.x1, rect.y0),
  ]

  # Step 4: Create a new Rect from the rotated points
  new_rect = Rect(points[0], points[1], points[2], points[3])
    
  # Return the new, rotated rectangle
  return new_rect