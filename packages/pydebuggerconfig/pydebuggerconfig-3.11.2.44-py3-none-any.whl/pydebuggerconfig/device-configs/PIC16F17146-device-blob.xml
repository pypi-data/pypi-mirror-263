<?xml version="1.0" ?>
<deviceconf name="PIC16F17146">
    <!--device config for pic16f17146 generated 2022.05.09, 21:06:52-->
    <register name="DEVICE_CONFIG_MAJOR" value="1"/>
    <register name="DEVICE_CONFIG_MINOR" value="8"/>
    <register name="DEVICE_CONFIG_BUILD" value="60"/>
    <register name="CONTENT_LENGTH" value="0"/>
    <register name="CONTENT_CHECKSUM" value="0"/>
    <register name="INSTANCE" value="0"/>
    <register name="INTERFACE_TYPE" value="0x04"/>
    <register name="DEVICE_VARIANT" value="0x00"/>
    <register name="BLOB" value="">
        <blob>
            <!--Source code used to generate this blob:
class DeviceDefinition(PicDevice):
    """
    PIC device definition
    """
    # ICSP interface clock period in nano seconds
    ICSP_CLOCK_PERIOD_NS = 200

    # Debugger model specifies how the Python stack interacts with the debugger over USB
    DEBUGGER_MODEL = PythonScriptedPic16Debugger
    # Programming interface specifies how the debugger tool interacts with the target device
    PROGRAMMING_INTERFACE = ProgInterfaceIcspC8D24
    # Debugging interface specifies how the debugger tool interacts with the debug executive
    DEBUGGING_INTERFACE = DebugExecApiVx

    # Flash properties for this device
    FLASH_WRITE_BYTES_PER_PAGE = 64

    # ICSP programming command-set for this device. Commands from programming spec.
    LOAD_PC_COMMAND = 0x80
    BULK_ERASE_COMMAND = 0x18
    ROW_ERASE_COMMAND = 0xF0
    LOAD_DATA_NVM_COMMAND = 0x00
    LOAD_DATA_NVM_INC_COMMAND = 0x02
    READ_DATA_NVM_COMMAND = 0xFC
    READ_DATA_NVM_INC_COMMAND = 0xFE
    ADDRESS_INC = 0xF8
    INTERNALLY_TIMED_PROG_COMMAND = 0xE0
    INCREMENT_ADDRESS_COMMAND = 0xF8

    # Extra commands for DE access
    MAE_COMMAND = 0xC4
    MAE_IEDE = 0x006355
    MAE_DELAY_MS = 3

    # Delays for internally timed programming
    BULK_ERASE_DELAY_US = 11000 # Prog spec says 8400ys, but drag and drop fails with only 8400us
    ROW_ERASE_DELAY_US = 2800
    PAGE_PROGRAMMING_DELAY_US = 2800
    WRITE_CONFIG_WORD_DELAY_US = 5600
    DE_ERASE_DELAY_US = 14000
    EEPROM_PROGRAMMING_DELAY_US = WRITE_CONFIG_WORD_DELAY_US
    ID_PROGRAMMING_DELAY_US = WRITE_CONFIG_WORD_DELAY_US
    WRITE_DE_PAGE_DELAY_US = WRITE_CONFIG_WORD_DELAY_US

    # ICSP command level timing
    TDLY_US = 1

    # Bulk erase bitfields
    EEPROM_MEMORY = 0x01
    PROGRAM_MEMORY = 0x02
    USER_ID_MEMORY = 0x04
    CONFIG_MEMORY = 0x08
    ICD_MEMORY = 0x10

    # Program counter/address values
    DEVICE_ID_ADDRESS_B = 0x8006*2
    DEVICE_REV_ADDRESS_B = 0x8005*2

    def __init__(self):
        PicDevice.__init__(self)

    def enter_tmod(self):
        """
        Enter TMOD.

        Puts the PIC device into its "Programming mode"
        """
        # MCLR high
        self.hw.set_mclr_high()
        # Have to wait for a minimum of TENTS = 100ns
        self.board.delay_us(1)

        # ICSP pins low
        self.hw.set_all_pins_low()

        # MCLR low
        self.hw.set_mclr_low()
        # Have to wait for a minimum of TENTH = 250us
        self.board.delay_us(250)

        # Send the MCHP string, backwards
        self.prog.write_string_literal('MCHP'[::-1])

    def exit_tmod(self):
        """
        Exit TMOD.
        """
        # MCLR back high
        self.hw.set_mclr_high()
        # Have to wait for a minimum of TEXIT = 1us
        self.board.delay_us(1)

    def hold_in_reset(self):
        """
        Hold the device in reset by driving MCLR low
        """
        # Tristate
        self.hw.set_clk_in_data_in()
        # MCLR low
        self.hw.set_mclr_low()

    def release_from_reset(self):
        """
        Release the device from reset by setting MCLR high
        """
        # Tristate
        self.hw.set_clk_in_data_in()
        # MCLR high
        self.hw.set_mclr_high()

    def read_id(self):
        """
        Read the device ID from the PIC
        """
        # Set address to configuration space
        self.prog.command(self.LOAD_PC_COMMAND)
        # PIC16 devices takes word addresses
        self.prog.payload(self.DEVICE_ID_ADDRESS_B // 2)
        # Read a word from NVM
        self.prog.command(self.READ_DATA_NVM_COMMAND)
        device_id = self.prog.read_data_word()
        return device_id

    def read_device_revision(self):
        """
        Read the device rev from the PIC
        """
        # Set address to configuration space
        self.prog.command(self.LOAD_PC_COMMAND)
        # PIC16 devices takes word addresses
        self.prog.payload(self.DEVICE_REV_ADDRESS_B // 2)
        # Read a word from NVM
        self.prog.command(self.READ_DATA_NVM_COMMAND)
        device_rev = self.prog.read_data_word()
        return device_rev

    def bulk_erase(self, byte_address=None):
        """
        Erase all memories

        :param byte_address: not used but kept for API compatibility
        """
        # Set address to configuration space
        self.prog.command(self.BULK_ERASE_COMMAND)
        self.prog.payload(self.EEPROM_MEMORY | self.PROGRAM_MEMORY | self.CONFIG_MEMORY | self.USER_ID_MEMORY)

        # Internally timed erase command
        self.board.delay_us(self.BULK_ERASE_DELAY_US)

        # Cycle TMOD to ensure correct erasure
        self.exit_tmod()
        self.enter_tmod()

    def write_flash_page(self, byte_address, words):
        """
        Write one flash page to the PIC

        :Note: Data is taken indirectly from the data buffer

        :param byte_address: start address of the page to write
        :param words: number of words to write
        """
        self.prog.command(self.LOAD_PC_COMMAND)
        # PIC16 devices uses word addressing
        self.prog.payload(byte_address // 2)

        # Loop through all but the last word
        for word in range(words - 1):
            self.prog.command(self.LOAD_DATA_NVM_INC_COMMAND)
            self.prog.write_data_word()

        # Write last word with no increment
        self.prog.command(self.LOAD_DATA_NVM_COMMAND)
        self.prog.write_data_word()

        # Timed flash programming procedure
        self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
        self.board.delay_us(self.PAGE_PROGRAMMING_DELAY_US)

    def read_flash(self, byte_address, words):
        """
        Reads a block of flash from the PIC

        :Note: Data is sent indirectly to the data buffer

        :param byte_address: start address to read from
        :param words: number of words to read
        """
        # Set the address to read from
        self.prog.command(self.LOAD_PC_COMMAND)
        # PIC16 devices uses word addressing
        self.prog.payload(byte_address // 2)
        # Loop through range, reading words
        for word in range(words):
            self.prog.command(self.READ_DATA_NVM_INC_COMMAND)
            self.prog.read_data_word()

    def read_config_word(self, byte_address):
        """
        Reads one config word from config space.

        :Note: Data is sent indirectly to the data buffer

        :param byte_address: address of the word
        """
        self.read_flash(byte_address, 1)

    def write_config_word(self, byte_address):
        """
        Writes one word to the config space

        :Note: Data is taken indirectly from the data buffer

        :param byte_address: byte address to write
        """
        # Set the address to write to
        self.prog.command(self.LOAD_PC_COMMAND)
        # PIC16 devices uses word addressing
        self.prog.payload(byte_address // 2)
        # Write data into NVM
        self.prog.command(self.LOAD_DATA_NVM_COMMAND)
        self.prog.write_data_word()
        # Internally timed write procedure
        self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
        self.board.delay_us(self.WRITE_CONFIG_WORD_DELAY_US)

    def write_user_id_word(self, byte_address):
        """
        Writes one word to the user_id space

        :Note: Data is taken indirectly from the data buffer

        :param byte_address: byte address to write
        """
        # Identical to write config words
        self.write_config_word(byte_address)

    def write_eeprom(self, byte_address, numbytes):
        """
        Writes bytes of data to EEPROM

        :Note: Data is taken indirectly from the data buffer

        :param byte_address: start address to write
        :param numbytes: number of bytes to write
        """
        # Set the address to write to
        self.prog.command(self.LOAD_PC_COMMAND)
        self.prog.payload(byte_address//2)
        # Loop through range
        for value in range(numbytes):
            # Write byte with internally timed write
            self.prog.command(self.LOAD_DATA_NVM_COMMAND)
            self.prog.write_data_byte()
            self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
            self.board.delay_us(self.EEPROM_PROGRAMMING_DELAY_US)
            # Increment address
            self.prog.command(self.ADDRESS_INC)

    def read_eeprom(self, byte_address, numbytes):
        """
        Reads bytes of data from EEPROM

        :Note: Data is sent indirectly to the data buffer

        :param byte_address: start address to read
        :param numbytes: number of bytes to read
        """
        # Set the address to read from
        self.prog.command(self.LOAD_PC_COMMAND)
        self.prog.payload(byte_address//2)
        # Loop through range, reading bytes
        for value in range(numbytes):
            self.prog.command(self.READ_DATA_NVM_INC_COMMAND)
            self.prog.read_data_byte()

    def enter_debug(self):
        """
        Enters DEBUG state on the PIC

        :Note: The Debug Executive must be in place first!
        :Note: This device does not require a "debug vector" to be set
        """
        # MCLR low
        self.hw.set_mclr_low()
        self.board.delay_ms(100)
        # ICSP pins low
        self.hw.set_all_pins_low()
        # MCLR high
        self.hw.set_mclr_high()
        self.board.delay_ms(100)
        # ICSP input
        self.hw.set_clk_in_data_in()
        # MCLR low
        self.hw.set_mclr_low()
        self.board.delay_ms(100)
        # MCLR high
        self.hw.set_mclr_high()
        self.board.delay_ms(100)

    def erase_de(self, byte_address, words):
        """
        Erase the Debug Executive

        :param byte_address: unused, kept for API compatibility
        :param words: unused
        """
        self.enable_de_access()

        # Internally timed erase command
        self.prog.command(self.BULK_ERASE_COMMAND)
        self.prog.payload(self.ICD_MEMORY)
        self.board.delay_us(self.BULK_ERASE_DELAY_US)

    def enable_de_access(self):
        """
        Enable access to the Debug Executive memory
        """
        self.prog.command(self.MAE_COMMAND)
        self.prog.payload(self.MAE_IEDE)
        self.board.delay_ms(self.MAE_DELAY_MS)

    def write_de_page(self, byte_address, words):
        """
        Write a page of the Debug Executive

        :param byte_address: start address to write
        :param words: number of words to write
        """
        # Set the address to write to
        self.prog.command(self.LOAD_PC_COMMAND)
        # PIC16 devices uses word addressing
        self.prog.payload(byte_address // 2)
        self.enable_de_access()

        # Loop through all but the last word
        for word in range(words - 1):
            self.prog.command(self.LOAD_DATA_NVM_INC_COMMAND)
            self.prog.write_data_word()

        # Write last word with no increment
        self.prog.command(self.LOAD_DATA_NVM_COMMAND)
        self.prog.write_data_word()

        # Timed flash programming procedure
        self.prog.command(self.INTERNALLY_TIMED_PROG_COMMAND)
        self.board.delay_us(self.WRITE_DE_PAGE_DELAY_US)
-->
            <token>LIST</token>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>12</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x01, 0xEC, 0xC8, 0x00, 0x00, 0x00</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>0</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x06, 0xB0, 0xA0, 0x01, 0x00, 0xB2, 0x00, 0xB1, 0xA0, 0xFA, 0x00, 0x83, 0x20, 0x50, 0x48, 0x43, 0x4D</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>1</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x04, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x06, 0x80, 0x00, 0x00, 0x83, 0x08, 0xFC, 0x00, 0x00, 0x00, 0x84</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>5</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x02, 0xB0, 0xA0, 0x01, 0x00</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>2</id>
                <data>0x54, 0x00, 0x00, 0xAD, 0x00, 0x0B, 0x83, 0x08, 0x18, 0x00, 0x00, 0x00, 0x87, 0x18, 0x0F, 0x00, 0x00, 0x00, 0xA0, 0xF8, 0x2A, 0xB0, 0xA0, 0x01, 0x00, 0xB0, 0xA0, 0x01, 0x00, 0xB2, 0x00, 0xB1, 0xA0, 0xFA, 0x00, 0x83, 0x20, 0x50, 0x48, 0x43, 0x4D</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>3</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x07, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x1E, 0x02, 0x83, 0x08, 0x02, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xF0, 0x0A</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>4</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x06, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xE0, 0x15</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>7</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x03, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x01, 0x05, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x49, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xE0, 0x15, 0x83, 0x08, 0xF8, 0x00, 0x00, 0x00</data>
            </entry>
            <entry>
                <type>PRIMITIVE_SEQUENCE</type>
                <id>8</id>
                <data>0x54, 0x00, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0xAD, 0x00, 0x06, 0x83, 0x08, 0x80, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0x83, 0x08, 0xE0, 0x00, 0x00, 0x00, 0xA0, 0xE0, 0x15</data>
            </entry>
            <entry>
                <type>D_ICSP</type>
                <data type="PIC_FLASH_BASE_W">0x00000000</data>
                <data type="PIC_EEPROM_BASE_W">0x0000F000</data>
                <data type="PIC_USER_ID_BASE_W">0x00008000</data>
                <data type="PIC_CONFIG_BASE_W">0x00008007</data>
                <data type="PIC_FLASH_SIZE_W">0x00004000</data>
                <data type="PIC_EEPROM_SIZE_B">0x0100</data>
                <data type="PIC_USER_ID_SIZE_W">4</data>
                <data type="PIC_CONFIG_SIZE_W">5</data>
                <data type="PIC_FLASH_WRITE_BLOCK_B">64</data>
                <data type="PIC_EEPROM_WRITE_BLOCK_B">2</data>
                <data type="PIC_USER_ID_WRITE_BLOCK_B">2</data>
                <data type="PIC_CONFIG_WRITE_BLOCK_B">2</data>
                <data type="PIC_DEVICE_ID">0x30E1</data>
            </entry>
        </blob>
    </register>
</deviceconf>
