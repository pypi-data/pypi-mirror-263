# Author: Yiannis Charalambous

import os
from pathlib import Path
from dotenv import load_dotenv, find_dotenv
from dataclasses import dataclass
from typing_extensions import override, Optional

from pyautoconfig import EnvTypes
from .base_config_loader import BaseConfigLoader


@dataclass
class EnvConfigField:
    name: str
    default_value: EnvTypes = ""
    is_optional: bool = False
    """Will not load the config if the value is not specified by the user. If
    true will assign default_value."""
    show_in_config: bool = True
    """Show in config tool UI."""


class EnvConfigLoader(BaseConfigLoader):
    """Class that allows loading and reading from multiple dotenv files."""

    autogenerated_string: str = "# Generated automatically by PyAutoConfig."

    def __init__(
        self,
        fields: list[EnvConfigField],
        env_name: Optional[str] = ".env",
        env_paths: list[str] = [],
        create_missing_fields: bool = False,
        verbose: bool = False,
    ) -> None:
        """Creates an env config loader. The loader can search the environment and also multiple files.

        Args:
            * fields - Describes the structure of the config.
            * env_name - Name of the dotenv file to load, if not present in current directory, will search upwards.
            * env_paths - List of additional directory paths to look for dotenv file. Only set if `env_name` is set.
            * create_missing_fields - Will initialize missing values that haven't been labeled as
            `is_optional`.
        """

        self.fields: list[EnvConfigField] = fields
        self.values: dict[str, EnvTypes] = {}

        self.env_paths: list[Path] = []
        self.verbose: bool = verbose

        # Search current path.
        if env_name:
            dotenv_file_path: str = find_dotenv(filename=env_name, usecwd=True)
            if dotenv_file_path != "":
                self.env_paths.append(Path(dotenv_file_path))

            # Search additional paths.
            for path in env_paths:
                dir_path: str = os.path.expandvars(os.path.expanduser(path))
                assert os.path.isdir(dir_path)
                self.env_paths.append(Path(dir_path) / env_name)

        self._read_fields(create_missing_fields=create_missing_fields)

    @classmethod
    def from_schema(cls, fields: list[EnvConfigField]) -> "EnvConfigLoader":
        """Creates a loader from only fields."""
        return EnvConfigLoader(fields=fields, create_missing_fields=True)

    @classmethod
    def generate_default_file(cls, fields: list[EnvConfigField]) -> str:
        """Returns a string representation of a default file generated from
        a list of `EnvConfigField`."""
        lines: list[str] = [EnvConfigLoader.autogenerated_string] + [
            f"{f.name}={f.default_value}" for f in fields
        ]
        return "\n".join(lines)

    @override
    def save(self, file_path: str) -> None:
        with open(file_path, "w") as file:
            file.write(EnvConfigLoader.autogenerated_string + "\n")
            for field in self.fields:
                file.write(f"{field.name}={self.values[field.name]}\n")

    def get_value(self, key: str) -> Optional[EnvTypes]:
        """Get a value from the env configuration, if the return is `None`, then that
        means that they value does not exist."""
        return self.values[key] if key in self.values else None

    @override
    def _read_fields(
        self,
        create_missing_fields: bool = False,
    ) -> None:
        values: dict[str, EnvTypes] = {}

        def get_env_vars() -> None:
            """Gets all the system environment variables that are currently loaded. Will not
            load values that are not following the EnvConfigField specification."""
            for field in self.fields:
                value: Optional[str] = os.getenv(field.name)
                # Check if value is not None
                if value != None:
                    values[field.name] = value

        # Read from system environment.
        get_env_vars()

        # Load from each file.
        for file in self.env_paths:
            load_dotenv(dotenv_path=file, override=False, verbose=self.verbose)
            get_env_vars()

        # Check if all the values are set, else create them with defaults.
        for field in self.fields:
            if field.name not in values:
                if create_missing_fields or field.is_optional:
                    # Create new field with default value.
                    values[field.name] = field.default_value
                else:
                    raise ValueError(f"Error: No ${field.name} in environment.")

        self.values: dict[str, EnvTypes] = values
