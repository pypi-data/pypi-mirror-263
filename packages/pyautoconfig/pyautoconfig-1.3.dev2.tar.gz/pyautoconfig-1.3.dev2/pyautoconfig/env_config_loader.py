# Author: Yiannis Charalambous

import os
from contextlib import chdir
from pathlib import Path
from dotenv import find_dotenv
from dotenv.main import DotEnv
from dataclasses import dataclass
from typing_extensions import override, Optional

from pyautoconfig import EnvTypes
from .base_config_loader import BaseConfigLoader


@dataclass
class EnvConfigField:
    name: str
    default_value: EnvTypes = ""
    is_optional: bool = False
    """Will not load the config if the value is not specified by the user. If
    true will assign default_value."""
    show_in_config: bool = True
    """Show in config tool UI."""


class EnvConfigLoader(BaseConfigLoader):
    """Class that allows loading and reading from multiple dotenv files."""

    autogenerated_string: str = "# Generated automatically by PyAutoConfig."

    def __init__(
        self,
        fields: list[EnvConfigField],
        create_missing_fields: bool = False,
        fail_on_missing_field: bool = False,
        read_sys_env: bool = True,
        verbose: bool = False,
    ) -> None:
        """Creates an env config loader. The loader will automatically load from the system
        env.

        Args:
            * fields - Describes the structure of the config.
            * create_missing_fields - Will initialize missing values that haven't been labeled as
            `is_optional`. If this is not supplied then the missing values will return as None.
            * fail_on_missing_field - Will cause a value error when a field is missing.
        """

        self.fields: list[EnvConfigField] = fields
        self.values: dict[str, EnvTypes] = {}
        self.env_paths: list[Path] = []
        self.verbose: bool = verbose
        self.read_sys_env: bool = read_sys_env
        self.fail_on_missing_field: bool = fail_on_missing_field
        self.create_missing_fields: bool = create_missing_fields

        self._read_fields(create_missing_fields=self.create_missing_fields)

    @classmethod
    def generate_default_file(cls, fields: list[EnvConfigField]) -> str:
        """Returns a string representation of a default file generated from
        a list of `EnvConfigField`."""
        lines: list[str] = [EnvConfigLoader.autogenerated_string] + [
            f"{f.name}={f.default_value}" for f in fields
        ]
        return "\n".join(lines)

    def load_env_file(
        self,
        file_path: str,
        search_in_path: bool = False,
    ) -> None:
        """Load an env file and add it to the env_paths, read fields again.
        Any overlapping variables will not be overwritten.

        Args:
            * path - Can be a path to a folder or file. If path to a file, will directly load that file,
            if path to a folder,"""

        real_path: str = os.path.realpath(
            os.path.expanduser(os.path.expandvars(file_path))
        )
        file_name: str = os.path.basename(real_path)
        file_dir: str = os.path.dirname(real_path)

        # Search current path.
        with chdir(file_dir):
            dotenv_file_path: str = find_dotenv(
                filename=file_name, usecwd=not search_in_path
            )
            if dotenv_file_path != "":
                self.env_paths.append(Path(dotenv_file_path))

            self._read_fields(create_missing_fields=self.create_missing_fields)

    @override
    def save(self, file_path: str) -> None:
        with open(file_path, "w") as file:
            file.write(EnvConfigLoader.autogenerated_string + "\n")
            for field in self.fields:
                file.write(f"{field.name}={self.values[field.name]}\n")

    def get_value(self, key: str) -> Optional[EnvTypes]:
        """Get a value from the env configuration, if the return is `None`, then that
        means that they value does not exist."""
        return self.values[key] if key in self.values else None

    def refresh_data(
        self,
        create_missing_fields: bool = False,
    ) -> None:
        """Calls _read_fields, use this instead of calling private method directly."""
        self._read_fields(create_missing_fields=create_missing_fields)

    @override
    def _read_fields(
        self,
        create_missing_fields: bool = False,
    ) -> None:
        values: dict[str, EnvTypes] = {}

        def update_env_values(dotenv: Optional[DotEnv] = None) -> None:
            """Gets all the system environment variables that are currently loaded. Will not
            load values that are not following the EnvConfigField specification."""
            for field in self.fields:
                value: Optional[str] = (
                    dotenv.get(field.name) if dotenv else os.getenv(field.name)
                )
                # Check if value is not None
                if value != None:
                    if isinstance(field.default_value, bool):
                        values[field.name] = value.lower() in ["1", "true"]
                    else:
                        # Convert to the type of the default value before storing.
                        try:
                            values[field.name] = type(field.default_value)(value)
                        except ValueError as e:
                            if field.is_optional or create_missing_fields:
                                values[field.name] = field.default_value
                            else:
                                raise e

        # Read from system environment.
        if self.read_sys_env:
            update_env_values()

        # Load from each file.
        for file in self.env_paths:
            dotenv: DotEnv = DotEnv(
                dotenv_path=file,
                verbose=self.verbose,
                stream=None,
                encoding="utf-8",
                interpolate=True,
                override=False,
            )
            update_env_values(dotenv)

        # Check if all the values are set, else create them with defaults.
        for field in self.fields:
            if field.name not in values:
                if create_missing_fields or field.is_optional:
                    # Create new field with default value.
                    values[field.name] = field.default_value
                elif self.fail_on_missing_field:
                    raise ValueError(f"Error: No ${field.name} in environment.")

        self.values: dict[str, EnvTypes] = values
