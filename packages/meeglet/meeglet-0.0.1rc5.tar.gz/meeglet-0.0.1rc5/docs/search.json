[
  {
    "objectID": "tutorials/plot_eeg_power.html",
    "href": "tutorials/plot_eeg_power.html",
    "title": "EEG power",
    "section": "",
    "text": "Compute, plot and manipulate EEG power spectra using Morlet Wavelets\nIn this example we will load the fmailiar MNE sample data and compute Morlet Wavelets.\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\nimport mne\nfrom mne.datasets import sample\n\nimport meeglet\nfrom meeglet import compute_spectral_features, spectrum_from_features",
    "crumbs": [
      "Python tutorials",
      "EEG power"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_power.html#load-data",
    "href": "tutorials/plot_eeg_power.html#load-data",
    "title": "EEG power",
    "section": "Load data",
    "text": "Load data\nLet’s read in the raw data and pick the EEG channel type\n\ndata_path = sample.data_path()\n\nraw = mne.io.read_raw_fif(data_path / 'MEG/sample/sample_audvis_raw.fif')\nraw = raw.pick_types(meg=False, eeg=True, eog=False, ecg=False, stim=False,\n                     exclude=raw.info['bads']).load_data()\nraw.set_eeg_reference(projection=True).apply_proj()\n\n\n\n    General\n    \n\n\n\n\nMeasurement date\nDecember 03, 2002 19:01:10 GMT\n\n\nExperimenter\nMEG\n\n\nParticipant\nUnknown\n\n\n\n\n\n\n\nChannels\n\n\n\n\n\nDigitized points\n146 points\n\n\nGood channels\n59 EEG\n\n\nBad channels\nNone\n\n\nEOG channels\nNot available\n\n\nECG channels\nNot available\n\n\n\n\n\n\n\nData\n\n\n\n\n\nSampling frequency\n600.61 Hz\n\n\nHighpass\n0.10 Hz\n\n\nLowpass\n172.18 Hz\n\n\nProjections\nAverage EEG reference : on\n\n\nFilenames\nsample_audvis_raw.fif\n\n\nDuration\n00:04:38 (HH:MM:SS)",
    "crumbs": [
      "Python tutorials",
      "EEG power"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_power.html#compute-the-features-using-the-high-level-api-of-meeglet.",
    "href": "tutorials/plot_eeg_power.html#compute-the-features-using-the-high-level-api-of-meeglet.",
    "title": "EEG power",
    "section": "Compute the features using the high-level API of meeglet.",
    "text": "Compute the features using the high-level API of meeglet.\nThis will return tow simple namespaces, one for the spectral features, one for the meta data.\n\nfeatures, info = compute_spectral_features(\n    raw, foi_start=2, foi_end=32, bw_oct=0.5, density='Hz', features='pow')",
    "crumbs": [
      "Python tutorials",
      "EEG power"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_power.html#use-mne-high-level-plotting-api",
    "href": "tutorials/plot_eeg_power.html#use-mne-high-level-plotting-api",
    "title": "EEG power",
    "section": "Use MNE high-level plotting API",
    "text": "Use MNE high-level plotting API\nTo make use of MNE’s latest Spectum data container, we can use a little helper function from meeglet\n\nPower spectrum plot (2D lines)\nNow we can readily make use of MNE’s plotting API. Let’s first plot data on a linear scale\n\nspectrum = meeglet.spectrum_from_features(\n    features.pow, info.foi, raw.info\n)\n\n\nfig = plt.figure()\nspectrum.plot(dB=True, axes=plt.gca())\nfig.set_size_inches(8, 4);\nfig;\n\n\n\n\n\n\n\n\nLet’s update the output to log scale with base = 2. Note that for a base 10 logarithm, we could have simply used the xscale from the plot method. Some adjustments follow to reflect updated scaling\n\nfig = plt.figure()\n\nspectrum.plot(dB=True, axes=plt.gca())\n\nfig.axes[0].set_xscale('log', base=2)\nfig.axes[0].set_xticks(2 ** np.arange(1, 6), 2 ** np.arange(1, 6))\n\nfig.set_size_inches(8, 4);\nfig;\n\n\n\n\n\n\n\n\n\n\nTopographic plots\nUsing default settings, MNE will returns bands.\n\nspectrum.plot_topomap(cmap='viridis');\n\n\n\n\n\n\n\n\nBut we can simply pass frequency coordinates as tuples. Of note, due to the logarithmic frequency grid and the particular octave band width, one octave is reached every 8 indices if we use a band width of 0.5 and bw / 4 spaxcing (defaults).\n\ninfo.foi[::8]\n\narray([ 2.,  4.,  8., 16., 32.])\n\n\n\nfreqs = info.foi[::8][2:]\n\n\nspectrum.plot_topomap(zip(freqs, freqs), cmap='viridis');\n\n\n\n\n\n\n\n\nFinally, we can normalize the output, such that the total power adds up to one.\n\nspectrum.plot_topomap(zip(freqs, freqs), cmap='viridis', normalize=True);",
    "crumbs": [
      "Python tutorials",
      "EEG power"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_power.html#advanced-options",
    "href": "tutorials/plot_eeg_power.html#advanced-options",
    "title": "EEG power",
    "section": "Advanced Options",
    "text": "Advanced Options\n\nOctave scaling\nTo take into account a-periodic dynamics, we can integrate over octaves, i.e. \\(log_2(Hz)\\). As a result, the 1/f will be mitigated.\n\nfeatures2, info = compute_spectral_features(\n    raw, foi_start=2, foi_end=32, bw_oct=0.5, density='oct', features='pow')\n\nspectrum_oct = spectrum_from_features(\n    data=features2.pow,\n    freqs=info.foi,\n    inst_info=raw.info\n)\n\n\nfig = plt.figure();\nspectrum_oct.plot(dB=True, axes=plt.gca());\nfig.set_size_inches(8,4);\nfig.axes[0].set_xscale('log', base=2);\nfig.axes[0].set_xticks(2 ** np.arange(1, 6), 2 ** np.arange(1, 6));\nfor tt in fig.findobj(plt.Text):\n    if '/Hz' in tt.get_text():\n        tt.set_text(tt.get_text().replace('Hz', 'oct'));\nfig;\n\n\n\n\n\n\n\n\n\n\nFrequency shifting\nWe can now explore shifting in log domain. We will apply a frequency shiftt to arbitrary reference=12Hz. Then we plot both results using the original frequency grid\n\nreference = 12\npeak = 8  # we know this subject has an 8 Hz peak.\nshift = peak / reference \n\nfeatures3, info3 = compute_spectral_features(\n    raw, foi_start=2, foi_end=32, bw_oct=0.5, density='oct',\n    features='pow', freq_shift_factor=shift\n)\n\n\nplt.close('all')\nfig = plt.figure()\nplt.ion()\nplt.title('shift VS original grid')\nplt.loglog(info.foi, features2.pow.mean(0), label='original', color='orange',\n           linewidth=3)\nplt.axvline(peak, color='black', linestyle='--')\nplt.semilogy(info3.foi, features3.pow.mean(0), label='shifted', color='blue',\n             linewidth=3)\nplt.axvline(reference, color='black', linestyle='--')\nplt.legend()\nplt.xlabel('Frequency [Hz]')\nplt.ylabel(r'${\\mu}V^2/oct$')\nfig.axes[0].set_xscale('log', base=2)\nfig.axes[0].set_xticks(2 ** np.arange(1, 6), 2 ** np.arange(1, 6))\nfig.set_size_inches(8, 4)\nfig;\n\n\n\n\n\n\n\n\nOne can nicely see the up-shift while the x axes are identical.\nWe can now see that the default log-scaled smoothing leads to smoother PSD estimates in high frequencies. On the left-hand side, we see that log scaling VS linear scaling are more similar in low frequencies.",
    "crumbs": [
      "Python tutorials",
      "EEG power"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_covariance.html",
    "href": "tutorials/plot_eeg_covariance.html",
    "title": "EEG covariance",
    "section": "",
    "text": "Compare covariances from Morlet Wavelets versus broadband methods for spatial whitening\nIn this tutorial we will load the fmailiar MNE sample data and compute Morlet wavelets based on (Bomatter et al. 2023). We then compare the covariances and show how to achieve comparable results for spatial whitening with evoked responses.\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\nimport mne\nfrom mne.datasets import sample\n\nimport pyriemann\n\nfrom meeglet import compute_spectral_features, spectrum_from_features",
    "crumbs": [
      "Python tutorials",
      "EEG covariance"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_covariance.html#load-data",
    "href": "tutorials/plot_eeg_covariance.html#load-data",
    "title": "EEG covariance",
    "section": "Load data",
    "text": "Load data\nLet’s read in the raw data and pick the EEG channel type\n\ndata_path = sample.data_path()\n\nraw_fname = data_path / 'MEG/sample/sample_audvis_raw.fif'\nraw = mne.io.read_raw_fif(raw_fname)\nraw = raw.pick_types(meg=False, eeg=True, eog=True, ecg=False, stim=True,\n                     exclude=raw.info['bads']).load_data()\nraw.set_eeg_reference(projection=True).apply_proj()\nraw.resample(200)\nraw.filter(1, 32)\n\n\n\n    General\n    \n\n\n\n\nMeasurement date\nDecember 03, 2002 19:01:10 GMT\n\n\nExperimenter\nMEG\n\n\nParticipant\nUnknown\n\n\n\n\n\n\n\nChannels\n\n\n\n\n\nDigitized points\n146 points\n\n\nGood channels\n9 Stimulus, 59 EEG, 1 EOG\n\n\nBad channels\nNone\n\n\nEOG channels\nEOG 061\n\n\nECG channels\nNot available\n\n\n\n\n\n\n\nData\n\n\n\n\n\nSampling frequency\n200.00 Hz\n\n\nHighpass\n1.00 Hz\n\n\nLowpass\n32.00 Hz\n\n\nProjections\nAverage EEG reference : on\n\n\nFilenames\nsample_audvis_raw.fif\n\n\nDuration\n00:04:38 (HH:MM:SS)",
    "crumbs": [
      "Python tutorials",
      "EEG covariance"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_covariance.html#basic-steps",
    "href": "tutorials/plot_eeg_covariance.html#basic-steps",
    "title": "EEG covariance",
    "section": "Basic Steps",
    "text": "Basic Steps\n\nCalssical time-domain covariance computation\nThe most common way to compute the EEG covariance is the time-domain approach: \\[\\frac{1}{T} X^\\mathsf{T}X,\\] where \\(X \\in \\mathbb{R}^{E \\times T}\\), i.e., the EEG signals at \\(E\\) electrodes and \\(T\\) time points.\nFor denoising, one usually uses the broad-band covariance. For decoding, it is common to apply band-pass filtering before computing the covariance\n\nnoise_cov = mne.compute_raw_covariance(raw, method='oas')  # broad band\nalpha_cov = mne.compute_raw_covariance(raw.copy().filter(8, 12), method='oas') # alpha band\n\n\nnoise_cov.plot(raw.info);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nalpha_cov.plot(raw.info);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can see that a) the broad band contains larger variance and b) that a few channels in the upper left corner dominate the covariance in the broad-band case. The alpha band covariance is more likely to contain brain signal.\n\n\nCompute covariances per frequncy using Morlet wavelets\nWe can obtain covariances from Morlet Wavelets at eeach freuqency specified as follows. Let’s assume that \\(\\mathsf{Z}^f \\in \\mathbb{C}^{E \\times T}\\) is the complex-valued convolved signal at frequency \\(f\\), then its covariance can be denoted as\n\\[\\text{Re}(\\mathsf{Z}^{fH}\\mathsf{Z}^f) / \\mathrm{n},\\]\nwhere \\(^H\\) is the conjugate transpose, \\(\\text{Re}\\) is the real part, which is divided by the number of (valid) windows used for numerical approximations (not marked for artifact rejection / exclusion).\nFor details, see (Bomatter et al. 2023).\n\nout, info = compute_spectral_features(\n    raw, foi_start=1, foi_end=32, bw_oct=0.25, delta_oct=1,\n    density='oct', features='cov_oas')\nout.cov.shape\n\n(59, 59, 6)\n\n\nWe have one covariance per frequency. To compare this to previous outputs we can use summing or averaging and create an MNE covariance container. Note that this is somewhat approximative, as it may miss some part of the signal and does not account for potential overlap between the windows.\n\nout.cov.T.shape\n\n(6, 59, 59)\n\n\n\neeg_info = mne.pick_info(raw.info, sel=mne.pick_types(raw.info, eeg=True, eog=False, stim=False))\nnoise_cov_spect_full = mne.cov.Covariance(\n    out.cov.sum(axis=2),\n    eeg_info['ch_names'],\n    eeg_info['bads'],\n    eeg_info['projs'],\n    method='morlet-oas',\n    nfree=len(raw.times) - 1)\n\n\nnoise_cov_spect_alpha = mne.cov.Covariance(\n    out.cov[..., (info.foi &gt;=8) & (info.foi &lt;= 12)].sum(axis=2),\n    eeg_info['ch_names'],\n    eeg_info['bads'],\n    eeg_info['projs'],\n    method='morlet-oas',\n    nfree=len(raw.times) - 1)\n\n\nnoise_cov_spect_full.plot(info=eeg_info);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe results are very similar. Note however that subtle differences exist as summing does not take into account the overlap between individual wavelets. To improve precision, one needs to make sure that the spacing and width of the wavelets covers the frequency range without overlap, otherwise some weighted average is needed to remove the overlap. To achieve results below, we made the spacing 4 times the band width.\n\nnoise_cov_spect_alpha.plot(info=eeg_info);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis is again very close to the band-pass filtered version. We have seen in the EEG power tutorial, that the peak power was observed over 8Hz. One advantage of the Wavelet approach is that we can readily inspect more narrow frequency bins. In this case, the difference is not striking though.\n\nnoise_cov_spect_alpha2 = mne.cov.Covariance(\n    out.cov[..., info.foi == 8][..., 0],\n    eeg_info['ch_names'],\n    eeg_info['bads'],\n    eeg_info['projs'],\n    method='morlet-oas',\n    nfree=len(raw.times) - 1)\n\nnoise_cov_spect_alpha2.plot(eeg_info)",
    "crumbs": [
      "Python tutorials",
      "EEG covariance"
    ]
  },
  {
    "objectID": "tutorials/plot_eeg_covariance.html#investigate-equivalence-of-covariances-for-spatial-whitening",
    "href": "tutorials/plot_eeg_covariance.html#investigate-equivalence-of-covariances-for-spatial-whitening",
    "title": "EEG covariance",
    "section": "Investigate equivalence of covariances for spatial whitening",
    "text": "Investigate equivalence of covariances for spatial whitening\nWe will see now that the noise covariances obtained are very similar. This is only the case if overlap is controlled and summing is used for combining the covariances.\n\nraw = mne.io.read_raw_fif(raw_fname, preload=True)\nraw.pick_types(meg=False, eeg=True, stim=True, eog=True)\nevents = mne.find_events(raw, stim_channel='STI 014')\nevent_id = {'auditory/left': 1, 'auditory/right': 2, 'visual/left': 3,\n            'visual/right': 4, 'smiley': 5, 'button': 32}\nreject = dict(eog=150e-6)\nepochs = mne.Epochs(raw, events, event_id=event_id, reject=reject)\nevoked = epochs.average()\nfig, axes1 = plt.subplots(1, 2, figsize=(10, 3))\naxes1[0].set_ylim(-15, 15)\naxes1[1].set_ylim(0, 15)\n\nevoked.plot_white(noise_cov=noise_cov, axes=axes1);\nfig, axes2 = plt.subplots(1, 2, figsize=(10, 3))\naxes2[0].set_ylim(-15, 15)\naxes2[1].set_ylim(0, 15)\n\nevoked.plot_white(noise_cov=noise_cov_spect_full, axes=axes2);",
    "crumbs": [
      "Python tutorials",
      "EEG covariance"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Python API overview",
    "section": "",
    "text": "Morlet Wavelets for M/EEG\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Python API"
    ]
  },
  {
    "objectID": "matlab/index.html",
    "href": "matlab/index.html",
    "title": "Matlab functionality",
    "section": "",
    "text": "MATLAB functionality\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "MATLAB"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MEEGLET",
    "section": "",
    "text": "Morlet wavelets for M/EEG analysis, [ˈmiːglɪt]\nThis package provides a lean implementation of Morlet wavelets (Morlet et al. 1982) designed for power-spectral analysis of M/EEG resting-state signals (Hipp et al. 2012; Bomatter et al. 2023).\nCode\nimport matplotlib.pyplot as plt\nfrom meeglet import define_frequencies, define_wavelets, plot_wavelet_family\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, bw_oct=1, delta_oct=1\n)\n\nwavelets = define_wavelets(\n    foi=foi, sigma_time=sigma_time, sfreq=1000., density='oct'\n)\n\nplot_wavelet_family(wavelets, foi, fmax=64)\nplt.gcf().set_size_inches(9, 3)",
    "crumbs": [
      "MEEGLET"
    ]
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "MEEGLET",
    "section": "Documentation",
    "text": "Documentation\n\n\n\nBackground\noverview on scope, rationale & design choices\n\n\nPython tutorials\nM/EEG data analysis examples\n\n\nPython API\nDocumentation of Python functions and unit tests\n\n\nMATLAB functionality\nMATLAB documentation and data analysis example\n\n\n\nUse the left sidebar for navigating conveniently!",
    "crumbs": [
      "MEEGLET"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "MEEGLET",
    "section": "Installation",
    "text": "Installation",
    "crumbs": [
      "MEEGLET"
    ]
  },
  {
    "objectID": "index.html#from-pypi",
    "href": "index.html#from-pypi",
    "title": "MEEGLET",
    "section": "from PyPi",
    "text": "from PyPi\nIn your environment of choice, use pip to install meeglet:\npip install meeglet\n\nfrom the sources\nPlease clone the software, consider installing the dependencies listed in the `environment.yml.\nThen do in your conda/mamba environment of choice:\npip install -e .",
    "crumbs": [
      "MEEGLET"
    ]
  },
  {
    "objectID": "index.html#citation",
    "href": "index.html#citation",
    "title": "MEEGLET",
    "section": "Citation",
    "text": "Citation\nWhen using our package, please cite our two reference articles:\nPython implementation and covariance computation.\n@article {bomatter2023,\n    author = {Philipp Bomatter and Joseph Paillard and Pilar Garces and Joerg F Hipp and Denis A Engemann},\n    title = {Machine learning of brain-specific biomarkers from EEG},\n    elocation-id = {2023.12.15.571864},\n    year = {2023},\n    doi = {10.1101/2023.12.15.571864},\n    publisher = {Cold Spring Harbor Laboratory},\n    URL = {https://www.biorxiv.org/content/early/2023/12/21/2023.12.15.571864},\n    eprint = {https://www.biorxiv.org/content/early/2023/12/21/2023.12.15.571864.full.pdf},\n    journal = {bioRxiv}\n}\nGeneral methodology, MATLAB implementation and power-envelope correlations.\n@article{hipp2012large,\n  title={Large-scale cortical correlation structure of spontaneous oscillatory activity},\n  author={Hipp, Joerg F and Hawellek, David J and Corbetta, Maurizio and Siegel, Markus and Engel, Andreas K},\n  journal={Nature neuroscience},\n  volume={15},\n  number={6},\n  pages={884--890},\n  year={2012},\n  publisher={Nature Publishing Group US New York}\n}",
    "crumbs": [
      "MEEGLET"
    ]
  },
  {
    "objectID": "index.html#related-software",
    "href": "index.html#related-software",
    "title": "MEEGLET",
    "section": "Related software",
    "text": "Related software\nM/EEG features based on Morlet wavelets using the more familiar time-domain parametrization can be readily computed is sevaral major software packages for M/EEG analysis:\n\nFieldTrip\nBrainStorm\nMNE\nMNE-Connectivity",
    "crumbs": [
      "MEEGLET"
    ]
  },
  {
    "objectID": "background/1_background_wavelets.html",
    "href": "background/1_background_wavelets.html",
    "title": "Mathematical Deep Dive",
    "section": "",
    "text": "Definition and parameterization of Morlet wavelets\n\n\nBackground and setting\nDespite the popularity and extensive use of Morlet wavelets for M/EEG analysis, differences in notation and parameterization used in the literature can be confusing. In the following, we provide visual and formal definitions, introduce our logarithmic parameterization, and establish its link with other parameterizations.\nFirst of all, Morlet wavelets (Morlet et al. 1982) extend Gabor wavelets (Gabor 1946): Both, Gabor wavelets and Morlet wavelets are obtained by multiplying a complex sine-wave (oscillation) with a Gaussian taper. By construction, following from the uncertainty principle, Gabor and Morlet wavelets will also have a Gaussian shape in the frequency domain (if finite window lengths are neglected). Morlet wavelets define families of Gabor wavelets in which width and frequency are logarithmically scaled (Morlet et al. 1982; Tallon-Baudry et al. 1996). This means that a single Morlet wavelet is essentially a Gabor wavelet.\n\n\n\n\n\n\nGabor and Morlet Wavelets\n\n\n\nTo capture the variations of the spectral content of a signal over time, Gabor introduced in 1946 a basis of elementary waveforms, also known as time-frequency atoms (Gabor 1946). Such wavelets provide a localized time-frequency representation of the signal with an optimal tradeoff between time and frequency precision. Later, in 1982, Morlet adapted these wavelets to include a logarithmic scale in octave for the frequency of the sine wave and the width of the Gaussian window (Morlet et al. 1982). This scaling means that with increasing frequency, the wavelet becomes more time-localized (narrower time window) and less frequency-localized in (wider frequency bandwidth). Such wavelets, henceforth referred to as Morlet wavelets, account for log-frequency behavior and can be better suited for electrophysiological signals (Tallon-Baudry et al. 1996).\n\n\n\n\n\n\n\n\nEssential design choice\n\n\n\nA key feature of our parameterization is to express the Gaussian taper in terms of its spectral smoothing, i.e., spectral bandwidth (\\(bw\\)), logarithmically in units of octaves (Hipp et al. 2012).\n\n\nLet’s consider an example of a Morlet wavelet with a center frequency of interest \\(f=2 Hz\\) and a bandwidth of \\(bw=0.5 oct\\). The example Morlet wavelet is illustrated in Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as transforms\n\n# parameter\nsfreq = 1000.\nfoi = 2.0\nbw = 0.5\n\n# for arithmetic mean\nfoi_min = 2 * foi / (2 ** bw + 1)\nfoi_max = 2 * foi / (2 ** -bw + 1)\ndf = foi_max - foi_min # frequency smoothing / FWHM\nsf = df / (2*np.sqrt(2*np.log(2))) # map FWHM to sigma_f\nst = 1 / 2 / np.pi /sf # sigma t (uncertainty relation)\nkernel_width = 5\nT = kernel_width * st\nT = np.round(T * sfreq)  / sfreq\nn_win = np.round(T * sfreq)\ntime = np.arange(-n_win / 2, n_win / 2) / sfreq\nfreq = np.arange(0, n_win) / T\nZ = time / st\ngaussian = np.exp(-(1 / 2) * Z ** 2)\ngaussian /= np.sum(gaussian)\noscillation = np.exp(1j * 2 * np.pi * foi * time)\nkernel = (gaussian * oscillation)\n\n#freq = np.arange(0, len(kernel)) / T\nfreq_high_res = np.arange(0, 2**14) / (2**14 / sfreq)\nkernel_fft = np.fft.fft(kernel, 2**14)\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7.5, 7))\n\n# Panel A\nax1.plot(time, kernel.real, 'b')\nax1.plot(time, kernel.imag,'c')\nax1.plot(time, gaussian,'k')\nax1.ticklabel_format(axis='y', style='sci',\n                     scilimits=(0, 0), useMathText=True)\n\ntrans = transforms.blended_transform_factory(\n    ax1.transData, ax1.transAxes)\n\ntrans2 = transforms.blended_transform_factory(\n    ax2.transData, ax2.transAxes)\n\nax1.text(-0.1, 1.15, 'A',\n          {'color': 'k', 'fontsize': 20},\n         horizontalalignment='center',\n         verticalalignment='center', transform=ax1.transAxes)\nax1.text(0.85, 0.82, 'cos', \n         {'color': 'b'},\n         horizontalalignment='center',\n         verticalalignment='center', transform=ax1.transAxes)\nax1.text(0.85, 0.75, 'sin', \n         {'color': 'c'},\n         horizontalalignment='center',\n         verticalalignment='center', transform=ax1.transAxes)\nax1.text(-0.03, 0.15, \n         \"\"\"\n         Morlet wavelet:\n         center frequency = %.1f Hz\n         band width = %.1f octaves\n         \"\"\" % (foi,bw),\n         horizontalalignment='left',\n         verticalalignment='center', transform=ax1.transAxes\n)\n\nax1.axvline(0, linewidth=1, linestyle='--', color='#ff7f0e')\nax1.axvline(-st, linewidth=1, linestyle='--', color='#ff7f0e')\nax1.axvline(st, linewidth=1, linestyle='--', color='#ff7f0e')\n\nax1.text(0.5, 1.05, r'$0$', horizontalalignment='center',\n         verticalalignment='center', transform=ax1.transAxes, color='#ff7f0e')\nax1.text(-st, 1.05, r'$\\sigma_t$', horizontalalignment='center',\n         verticalalignment='center', transform=trans, color='#ff7f0e')\nax1.text(st, 1.05, r'$\\sigma_t$', horizontalalignment='center',\n         verticalalignment='center', transform=trans, color='#ff7f0e')\n\nax1.annotate(\"\", xy=(-kernel_width/2*st, 1.15\n), xytext=(kernel_width/2*st, 1.15),\n             arrowprops=dict(arrowstyle=\"&lt;-&gt;\", connectionstyle=\"arc3\"),\n             xycoords=trans, textcoords=trans)\nax1.text(0.5, 1.15, r'$T$',\n         {'color': 'black', 'fontsize': 10, 'ha': 'center', 'va': 'center',\n          'bbox': dict(boxstyle=\"round\", fc=\"white\", ec=\"black\", pad=0.2)},\n         transform=ax1.transAxes\n)\n\nax1.set_xlabel('Time [s]')\nax1.set_ylabel('Amplitude [a.u.]')\nax1.set_xlim(-T/2, T/2)\n\n# Panel B\nax2.text(-0.1, 1.05, 'B',\n          {'color': 'k', 'fontsize': 20},\n         horizontalalignment='center',\n         verticalalignment='center', transform=ax2.transAxes)\n\nidx = (freq_high_res &gt;= 1) & (freq_high_res &lt;= 3)\nax2.plot(freq_high_res[idx], np.abs(kernel_fft[idx]), color='black')\nax2.set_xlabel('Frequency [Hz]')\nax2.set_ylabel('Amplitude [a.u.]')\n\nax2.axvline(foi, linewidth=1, linestyle='--', color='#ff7f0e')\nax2.axvline(foi-sf, linewidth=1, linestyle='--', color='#ff7f0e')\nax2.axvline(foi+sf, linewidth=1, linestyle='--', color='#ff7f0e')\nax2.text(0.5, 1.05, r'$f$', horizontalalignment='center',\n         verticalalignment='center', transform=ax2.transAxes, color='#ff7f0e')\nax2.text(foi-sf, 1.03, r'$f-\\sigma_f$', horizontalalignment='center',\n         verticalalignment='center', transform=trans2, color='#ff7f0e')\nax2.text(foi+sf, 1.03, r'$f+\\sigma_f$', horizontalalignment='center',\n         verticalalignment='center', transform=trans2, color='#ff7f0e')\n\nax2.axvline(foi-df/2, color='black', linewidth=1)\nax2.axvline(foi+df/2, color='black', linewidth=1)\nax2.text(foi-df/2, 1.11, r'$f_{min}$', horizontalalignment='center',\n         verticalalignment='center', transform=trans2, color='black')\nax2.text(foi+df/2, 1.09, r'$f_{max}$', horizontalalignment='center',\n         verticalalignment='center', transform=trans2, color='black')\n\nax2.text(0.7, 0.8, 'Fourier transform\\nof Morlet wavelet in panel A',\n         {'color': 'k'},\n         horizontalalignment='left',\n         verticalalignment='center', transform=ax2.transAxes)\n\nax2.set_xlim(1, 3)\n\nplt.tight_layout();\n\n\n\n\n\n\n\n\nFigure 1: Example Morlet wavelet in time and frequency domain (a.u., arbitrary units).\n\n\n\n\n\n\n\nMorlet wavelet parameterization\nIn our parameterization, we describe Morlet wavelets families by the spectral smoothing, i.e. spectral bandwidth (\\(bw\\)). In the following, we detail, how the Morlet wavelets are derived for center frequencies \\(f\\) .\nA bandpass filter, that a Morlet wavelet basically is, is described by the two edge frequencies, \\(f_{min}\\) and \\(f_{max}\\), where the signal subjected to the filter is attenuated by 50% (see Figure 1 panel B). We define the bandwidth of the filter as:\n\\[\nbw = log_2\\left(\\frac{f_{max}}{f_{min}}\\right)\n\\tag{1}\\]\nFor a given center frequency \\(f\\) and a desired spectral bandwidth \\(bw\\), \\(f_{min}\\) and \\(f_{max}\\) can then be derived as follows:\n\n\n\n\n\n\nNote\n\n\n\nAuxiliary calculations \\[\nf = \\frac{f_{min} + f_{max}}{2} \\rightarrow f_{min} = 2f-f_{max}\n\\]\n\\[\nbw = log_2\\left(\\frac{f_{max}}{2f-f_{max}}\\right)\n\\]\n\n\n\\[\nf_{min} = \\frac{2f}{2^{bw} + 1}\n\\tag{2}\\]\n\\[\nf_{max} = \\frac{2f}{2^{-bw} + 1}\n\\tag{3}\\]\n\n\n\n\n\n\nNote\n\n\n\nAlternatively, one could use a geometric mean definition (implemented in our package but our default is the arithmetic mean)\n\\(f = \\sqrt{f_{min}f_{max}} \\rightarrow f_{max} = \\frac{f^2}{f_{min}}\\)\n\\(bw = log_2(\\frac{f^2}{{f_{min}}^2}) = 2log_2(\\frac{f}{f_{min}})\\)\n\\(f_{min} = 2^{-bw/2}\\)\n\\(f_{max} = 2^{bw/2}\\)\n\n\nUsing the relationship between the standard deviation and the FWHM (full width at half maximum) for a normal distribution, we find:\n\\[\nFWHM = f_{max}-f_{min} = 2\\sqrt{2ln(2)}\\sigma_f\n\\tag{4}\\]\n\\[\n\\sigma_f = \\frac{f_{max}-f_{min}}{2\\sqrt{2ln(2)}}\n\\tag{5}\\]\nWith the uncertainty principle we can derive \\(\\sigma_t\\) \\[\n\\sigma_t = \\frac{1}{2\\pi\\sigma_f} = \\frac{\\sqrt{2ln(2)}}{\\pi\\left(\\frac{2f}{2^{-bw} + 1}-\\frac{2f}{2^{bw} + 1}\\right)}\n\\tag{6}\\]\nThe Morlet wavelet for center frequency \\(f\\) and spectral smoothing \\(bw\\) is then (A is a normalization constant):\n\\[\nW(t|f,\\sigma_t(bw)) = A e^{-\\left(\\frac{t}{2\\sigma_t}\\right)^2}e^{i2\\pi f t}\n\\tag{7}\\]\nThe convolution kernel that implements a Morlet wavelet has finite length. The length can be expressed in multiples of the temporal standard deviation of the Gaussian taper \\(\\sigma_t\\). In our implementation this is the parameter kernel_width with the default value 5, corresponding to an extend of the Gaussian taper of \\(\\pm 2.5 \\times \\sigma_t\\).\n\nSelection of a grid of center frequencies for spectral analyses\nOur Morlet wavelet package implements a grid with center frequencies spaced logarithmically according to the exponentiation of the base 2 with exponents ranging from \\(f_{min}\\) (e.g. 1 Hz, exponent 0) to \\(f_{max}\\) (e.g. 32 Hz, exponent 5) in steps \\(delta\\) (e.g. 1/8 oct). This ensures a coverage of frequencies that is coordinated with the spectral bandwidth and ensures a homogeneous coverage in the logarithmic frequency space.\n\n\nRelationship between the bandwidth in octaves and the characteristic Morlet wavelet parameter \\(q\\)\nA common way to parameterize Morlet wavelets is the characteristic parameter \\(q\\) (Tallon-Baudry et al. 1996; Oostenveld et al. 2011). See also, MNE-Python examples.\n\\[\nq=f/\\sigma_f\n\\tag{8}\\]\nFrom Equation 6 and Equation 8 follows:\n\\[\nq=\\frac{\\sqrt{2ln(2)} 2 f}{\\left(\\frac{2f}{2^{-bw} + 1}-\\frac{2f}{2^{bw} + 1}\\right)}\n\\tag{9}\\]\n\n\n\n\n\n\nNote\n\n\n\nAuxiliary calculation \\[\n\\frac{2f}{2^{-bw} + 1}-\\frac{2f}{2^{bw} + 1}=\\frac{2f\\left(2^{bw}-2^{-bw}\\right)}{2^{bw}+2^{-bw}+2}\n\\]\n\n\n\\[\nq=\\frac{2^{bw}+2^{-bw}+2}{2^{bw}-2^{-bw}} \\sqrt{2ln(2)}\n\\tag{10}\\]\nApplied, to our defaults of \\(bw=0.5\\), using the arithmetic mean, we find \\(q=6.9\\), which is close to the \\(q=7\\) that is used in literature (Tallon-Baudry et al. 1996).\n\ndef bw2q(bw):\n    L = np.sqrt(2*np.log(2))\n    return (2 ** bw + 2 ** - bw + 2) / (2 ** bw - 2 ** - bw) * L\n\nbw = 0.5\nq = bw2q(bw)\nprint(f\"q(bw={bw:0.2f}) = {q:0.2f}\")\n\nq(bw=0.50) = 6.86\n\n\nWith this we can also compute the bandwidth \\(bw\\) from a given \\(q\\) by inverting Equation 10:\n\n\n\n\n\n\nNote\n\n\n\nAuxiliary calculations\n\\[\nDef: \\lambda=\\sqrt{2 ln(2)}\n\\]\n\\[\n2^{bw} \\lambda + 2^{-bw} \\lambda + 2 \\lambda -q 2^{bw} + q 2^{-bw} = 0\n\\]\n\\[\n2^{bw}(\\lambda - q)+2^{-bw}(\\lambda + q) + 2\\lambda=0\n\\]\n\\[\n\\left(2^{bw}\\right)^2+\\frac{\\lambda+q}{\\lambda-q}+2\\frac{\\lambda}{\\lambda - q} 2^{bw}=0\n\\]\n\\[\n\\left(2^{bw}+\\frac{\\lambda}{\\lambda-q}\\right)^2=\\frac{\\lambda^2}{(\\lambda - q)^2}-\\frac{\\lambda+q}{\\lambda-q}\n\\]\n\n\n\\[\nbw = log_2\\left( \\pm\\sqrt{\\frac{\\lambda^2}{(\\lambda-q)^2}-\\frac{\\lambda+q}{\\lambda-q}} - \\frac{\\lambda}{\\lambda-q} \\right)\n\\tag{11}\\]\n\ndef q2bw(q):\n    L = np.sqrt(2*np.log(2))\n    return np.log2(\n        np.sqrt((L ** 2) / (L - q) ** 2 - (L + q) / (L - q)) - L / (L - q)\n    )\nq = 6.86\nbw = q2bw(q)\nprint(f\"bw(q={q:0.2f}) = {bw:0.2f}\")\n\nbw(q=6.86) = 0.50\n\n\nThis allows us to plot the following relationship between our bandwidth the the classical \\(q\\) parameter (see Figure 2).\n\n\nCode\nq = np.linspace(4, 20, 1000)\nbw = q2bw(q)\nplt.plot(q, bw, linewidth=3)\nplt.xlabel(r\"Morlet wavelet parameter $q=f/\\sigma_f$\")\nplt.ylabel(\"Bandwidth bw [oct]\")\nplt.axvline(bw2q(0.5), color='k', linestyle='--')\nplt.axhline(0.5, color='k', linestyle='--')\nplt.grid(True)\n\n\n\n\n\n\n\n\nFigure 2: Relationship between characteristic Morlet-wavelet parameter and bandwidth in octaves. Black lines indicate the mapping from our default bandwidth to \\(q\\).\n\n\n\n\n\n\n\n\n\n\n\nReferences\n\nGabor, Dennis. 1946. “Theory of Communication. Part 1: The Analysis of Information.” Journal of the Institution of Electrical Engineers-Part III: Radio and Communication Engineering 93 (26): 429–41.\n\n\nHipp, Joerg F, David J Hawellek, Maurizio Corbetta, Markus Siegel, and Andreas K Engel. 2012. “Large-Scale Cortical Correlation Structure of Spontaneous Oscillatory Activity.” Nature Neuroscience 15 (6): 884–90.\n\n\nMorlet, J., G. Arens, E. Fourgeau, and D. Giard. 1982. “Wave Propagation and Sampling Theory—Part II: Sampling Theory and Complex Waves.” GEOPHYSICS 47 (2): 222–36. https://doi.org/10.1190/1.1441329.\n\n\nOostenveld, Robert, Pascal Fries, Eric Maris, and Jan-Mathijs Schoffelen. 2011. “FieldTrip: Open Source Software for Advanced Analysis of MEG, EEG, and Invasive Electrophysiological Data.” Computational Intelligence and Neuroscience 2011: 1–9.\n\n\nTallon-Baudry, Catherine, Olivier Bertrand, Claude Delpuech, and Jacques Pernier. 1996. “Stimulus Specificity of Phase-Locked and Non-Phase-Locked 40 Hz Visual Responses in Human.” Journal of Neuroscience 16 (13): 4240–49.",
    "crumbs": [
      "Background",
      "Mathematical Deep Dive"
    ]
  },
  {
    "objectID": "background/0_tour.html",
    "href": "background/0_tour.html",
    "title": "Onboarding",
    "section": "",
    "text": "Morlet wavelets designed for power-spectral analysis of M/EEG\nAnalysis of M/EEG signals in the frequency domain is widely used and has proven useful in various applications. This is due to a key contribution of periodic processes to electrophysiological signals, which are well represented in the frequency domain. Electrophysiological signals (as many other naturally occurring signals) show a log-frequency behavior, i.e., the magnitude and spectral width of oscillatory signals scale logarithmically rather than linearly with frequency (Buzsáki and Mizuseki 2014). The commonly used Fourier transform is optimal for signals with a linear frequency behavior. Frequency transformations that account for log-frequency behavior may be better suited for electrophysiological signals. Morlet wavelets (Morlet et al. 1982) that extend Gabor Wavelets (Gabor 1946) into families of wavelets are widely used for time-frequency analyses in M/EEG (Tallon-Baudry et al. 1996), can be used to this end.\nThis package provides a lean implementation of Morlet wavelets using a frequency-domain parametrization initially developed to facilitate the spectral analysis of M/EEG resting-state signals (Hipp et al. 2012). The package derives besides spectral power also the covariance matrix and several other bi-variate and summary measures (coherence, imaginary coherence, phase-locking value, phase-lag index, de-biased weighted phase-lag index, power correlations, orthogonalized power correlations) and the global interaction measure. These representations can be used for exploration and for further statistical analyses of M/EEG signals (e.g. for cluster permutation statistics or as features for machine learning).",
    "crumbs": [
      "Background",
      "Onboarding"
    ]
  },
  {
    "objectID": "background/0_tour.html#power-spectral-density-in-units-of-µv²oct",
    "href": "background/0_tour.html#power-spectral-density-in-units-of-µv²oct",
    "title": "Onboarding",
    "section": "Power spectral density in units of µV²/oct",
    "text": "Power spectral density in units of µV²/oct\nThe implementation provides the power spectrum in units of \\(µV^2/oct\\). While this is an unusual normalization for power spectral density, it is a logical continuation embracing the logarithmic nature of electrophysiological signals and Jean Morlet’s work extending Gabor wavelets (Gabor 1946) into families of proportionial wavelets (Morlet et al. 1982). It automatically leads to larger values at higher frequencies compared to the traditional \\(µV^2/Hz\\) normalization, thereby accounting for lower amplitudes at higher frequencies.\nWe therefore use a log-frequency grid with a wavelet design that increases spectral smoothing log-linearly with frequency. The implementation parameterizes spectral spacing and smoothing in units of octaves (delta_oct and bw_oct). We provide a python and a Matlab implementation. In the following we describe the python version.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport meeglet\nfrom meeglet import define_frequencies, define_wavelets\n\nbw_oct = 0.5 # half an octave of standard deviation around center frequency\ndelta_oct = 1 # one octave spacing between frequencies of interest (foi)\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, delta_oct=delta_oct, bw_oct=bw_oct\n)\n\nThe first step prepares frequencies of interest, foi, for which Morlet wavelets are constructed.\n\nwavelets  = define_wavelets(foi, sigma_time, sfreq=1000)\n\nfig, axes = plt.subplots(len(wavelets), sharex=True)\naxes = list(reversed(axes))\ncolors = plt.cm.viridis(np.linspace(0.1, 0.9, len(wavelets)))\n\nfor ii, (w, *_) in enumerate(wavelets):\n    w_range = np.arange(len(w)) - len(w)/2\n    axes[ii].plot(w_range, w.real, color=colors[ii])\n    axes[ii].plot(w_range, w.imag, color=colors[ii], linestyle='--', alpha=0.7)\n    axes[ii].set_title(f'{foi[ii]} Hz', y=0.5, x=0.1)\n\nplt.xlabel(\"Time (ms)\")\n\nText(0.5, 0, 'Time (ms)')\n\n\n\n\n\n\n\n\n\nThe Morlet wavelets are widest in lower frequencies and shorter in higher frequencies. Note also that the number of cycles is constant across wavelets, which is in line with Jean Morlet’s original work (Morlet et al. 1982) as it is controlled by the kernel width.\nIn addition, our Morlet wavelet family does not only have a log-linearly increasing spectral width and a log-linearly decreasing temporal width, but spacing between frequencies increases log-linearly, i.e., increasingly fewer wavelets are deployed at higher frequencies. The spectral distance between two wavelets, i.e. spacing, is expressed in octaves, hence, log-linear too. This is a natural choice and ensures efficient spectral sampling.\n\ndelta_foi = np.c_[\n    2 ** (np.log2(foi) - delta_oct / 2), \n    2 ** (np.log2(foi) + delta_oct / 2)\n]\nplt.figure()\nplt.loglog(foi, sigma_freq, marker='o', base=2, label=r'$\\sigma_f$', color='orange')\nplt.loglog(foi, sigma_time, marker='o', base=2, label=r'$\\sigma_t$', color='steelblue')\nplt.loglog(delta_foi.T,  np.c_[sigma_freq, sigma_freq].T, color='orange')\nplt.loglog(delta_foi.T, np.c_[sigma_time, sigma_time].T, color='steelblue')\n\nplt.legend()\nplt.xticks(ticks=foi, labels=foi)\nplt.xlabel('Frequency (Hz)')\nplt.ylabel(r'Bandwidth of Wavelet (temporal: $\\sigma_t$, spectral: $\\sigma_f$)')\nplt.grid(True)",
    "crumbs": [
      "Background",
      "Onboarding"
    ]
  },
  {
    "objectID": "background/0_tour.html#key-features-of-this-morlet-wavelet-implementation",
    "href": "background/0_tour.html#key-features-of-this-morlet-wavelet-implementation",
    "title": "Onboarding",
    "section": "Key features of this Morlet wavelet implementation",
    "text": "Key features of this Morlet wavelet implementation\n\nFocused on power-spectral analysis of resting-state EEG (not time-frequency analysis) and proven useful in past pharmacological research & clinical applications.\nThe log-linear parametrization in octaves enables intuitive reasoning about frequencies of interest.\nHelps avoid thinking in (arbitrary) frequency bands while expressing prior knowledge about log-linear scaling of brain structure and function (Buzsáki and Mizuseki 2014).\nThe main reason for using a frequency domain representation based on Morlet wavelets over widely used Fourier transform based approaches is that the Fourier transform implies a linear grid and constant spectral width and is therefore not optimal for log-frequency scaling of electrophysiological signals.\nA simple time-domain convolution is implemented, whereas other implementations use convolutions in the frequency domain for improved speed (Cohen 2019; Gramfort et al. 2013). In our experience, computation tis are not an issue when using modern computers.\nAs a consequence, our implementation makes ignoring bad segments labeled as missing (NaN) straight forward, propagating the number of effective samples to down-stream statistics like power or covariance.\nBeing Morlet wavelets, the kernel families that can be obtained from our package can be used with other convolution implementations, if desired. This is explicitly supported by our API, supported by convenient visualization functionality.\nOur package provides practically tested implementations of popular spectral metrics based on the same Wavelet convolutions (see next section).\nUnit tests establish that Python and MATLAB code provide numerically equivalent results.",
    "crumbs": [
      "Background",
      "Onboarding"
    ]
  },
  {
    "objectID": "background/0_tour.html#overview-on-implemented-meeg-spectral-metrics",
    "href": "background/0_tour.html#overview-on-implemented-meeg-spectral-metrics",
    "title": "Onboarding",
    "section": "Overview on implemented M/EEG spectral metrics",
    "text": "Overview on implemented M/EEG spectral metrics\n\nPower measures\n\npow: power spectral density\ncsd: cross-spectral density\ncov: covariance estimated from wavelet convolutons (Bomatter et al. 2023)\n\n\n\nMeasures of phase interaction (mixed, coherence type)\n\ncoh: coherence (Varela et al. 2001)\nicoh: imaginary coherence (Nolte et al. 2004)\ngim: global interaction measure (Ewald et al. 2012)\n\n\n\nMore specific measures of phase interaction\n\nplv: phase-locking value (Lachaux et al. 1999)\npli: phase-locking index (Stam, Nolte, and Daffertshofer 2007)\ndwpli: debiased squared weighted phase-lag index (Vinck et al. 2011)\n\n\n\nPower envelope correlations\n\nr_plain: power envelope correlation (log of rectified wavelet-convoluted timeseries) (Hipp et al. 2012)\nr_orth: orthogonalized power envelope correlation (Hipp et al. 2012)",
    "crumbs": [
      "Background",
      "Onboarding"
    ]
  },
  {
    "objectID": "background/index.html",
    "href": "background/index.html",
    "title": "Scientific Background",
    "section": "",
    "text": "Onboarding\n\n\n\n\n\n\n\n\n\n\n\n\n\nMathematical Deep Dive\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Background"
    ]
  },
  {
    "objectID": "matlab/matlab_functions.html",
    "href": "matlab/matlab_functions.html",
    "title": "MATLAB functionality",
    "section": "",
    "text": "We perform the same computations using MATLAB.\nWith a few exceptions, the arguments are named the same.\nThe same default options are set.\nThe examples below processes the MNE sample EEG data in MATLAB and then computes power spectra as in the EEG power.",
    "crumbs": [
      "MATLAB",
      "MATLAB functionality"
    ]
  },
  {
    "objectID": "matlab/matlab_functions.html#loading-the-matlab-functions.",
    "href": "matlab/matlab_functions.html#loading-the-matlab-functions.",
    "title": "MATLAB functionality",
    "section": "Loading the matlab functions.",
    "text": "Loading the matlab functions.\n\naddpath('./matlab')\n\n\nfprintf('MATLAB version\\n')\nversion\n\nMATLAB version\n\n\nans = '9.11.0.1809720 (R2021b) Update 1'",
    "crumbs": [
      "MATLAB",
      "MATLAB functionality"
    ]
  },
  {
    "objectID": "matlab/matlab_functions.html#load-mne-samlpe-eeg-data",
    "href": "matlab/matlab_functions.html#load-mne-samlpe-eeg-data",
    "title": "MATLAB functionality",
    "section": "load MNE samlpe EEG data",
    "text": "load MNE samlpe EEG data\n\n[status, data_path] = system('python -c \"import mne; print(mne.datasets.sample.data_path(), end=str())\"')\n\nstatus = 0\n\n\ndata_path = '/Users/engemand/mne_data/MNE-sample-data'\n\n\n\nfname = strcat(data_path, '/MEG', '/sample', '/sample_audvis_raw.fif');\n\n\nraw = fiff_setup_read_raw(fname);\n\nOpening raw data file /Users/engemand/mne_data/MNE-sample-data/MEG/sample/sample_audvis_raw.fif...\n    Read a total of 3 projection items:\n        PCA-v1 (1 x 102) idle\n        PCA-v2 (1 x 102) idle\n        PCA-v3 (1 x 102) idle\n    Range : 25800 ... 192599  =     42.956 ...   320.670 secs\nReady.\n\n\n\npicks_eeg = fiff_pick_types(raw.info, 0, 1);\npicks_eeg(53) = [];  % flat channel EEG 53\n\n\n[data, times] = fiff_read_raw_segment(raw, raw.first_samp, raw.last_samp, picks_eeg);\n\nReading 25800 ... 192599  =     42.956 ...   320.670 secs... [done]\n\n\n\ndata = data - mean(data, 1);  %average ref for comparability with Python example\n\n\nplot(data(1:10,1:3000)' * 1e6)\n\nset(gcf, 'Units', 'inches');\nscreenPosition = get(gcf, 'Position');\nset(gcf, 'Position', [screenPosition(1), screenPosition(2), 8, 4]);\nylabel('EEG [${\\mu V}$]', 'Interpreter','latex')\nxlabel('Time [ms]')",
    "crumbs": [
      "MATLAB",
      "MATLAB functionality"
    ]
  },
  {
    "objectID": "matlab/matlab_functions.html#compute-power-from-morlet-wavelets",
    "href": "matlab/matlab_functions.html#compute-power-from-morlet-wavelets",
    "title": "MATLAB functionality",
    "section": "Compute power from Morlet Wavelets",
    "text": "Compute power from Morlet Wavelets\n\nhelp(\"ro_freq_meeglet\")\n\n  meeglet (ver 1.0)\n  Denis Engemann & Jörg Hipp, Feb 2024\n \n  Log-spaced frequency transform using Morlet wavelets for continous\n  electrophysiological signals. Derive power, covariance and various\n  conncetivity metrics\n \n  % Input\n  - dat ... [channels x samples], set invalid data sections to NaN;\n            Input signal needs to have in µV\n  - cfg ... struct, see script itself for default parameters, cfg.fsample\n            has to be set by the user\n  \n  % Output\n  Metrics indicated in cfg.output (default: all)\n  Values returned as fields in struct out:\n  - foi .. frequencies for which below metrics are derived in Hz\n  - n .. number of time-windows used to compute below metrics\n  - cfg .. the cfg struct containing all parameters\n  - unit .. unit of the power spectral density (pow)\n  - pow .. Power spectrum. The total power in µV² for a channel (ich) over\n           the frequency range [cfg.f_start,cfg.f_end] can be derived as:\n           if cfg.density is 'linear'         -&gt; total_power = trapz(foi,pow(ich,:))\n           if cfg.density is 'log2' (default) -&gt; total_power = trapz(log2(foi),pow(ich,:))\n  - csd .. Cross-spectral density matrix\n  - cov .. Covariance matrix, same as real(csd)\n  - coh .. Coherence, compley values use coh.*conj(coh) to derive magnitude squared coherence\n  - icoh .. Imaginary coherence (Nolte et al., Clin Neurophys, 2004); \n            function returns signed values, use abs(icoh) to be line with the original definition\n            is the same as the cross-sepectral density of the orthogonalized signal\n  - plv .. Phase-locking value (Lachaux et al., HBM, 1999)\n  - pli .. Phase lag index (Stam et al., HBM, 2007); function returns signed values,\n           use abs(pli) to be in line with the original definition;\n           is the same as the phase-locking value of the orthognalized signal.\n  - dwpli .. Debiased weighted phase lag index (Vinck et al., NeuroImage 2011)\n  - r_plain .. Power correlation\n  - r_orth .. Orthogonalized power correlation (Hipp et al., Nature Neurosci, 2012)\n  - gim .. Global interaction measure (Ewald et al., NeuroImage, 2012)\n \n  %% Example 1:\n  % Single channel with background noise and sine wave at 10 Hz\n  fsample = 250;\n  T = 60; % [s]\n  n_chan=1;\n  n_sample = T*fsample;\n  t=(0:n_sample-1)/fsample; % [s]\n  f = 10; % Hz\n  rng(0)\n  x=randn(n_chan,n_sample)*10+repmat(sin(2*pi*f*t)*10,[n_chan,1]); % [µV]\n  %\n  clear cfg\n  cfg.fsample = fsample;\n  cfg.delta_oct = 0.05;\n  cfg.foi_start = 0.1; % given parameterization cannot start at 0\n  cfg.foi_end = fsample/2;\n  cfg.density='Hz';\n  % µV²/Hz density\n  freq = ro_freq_meeglet(x,cfg);\n  figure('Color','w')\n  plot(freq.foi,freq.pow,'r')\n  xlabel('Frequency (Hz)'), ylabel(sprintf('%s',freq.unit))\n  % µV²/oct density\n  cfg.density='oct';\n  freq2 = ro_freq_meeglet(x,cfg);\n  %\n  % Test Parseval's theoreme, i.e. power should be identical in time and\n  % frequency domain (note: expected not to numerically match given the parameterization)\n  Pt = mean(x.^2,2);    % time domain; same as sum(x.^2*dt)/T, where dt=1/fsample, T=n_sample*dt\n  Pf_lin = sum(freq.pow(1:end-1).*diff(freq.foi)); % Frequency domain with linear frequency spaceing\n  Pf_log = sum(freq2.pow(1:end-1).*diff(log2(freq2.foi))); % Frequency domain with log frequency spaceing\n  fprintf('Power derived in time and frequency domains:\\nPt = %.1f µV²\\nPf_lin = %.1f µV²\\nPf_log = %.1f µV²\\n',Pt,Pf_lin,Pf_log)\n \n  %% Example 2:\n  % Artificial signal with background noise on 19 channels and two coherent sine-waves at two channels\n  fsample = 250; % [Hz]\n  T = 60; % [s]\n  n_chan = 19;\n  n_sample = T*fsample;\n  t=(0:n_sample-1)/fsample; % [s]\n  f = 10; % [Hz]\n  rng(0)\n  x=cumsum(randn(n_chan,n_sample),2); x=5*x./repmat(std(x,[],2),[1,size(x,2)]); % pink noise\n  x(1,:) = x(1,:)+sin(2*pi*f*t);\n  x(10,:) = x(10,:)+sin(2*pi*f*t+pi/4);\n  %\n  clear cfg\n  cfg.output={'pow','coh','icoh'};\n  cfg.fsample = fsample;\n  freq = ro_freq_meeglet(x,cfg);\n  %\n  figure('Color','w')\n  h=subplot(2,1,1); plot(log2(freq.foi),mean(freq.pow)), set(h,'XTick',log2(freq.foi(mod(log2(freq.foi),1)==0)),'XTickLabel',freq.foi(mod(log2(freq.foi),1)==0))\n  title('Power spetral density'), xlabel('Frequency [Hz]'), ylabel(freq.unit), a=axis; a(3)=0; axis(a)\n  subplot(2,2,3), imagesc(abs(freq.coh(:,:,20)),[0,1]), axis square, colorbar, title(sprintf('abs(COH), f=%.1fHz',freq.foi(20)))\n  subplot(2,2,4), imagesc(freq.icoh(:,:,20),[-1,1]), axis square, colorbar, title(sprintf('iCOH, f=%.1fHz',freq.foi(20)))\n\n\n\n\ncfg.fsample = raw.info.sfreq;\ncfg.output = {'pow'}\n\ncfg = struct with fields:\n    fsample: 600.6150\n     output: {'pow'}\n\n\n\n\nout = ro_freq_meeglet(data * 1e6,cfg);\n\nMorlet wavelet transform [.................................] 8.1 sec\n\n\n\nout\n\nout = struct with fields:\n           cfg: [1x1 struct]\n           foi: [2 2.1810 2.3784 2.5937 2.8284 3.0844 3.3636 3.6680 4 4.3620 4.7568 5.1874 5.6569 6.1688 6.7272 7.3360 8 8.7241 9.5137 10.3747 11.3137 12.3377 13.4543 14.6721 16 17.4481 19.0273 20.7494 22.6274 24.6754 26.9087 29.3441 32]\n           pow: [59x33 double]\n       pow_var: [59x33 double]\n          unit: 'µV²/oct'\n    pow_median: [59x33 double]\n       pow_geo: [59x33 double]\n             n: [402 439 479 523 570 621 677 741 806 879 961 1046 1139 1241 1353 1473 1616 1752 1914 2082 2281 2486 2687 2923 3204 3472 3787 4167 4505 4902 5377 5748 6412]\n            qt: 6.8624\n        bw_oct: 0.5000\n\n\n\nPlot log power and on log frequency grid\n\nlog_foi = log2(out.foi);\nlog_pow_db = 10 * log10(out.pow);\n\n\nplot(log_foi, log_pow_db')\nxlabel('Frequency [Hz]')\nxticks([1, 2, 3, 4, 5]);\nxticklabels([2, 4, 8, 16, 32]);\nylabel('${10 \\times \\log_{10}(\\mu V ^ 2 / oct)}$','Interpreter','Latex')\n\nset(gcf, 'Units', 'inches');\nscreenPosition = get(gcf, 'Position');\nset(gcf, 'Position', [screenPosition(1), screenPosition(2), 8, 4]);",
    "crumbs": [
      "MATLAB",
      "MATLAB functionality"
    ]
  },
  {
    "objectID": "api/wavelets.html",
    "href": "api/wavelets.html",
    "title": "Morlet Wavelets for M/EEG",
    "section": "",
    "text": "The following functions facilitate defining families of Morlet Wavelets. This is useful to e.g. plot or analyze properties of the wavelets us ed for feature extraction. These functions are used internally by the feature-computation functions below.\n\n\n\n\n define_wavelets (foi:numpy.ndarray, sigma_time:numpy.ndarray,\n                  sfreq:float, kernel_width:int=5,\n                  window_shift:float=0.25, density:str='oct')\n\nCompute Morelt Wavelets from frequency-domain parametrization.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfoi\nndarray\n\nThe range of center frequencies.\n\n\nsigma_time\nndarray\n\nThe temporal width (standard deviations) at a given frequency.\n\n\nsfreq\nfloat\n\nThe sampling frequency in Hz.\n\n\nkernel_width\nint\n5\nThe width of the kernel in standard deviations, leading to truncation.\n\n\nwindow_shift\nfloat\n0.25\nControls the spacing of the sliding windows proportionally to the\n\n\ndensity\nstr\noct\nScaling of the power spectrum in Hz or per octave (‘oct’). Defaults to ‘oct’.\n\n\nReturns\nlist\n\nThe list of complex Morlet wavelets alongside the scaling applied, the effective number of samples and the amount of samples shifted in time, ordered by input frequencies.\n\n\n\n\n\n\n\n\n define_frequencies (foi_start:float=2, foi_end:float=32,\n                     delta_oct:Optional[float]=None, bw_oct:float=0.5,\n                     qt:Optional[float]=None, freq_shift_factor:int=1)\n\nConstruct log-space equidistant frequency bins with proportional variance.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfoi_start\nfloat\n2\nThe lowest frequency of interest.\n\n\nfoi_end\nfloat\n32\nThe highest frequency of interest.\n\n\ndelta_oct\nOptional\nNone\nControls the frequency resolution. If None, defaults\n\n\nbw_oct\nfloat\n0.5\nThe bandwidth of the Wavelets in octaves. Larger band width lead to more smoothing.\n\n\nqt\nOptional\nNone\nThe bandwidth of the Wavelets expressed in characteristic Morlet parameter Q (overriding bw_oct).\n\n\nfreq_shift_factor\nint\n1\nAllows shifting the frequency spectrum in logarithmic space (in octave units).\n\n\nReturns\n(&lt;class ‘numpy.ndarray’&gt;, &lt;class ‘numpy.ndarray’&gt;, &lt;class ‘numpy.ndarray’&gt;, &lt;class ‘numpy.ndarray’&gt;)\n\nfoi, the expaneded frequency range, sigma_time, the temporal width (SD), sigma_freq, the spectral width.",
    "crumbs": [
      "Python API",
      "Morlet Wavelets for M/EEG"
    ]
  },
  {
    "objectID": "api/wavelets.html#defnining-families-of-morlet-wavelets",
    "href": "api/wavelets.html#defnining-families-of-morlet-wavelets",
    "title": "Morlet Wavelets for M/EEG",
    "section": "",
    "text": "The following functions facilitate defining families of Morlet Wavelets. This is useful to e.g. plot or analyze properties of the wavelets us ed for feature extraction. These functions are used internally by the feature-computation functions below.\n\n\n\n\n define_wavelets (foi:numpy.ndarray, sigma_time:numpy.ndarray,\n                  sfreq:float, kernel_width:int=5,\n                  window_shift:float=0.25, density:str='oct')\n\nCompute Morelt Wavelets from frequency-domain parametrization.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfoi\nndarray\n\nThe range of center frequencies.\n\n\nsigma_time\nndarray\n\nThe temporal width (standard deviations) at a given frequency.\n\n\nsfreq\nfloat\n\nThe sampling frequency in Hz.\n\n\nkernel_width\nint\n5\nThe width of the kernel in standard deviations, leading to truncation.\n\n\nwindow_shift\nfloat\n0.25\nControls the spacing of the sliding windows proportionally to the\n\n\ndensity\nstr\noct\nScaling of the power spectrum in Hz or per octave (‘oct’). Defaults to ‘oct’.\n\n\nReturns\nlist\n\nThe list of complex Morlet wavelets alongside the scaling applied, the effective number of samples and the amount of samples shifted in time, ordered by input frequencies.\n\n\n\n\n\n\n\n\n define_frequencies (foi_start:float=2, foi_end:float=32,\n                     delta_oct:Optional[float]=None, bw_oct:float=0.5,\n                     qt:Optional[float]=None, freq_shift_factor:int=1)\n\nConstruct log-space equidistant frequency bins with proportional variance.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfoi_start\nfloat\n2\nThe lowest frequency of interest.\n\n\nfoi_end\nfloat\n32\nThe highest frequency of interest.\n\n\ndelta_oct\nOptional\nNone\nControls the frequency resolution. If None, defaults\n\n\nbw_oct\nfloat\n0.5\nThe bandwidth of the Wavelets in octaves. Larger band width lead to more smoothing.\n\n\nqt\nOptional\nNone\nThe bandwidth of the Wavelets expressed in characteristic Morlet parameter Q (overriding bw_oct).\n\n\nfreq_shift_factor\nint\n1\nAllows shifting the frequency spectrum in logarithmic space (in octave units).\n\n\nReturns\n(&lt;class ‘numpy.ndarray’&gt;, &lt;class ‘numpy.ndarray’&gt;, &lt;class ‘numpy.ndarray’&gt;, &lt;class ‘numpy.ndarray’&gt;)\n\nfoi, the expaneded frequency range, sigma_time, the temporal width (SD), sigma_freq, the spectral width.",
    "crumbs": [
      "Python API",
      "Morlet Wavelets for M/EEG"
    ]
  },
  {
    "objectID": "api/wavelets.html#computing-spectral-features-from-families-of-morlet-wavelets.",
    "href": "api/wavelets.html#computing-spectral-features-from-families-of-morlet-wavelets.",
    "title": "Morlet Wavelets for M/EEG",
    "section": "Computing spectral features from families of Morlet Wavelets.",
    "text": "Computing spectral features from families of Morlet Wavelets.\nThe following functions provide NumPy and an MNE interfaces for computing spectral features features from M/EEG input signals for a defined family of Morlet wavelets.\nThe spectral measures implemented include:\n\nPower measures\n\npow: power spectral density\ncsd: cross-spectral density\ncov: covariance estimated from wavelet convolutons (Bomatter et al. 2023)\n\n\n\nMeasures of phase interaction (mixed, coherence type)\n\ncoh: coherence (Varela et al. 2001)\nicoh: imaginary coherence (Nolte et al. 2004)\ngim: global interaction measure (Ewald et al. 2012)\n\n\n\nMore specific measures of phase interaction\n\nplv: phase-locking value (Lachaux et al. 1999)\npli: phase-locking index (Stam, Nolte, and Daffertshofer 2007)\ndwpli: debiased squared weighted phase-lag index (Vinck et al. 2011)\n\n\n\nPower envelope correlations\n\nr_plain: power envelope correlation (log of rectified wavelet-convoluted timeseries) (Hipp et al. 2012)\nr_orth: orthogonalized power envelope correlation (Hipp et al. 2012)\n\n\n\n\ncompute_spectral_features\n\n compute_spectral_features\n                            (inst:Union[mne.io.fiff.raw.Raw,mne.epochs.Epo\n                            chs], delta_oct:Optional[float]=None,\n                            bw_oct:float=0.5, qt:Optional[float]=None,\n                            foi_start:float=2, foi_end:float=32,\n                            window_shift:float=0.25, kernel_width:int=5,\n                            freq_shift_factor:int=1,\n                            allow_fraction_nan:int=0,\n                            features:Union[tuple,list]=('pow',),\n                            density:str='oct',\n                            nan_from_annotations:bool=False,\n                            prepend_nan_epochs:bool=False,\n                            rank:Optional[int]=None,\n                            verbose:Union[bool,int,str]=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninst\nUnion\n\nAn MNE object representing raw (continous) or epoched data.\n\n\ndelta_oct\nOptional\nNone\nControls the frequency resolution. If None, defaults\n\n\nbw_oct\nfloat\n0.5\nThe bandwidth of the Wavelets in octaves. Larger band width lead to more smoothing.\n\n\nqt\nOptional\nNone\nThe bandwidth of the Wavelets expressed in characteristic Morlet parameter Q (overriding bw_oct).\n\n\nfoi_start\nfloat\n2\nThe lowest frequency of interest.\n\n\nfoi_end\nfloat\n32\nThe highest frequency of interest.\n\n\nwindow_shift\nfloat\n0.25\nControls the spacing of the sliding windows proportionally to the\n\n\nkernel_width\nint\n5\nThe width of the kernel in standard deviations, leading to truncation.\n\n\nfreq_shift_factor\nint\n1\nAllows shifting the frequency spectrum in logarithmic space (in octave units).\n\n\nallow_fraction_nan\nint\n0\nThe fraction of NA values allowed.\n\n\nfeatures\nUnion\n(‘pow’,)\nThe spectral featueres to be computed.\n\n\ndensity\nstr\noct\nScaling of the power spectrum in Hz or per octave (‘oct’). Defaults to ‘oct’.\n\n\nnan_from_annotations\nbool\nFalse\nIf annotations should be converted to missing values. Currently only\n\n\nprepend_nan_epochs\nbool\nFalse\nWhether to add a Nan value at the beginning of each epoch to avoid boundary artifacts.\n\n\nrank\nOptional\nNone\nnumeric rank of the input\n\n\nverbose\nUnion\nFalse\nmne.verbose for details. Should only be passed as a keyword argument.\n\n\nReturns\n(&lt;class ‘types.SimpleNamespace’&gt;, &lt;class ‘types.SimpleNamespace’&gt;)\n\nThe features with, e.g., .pow, .cov as attributes\n\n\n\n\n\n\ncompute_spectral_features_array\n\n compute_spectral_features_array (data:numpy.ndarray, sfreq:float,\n                                  delta_oct:Optional[float]=None,\n                                  bw_oct:float=0.5,\n                                  qt:Optional[float]=None,\n                                  foi_start:float=2, foi_end:float=32,\n                                  window_shift:float=0.25,\n                                  kernel_width:int=5,\n                                  freq_shift_factor:int=1,\n                                  allow_fraction_nan:int=0,\n                                  features:Union[tuple,list]=('pow',),\n                                  density:str='oct',\n                                  rank:Optional[int]=None,\n                                  verbose:Union[bool,int,str]=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndata\nndarray\n\nThe continously sampled input data (may contain NaNs),\n\n\nsfreq\nfloat\n\nThe sampling frequency in Hz.\n\n\ndelta_oct\nOptional\nNone\nControls the frequency resolution. If None, defaults\n\n\nbw_oct\nfloat\n0.5\nThe bandwidth of the Wavelets in octaves. Larger band width lead to more smoothing.\n\n\nqt\nOptional\nNone\nThe bandwidth of the Wavelets expressed in characteristic Morlet parameter Q (overriding bw_oct).\n\n\nfoi_start\nfloat\n2\nThe lowest frequency of interest.\n\n\nfoi_end\nfloat\n32\nThe highest frequency of interest.\n\n\nwindow_shift\nfloat\n0.25\nControls the spacing of the sliding windows proportionally to the\n\n\nkernel_width\nint\n5\nThe width of the kernel in standard deviations, leading to truncation.\n\n\nfreq_shift_factor\nint\n1\nAllows shifting the frequency spectrum in logarithmic space (in octave units).\n\n\nallow_fraction_nan\nint\n0\nThe fraction of NA values allowed.\n\n\nfeatures\nUnion\n(‘pow’,)\nThe spectral featueres to be computed.\n\n\ndensity\nstr\noct\nScaling of the power spectrum in Hz or per octave (‘oct’). Defaults to ‘oct’.\n\n\nrank\nOptional\nNone\nnumeric rank of the input\n\n\nverbose\nUnion\nFalse\nmne.verbose for details. Should only be passed as a keyword argument.\n\n\nReturns\n(&lt;class ‘types.SimpleNamespace’&gt;, &lt;class ‘types.SimpleNamespace’&gt;)\n\nThe features with, e.g., .pow, .cov as attributes",
    "crumbs": [
      "Python API",
      "Morlet Wavelets for M/EEG"
    ]
  },
  {
    "objectID": "api/wavelets.html#helper-functions",
    "href": "api/wavelets.html#helper-functions",
    "title": "Morlet Wavelets for M/EEG",
    "section": "Helper functions",
    "text": "Helper functions\nTo facilitate the integration with the MNE workflow, a simple wrapper can map outputs to the MNE Spectrum class.\n\n\nspectrum_from_features\n\n spectrum_from_features (data:numpy.ndarray, freqs:numpy.ndarray,\n                         inst_info:mne._fiff.meas_info.Info)\n\nCreate MNE averaged power spectrum object from features\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndata\nndarray\nspectral features, e.g. power, shape(n_channels, n_frequencies)\n\n\nfreqs\nndarray\nfrequencies, shape(n_frequencies)\n\n\ninst_info\nInfo\nthe meta data of the MNE instance used for computing the features\n\n\nReturns\nSpectrum\nthe MNE power spectrum object\n\n\n\nVectorized correlation coefficients.\n\n\n\nro_corrcoef\n\n ro_corrcoef (x:numpy.ndarray, y:numpy.ndarray, dim:int)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nx\nndarray\nthe seed (assuming time samples on last axis)\n\n\ny\nndarray\nthe targets (assuming time samples on last axis)\n\n\ndim\nint\nnumber of dimensions\n\n\nReturns\nSimpleNamespace\nthe computed correlation values and statistics:\n\n\n\n\nfrom scipy.linalg import svd\n\n\ndef ro_pinv(\n        A: np.ndarray,  # 2d matrix\n        r: Union[int, None]=None,  # numeric rank\n    ) -&gt; np.ndarray:  # the pseudoinverse of A\n    if r is None:\n        r = A.shape[0]\n    U, s, Vt = svd(A, full_matrices=False)\n\n    s_inv = np.diag(1 / s[:r])\n\n    X = Vt.T[:, :r] @ s_inv @ U[:, :r].T\n    return X\n\nA = np.array(\n   [[-1.6747, -0.4051, 1.5477],\n    [-0.7688, -0.5308, 0.6110],\n    [-1.6105, 0.3157, -0.1422]]\n)\n\nA_inv = ro_pinv(A)\n\nassert np.allclose(A, ro_pinv(A_inv))\nassert np.allclose(A @ A_inv, np.eye(3))\nassert np.allclose(A_inv @ A, np.eye(3))\nA_inv\n\narray([[ 0.11085518, -0.40693121, -0.54194378],\n       [ 1.03227358, -2.57819711,  0.15732342],\n       [ 1.03626232, -1.1151485 , -0.54523585]])\n\n\n\n\n\nbw2qt\n\n bw2qt (bw:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nbw\nfloat\nthe Wavelet’s bandwidth\n\n\nReturns\nfloat\ncharacteristic Morlet parameter\n\n\n\n\n\n\nqt2bw\n\n qt2bw (qt:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nqt\nfloat\ncharacteristic Morlet parameter\n\n\nReturns\nfloat\nthe Wavelet’s bandwidth\n\n\n\n\n\nPlot time and frequency domain representations of the Morlet wavelet family.\n\n\n\nplot_wavelet_family\n\n plot_wavelet_family (wavelets:list, foi:numpy.ndarray,\n                      sampling_rate:float=1000.0, cmap:matplotlib.colors.C\n                      olormap=&lt;matplotlib.colors.ListedColormap object at\n                      0x164daee60&gt;, f_scale:str='linear',\n                      scale:Union[float,int]=4, fmin:Union[float,int]=0,\n                      fmax:Union[float,int]=120)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nwavelets\nlist\n\nList of wavelets and associated parameters.\n\n\nfoi\nndarray\n\nFrequencies of interest.\n\n\nsampling_rate\nfloat\n1000.0\nWavelet frequency. Inverse of the time separating two points.\n\n\ncmap\nColormap\n&lt;matplotlib.colors.ListedColormap object at 0x164daee60&gt;\nColormap.\n\n\nf_scale\nstr\nlinear\nX-axis scale for the power spectra. ‘log’ | ‘linear’.\n\n\nscale\nUnion\n4\nWindow scaling factor. If &lt;1 the wavelet will be cropped. If &gt;1 wavelet will be padded with 0 leading to a smoother frequency domain representation.\n\n\nfmin\nUnion\n0\nMin frequency to display.\n\n\nfmax\nUnion\n120\nMax frequency to display,\n\n\nReturns\nFigure\n\n\n\n\n\n\nbw_oct = 0.5\ndelta_oct = 0.5  # one octave spacing between frequencies of interest (foi)\nsampling_rate = 1e3\nfoi, sigma_time, sigma_freq, *_ = define_frequencies(\n    foi_start=5, foi_end=120, delta_oct=delta_oct, bw_oct=bw_oct\n)\nwavelets = define_wavelets(\n    foi,\n    sigma_time,\n    sfreq=sampling_rate\n)\nplot_wavelet_family(wavelets, foi)\nplt.show()\n\n\n\n\n\n\n\n\nThis helper computes correlation coefficients and related statistics, including hypothesis tests from input vectors or matricess. The correlations are between either the input vector x and vector y or all columns of y or between each column of x and the corresponding colymn in y with the same index.\n\nrng = np.random.RandomState(42)\nx = rng.random_sample((100, 1)).T \ny = rng.random_sample((100, 3)).T\nout = ro_corrcoef(x, y, 2)\nprint(out.r)  # correlation between pairs of columns in x and y\nprint(out.p)  # associated p values\n\n[-0.14794559  0.10328645  0.03207745]\n[0.14184577 0.30648903 0.75137784]",
    "crumbs": [
      "Python API",
      "Morlet Wavelets for M/EEG"
    ]
  },
  {
    "objectID": "api/wavelets.html#more-unit-tests-and-validation",
    "href": "api/wavelets.html#more-unit-tests-and-validation",
    "title": "Morlet Wavelets for M/EEG",
    "section": "More unit tests and validation",
    "text": "More unit tests and validation\nThe tests below establish equivalence up to a given decimal with the original Matlab code.\n\ndef read_testing_data():\n    raw = mne.io.read_raw(\n        mne.datasets.testing.data_path() / 'MEG/sample/sample_audvis_trunc_raw.fif'\n    )\n    raw.pick('eeg')\n    raw.drop_channels('EEG 053')\n    raw.load_data()\n    return raw\n\ndef get_matlab_results():\n    testing_path =  Path().cwd() / 'data'\n    matlab_results = loadmat(\n        testing_path / 'mne_meeglet_testing_data.mat', squeeze_me=True\n    )\n    mat_results = [\n        matlab_results[f'out{kk}'] for kk in (1, 2, 3)\n    ]\n    return mat_results, matlab_results\n\n\nif False:  # testing & exploring testing data\n    raw = read_testing_data()\n    plt.figure(figsize=(10, 6))\n    plt.plot(raw.times, read_testing_data().get_data().T * 1e6);\n    plt.ylabel(f'EEG $\\mu V$')\n    plt.xlabel('Time [s]')\n    plt.xlim(0, raw.times[-1]);\n    plt.ylim(-100, 200);\n\n\ndef test_compare_matlab_vs_python():\n    \"Test spectral features array-interface against Matlab implementation.\"\n    \n    raw = read_testing_data()\n    \n    dat = raw.get_data() * 1e6\n    dat[:, 4999:5050] = np.nan\n    \n    sfreq = raw.info['sfreq']\n    print(\n        dat.shape,\n        sfreq\n    )\n        \n    mat_results, matlab_results = get_matlab_results()\n        \n    features = [\n        'pow', 'pow_geo', 'pow_median', 'pow_var', 'csd', 'cov', 'gim',\n        'coh', 'icoh', 'plv', 'pli', 'dwpli', 'r_plain', 'r_orth'\n    ]\n    \n    cfg1 = dict(\n        data=dat,\n        sfreq=sfreq,\n        bw_oct=0.5,\n        foi_start=2,\n        foi_end=32,\n        window_shift=0.25,\n        kernel_width=5,\n        allow_fraction_nan=0,\n        freq_shift_factor=1,\n        features=features,\n        density='oct'\n    )\n    cfg2 = dict(cfg1)\n    cfg2['density'] = 'Hz'\n    cfg2['bw_oct'] = None\n    cfg2['qt'] = 7\n    \n    cfg3 = dict(cfg1)\n    cfg3['allow_fraction_nan'] = 0.1\n    cfg3['rank'] = 20\n    \n    out1, info1 = compute_spectral_features_array(**cfg1)\n    # test that basic frequency definitions & valid samples match\n    assert_array_almost_equal(\n        info1.foi, \n        matlab_results['out1']['foi'].ravel()[0]\n    )\n    assert_array_almost_equal(\n        info1.n_valid_total, \n        matlab_results['out1']['n'].ravel()[0]\n    )\n    assert_array_almost_equal(\n        info1.qt, \n        matlab_results['out1']['qt'].ravel()[0]\n    )\n    \n    assert_array_almost_equal(\n        info1.bw_oct, \n        matlab_results['out1']['bw_oct'].ravel()[0]\n    )\n    \n    out2, _ = compute_spectral_features_array(**cfg2)\n    out3, _ = compute_spectral_features_array(**cfg3)\n    \n    # with nans, powers should be different if nans are present VS not present.\n    assert np.any(np.not_equal(out1.pow, out3.pow))\n    \n    pyt_results = [out1, out2, out3]\n    \n    for ii, (mat_res, pyt_res) in enumerate(zip(mat_results, pyt_results)):\n        for meas in features:\n            decimal = {\n                'pow': 12,\n                'pow_geo': 13,\n                'pow_median': 13,\n                'pow_var': 9,\n                'csd': 12,\n                'cov': 12,\n                'gim': 8 if ii &lt; 2 else 12,\n                'coh': 14,\n                'icoh': 14,\n                'plv': 14,\n                'pli': 14, # XXX\n                'dwpli': 13,\n                'r_plain': 10,\n                'r_orth': 10\n            }[meas]\n            x = mat_res[meas].tolist()\n            y = getattr(pyt_res, meas)\n            if meas in ('r_orth'):  # handle diagonals\n                for ii in range(x.shape[-1]):\n                    x[..., ii].flat[::x.shape[0] + 1] = np.nan\n                for ii in range(y.shape[-1]):\n                    y[..., ii].flat[::y.shape[0] + 1] = np.nan\n            x_flat = x.flatten()\n            y_flat = y.flatten()\n            assert_array_almost_equal(x_flat, y_flat, decimal=decimal)\n    cfg4 = dict(cfg3)\n\ntest_compare_matlab_vs_python()\n\nOpening raw data file /Users/engemand/mne_data/MNE-testing-data/MEG/sample/sample_audvis_trunc_raw.fif...\n    Read a total of 4 projection items:\n        PCA-v1 (1 x 102)  idle\n        PCA-v2 (1 x 102)  idle\n        PCA-v3 (1 x 102)  idle\n        Average EEG reference (1 x 60)  idle\n    Range : 12900 ... 18906 =     42.956 ...    62.955 secs\nReady.\nRemoving projector &lt;Projection | PCA-v1, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v2, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v3, active : False, n_channels : 102&gt;\nReading 0 ... 6006  =      0.000 ...    20.000 secs...\n(59, 6007) 300.3074951171875\n\n\n\n@requires_testing_data\ndef test_meg_eeg_data_handling():\n    \"Test handling of appropriate input data\"\n\n    fname = (Path(mne.datasets.testing.data_path()) / 'MEG' / 'sample' /\n             'sample_audvis_trunc_raw.fif')\n    raw = mne.io.read_raw_fif(fname).load_data()\n\n    raw_no_meeg = raw.copy().pick(['stim'])\n    # test type handling: no relvant data\n    with pytest.raises(ValueError) as excinfo:\n        out, info = compute_spectral_features(raw_no_meeg)\n    assert \"Currently only supporting EEG or MEG data\" in str(excinfo.value)\n    del raw_no_meeg\n\n    # test type handling: data types not unique\n    raw_grad_mag = raw.copy().pick(['meg'])\n    for this_raw in (raw, raw_grad_mag):\n        with pytest.raises(ValueError) as excinfo:\n            out, info = compute_spectral_features(this_raw)\n        assert ('Currently only supporting unique sensor types at once. '\n                'Please pick your data types.') in str(excinfo.value)\n    del raw_grad_mag\n\n    # Test setting of correct units\\\n    data = [raw.copy().pick(['eeg']),\n            raw.copy().pick(['mag']),\n            raw.copy().pick(['grad'])]\n    for density in ('Hz', 'oct'):\n        for this_raw, data_type in zip(data, ('eeg', 'mag', 'grad')):\n            out, info = compute_spectral_features(this_raw, density=density)\n            data_unit = ''\n            if 'eeg' in this_raw:\n                data_unit = 'V'\n            elif 'mag' in this_raw:\n                data_unit = 'T'\n            elif 'grad' in this_raw:\n                data_unit = 'T/cm'\n            data_unit_expected = f'{data_unit}²/{\"Hz\" if density == \"Hz\" else \"oct\"}'\n            assert info.unit == data_unit_expected\n\ntest_meg_eeg_data_handling()\n\nOpening raw data file /Users/engemand/mne_data/MNE-testing-data/MEG/sample/sample_audvis_trunc_raw.fif...\n    Read a total of 4 projection items:\n        PCA-v1 (1 x 102)  idle\n        PCA-v2 (1 x 102)  idle\n        PCA-v3 (1 x 102)  idle\n        Average EEG reference (1 x 60)  idle\n    Range : 12900 ... 18906 =     42.956 ...    62.955 secs\nReady.\nReading 0 ... 6006  =      0.000 ...    20.000 secs...\nRemoving projector &lt;Projection | PCA-v1, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v2, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v3, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | Average EEG reference, active : False, n_channels : 60&gt;\nRemoving projector &lt;Projection | Average EEG reference, active : False, n_channels : 60&gt;\nRemoving projector &lt;Projection | PCA-v1, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v2, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v3, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | Average EEG reference, active : False, n_channels : 60&gt;\nRemoving projector &lt;Projection | PCA-v1, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v2, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v3, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | Average EEG reference, active : False, n_channels : 60&gt;\n\n\n\ndef test_regularized_covariance():\n    \"Test spectral features array-interface against Matlab implementation.\"\n    matlab_results = get_matlab_results()\n\n    raw = read_testing_data()\n    dat = raw.get_data() * 1e6\n    dat[:, 4999:5050] = np.nan\n    \n    cfg1 = dict(\n        data=dat,\n        sfreq=raw.info['sfreq'],\n        bw_oct=0.5,\n        foi_start=2,\n        foi_end=32,\n        window_shift=0.25,\n        kernel_width=5,\n        allow_fraction_nan=0,\n        freq_shift_factor=1,\n        features=('cov', 'cov_oas'),\n        density='oct'\n    )\n    out1, info = compute_spectral_features_array(**cfg1)\n    # short data, ill conditioned covariances ...\n    assert not all(pyriemann.utils.test.is_pos_def(C) for C in out1.cov.T)\n    # ... fixed by regularization\n    assert all(pyriemann.utils.test.is_pos_def(C) for C in out1.cov_oas.T)\n\n    # Test that regularization improves matrix rank (affected due to short signal).\n    for ii in range(len(info.foi)):\n        assert np.linalg.matrix_rank(out1.cov[..., ii] &lt; out1.cov_oas[..., ii])\n        assert np.linalg.matrix_rank(out1.cov_oas[..., ii]) == dat.shape[0]\n\ntest_regularized_covariance()\n\nOpening raw data file /Users/engemand/mne_data/MNE-testing-data/MEG/sample/sample_audvis_trunc_raw.fif...\n    Read a total of 4 projection items:\n        PCA-v1 (1 x 102)  idle\n        PCA-v2 (1 x 102)  idle\n        PCA-v3 (1 x 102)  idle\n        Average EEG reference (1 x 60)  idle\n    Range : 12900 ... 18906 =     42.956 ...    62.955 secs\nReady.\nRemoving projector &lt;Projection | PCA-v1, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v2, active : False, n_channels : 102&gt;\nRemoving projector &lt;Projection | PCA-v3, active : False, n_channels : 102&gt;\nReading 0 ... 6006  =      0.000 ...    20.000 secs...",
    "crumbs": [
      "Python API",
      "Morlet Wavelets for M/EEG"
    ]
  },
  {
    "objectID": "tutorials/plot_wavelets.html",
    "href": "tutorials/plot_wavelets.html",
    "title": "Define Wavelets",
    "section": "",
    "text": "In this tutorial we present the meeglet for creating wavelets API for creating wavelets.\nFor a deep-dive into mathematical background and comparison against alternative definitions, please see Morlet wavelet definition\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom meeglet import define_frequencies, define_wavelets, plot_wavelet_family\nThe following examples illustrate default settings and options to change smoothing, number of wavelets, frequency shifts an other options.",
    "crumbs": [
      "Python tutorials",
      "Define Wavelets"
    ]
  },
  {
    "objectID": "tutorials/plot_wavelets.html#default-settings",
    "href": "tutorials/plot_wavelets.html#default-settings",
    "title": "Define Wavelets",
    "section": "Default settings",
    "text": "Default settings\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, bw_oct=0.5, delta_oct=0.5 / 4.0\n)\n\nwavelets = define_wavelets(\n    foi=foi, sigma_time=sigma_time, sfreq=250., density='oct'\n)\n\nplot_wavelet_family(wavelets, foi, fmax=250);\nplt.gcf().set_size_inches(12, 8)",
    "crumbs": [
      "Python tutorials",
      "Define Wavelets"
    ]
  },
  {
    "objectID": "tutorials/plot_wavelets.html#fewer-wavelets",
    "href": "tutorials/plot_wavelets.html#fewer-wavelets",
    "title": "Define Wavelets",
    "section": "Fewer wavelets",
    "text": "Fewer wavelets\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, bw_oct=0.5, delta_oct=0.5\n)\n\nwavelets = define_wavelets(\n    foi=foi, sigma_time=sigma_time, sfreq=250., density='oct'\n)\n\nplot_wavelet_family(wavelets, foi, fmax=250);\nplt.gcf().set_size_inches(12, 8)",
    "crumbs": [
      "Python tutorials",
      "Define Wavelets"
    ]
  },
  {
    "objectID": "tutorials/plot_wavelets.html#fewer-wavelets-narrower-width",
    "href": "tutorials/plot_wavelets.html#fewer-wavelets-narrower-width",
    "title": "Define Wavelets",
    "section": "Fewer wavelets, narrower width",
    "text": "Fewer wavelets, narrower width\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, bw_oct=0.25, delta_oct=0.5\n)\n\nwavelets = define_wavelets(\n    foi=foi, sigma_time=sigma_time, sfreq=250., density='oct'\n)\n\nplot_wavelet_family(wavelets, foi, fmax=250);\nplt.gcf().set_size_inches(12, 8)",
    "crumbs": [
      "Python tutorials",
      "Define Wavelets"
    ]
  },
  {
    "objectID": "tutorials/plot_wavelets.html#fewer-wavelets-clip-kernel",
    "href": "tutorials/plot_wavelets.html#fewer-wavelets-clip-kernel",
    "title": "Define Wavelets",
    "section": "Fewer wavelets, clip kernel",
    "text": "Fewer wavelets, clip kernel\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, bw_oct=0.25, delta_oct=0.5\n)\n\nwavelets = define_wavelets(\n    foi=foi, sigma_time=sigma_time, sfreq=250., density='oct',\n    kernel_width=2\n)\n\nplot_wavelet_family(wavelets, foi, fmax=250);\nplt.gcf().set_size_inches(12, 8)",
    "crumbs": [
      "Python tutorials",
      "Define Wavelets"
    ]
  },
  {
    "objectID": "tutorials/plot_wavelets.html#fewer-wavelets-shift-150",
    "href": "tutorials/plot_wavelets.html#fewer-wavelets-shift-150",
    "title": "Define Wavelets",
    "section": "Fewer wavelets, shift 150%",
    "text": "Fewer wavelets, shift 150%\n\nfoi, sigma_time, sigma_freq, bw_oct, qt = define_frequencies(\n    foi_start=1, foi_end=32, bw_oct=0.25, delta_oct=0.5,\n    freq_shift_factor=1.5\n)\n\nwavelets = define_wavelets(\n    foi=foi, sigma_time=sigma_time, sfreq=250., \n)\n\nplot_wavelet_family(wavelets, foi, fmax=250);\nplt.gcf().set_size_inches(12, 8)",
    "crumbs": [
      "Python tutorials",
      "Define Wavelets"
    ]
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Python tutorials",
    "section": "",
    "text": "Define Wavelets\n\n\n\n\n\n\n\n\n\n\n\n\n\nEEG covariance\n\n\n\n\n\n\n\n\n\n\n\n\n\nEEG power\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Python tutorials"
    ]
  }
]