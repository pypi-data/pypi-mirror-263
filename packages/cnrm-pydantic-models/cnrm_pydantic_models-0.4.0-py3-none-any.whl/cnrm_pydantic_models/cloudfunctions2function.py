# generated by datamodel-codegen:
#   filename:  cloudfunctions2function_v1alpha1.json
#   timestamp: 2024-03-18T21:06:52+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field


class BuildConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    build: Optional[str] = Field(
        default=None,
        description='The Cloud Build name of the latest successful\ndeployment of the function.',
    )
    dockerRepository: Optional[str] = Field(
        default=None,
        description='User managed repository created in Artifact Registry optionally with a customer managed encryption key.',
    )
    entryPoint: Optional[str] = Field(
        default=None,
        description='The name of the function (as defined in source code) that will be executed.\nDefaults to the resource name suffix, if not specified. For backward\ncompatibility, if function with given name is not found, then the system\nwill try to use function named "function". For Node.js this is name of a\nfunction exported by the module specified in source_location.',
    )
    environmentVariables: Optional[Dict[str, str]] = Field(
        default=None,
        description='User-provided build-time environment variables for the function.',
    )
    runtime: Optional[str] = Field(
        default=None,
        description='The runtime in which to run the function. Required when deploying a new\nfunction, optional when updating an existing function.',
    )
    source: Optional[Source] = Field(
        default=None, description='The location of the function source code.'
    )
    workerPool: Optional[str] = Field(
        default=None,
        description='Name of the Cloud Build Custom Worker Pool that should be used to build the function.',
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class EventFilter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    attribute: str = Field(
        ...,
        description="'Required. The name of a CloudEvents attribute.\nCurrently, only a subset of attributes are supported for filtering. Use the 'gcloud eventarc providers describe' command to learn more about events and their attributes.\nDo not filter for the 'type' attribute here, as this is already achieved by the resource's 'event_type' attribute.",
    )
    operator: Optional[str] = Field(
        default=None,
        description="Optional. The operator used for matching the events with the value of\nthe filter. If not specified, only events that have an exact key-value\npair specified in the filter are matched.\nThe only allowed value is 'match-path-pattern'.\n[See documentation on path patterns here](https://cloud.google.com/eventarc/docs/path-patterns)'.",
    )
    value: str = Field(
        ...,
        description="Required. The value for the attribute.\nIf the operator field is set as 'match-path-pattern', this value can be a path pattern instead of an exact value.",
    )


class EventTrigger(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    eventFilters: Optional[List[EventFilter]] = Field(
        default=None, description='Criteria used to filter events.'
    )
    eventType: Optional[str] = Field(
        default=None, description='Required. The type of event to observe.'
    )
    pubsubTopic: Optional[str] = Field(
        default=None,
        description='The name of a Pub/Sub topic in the same project that will be used\nas the transport topic for the event delivery.',
    )
    retryPolicy: Optional[str] = Field(
        default=None,
        description='Describes the retry policy in case of function\'s execution failure.\nRetried execution is charged as any other execution. Possible values: ["RETRY_POLICY_UNSPECIFIED", "RETRY_POLICY_DO_NOT_RETRY", "RETRY_POLICY_RETRY"].',
    )
    serviceAccountEmail: Optional[str] = Field(
        default=None, description='The email of the service account for this function.'
    )
    trigger: Optional[str] = Field(
        default=None,
        description='Output only. The resource name of the Eventarc trigger.',
    )
    triggerRegion: Optional[str] = Field(
        default=None,
        description='The region that the trigger will be in. The trigger will only receive\nevents originating in this region. It can be the same\nregion as the function, a different region or multi-region, or the global\nregion. If not provided, defaults to the same region as the function.',
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class ProjectRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The `name` field of a `Project` resource.',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ..., description='Allowed value: The `name` field of a `Project` resource.'
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class RepoSource(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    branchName: Optional[str] = Field(
        default=None, description='Regex matching branches to build.'
    )
    commitSha: Optional[str] = Field(
        default=None, description='Regex matching tags to build.'
    )
    dir: Optional[str] = Field(
        default=None,
        description='Directory, relative to the source root, in which to run the build.',
    )
    invertRegex: Optional[bool] = Field(
        default=None,
        description='Only trigger a build if the revision regex does\nNOT match the revision regex.',
    )
    projectId: Optional[str] = Field(
        default=None,
        description='Immutable. ID of the project that owns the Cloud Source Repository. If omitted, the\nproject ID requesting the build is assumed.',
    )
    repoName: Optional[str] = Field(
        default=None, description='Name of the Cloud Source Repository.'
    )
    tagName: Optional[str] = Field(
        default=None, description='Regex matching tags to build.'
    )


class SecretEnvironmentVariable(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: str = Field(..., description='Name of the environment variable.')
    projectId: str = Field(
        ...,
        description="Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.",
    )
    secret: str = Field(
        ...,
        description='Name of the secret in secret manager (not the full resource name).',
    )
    version: str = Field(
        ...,
        description="Version of the secret (version number or the string 'latest'). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new instances start.",
    )


class SecretVolume(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mountPath: str = Field(
        ...,
        description='The path within the container to mount the secret volume. For example, setting the mountPath as /etc/secrets would mount the secret value files under the /etc/secrets directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount path: /etc/secrets.',
    )
    projectId: str = Field(
        ...,
        description="Project identifier (preferrably project number but can also be the project ID) of the project that contains the secret. If not set, it will be populated with the function's project assuming that the secret exists in the same project as of the function.",
    )
    secret: str = Field(
        ...,
        description='Name of the secret in secret manager (not the full resource name).',
    )
    versions: Optional[List[Version]] = Field(
        default=None,
        description="List of secret versions to mount for this secret. If empty, the latest version of the secret will be made available in a file named after the secret under the mount point.'.",
    )


class ServiceConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allTrafficOnLatestRevision: Optional[bool] = Field(
        default=None,
        description='Whether 100% of traffic is routed to the latest revision. Defaults to true.',
    )
    availableCpu: Optional[str] = Field(
        default=None,
        description='The number of CPUs used in a single container instance. Default value is calculated from available memory.',
    )
    availableMemory: Optional[str] = Field(
        default=None,
        description='The amount of memory available for a function.\nDefaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is\nsupplied the value is interpreted as bytes.',
    )
    environmentVariables: Optional[Dict[str, str]] = Field(
        default=None,
        description='Environment variables that shall be available during function execution.',
    )
    gcfUri: Optional[str] = Field(
        default=None, description='URIs of the Service deployed.'
    )
    ingressSettings: Optional[str] = Field(
        default=None,
        description='Available ingress settings. Defaults to "ALLOW_ALL" if unspecified. Default value: "ALLOW_ALL" Possible values: ["ALLOW_ALL", "ALLOW_INTERNAL_ONLY", "ALLOW_INTERNAL_AND_GCLB"].',
    )
    maxInstanceCount: Optional[int] = Field(
        default=None,
        description='The limit on the maximum number of function instances that may coexist at a\ngiven time.',
    )
    maxInstanceRequestConcurrency: Optional[int] = Field(
        default=None,
        description='Sets the maximum number of concurrent requests that each instance can receive. Defaults to 1.',
    )
    minInstanceCount: Optional[int] = Field(
        default=None,
        description='The limit on the minimum number of function instances that may coexist at a\ngiven time.',
    )
    secretEnvironmentVariables: Optional[List[SecretEnvironmentVariable]] = Field(
        default=None, description='Secret environment variables configuration.'
    )
    secretVolumes: Optional[List[SecretVolume]] = Field(
        default=None, description='Secret volumes configuration.'
    )
    service: Optional[str] = Field(
        default=None, description='Name of the service associated with a Function.'
    )
    serviceAccountEmail: Optional[str] = Field(
        default=None, description='The email of the service account for this function.'
    )
    timeoutSeconds: Optional[int] = Field(
        default=None,
        description='The function execution timeout. Execution is considered failed and\ncan be terminated if the function is not completed at the end of the\ntimeout period. Defaults to 60 seconds.',
    )
    uri: Optional[str] = Field(default=None, description='URI of the Service deployed.')
    vpcConnector: Optional[str] = Field(
        default=None,
        description='The Serverless VPC Access connector that this cloud function can connect to.',
    )
    vpcConnectorEgressSettings: Optional[str] = Field(
        default=None,
        description='Available egress settings. Possible values: ["VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED", "PRIVATE_RANGES_ONLY", "ALL_TRAFFIC"].',
    )


class Source(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    repoSource: Optional[RepoSource] = Field(
        default=None,
        description='If provided, get the source from this location in a Cloud Source Repository.',
    )
    storageSource: Optional[StorageSource] = Field(
        default=None,
        description='If provided, get the source from this location in Google Cloud Storage.',
    )


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buildConfig: Optional[BuildConfig] = Field(
        default=None,
        description='Describes the Build step of the function that builds a container\nfrom the given source.',
    )
    description: Optional[str] = Field(
        default=None, description='User-provided description of a function.'
    )
    eventTrigger: Optional[EventTrigger] = Field(
        default=None,
        description='An Eventarc trigger managed by Google Cloud Functions that fires events in\nresponse to a condition in another service.',
    )
    kmsKeyName: Optional[str] = Field(
        default=None,
        description='Resource name of a KMS crypto key (managed by the user) used to encrypt/decrypt function resources.\nIt must match the pattern projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}.',
    )
    location: str = Field(
        ..., description='Immutable. The location of this cloud function.'
    )
    projectRef: Union[ProjectRef, ProjectRef1] = Field(
        ..., description='The project that this resource belongs to.'
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )
    serviceConfig: Optional[ServiceConfig] = Field(
        default=None, description='Describes the Service being deployed.'
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    environment: Optional[str] = Field(
        default=None, description='The environment the function is hosted on.'
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )
    state: Optional[str] = Field(
        default=None, description='Describes the current state of the function.'
    )
    updateTime: Optional[str] = Field(
        default=None, description='The last update timestamp of a Cloud Function.'
    )
    url: Optional[str] = Field(
        default=None, description='Output only. The deployed url for the function.'
    )


class StorageSource(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucket: Optional[str] = Field(
        default=None, description='Google Cloud Storage bucket containing the source.'
    )
    generation: Optional[int] = Field(
        default=None,
        description='Google Cloud Storage generation for the object. If the generation\nis omitted, the latest generation will be used.',
    )
    object: Optional[str] = Field(
        default=None, description='Google Cloud Storage object containing the source.'
    )


class Version(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str = Field(
        ...,
        description="Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mountPath as '/etc/secrets' and path as secret_foo would mount the secret value file at /etc/secrets/secret_foo.",
    )
    version: str = Field(
        ...,
        description="Version of the secret (version number or the string 'latest'). It is preferable to use latest version with secret volumes as secret value changes are reflected immediately.",
    )
