# generated by datamodel-codegen:
#   filename:  dlpdeidentifytemplate_v1beta1.json
#   timestamp: 2024-03-18T21:07:50+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import AwareDatetime, BaseModel, ConfigDict, Field


class Bucket(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[Max] = Field(
        default=None,
        description='Upper bound of the range, exclusive; type must match min.',
    )
    min: Optional[Min] = Field(
        default=None,
        description='Lower bound of the range, inclusive. Type should be the same as max if used.',
    )
    replacementValue: ReplacementValue = Field(
        ..., description='Required. Replacement value for this bucket.'
    )


class Bucket1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[Max1] = Field(
        default=None,
        description='Upper bound of the range, exclusive; type must match min.',
    )
    min: Optional[Min1] = Field(
        default=None,
        description='Lower bound of the range, inclusive. Type should be the same as max if used.',
    )
    replacementValue: ReplacementValue1 = Field(
        ..., description='Required. Replacement value for this bucket.'
    )


class Bucket2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[Max2] = Field(
        default=None,
        description='Upper bound of the range, exclusive; type must match min.',
    )
    min: Optional[Min2] = Field(
        default=None,
        description='Lower bound of the range, inclusive. Type should be the same as max if used.',
    )
    replacementValue: ReplacementValue2 = Field(
        ..., description='Required. Replacement value for this bucket.'
    )


class Bucket3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[Max3] = Field(
        default=None,
        description='Upper bound of the range, exclusive; type must match min.',
    )
    min: Optional[Min3] = Field(
        default=None,
        description='Lower bound of the range, inclusive. Type should be the same as max if used.',
    )
    replacementValue: ReplacementValue3 = Field(
        ..., description='Required. Replacement value for this bucket.'
    )


class Bucket4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[Max4] = Field(
        default=None,
        description='Upper bound of the range, exclusive; type must match min.',
    )
    min: Optional[Min4] = Field(
        default=None,
        description='Lower bound of the range, inclusive. Type should be the same as max if used.',
    )
    replacementValue: ReplacementValue4 = Field(
        ..., description='Required. Replacement value for this bucket.'
    )


class Bucket5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[Max5] = Field(
        default=None,
        description='Upper bound of the range, exclusive; type must match min.',
    )
    min: Optional[Min5] = Field(
        default=None,
        description='Lower bound of the range, inclusive. Type should be the same as max if used.',
    )
    replacementValue: ReplacementValue5 = Field(
        ..., description='Required. Replacement value for this bucket.'
    )


class BucketingConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buckets: Optional[List[Bucket]] = Field(
        default=None, description='Set of buckets. Ranges must be non-overlapping.'
    )


class BucketingConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buckets: Optional[List[Bucket1]] = Field(
        default=None, description='Set of buckets. Ranges must be non-overlapping.'
    )


class BucketingConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buckets: Optional[List[Bucket2]] = Field(
        default=None, description='Set of buckets. Ranges must be non-overlapping.'
    )


class BucketingConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buckets: Optional[List[Bucket3]] = Field(
        default=None, description='Set of buckets. Ranges must be non-overlapping.'
    )


class BucketingConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buckets: Optional[List[Bucket4]] = Field(
        default=None, description='Set of buckets. Ranges must be non-overlapping.'
    )


class BucketingConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    buckets: Optional[List[Bucket5]] = Field(
        default=None, description='Set of buckets. Ranges must be non-overlapping.'
    )


class CharacterMaskConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToIgnore: Optional[List[CharactersToIgnoreItem]] = Field(
        default=None,
        description='When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.',
    )
    maskingCharacter: Optional[str] = Field(
        default=None,
        description='Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.',
    )
    numberToMask: Optional[int] = Field(
        default=None,
        description='Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.',
    )
    reverseOrder: Optional[bool] = Field(
        default=None,
        description='Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.',
    )


class CharacterMaskConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToIgnore: Optional[List[CharactersToIgnoreItem]] = Field(
        default=None,
        description='When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.',
    )
    maskingCharacter: Optional[str] = Field(
        default=None,
        description='Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.',
    )
    numberToMask: Optional[int] = Field(
        default=None,
        description='Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.',
    )
    reverseOrder: Optional[bool] = Field(
        default=None,
        description='Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.',
    )


class CharacterMaskConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToIgnore: Optional[List[CharactersToIgnoreItem]] = Field(
        default=None,
        description='When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.',
    )
    maskingCharacter: Optional[str] = Field(
        default=None,
        description='Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.',
    )
    numberToMask: Optional[int] = Field(
        default=None,
        description='Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.',
    )
    reverseOrder: Optional[bool] = Field(
        default=None,
        description='Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.',
    )


class CharacterMaskConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToIgnore: Optional[List[CharactersToIgnoreItem]] = Field(
        default=None,
        description='When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.',
    )
    maskingCharacter: Optional[str] = Field(
        default=None,
        description='Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.',
    )
    numberToMask: Optional[int] = Field(
        default=None,
        description='Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.',
    )
    reverseOrder: Optional[bool] = Field(
        default=None,
        description='Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.',
    )


class CharacterMaskConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToIgnore: Optional[List[CharactersToIgnoreItem]] = Field(
        default=None,
        description='When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.',
    )
    maskingCharacter: Optional[str] = Field(
        default=None,
        description='Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.',
    )
    numberToMask: Optional[int] = Field(
        default=None,
        description='Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.',
    )
    reverseOrder: Optional[bool] = Field(
        default=None,
        description='Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.',
    )


class CharacterMaskConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToIgnore: Optional[List[CharactersToIgnoreItem]] = Field(
        default=None,
        description='When masking a string, items in this list will be skipped when replacing characters. For example, if the input string is `555-555-5555` and you instruct Cloud DLP to skip `-` and mask 5 characters with `*`, Cloud DLP returns `***-**5-5555`.',
    )
    maskingCharacter: Optional[str] = Field(
        default=None,
        description='Character to use to mask the sensitive values—for example, `*` for an alphabetic string such as a name, or `0` for a numeric string such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to `*` for strings, and `0` for digits.',
    )
    numberToMask: Optional[int] = Field(
        default=None,
        description='Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.',
    )
    reverseOrder: Optional[bool] = Field(
        default=None,
        description='Mask characters in reverse order. For example, if `masking_character` is `0`, `number_to_mask` is `14`, and `reverse_order` is `false`, then the input string `1234-5678-9012-3456` is masked as `00000000000000-3456`. If `masking_character` is `*`, `number_to_mask` is `3`, and `reverse_order` is `true`, then the string `12345` is masked as `12***`.',
    )


class CharactersToIgnoreItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    charactersToSkip: Optional[str] = Field(
        default=None, description='Characters to not transform when masking.'
    )
    commonCharactersToIgnore: Optional[str] = Field(
        default=None,
        description='Common characters to not transform when masking. Useful to avoid removing punctuation. Possible values: COMMON_CHARS_TO_IGNORE_UNSPECIFIED, NUMERIC, ALPHA_UPPER_CASE, ALPHA_LOWER_CASE, PUNCTUATION, WHITESPACE',
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expressions: Optional[Expressions] = Field(
        default=None, description='An expression.'
    )


class Condition1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: FieldModel = Field(
        ...,
        description='Required. Field within the record this condition is evaluated against.',
    )
    operator: str = Field(
        ...,
        description='Required. Operator used to compare the field or infoType to the value. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )
    value: Optional[Value] = Field(
        default=None,
        description='Value to compare against. [Mandatory, except for `EXISTS` tests.]',
    )


class Condition2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expressions: Optional[Expressions1] = Field(
        default=None, description='An expression.'
    )


class Condition3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: FieldModel = Field(
        ...,
        description='Required. Field within the record this condition is evaluated against.',
    )
    operator: str = Field(
        ...,
        description='Required. Operator used to compare the field or infoType to the value. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )
    value: Optional[Value1] = Field(
        default=None,
        description='Value to compare against. [Mandatory, except for `EXISTS` tests.]',
    )


class Condition4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expressions: Optional[Expressions2] = Field(
        default=None, description='An expression.'
    )


class Condition5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: FieldModel = Field(
        ...,
        description='Required. Field within the record this condition is evaluated against.',
    )
    operator: str = Field(
        ...,
        description='Required. Operator used to compare the field or infoType to the value. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )
    value: Optional[Value2] = Field(
        default=None,
        description='Value to compare against. [Mandatory, except for `EXISTS` tests.]',
    )


class Condition6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expressions: Optional[Expressions3] = Field(
        default=None, description='An expression.'
    )


class Condition7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: FieldModel = Field(
        ...,
        description='Required. Field within the record this condition is evaluated against.',
    )
    operator: str = Field(
        ...,
        description='Required. Operator used to compare the field or infoType to the value. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )
    value: Optional[Value3] = Field(
        default=None,
        description='Value to compare against. [Mandatory, except for `EXISTS` tests.]',
    )


class Condition8(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class Conditions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition1]] = Field(
        default=None, description='A collection of conditions.'
    )


class Conditions1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition3]] = Field(
        default=None, description='A collection of conditions.'
    )


class Conditions2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition5]] = Field(
        default=None, description='A collection of conditions.'
    )


class Conditions3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition7]] = Field(
        default=None, description='A collection of conditions.'
    )


class Context(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(default=None, description='Name describing the field.')


class CryptoDeterministicConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.',
    )
    cryptoKey: Optional[CryptoKey] = Field(
        default=None,
        description='The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.",
    )


class CryptoDeterministicConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.',
    )
    cryptoKey: Optional[CryptoKey4] = Field(
        default=None,
        description='The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.",
    )


class CryptoDeterministicConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.',
    )
    cryptoKey: Optional[CryptoKey8] = Field(
        default=None,
        description='The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.",
    )


class CryptoDeterministicConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.',
    )
    cryptoKey: Optional[CryptoKey12] = Field(
        default=None,
        description='The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.",
    )


class CryptoDeterministicConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.',
    )
    cryptoKey: Optional[CryptoKey16] = Field(
        default=None,
        description='The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.",
    )


class CryptoDeterministicConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well. If the context is not set, plaintext would be used as is for encryption. If the context is set but: 1. there is no record present when transforming a given value or 2. the field is not present when transforming a given value, plaintext would be used as is for encryption. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s.',
    )
    cryptoKey: Optional[CryptoKey20] = Field(
        default=None,
        description='The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate} For example, if the name of custom info type is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text. Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text. In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either - reverse a surrogate that does not correspond to an actual identifier - be unable to parse the surrogate and result in an error Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE.",
    )


class CryptoHashConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKey: Optional[CryptoKey1] = Field(
        default=None, description='The key used by the hash function.'
    )


class CryptoHashConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKey: Optional[CryptoKey5] = Field(
        default=None, description='The key used by the hash function.'
    )


class CryptoHashConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKey: Optional[CryptoKey9] = Field(
        default=None, description='The key used by the hash function.'
    )


class CryptoHashConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKey: Optional[CryptoKey13] = Field(
        default=None, description='The key used by the hash function.'
    )


class CryptoHashConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKey: Optional[CryptoKey17] = Field(
        default=None, description='The key used by the hash function.'
    )


class CryptoHashConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKey: Optional[CryptoKey21] = Field(
        default=None, description='The key used by the hash function.'
    )


class CryptoKey(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped1] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey10(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped10] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey11(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped11] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey12(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped12] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey13(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped13] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey14(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped14] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey15(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped15] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey16(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped16] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey17(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped17] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey18(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped18] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey19(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped19] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped2] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey20(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped20] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey21(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped21] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey22(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped22] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey23(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped23] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped3] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped4] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped5] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped6] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped7] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey8(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped8] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKey9(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    kmsWrapped: Optional[KmsWrapped9] = Field(
        default=None, description='Key wrapped using Cloud KMS'
    )
    transient: Optional[Transient] = Field(
        default=None, description='Transient crypto key'
    )
    unwrapped: Optional[Unwrapped] = Field(
        default=None, description='Unwrapped crypto key'
    )


class CryptoKeyRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef10(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef11(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef12(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef13(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef14(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef15(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef16(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef17(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef18(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef19(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef20(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef21(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef22(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef23(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef24(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef25(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef26(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef27(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef28(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef29(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef30(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef31(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef32(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef33(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef34(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef35(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef36(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef37(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef38(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef39(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef40(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef41(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef42(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef43(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef44(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef45(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef46(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef47(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef8(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoKeyRef9(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Required. The resource name of the KMS CryptoKey to use for unwrapping.\n\nAllowed value: The Google Cloud resource name of a `KMSCryptoKey` resource (format: `{{selfLink}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class CryptoReplaceFfxFpeConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commonAlphabet: Optional[str] = Field(
        default=None,
        description='Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC',
    )
    context: Optional[Context] = Field(
        default=None,
        description="The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2",
    )
    cryptoKey: CryptoKey2 = Field(
        ..., description='Required. The key used by the encryption algorithm.'
    )
    customAlphabet: Optional[str] = Field(
        default=None,
        description='This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"\'<,>.?/``',
    )
    radix: Optional[int] = Field(
        default=None,
        description='The native way to select the alphabet. Must be in the range [2, 95].',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE",
    )


class CryptoReplaceFfxFpeConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commonAlphabet: Optional[str] = Field(
        default=None,
        description='Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC',
    )
    context: Optional[Context] = Field(
        default=None,
        description="The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2",
    )
    cryptoKey: CryptoKey6 = Field(
        ..., description='Required. The key used by the encryption algorithm.'
    )
    customAlphabet: Optional[str] = Field(
        default=None,
        description='This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"\'<,>.?/``',
    )
    radix: Optional[int] = Field(
        default=None,
        description='The native way to select the alphabet. Must be in the range [2, 95].',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE",
    )


class CryptoReplaceFfxFpeConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commonAlphabet: Optional[str] = Field(
        default=None,
        description='Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC',
    )
    context: Optional[Context] = Field(
        default=None,
        description="The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2",
    )
    cryptoKey: CryptoKey10 = Field(
        ..., description='Required. The key used by the encryption algorithm.'
    )
    customAlphabet: Optional[str] = Field(
        default=None,
        description='This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"\'<,>.?/``',
    )
    radix: Optional[int] = Field(
        default=None,
        description='The native way to select the alphabet. Must be in the range [2, 95].',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE",
    )


class CryptoReplaceFfxFpeConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commonAlphabet: Optional[str] = Field(
        default=None,
        description='Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC',
    )
    context: Optional[Context] = Field(
        default=None,
        description="The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2",
    )
    cryptoKey: CryptoKey14 = Field(
        ..., description='Required. The key used by the encryption algorithm.'
    )
    customAlphabet: Optional[str] = Field(
        default=None,
        description='This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"\'<,>.?/``',
    )
    radix: Optional[int] = Field(
        default=None,
        description='The native way to select the alphabet. Must be in the range [2, 95].',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE",
    )


class CryptoReplaceFfxFpeConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commonAlphabet: Optional[str] = Field(
        default=None,
        description='Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC',
    )
    context: Optional[Context] = Field(
        default=None,
        description="The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2",
    )
    cryptoKey: CryptoKey18 = Field(
        ..., description='Required. The key used by the encryption algorithm.'
    )
    customAlphabet: Optional[str] = Field(
        default=None,
        description='This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"\'<,>.?/``',
    )
    radix: Optional[int] = Field(
        default=None,
        description='The native way to select the alphabet. Must be in the range [2, 95].',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE",
    )


class CryptoReplaceFfxFpeConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commonAlphabet: Optional[str] = Field(
        default=None,
        description='Common alphabets. Possible values: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED, NUMERIC, HEXADECIMAL, UPPER_CASE_ALPHA_NUMERIC, ALPHA_NUMERIC',
    )
    context: Optional[Context] = Field(
        default=None,
        description="The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used. If the context is set but: 1. there is no record present when transforming a given value or 1. the field is not present when transforming a given value, a default tweak will be used. Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string. The tweak is constructed as a sequence of bytes in big endian byte order such that: - a 64 bit integer is encoded followed by a single byte of value 1 - a string is encoded in UTF-8 format followed by a single byte of value 2",
    )
    cryptoKey: CryptoKey22 = Field(
        ..., description='Required. The key used by the encryption algorithm.'
    )
    customAlphabet: Optional[str] = Field(
        default=None,
        description='This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range [2, 95]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is: ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"\'<,>.?/``',
    )
    radix: Optional[int] = Field(
        default=None,
        description='The native way to select the alphabet. Must be in the range [2, 95].',
    )
    surrogateInfoType: Optional[SurrogateInfoType] = Field(
        default=None,
        description="The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info_type_name(surrogate_character_count):surrogate For example, if the name of custom infoType is 'MY_TOKEN_INFO_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY_TOKEN_INFO_TYPE(3):abc' This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text. In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: ⧝MY_TOKEN_TYPE",
    )


class DateShiftConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.',
    )
    cryptoKey: Optional[CryptoKey3] = Field(
        default=None,
        description='Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.',
    )
    lowerBoundDays: int = Field(
        ...,
        description='Required. For example, -5 means shift date to at most 5 days back in the past.',
    )
    upperBoundDays: int = Field(
        ...,
        description='Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.',
    )


class DateShiftConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.',
    )
    cryptoKey: Optional[CryptoKey7] = Field(
        default=None,
        description='Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.',
    )
    lowerBoundDays: int = Field(
        ...,
        description='Required. For example, -5 means shift date to at most 5 days back in the past.',
    )
    upperBoundDays: int = Field(
        ...,
        description='Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.',
    )


class DateShiftConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.',
    )
    cryptoKey: Optional[CryptoKey11] = Field(
        default=None,
        description='Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.',
    )
    lowerBoundDays: int = Field(
        ...,
        description='Required. For example, -5 means shift date to at most 5 days back in the past.',
    )
    upperBoundDays: int = Field(
        ...,
        description='Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.',
    )


class DateShiftConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.',
    )
    cryptoKey: Optional[CryptoKey15] = Field(
        default=None,
        description='Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.',
    )
    lowerBoundDays: int = Field(
        ...,
        description='Required. For example, -5 means shift date to at most 5 days back in the past.',
    )
    upperBoundDays: int = Field(
        ...,
        description='Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.',
    )


class DateShiftConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.',
    )
    cryptoKey: Optional[CryptoKey19] = Field(
        default=None,
        description='Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.',
    )
    lowerBoundDays: int = Field(
        ...,
        description='Required. For example, -5 means shift date to at most 5 days back in the past.',
    )
    upperBoundDays: int = Field(
        ...,
        description='Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.',
    )


class DateShiftConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[Context] = Field(
        default=None,
        description='Points to the field that contains the context, for example, an entity id. If set, must also set cryptoKey. If set, shift will be consistent for the given context.',
    )
    cryptoKey: Optional[CryptoKey23] = Field(
        default=None,
        description='Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and crypto_key. If set, must also set context. Can only be applied to table items.',
    )
    lowerBoundDays: int = Field(
        ...,
        description='Required. For example, -5 means shift date to at most 5 days back in the past.',
    )
    upperBoundDays: int = Field(
        ...,
        description='Required. Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction. For example, 3 means shift date to at most 3 days into the future.',
    )


class DateValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    day: Optional[int] = Field(
        default=None,
        description="Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
    )
    month: Optional[int] = Field(
        default=None,
        description='Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.',
    )
    year: Optional[int] = Field(
        default=None,
        description='Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.',
    )


class DeidentifyConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    infoTypeTransformations: Optional[InfoTypeTransformations] = Field(
        default=None,
        description='Treat the dataset as free-form text and apply the same free text transformation everywhere.',
    )
    recordTransformations: Optional[RecordTransformations] = Field(
        default=None,
        description='Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.',
    )
    transformationErrorHandling: Optional[TransformationErrorHandling] = Field(
        default=None,
        description='Mode for handling transformation errors. If left unspecified, the default mode is `TransformationErrorHandling.ThrowError`.',
    )


class DeidentifyConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    infoTypeTransformations: Optional[InfoTypeTransformations2] = Field(
        default=None,
        description='Treat the dataset as free-form text and apply the same free text transformation everywhere.',
    )
    recordTransformations: Optional[RecordTransformations1] = Field(
        default=None,
        description='Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.',
    )
    transformationErrorHandling: Optional[TransformationErrorHandling] = Field(
        default=None,
        description='Mode for handling transformation errors. If left unspecified, the default mode is `TransformationErrorHandling.ThrowError`.',
    )


class Expressions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[Conditions] = Field(
        default=None, description='Conditions to apply to the expression.'
    )
    logicalOperator: Optional[str] = Field(
        default=None,
        description='The operator to apply to the result of conditions. Default and currently only supported value is `AND`. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )


class Expressions1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[Conditions1] = Field(
        default=None, description='Conditions to apply to the expression.'
    )
    logicalOperator: Optional[str] = Field(
        default=None,
        description='The operator to apply to the result of conditions. Default and currently only supported value is `AND`. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )


class Expressions2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[Conditions2] = Field(
        default=None, description='Conditions to apply to the expression.'
    )
    logicalOperator: Optional[str] = Field(
        default=None,
        description='The operator to apply to the result of conditions. Default and currently only supported value is `AND`. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )


class Expressions3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[Conditions3] = Field(
        default=None, description='Conditions to apply to the expression.'
    )
    logicalOperator: Optional[str] = Field(
        default=None,
        description='The operator to apply to the result of conditions. Default and currently only supported value is `AND`. Possible values: LOGICAL_OPERATOR_UNSPECIFIED, AND',
    )


class FieldModel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(default=None, description='Name describing the field.')


class FieldTransformation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    condition: Optional[Condition] = Field(
        default=None,
        description='Only apply the transformation if the condition evaluates to true for the given `RecordCondition`. The conditions are allowed to reference fields that are not used in the actual transformation. Example Use Cases: - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range. - Redact a field if the date of birth field is greater than 85.',
    )
    fields: List[FieldModel] = Field(
        ...,
        description='Required. Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId. FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".',
    )
    infoTypeTransformations: Optional[InfoTypeTransformations1] = Field(
        default=None,
        description='Treat the contents of the field as free text, and selectively transform content that matches an `InfoType`.',
    )
    primitiveTransformation: Optional[PrimitiveTransformation2] = Field(
        default=None, description='Apply the transformation to the entire field.'
    )


class FieldTransformation1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    condition: Optional[Condition4] = Field(
        default=None,
        description='Only apply the transformation if the condition evaluates to true for the given `RecordCondition`. The conditions are allowed to reference fields that are not used in the actual transformation. Example Use Cases: - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range. - Redact a field if the date of birth field is greater than 85.',
    )
    fields: List[FieldModel] = Field(
        ...,
        description='Required. Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId. FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".',
    )
    infoTypeTransformations: Optional[InfoTypeTransformations3] = Field(
        default=None,
        description='Treat the contents of the field as free text, and selectively transform content that matches an `InfoType`.',
    )
    primitiveTransformation: Optional[PrimitiveTransformation5] = Field(
        default=None, description='Apply the transformation to the entire field.'
    )


class FixedSizeBucketingConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketSize: float = Field(
        ...,
        description='Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.',
    )
    lowerBound: LowerBound = Field(
        ...,
        description='Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".',
    )
    upperBound: UpperBound = Field(
        ...,
        description='Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".',
    )


class FixedSizeBucketingConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketSize: float = Field(
        ...,
        description='Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.',
    )
    lowerBound: LowerBound1 = Field(
        ...,
        description='Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".',
    )
    upperBound: UpperBound1 = Field(
        ...,
        description='Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".',
    )


class FixedSizeBucketingConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketSize: float = Field(
        ...,
        description='Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.',
    )
    lowerBound: LowerBound2 = Field(
        ...,
        description='Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".',
    )
    upperBound: UpperBound2 = Field(
        ...,
        description='Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".',
    )


class FixedSizeBucketingConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketSize: float = Field(
        ...,
        description='Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.',
    )
    lowerBound: LowerBound3 = Field(
        ...,
        description='Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".',
    )
    upperBound: UpperBound3 = Field(
        ...,
        description='Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".',
    )


class FixedSizeBucketingConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketSize: float = Field(
        ...,
        description='Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.',
    )
    lowerBound: LowerBound4 = Field(
        ...,
        description='Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".',
    )
    upperBound: UpperBound4 = Field(
        ...,
        description='Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".',
    )


class FixedSizeBucketingConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketSize: float = Field(
        ...,
        description='Required. Size of each bucket (except for minimum and maximum buckets). So if `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works.',
    )
    lowerBound: LowerBound5 = Field(
        ...,
        description='Required. Lower bound value of buckets. All values less than `lower_bound` are grouped together into a single bucket; for example if `lower_bound` = 10, then all values less than 10 are replaced with the value "-10".',
    )
    upperBound: UpperBound5 = Field(
        ...,
        description='Required. Upper bound value of buckets. All values greater than upper_bound are grouped together into a single bucket; for example if `upper_bound` = 89, then all values greater than 89 are replaced with the value "89+".',
    )


class InfoType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.',
    )


class InfoTypeTransformations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    transformations: List[Transformation] = Field(
        ...,
        description='Required. Transformation for each infoType. Cannot specify more than one for a given infoType.',
    )


class InfoTypeTransformations1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    transformations: List[Transformation1] = Field(
        ...,
        description='Required. Transformation for each infoType. Cannot specify more than one for a given infoType.',
    )


class InfoTypeTransformations2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    transformations: List[Transformation2] = Field(
        ...,
        description='Required. Transformation for each infoType. Cannot specify more than one for a given infoType.',
    )


class InfoTypeTransformations3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    transformations: List[Transformation3] = Field(
        ...,
        description='Required. Transformation for each infoType. Cannot specify more than one for a given infoType.',
    )


class KmsWrapped(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef, CryptoKeyRef1]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef2, CryptoKeyRef3]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped10(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef20, CryptoKeyRef21]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped11(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef22, CryptoKeyRef23]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped12(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef24, CryptoKeyRef25]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped13(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef26, CryptoKeyRef27]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped14(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef28, CryptoKeyRef29]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped15(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef30, CryptoKeyRef31]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped16(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef32, CryptoKeyRef33]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped17(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef34, CryptoKeyRef35]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped18(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef36, CryptoKeyRef37]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped19(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef38, CryptoKeyRef39]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef4, CryptoKeyRef5]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped20(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef40, CryptoKeyRef41]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped21(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef42, CryptoKeyRef43]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped22(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef44, CryptoKeyRef45]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped23(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef46, CryptoKeyRef47]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef6, CryptoKeyRef7]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef8, CryptoKeyRef9]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef10, CryptoKeyRef11]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef12, CryptoKeyRef13]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef14, CryptoKeyRef15]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped8(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef16, CryptoKeyRef17]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class KmsWrapped9(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cryptoKeyRef: Union[CryptoKeyRef18, CryptoKeyRef19]
    wrappedKey: str = Field(..., description='Required. The wrapped data crypto key.')


class LowerBound(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class LowerBound1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class LowerBound2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class LowerBound3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class LowerBound4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class LowerBound5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Max(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Max1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Max2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Max3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Max4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Max5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Min(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Min1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Min2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Min3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Min4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Min5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Optional[Union[Spec, Spec1]] = None
    status: Optional[Status] = None


class NewValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class NewValue1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class NewValue2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class NewValue3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class NewValue4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class NewValue5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class OrganizationRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).',
    )
    name: str = Field(
        ...,
        description="[WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class OrganizationRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description="[WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class OrganizationRef2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).',
    )
    name: str = Field(
        ...,
        description="[WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class OrganizationRef3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a Google Cloud Organization (format: `organizations/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description="[WARNING] Organization not yet supported in Config Connector, use 'external' field to reference existing resources.\nName of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class PrimitiveTransformation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketingConfig: Optional[BucketingConfig] = Field(
        default=None, description='Bucketing'
    )
    characterMaskConfig: Optional[CharacterMaskConfig] = Field(
        default=None, description='Mask'
    )
    cryptoDeterministicConfig: Optional[CryptoDeterministicConfig] = Field(
        default=None, description='Deterministic Crypto'
    )
    cryptoHashConfig: Optional[CryptoHashConfig] = Field(
        default=None, description='Crypto'
    )
    cryptoReplaceFfxFpeConfig: Optional[CryptoReplaceFfxFpeConfig] = Field(
        default=None, description='Ffx-Fpe'
    )
    dateShiftConfig: Optional[DateShiftConfig] = Field(
        default=None, description='Date Shift'
    )
    fixedSizeBucketingConfig: Optional[FixedSizeBucketingConfig] = Field(
        default=None, description='Fixed size bucketing'
    )
    redactConfig: Optional[Dict[str, Any]] = Field(default=None, description='Redact')
    replaceConfig: Optional[ReplaceConfig] = Field(
        default=None, description='Replace with a specified value.'
    )
    replaceWithInfoTypeConfig: Optional[Dict[str, Any]] = Field(
        default=None, description='Replace with infotype'
    )
    timePartConfig: Optional[TimePartConfig] = Field(
        default=None, description='Time extraction'
    )


class PrimitiveTransformation1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketingConfig: Optional[BucketingConfig1] = Field(
        default=None, description='Bucketing'
    )
    characterMaskConfig: Optional[CharacterMaskConfig1] = Field(
        default=None, description='Mask'
    )
    cryptoDeterministicConfig: Optional[CryptoDeterministicConfig1] = Field(
        default=None, description='Deterministic Crypto'
    )
    cryptoHashConfig: Optional[CryptoHashConfig1] = Field(
        default=None, description='Crypto'
    )
    cryptoReplaceFfxFpeConfig: Optional[CryptoReplaceFfxFpeConfig1] = Field(
        default=None, description='Ffx-Fpe'
    )
    dateShiftConfig: Optional[DateShiftConfig1] = Field(
        default=None, description='Date Shift'
    )
    fixedSizeBucketingConfig: Optional[FixedSizeBucketingConfig1] = Field(
        default=None, description='Fixed size bucketing'
    )
    redactConfig: Optional[Dict[str, Any]] = Field(default=None, description='Redact')
    replaceConfig: Optional[ReplaceConfig1] = Field(
        default=None, description='Replace with a specified value.'
    )
    replaceWithInfoTypeConfig: Optional[Dict[str, Any]] = Field(
        default=None, description='Replace with infotype'
    )
    timePartConfig: Optional[TimePartConfig] = Field(
        default=None, description='Time extraction'
    )


class PrimitiveTransformation2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketingConfig: Optional[BucketingConfig2] = Field(
        default=None, description='Bucketing'
    )
    characterMaskConfig: Optional[CharacterMaskConfig2] = Field(
        default=None, description='Mask'
    )
    cryptoDeterministicConfig: Optional[CryptoDeterministicConfig2] = Field(
        default=None, description='Deterministic Crypto'
    )
    cryptoHashConfig: Optional[CryptoHashConfig2] = Field(
        default=None, description='Crypto'
    )
    cryptoReplaceFfxFpeConfig: Optional[CryptoReplaceFfxFpeConfig2] = Field(
        default=None, description='Ffx-Fpe'
    )
    dateShiftConfig: Optional[DateShiftConfig2] = Field(
        default=None, description='Date Shift'
    )
    fixedSizeBucketingConfig: Optional[FixedSizeBucketingConfig2] = Field(
        default=None, description='Fixed size bucketing'
    )
    redactConfig: Optional[Dict[str, Any]] = Field(default=None, description='Redact')
    replaceConfig: Optional[ReplaceConfig2] = Field(
        default=None, description='Replace with a specified value.'
    )
    replaceWithInfoTypeConfig: Optional[Dict[str, Any]] = Field(
        default=None, description='Replace with infotype'
    )
    timePartConfig: Optional[TimePartConfig] = Field(
        default=None, description='Time extraction'
    )


class PrimitiveTransformation3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketingConfig: Optional[BucketingConfig3] = Field(
        default=None, description='Bucketing'
    )
    characterMaskConfig: Optional[CharacterMaskConfig3] = Field(
        default=None, description='Mask'
    )
    cryptoDeterministicConfig: Optional[CryptoDeterministicConfig3] = Field(
        default=None, description='Deterministic Crypto'
    )
    cryptoHashConfig: Optional[CryptoHashConfig3] = Field(
        default=None, description='Crypto'
    )
    cryptoReplaceFfxFpeConfig: Optional[CryptoReplaceFfxFpeConfig3] = Field(
        default=None, description='Ffx-Fpe'
    )
    dateShiftConfig: Optional[DateShiftConfig3] = Field(
        default=None, description='Date Shift'
    )
    fixedSizeBucketingConfig: Optional[FixedSizeBucketingConfig3] = Field(
        default=None, description='Fixed size bucketing'
    )
    redactConfig: Optional[Dict[str, Any]] = Field(default=None, description='Redact')
    replaceConfig: Optional[ReplaceConfig3] = Field(
        default=None, description='Replace with a specified value.'
    )
    replaceWithInfoTypeConfig: Optional[Dict[str, Any]] = Field(
        default=None, description='Replace with infotype'
    )
    timePartConfig: Optional[TimePartConfig] = Field(
        default=None, description='Time extraction'
    )


class PrimitiveTransformation4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketingConfig: Optional[BucketingConfig4] = Field(
        default=None, description='Bucketing'
    )
    characterMaskConfig: Optional[CharacterMaskConfig4] = Field(
        default=None, description='Mask'
    )
    cryptoDeterministicConfig: Optional[CryptoDeterministicConfig4] = Field(
        default=None, description='Deterministic Crypto'
    )
    cryptoHashConfig: Optional[CryptoHashConfig4] = Field(
        default=None, description='Crypto'
    )
    cryptoReplaceFfxFpeConfig: Optional[CryptoReplaceFfxFpeConfig4] = Field(
        default=None, description='Ffx-Fpe'
    )
    dateShiftConfig: Optional[DateShiftConfig4] = Field(
        default=None, description='Date Shift'
    )
    fixedSizeBucketingConfig: Optional[FixedSizeBucketingConfig4] = Field(
        default=None, description='Fixed size bucketing'
    )
    redactConfig: Optional[Dict[str, Any]] = Field(default=None, description='Redact')
    replaceConfig: Optional[ReplaceConfig4] = Field(
        default=None, description='Replace with a specified value.'
    )
    replaceWithInfoTypeConfig: Optional[Dict[str, Any]] = Field(
        default=None, description='Replace with infotype'
    )
    timePartConfig: Optional[TimePartConfig] = Field(
        default=None, description='Time extraction'
    )


class PrimitiveTransformation5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketingConfig: Optional[BucketingConfig5] = Field(
        default=None, description='Bucketing'
    )
    characterMaskConfig: Optional[CharacterMaskConfig5] = Field(
        default=None, description='Mask'
    )
    cryptoDeterministicConfig: Optional[CryptoDeterministicConfig5] = Field(
        default=None, description='Deterministic Crypto'
    )
    cryptoHashConfig: Optional[CryptoHashConfig5] = Field(
        default=None, description='Crypto'
    )
    cryptoReplaceFfxFpeConfig: Optional[CryptoReplaceFfxFpeConfig5] = Field(
        default=None, description='Ffx-Fpe'
    )
    dateShiftConfig: Optional[DateShiftConfig5] = Field(
        default=None, description='Date Shift'
    )
    fixedSizeBucketingConfig: Optional[FixedSizeBucketingConfig5] = Field(
        default=None, description='Fixed size bucketing'
    )
    redactConfig: Optional[Dict[str, Any]] = Field(default=None, description='Redact')
    replaceConfig: Optional[ReplaceConfig5] = Field(
        default=None, description='Replace with a specified value.'
    )
    replaceWithInfoTypeConfig: Optional[Dict[str, Any]] = Field(
        default=None, description='Replace with infotype'
    )
    timePartConfig: Optional[TimePartConfig] = Field(
        default=None, description='Time extraction'
    )


class ProjectRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class RecordSuppression(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    condition: Optional[Condition2] = Field(
        default=None,
        description='A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.',
    )


class RecordSuppression1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    condition: Optional[Condition6] = Field(
        default=None,
        description='A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.',
    )


class RecordTransformations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldTransformations: Optional[List[FieldTransformation]] = Field(
        default=None,
        description='Transform the record by applying various field transformations.',
    )
    recordSuppressions: Optional[List[RecordSuppression]] = Field(
        default=None,
        description='Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.',
    )


class RecordTransformations1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldTransformations: Optional[List[FieldTransformation1]] = Field(
        default=None,
        description='Transform the record by applying various field transformations.',
    )
    recordSuppressions: Optional[List[RecordSuppression1]] = Field(
        default=None,
        description='Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.',
    )


class ReplaceConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    newValue: Optional[NewValue] = Field(
        default=None, description='Value to replace it with.'
    )


class ReplaceConfig1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    newValue: Optional[NewValue1] = Field(
        default=None, description='Value to replace it with.'
    )


class ReplaceConfig2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    newValue: Optional[NewValue2] = Field(
        default=None, description='Value to replace it with.'
    )


class ReplaceConfig3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    newValue: Optional[NewValue3] = Field(
        default=None, description='Value to replace it with.'
    )


class ReplaceConfig4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    newValue: Optional[NewValue4] = Field(
        default=None, description='Value to replace it with.'
    )


class ReplaceConfig5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    newValue: Optional[NewValue5] = Field(
        default=None, description='Value to replace it with.'
    )


class ReplacementValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class ReplacementValue1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class ReplacementValue2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class ReplacementValue3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class ReplacementValue4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class ReplacementValue5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    deidentifyConfig: Optional[DeidentifyConfig] = Field(
        default=None, description='The core content of the template.'
    )
    description: Optional[str] = Field(
        default=None, description='Short description (max 256 chars).'
    )
    displayName: Optional[str] = Field(
        default=None, description='Display name (max 256 chars).'
    )
    location: Optional[str] = Field(
        default=None, description='Immutable. The location of the resource'
    )
    organizationRef: Union[OrganizationRef, OrganizationRef1] = Field(
        ...,
        description='Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.',
    )
    projectRef: Optional[Union[ProjectRef, ProjectRef1]] = Field(
        default=None,
        description='Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.',
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.',
    )


class Spec1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    deidentifyConfig: Optional[DeidentifyConfig1] = Field(
        default=None, description='The core content of the template.'
    )
    description: Optional[str] = Field(
        default=None, description='Short description (max 256 chars).'
    )
    displayName: Optional[str] = Field(
        default=None, description='Display name (max 256 chars).'
    )
    location: Optional[str] = Field(
        default=None, description='Immutable. The location of the resource'
    )
    organizationRef: Optional[Union[OrganizationRef2, OrganizationRef3]] = Field(
        default=None,
        description='Immutable. The Organization that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.',
    )
    projectRef: Union[ProjectRef2, ProjectRef3] = Field(
        ...,
        description='Immutable. The Project that this resource belongs to. Only one of [organizationRef, projectRef] may be specified.',
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The service-generated name of the resource. Used for acquisition only. Leave unset to create a new resource.',
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition8]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    createTime: Optional[AwareDatetime] = Field(
        default=None,
        description='Output only. The creation timestamp of an inspectTemplate.',
    )
    locationId: Optional[str] = Field(
        default=None,
        description='Output only. The geographic location where this resource is stored.',
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )
    updateTime: Optional[AwareDatetime] = Field(
        default=None,
        description='Output only. The last update timestamp of an inspectTemplate.',
    )


class SurrogateInfoType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.',
    )


class TimePartConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    partToExtract: Optional[str] = Field(
        default=None,
        description='The part of the time to keep. Possible values: TIME_PART_UNSPECIFIED, YEAR, MONTH, DAY_OF_MONTH, DAY_OF_WEEK, WEEK_OF_YEAR, HOUR_OF_DAY',
    )


class TimeValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hours: Optional[int] = Field(
        default=None,
        description='Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.',
    )
    minutes: Optional[int] = Field(
        default=None, description='Minutes of hour of day. Must be from 0 to 59.'
    )
    nanos: Optional[int] = Field(
        default=None,
        description='Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.',
    )
    seconds: Optional[int] = Field(
        default=None,
        description='Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.',
    )


class Transformation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    infoTypes: Optional[List[InfoType]] = Field(
        default=None,
        description='InfoTypes to apply the transformation to. An empty list will cause this transformation to apply to all findings that correspond to infoTypes that were requested in `InspectConfig`.',
    )
    primitiveTransformation: PrimitiveTransformation = Field(
        ..., description='Required. Primitive transformation to apply to the infoType.'
    )


class Transformation1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    infoTypes: Optional[List[InfoType]] = Field(
        default=None,
        description='InfoTypes to apply the transformation to. An empty list will cause this transformation to apply to all findings that correspond to infoTypes that were requested in `InspectConfig`.',
    )
    primitiveTransformation: PrimitiveTransformation1 = Field(
        ..., description='Required. Primitive transformation to apply to the infoType.'
    )


class Transformation2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    infoTypes: Optional[List[InfoType]] = Field(
        default=None,
        description='InfoTypes to apply the transformation to. An empty list will cause this transformation to apply to all findings that correspond to infoTypes that were requested in `InspectConfig`.',
    )
    primitiveTransformation: PrimitiveTransformation3 = Field(
        ..., description='Required. Primitive transformation to apply to the infoType.'
    )


class Transformation3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    infoTypes: Optional[List[InfoType]] = Field(
        default=None,
        description='InfoTypes to apply the transformation to. An empty list will cause this transformation to apply to all findings that correspond to infoTypes that were requested in `InspectConfig`.',
    )
    primitiveTransformation: PrimitiveTransformation4 = Field(
        ..., description='Required. Primitive transformation to apply to the infoType.'
    )


class TransformationErrorHandling(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    leaveUntransformed: Optional[Dict[str, Any]] = Field(
        default=None, description='Ignore errors'
    )
    throwError: Optional[Dict[str, Any]] = Field(
        default=None, description='Throw an error'
    )


class Transient(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(
        ...,
        description='Required. Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).',
    )


class Unwrapped(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: str = Field(..., description='Required. A 128/192/256 bit key.')


class UpperBound(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class UpperBound1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class UpperBound2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class UpperBound3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class UpperBound4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class UpperBound5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Value(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Value1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Value2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )


class Value3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    booleanValue: Optional[bool] = Field(default=None, description='boolean')
    dateValue: Optional[DateValue] = Field(default=None, description='date')
    dayOfWeekValue: Optional[str] = Field(
        default=None,
        description='day of week Possible values: DAY_OF_WEEK_UNSPECIFIED, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY',
    )
    floatValue: Optional[float] = Field(default=None, description='float')
    integerValue: Optional[int] = Field(default=None, description='integer')
    stringValue: Optional[str] = Field(default=None, description='string')
    timeValue: Optional[TimeValue] = Field(default=None, description='time of day')
    timestampValue: Optional[AwareDatetime] = Field(
        default=None, description='timestamp'
    )
