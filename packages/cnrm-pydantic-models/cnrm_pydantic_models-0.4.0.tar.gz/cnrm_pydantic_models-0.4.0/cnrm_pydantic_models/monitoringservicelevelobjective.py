# generated by datamodel-codegen:
#   filename:  monitoringservicelevelobjective_v1beta1.json
#   timestamp: 2024-03-18T21:08:28+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import AwareDatetime, BaseModel, ConfigDict, Field


class BasicSli(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    availability: Optional[Dict[str, Any]] = Field(
        default=None,
        description='Good service is defined to be the count of requests made to this service that return successfully.',
    )
    latency: Optional[Latency] = Field(
        default=None,
        description='Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.',
    )
    location: Optional[List[str]] = Field(
        default=None,
        description="OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
    )
    method: Optional[List[str]] = Field(
        default=None,
        description="OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
    )
    operationAvailability: Optional[Dict[str, Any]] = Field(
        default=None,
        description='Good service is defined to be the count of operations performed by this service that return successfully',
    )
    operationLatency: Optional[OperationLatency] = Field(
        default=None,
        description='Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.',
    )
    version: Optional[List[str]] = Field(
        default=None,
        description="OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.",
    )


class BasicSliPerformance(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    availability: Optional[Dict[str, Any]] = Field(
        default=None,
        description='Good service is defined to be the count of requests made to this service that return successfully.',
    )
    latency: Optional[Latency] = Field(
        default=None,
        description='Good service is defined to be the count of requests made to this service that are fast enough with respect to `latency.threshold`.',
    )
    location: Optional[List[str]] = Field(
        default=None,
        description="OPTIONAL: The set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.",
    )
    method: Optional[List[str]] = Field(
        default=None,
        description="OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.",
    )
    operationAvailability: Optional[Dict[str, Any]] = Field(
        default=None,
        description='Good service is defined to be the count of operations performed by this service that return successfully',
    )
    operationLatency: Optional[OperationLatency] = Field(
        default=None,
        description='Good service is defined to be the count of operations performed by this service that are fast enough with respect to `operation_latency.threshold`.',
    )
    version: Optional[List[str]] = Field(
        default=None,
        description="OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.",
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class DistributionCut(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    distributionFilter: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` aggregating values. Must have `ValueType = DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.',
    )
    range: Optional[Range] = Field(
        default=None,
        description='Range of values considered "good." For a one-sided range, set one bound to an infinite value.',
    )


class DistributionCut1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    distributionFilter: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` aggregating values. Must have `ValueType = DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.',
    )
    range: Optional[Range] = Field(
        default=None,
        description='Range of values considered "good." For a one-sided range, set one bound to an infinite value.',
    )


class GoodTotalRatio(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    badServiceFilter: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying bad service, either demanded service that was not provided or demanded service that was of inadequate quality. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.',
    )
    goodServiceFilter: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying good service provided. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.',
    )
    totalServiceFilter: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` quantifying total demanded service. Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.',
    )


class GoodTotalRatioThreshold(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    basicSliPerformance: Optional[BasicSliPerformance] = Field(
        default=None, description='`BasicSli` to evaluate to judge window quality.'
    )
    performance: Optional[Performance] = Field(
        default=None,
        description='`RequestBasedSli` to evaluate to judge window quality.',
    )
    threshold: Optional[float] = Field(
        default=None,
        description='If window `performance >= threshold`, the window is counted as good.',
    )


class Latency(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    experience: Optional[str] = Field(
        default=None,
        description='A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING',
    )
    threshold: Optional[str] = Field(
        default=None,
        description='Good service is defined to be the count of requests made to this service that return in no more than `threshold`.',
    )


class MetricMeanInRange(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    range: Optional[Range] = Field(
        default=None,
        description='Range of values considered "good." For a one-sided range, set one bound to an infinite value.',
    )
    timeSeries: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying the `TimeSeries` to use for evaluating window quality.',
    )


class MetricSumInRange(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    range: Optional[Range] = Field(
        default=None,
        description='Range of values considered "good." For a one-sided range, set one bound to an infinite value.',
    )
    timeSeries: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying the `TimeSeries` to use for evaluating window quality.',
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class OperationLatency(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    experience: Optional[str] = Field(
        default=None,
        description='A description of the experience associated with failing requests. Possible values: LATENCY_EXPERIENCE_UNSPECIFIED, DELIGHTING, SATISFYING, ANNOYING',
    )
    threshold: Optional[str] = Field(
        default=None,
        description='Good service is defined to be the count of operations that are completed in no more than `threshold`.',
    )


class Performance(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    distributionCut: Optional[DistributionCut1] = Field(
        default=None,
        description='`distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.',
    )
    goodTotalRatio: Optional[GoodTotalRatio] = Field(
        default=None,
        description='`good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.',
    )


class ProjectRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='The project for the resource\n\nAllowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='The project for the resource\n\nAllowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class Range(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: Optional[float] = Field(default=None, description='Range maximum.')
    min: Optional[float] = Field(default=None, description='Range minimum.')


class RequestBased(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    distributionCut: Optional[DistributionCut] = Field(
        default=None,
        description='`distribution_cut` is used when `good_service` is a count of values aggregated in a `Distribution` that fall into a good range. The `total_service` is the total count of all values aggregated in the `Distribution`.',
    )
    goodTotalRatio: Optional[GoodTotalRatio] = Field(
        default=None,
        description='`good_total_ratio` is used when the ratio of `good_service` to `total_service` is computed from two `TimeSeries`.',
    )


class ServiceLevelIndicator(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    basicSli: Optional[BasicSli] = Field(
        default=None, description='Basic SLI on a well-known service type.'
    )
    requestBased: Optional[RequestBased] = Field(
        default=None, description='Request-based SLIs'
    )
    windowsBased: Optional[WindowsBased] = Field(
        default=None, description='Windows-based SLIs'
    )


class ServiceRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='The service for the resource\n\nAllowed value: The Google Cloud resource name of a `MonitoringService` resource (format: `projects/{{project}}/services/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ServiceRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='The service for the resource\n\nAllowed value: The Google Cloud resource name of a `MonitoringService` resource (format: `projects/{{project}}/services/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    calendarPeriod: Optional[str] = Field(
        default=None,
        description='A calendar period, semantically "since the start of the current ``". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and `MONTH` are supported. Possible values: CALENDAR_PERIOD_UNSPECIFIED, DAY, WEEK, FORTNIGHT, MONTH, QUARTER, HALF, YEAR',
    )
    displayName: Optional[str] = Field(
        default=None, description='Name used for UI elements listing this SLO.'
    )
    goal: float = Field(
        ...,
        description='The fraction of service that must be good in order for this objective to be met. `0 < goal <= 0.999`.',
    )
    projectRef: Union[ProjectRef, ProjectRef1] = Field(
        ..., description='Immutable. The Project that this resource belongs to.'
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )
    rollingPeriod: Optional[str] = Field(
        default=None,
        description='A rolling time period, semantically "in the past ``". Must be an integer multiple of 1 day no larger than 30 days.',
    )
    serviceLevelIndicator: Optional[ServiceLevelIndicator] = Field(
        default=None,
        description="The definition of good service, used to measure and calculate the quality of the `Service`'s performance with respect to a single aspect of service quality.",
    )
    serviceRef: Union[ServiceRef, ServiceRef1] = Field(..., description='Immutable.')


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    createTime: Optional[AwareDatetime] = Field(
        default=None,
        description='Time stamp of the `Create` or most recent `Update` command on this `Slo`.',
    )
    deleteTime: Optional[AwareDatetime] = Field(
        default=None,
        description='Time stamp of the `Update` or `Delete` command that made this no longer a current `Slo`. This field is not populated in `ServiceLevelObjective`s returned from calls to `GetServiceLevelObjective` and `ListServiceLevelObjectives`, because it is always empty in the current version. It is populated in `ServiceLevelObjective`s representing previous versions in the output of `ListServiceLevelObjectiveVersions`. Because all old configuration versions are stored, `Update` operations mark the obsoleted version as deleted.',
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )
    serviceManagementOwned: Optional[bool] = Field(
        default=None,
        description='Output only. If set, this SLO is managed at the [Service Management](https://cloud.google.com/service-management/overview) level. Therefore the service yaml file is the source of truth for this SLO, and API `Update` and `Delete` operations are forbidden.',
    )


class WindowsBased(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    goodBadMetricFilter: Optional[str] = Field(
        default=None,
        description='A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if any `true` values appear in the window.',
    )
    goodTotalRatioThreshold: Optional[GoodTotalRatioThreshold] = Field(
        default=None,
        description='A window is good if its `performance` is high enough.',
    )
    metricMeanInRange: Optional[MetricMeanInRange] = Field(
        default=None,
        description="A window is good if the metric's value is in a good range, averaged across returned streams.",
    )
    metricSumInRange: Optional[MetricSumInRange] = Field(
        default=None,
        description="A window is good if the metric's value is in a good range, summed across returned streams.",
    )
    windowPeriod: Optional[str] = Field(
        default=None,
        description='Duration over which window quality is evaluated. Must be an integer fraction of a day and at least `60s`.',
    )
