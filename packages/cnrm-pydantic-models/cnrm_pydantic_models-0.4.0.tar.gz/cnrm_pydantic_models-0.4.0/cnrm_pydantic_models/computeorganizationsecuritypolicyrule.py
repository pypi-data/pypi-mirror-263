# generated by datamodel-codegen:
#   filename:  computeorganizationsecuritypolicyrule_v1alpha1.json
#   timestamp: 2024-03-18T21:07:12+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class Config(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    destIpRanges: Optional[List[str]] = Field(
        default=None,
        description='Destination IP address range in CIDR format. Required for\nEGRESS rules.',
    )
    layer4Config: List[Layer4ConfigItem] = Field(
        ..., description='Pairs of IP protocols and ports that the rule should match.'
    )
    srcIpRanges: Optional[List[str]] = Field(
        default=None,
        description='Source IP address range in CIDR format. Required for\nINGRESS rules.',
    )


class Layer4ConfigItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ipProtocol: str = Field(
        ...,
        description='The IP protocol to which this rule applies. The protocol\ntype is required when creating a firewall rule.\nThis value can either be one of the following well\nknown protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp),\nor the IP protocol number.',
    )
    ports: Optional[List[str]] = Field(
        default=None,
        description='An optional list of ports to which this rule applies. This field\nis only applicable for UDP or TCP protocol. Each entry must be\neither an integer or a range. If not specified, this rule\napplies to connections through any port.\n\nExample inputs include: ["22"], ["80","443"], and\n["12345-12349"].',
    )


class Match(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    config: Config = Field(
        ..., description='The configuration options for matching the rule.'
    )
    description: Optional[str] = Field(
        default=None, description='A description of the rule.'
    )
    versionedExpr: Optional[str] = Field(
        default=None,
        description='Preconfigured versioned expression. For organization security policy rules,\nthe only supported type is "FIREWALL". Default value: "FIREWALL" Possible values: ["FIREWALL"].',
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    action: str = Field(
        ...,
        description='The Action to perform when the client connection triggers the rule. Can currently be either\n"allow", "deny" or "goto_next".',
    )
    description: Optional[str] = Field(
        default=None, description='A description of the rule.'
    )
    direction: Optional[str] = Field(
        default=None,
        description='The direction in which this rule applies. If unspecified an INGRESS rule is created. Possible values: ["INGRESS", "EGRESS"].',
    )
    enableLogging: Optional[bool] = Field(
        default=None,
        description='Denotes whether to enable logging for a particular rule.\nIf logging is enabled, logs will be exported to the\nconfigured export destination in Stackdriver.',
    )
    match: Match = Field(
        ...,
        description="A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.",
    )
    policyId: str = Field(
        ...,
        description='Immutable. The ID of the OrganizationSecurityPolicy this rule applies to.',
    )
    preview: Optional[bool] = Field(
        default=None,
        description='If set to true, the specified action is not enforced.',
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The priority of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )
    targetResources: Optional[List[str]] = Field(
        default=None,
        description="A list of network resource URLs to which this rule applies.\nThis field allows you to control which network's VMs get\nthis rule. If this field is left blank, all VMs\nwithin the organization will receive the rule.",
    )
    targetServiceAccounts: Optional[List[str]] = Field(
        default=None,
        description='A list of service accounts indicating the sets of\ninstances that are applied with this rule.',
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )
