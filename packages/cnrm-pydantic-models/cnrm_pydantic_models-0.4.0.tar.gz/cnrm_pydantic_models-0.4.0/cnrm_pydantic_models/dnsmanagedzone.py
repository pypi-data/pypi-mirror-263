# generated by datamodel-codegen:
#   filename:  dnsmanagedzone_v1beta1.json
#   timestamp: 2024-03-18T21:07:53+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field


class CloudLoggingConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enableLogging: bool = Field(
        ...,
        description='If set, enable query logging for this ManagedZone. False by default, making logging opt-in.',
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class DefaultKeySpec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    algorithm: Optional[str] = Field(
        default=None,
        description='String mnemonic specifying the DNSSEC algorithm of this key Possible values: ["ecdsap256sha256", "ecdsap384sha384", "rsasha1", "rsasha256", "rsasha512"].',
    )
    keyLength: Optional[int] = Field(
        default=None, description='Length of the keys in bits.'
    )
    keyType: Optional[str] = Field(
        default=None,
        description='Specifies whether this is a key signing key (KSK) or a zone\nsigning key (ZSK). Key signing keys have the Secure Entry\nPoint flag set and, when active, will only be used to sign\nresource record sets of type DNSKEY. Zone signing keys do\nnot have the Secure Entry Point flag set and will be used\nto sign all other types of resource record sets. Possible values: ["keySigning", "zoneSigning"].',
    )
    kind: Optional[str] = Field(
        default=None, description='Identifies what kind of resource this is.'
    )


class DnssecConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultKeySpecs: Optional[List[DefaultKeySpec]] = Field(
        default=None,
        description="Specifies parameters that will be used for generating initial DnsKeys\nfor this ManagedZone. If you provide a spec for keySigning or zoneSigning,\nyou must also provide one for the other.\ndefault_key_specs can only be updated when the state is 'off'.",
    )
    kind: Optional[str] = Field(
        default=None, description='Identifies what kind of resource this is.'
    )
    nonExistence: Optional[str] = Field(
        default=None,
        description='Specifies the mechanism used to provide authenticated denial-of-existence responses.\nnon_existence can only be updated when the state is \'off\'. Possible values: ["nsec", "nsec3"].',
    )
    state: Optional[str] = Field(
        default=None,
        description='Specifies whether DNSSEC is enabled, and what mode it is in Possible values: ["off", "on", "transfer"].',
    )


class ForwardingConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    targetNameServers: List[TargetNameServer] = Field(
        ...,
        description='List of target name servers to forward to. Cloud DNS will\nselect the best available name server if more than\none target is given.',
    )


class GkeCluster(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gkeClusterNameRef: Union[GkeClusterNameRef, GkeClusterNameRef1] = Field(
        ...,
        description="The resource name of the cluster to bind this ManagedZone to.\nThis should be specified in the format like\n'projects/*/locations/*/clusters/*'.",
    )


class GkeClusterNameRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The `selfLink` field of a `ContainerCluster` resource.',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class GkeClusterNameRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The `selfLink` field of a `ContainerCluster` resource.',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class Namespace(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    namespaceUrl: str = Field(
        ...,
        description="The fully qualified or partial URL of the service directory namespace that should be\nassociated with the zone. This should be formatted like\n'https://servicedirectory.googleapis.com/v1/projects/{project}/locations/{location}/namespaces/{namespace_id}'\nor simply 'projects/{project}/locations/{location}/namespaces/{namespace_id}'\nIgnored for 'public' visibility zones.",
    )


class Network(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    networkRef: Union[NetworkRef2, NetworkRef3] = Field(
        ..., description='VPC network to bind to.'
    )


class NetworkRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The `selfLink` field of a `ComputeNetwork` resource.',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class NetworkRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The `selfLink` field of a `ComputeNetwork` resource.',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class NetworkRef2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The `selfLink` field of a `ComputeNetwork` resource.',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class NetworkRef3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The `selfLink` field of a `ComputeNetwork` resource.',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class PeeringConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    targetNetwork: TargetNetwork = Field(
        ..., description='The network with which to peer.'
    )


class PrivateVisibilityConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gkeClusters: Optional[List[GkeCluster]] = Field(
        default=None,
        description='The list of Google Kubernetes Engine clusters that can see this zone.',
    )
    networks: Optional[List[Network]] = None


class ServiceDirectoryConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    namespace: Namespace = Field(
        ..., description='The namespace associated with the zone.'
    )


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cloudLoggingConfig: Optional[CloudLoggingConfig] = Field(
        default=None, description='Cloud logging configuration.'
    )
    description: Optional[str] = Field(
        default=None,
        description="A textual description field. Defaults to 'Managed by Config Connector'.",
    )
    dnsName: str = Field(
        ...,
        description='Immutable. The DNS name of this managed zone, for instance "example.com.".',
    )
    dnssecConfig: Optional[DnssecConfig] = Field(
        default=None, description='DNSSEC configuration.'
    )
    forwardingConfig: Optional[ForwardingConfig] = Field(
        default=None,
        description='The presence for this field indicates that outbound forwarding is enabled\nfor this zone. The value of this field contains the set of destinations\nto forward to.',
    )
    peeringConfig: Optional[PeeringConfig] = Field(
        default=None,
        description='The presence of this field indicates that DNS Peering is enabled for this\nzone. The value of this field contains the network to peer with.',
    )
    privateVisibilityConfig: Optional[PrivateVisibilityConfig] = Field(
        default=None,
        description="For privately visible zones, the set of Virtual Private Cloud\nresources that the zone is visible from. At least one of 'gke_clusters' or 'networks' must be specified.",
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )
    reverseLookup: Optional[bool] = Field(
        default=None,
        description="Immutable. Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse\nlookup queries using automatically configured records for VPC resources. This only applies\nto networks listed under 'private_visibility_config'.",
    )
    serviceDirectoryConfig: Optional[ServiceDirectoryConfig] = Field(
        default=None,
        description='Immutable. The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.',
    )
    visibility: Optional[str] = Field(
        default=None,
        description='Immutable. The zone\'s visibility: public zones are exposed to the Internet,\nwhile private zones are visible only to Virtual Private Cloud resources. Default value: "public" Possible values: ["private", "public"].',
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    creationTime: Optional[str] = Field(
        default=None,
        description='The time that this resource was created on the server.\nThis is in RFC3339 text format.',
    )
    managedZoneId: Optional[int] = Field(
        default=None,
        description='Unique identifier for the resource; defined by the server.',
    )
    nameServers: Optional[List[str]] = Field(
        default=None,
        description='Delegate your managed_zone to these virtual name servers;\ndefined by the server.',
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )


class TargetNameServer(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    forwardingPath: Optional[str] = Field(
        default=None,
        description='Forwarding path for this TargetNameServer. If unset or \'default\' Cloud DNS will make forwarding\ndecision based on address ranges, i.e. RFC1918 addresses go to the VPC, Non-RFC1918 addresses go\nto the Internet. When set to \'private\', Cloud DNS will always send queries through VPC for this target Possible values: ["default", "private"].',
    )
    ipv4Address: str = Field(..., description='IPv4 address of a target name server.')


class TargetNetwork(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    networkRef: Union[NetworkRef, NetworkRef1] = Field(
        ..., description='VPC network to forward queries to.'
    )
