# generated by datamodel-codegen:
#   filename:  gkebackupbackupplan_v1alpha1.json
#   timestamp: 2024-03-18T21:08:03+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field


class BackupConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allNamespaces: Optional[bool] = Field(
        default=None, description='If True, include all namespaced resources.'
    )
    encryptionKey: Optional[EncryptionKey] = Field(
        default=None,
        description='This defines a customer managed encryption key that will be used to encrypt the "config"\nportion (the Kubernetes resources) of Backups created via this plan.',
    )
    includeSecrets: Optional[bool] = Field(
        default=None,
        description='This flag specifies whether Kubernetes Secret resources should be included\nwhen they fall into the scope of Backups.',
    )
    includeVolumeData: Optional[bool] = Field(
        default=None,
        description='This flag specifies whether volume data should be backed up when PVCs are\nincluded in the scope of a Backup.',
    )
    selectedApplications: Optional[SelectedApplications] = Field(
        default=None, description='A list of namespaced Kubernetes Resources.'
    )
    selectedNamespaces: Optional[SelectedNamespaces] = Field(
        default=None,
        description='If set, include just the resources in the listed namespaces.',
    )


class BackupSchedule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cronSchedule: Optional[str] = Field(
        default=None,
        description='A standard cron string that defines a repeating schedule for\ncreating Backups via this BackupPlan.\nIf this is defined, then backupRetainDays must also be defined.',
    )
    paused: Optional[bool] = Field(
        default=None,
        description='This flag denotes whether automatic Backup creation is paused for this BackupPlan.',
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class EncryptionKey(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gcpKmsEncryptionKey: str = Field(
        ...,
        description='Google Cloud KMS encryption key. Format: projects/*/locations/*/keyRings/*/cryptoKeys/*.',
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class NamespacedName(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(..., description='The name of a Kubernetes Resource.')
    namespace: str = Field(..., description='The namespace of a Kubernetes Resource.')


class ProjectRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The `name` field of a `Project` resource.',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ..., description='Allowed value: The `name` field of a `Project` resource.'
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class RetentionPolicy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    backupDeleteLockDays: Optional[int] = Field(
        default=None,
        description="Minimum age for a Backup created via this BackupPlan (in days).\nMust be an integer value between 0-90 (inclusive).\nA Backup created under this BackupPlan will not be deletable\nuntil it reaches Backup's (create time + backup_delete_lock_days).\nUpdating this field of a BackupPlan does not affect existing Backups.\nBackups created after a successful update will inherit this new value.",
    )
    backupRetainDays: Optional[int] = Field(
        default=None,
        description='The default maximum age of a Backup created via this BackupPlan.\nThis field MUST be an integer value >= 0 and <= 365. If specified,\na Backup created under this BackupPlan will be automatically deleted\nafter its age reaches (createTime + backupRetainDays).\nIf not specified, Backups created under this BackupPlan will NOT be\nsubject to automatic deletion. Updating this field does NOT affect\nexisting Backups under it. Backups created AFTER a successful update\nwill automatically pick up the new value.\nNOTE: backupRetainDays must be >= backupDeleteLockDays.\nIf cronSchedule is defined, then this must be <= 360 * the creation interval.].',
    )
    locked: Optional[bool] = Field(
        default=None,
        description='This flag denotes whether the retention policy of this BackupPlan is locked.\nIf set to True, no further update is allowed on this policy, including\nthe locked field itself.',
    )


class SelectedApplications(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    namespacedNames: List[NamespacedName] = Field(
        ..., description='A list of namespaced Kubernetes resources.'
    )


class SelectedNamespaces(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    namespaces: List[str] = Field(..., description='A list of Kubernetes Namespaces.')


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    backupConfig: Optional[BackupConfig] = Field(
        default=None,
        description='Defines the configuration of Backups created via this BackupPlan.',
    )
    backupSchedule: Optional[BackupSchedule] = Field(
        default=None,
        description='Defines a schedule for automatic Backup creation via this BackupPlan.',
    )
    cluster: str = Field(
        ...,
        description='Immutable. The source cluster from which Backups will be created via this BackupPlan.',
    )
    deactivated: Optional[bool] = Field(
        default=None,
        description='This flag indicates whether this BackupPlan has been deactivated.\nSetting this field to True locks the BackupPlan such that no further updates will be allowed\n(except deletes), including the deactivated field itself. It also prevents any new Backups\nfrom being created via this BackupPlan (including scheduled Backups).',
    )
    description: Optional[str] = Field(
        default=None,
        description='User specified descriptive string for this BackupPlan.',
    )
    location: str = Field(..., description='Immutable. The region of the Backup Plan.')
    projectRef: Union[ProjectRef, ProjectRef1] = Field(
        ..., description='The project that this resource belongs to.'
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )
    retentionPolicy: Optional[RetentionPolicy] = Field(
        default=None,
        description='RetentionPolicy governs lifecycle of Backups created under this plan.',
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    etag: Optional[str] = Field(
        default=None,
        description="etag is used for optimistic concurrency control as a way to help prevent simultaneous\nupdates of a backup plan from overwriting each other. It is strongly suggested that\nsystems make use of the 'etag' in the read-modify-write cycle to perform BackupPlan updates\nin order to avoid race conditions: An etag is returned in the response to backupPlans.get,\nand systems are expected to put that etag in the request to backupPlans.patch or\nbackupPlans.delete to ensure that their change will be applied to the same version of the resource.",
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )
    protectedPodCount: Optional[int] = Field(
        default=None,
        description='The number of Kubernetes Pods backed up in the last successful Backup created via this BackupPlan.',
    )
    state: Optional[str] = Field(
        default=None, description='The State of the BackupPlan.'
    )
    stateReason: Optional[str] = Field(
        default=None,
        description='Detailed description of why BackupPlan is in its current state.',
    )
    uid: Optional[str] = Field(
        default=None, description='Server generated, unique identifier of UUID format.'
    )
