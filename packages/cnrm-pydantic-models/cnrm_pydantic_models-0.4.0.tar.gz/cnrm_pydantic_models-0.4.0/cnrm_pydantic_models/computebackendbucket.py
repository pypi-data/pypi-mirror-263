# generated by datamodel-codegen:
#   filename:  computebackendbucket_v1beta1.json
#   timestamp: 2024-03-18T21:06:56+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field


class BucketRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The `name` field of a `StorageBucket` resource.',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class BucketRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The `name` field of a `StorageBucket` resource.',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class BypassCacheOnRequestHeader(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    headerName: Optional[str] = Field(
        default=None,
        description='The header field name to match on when bypassing cache. Values are case-insensitive.',
    )


class CacheKeyPolicy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    includeHttpHeaders: Optional[List[str]] = Field(
        default=None,
        description='Allows HTTP request headers (by name) to be used in the\ncache key.',
    )
    queryStringWhitelist: Optional[List[str]] = Field(
        default=None,
        description="Names of query string parameters to include in cache keys.\nDefault parameters are always included. '&' and '=' will\nbe percent encoded and not treated as delimiters.",
    )


class CdnPolicy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bypassCacheOnRequestHeaders: Optional[List[BypassCacheOnRequestHeader]] = Field(
        default=None,
        description='Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.',
    )
    cacheKeyPolicy: Optional[CacheKeyPolicy] = Field(
        default=None, description='The CacheKeyPolicy for this CdnPolicy.'
    )
    cacheMode: Optional[str] = Field(
        default=None,
        description='Specifies the cache setting for all responses from this backend.\nThe possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC Possible values: ["USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", "CACHE_ALL_STATIC"].',
    )
    clientTtl: Optional[int] = Field(
        default=None,
        description='Specifies the maximum allowed TTL for cached content served by this origin.',
    )
    defaultTtl: Optional[int] = Field(
        default=None,
        description='Specifies the default TTL for cached content served by this origin for responses\nthat do not have an existing valid TTL (max-age or s-max-age).',
    )
    maxTtl: Optional[int] = Field(
        default=None,
        description='Specifies the maximum allowed TTL for cached content served by this origin.',
    )
    negativeCaching: Optional[bool] = Field(
        default=None,
        description='Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.',
    )
    negativeCachingPolicy: Optional[List[NegativeCachingPolicyItem]] = Field(
        default=None,
        description="Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.\nOmitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.",
    )
    requestCoalescing: Optional[bool] = Field(
        default=None,
        description='If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.',
    )
    serveWhileStale: Optional[int] = Field(
        default=None,
        description='Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.',
    )
    signedUrlCacheMaxAgeSec: Optional[int] = Field(
        default=None,
        description='Maximum number of seconds the response to a signed URL request will\nbe considered fresh. After this time period,\nthe response will be revalidated before being served.\nWhen serving responses to signed URL requests,\nCloud CDN will internally behave as though\nall responses from this backend had a "Cache-Control: public,\nmax-age=[TTL]" header, regardless of any existing Cache-Control\nheader. The actual headers served in responses will not be altered.',
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class NegativeCachingPolicyItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: Optional[int] = Field(
        default=None,
        description='The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501\ncan be specified as values, and you cannot specify a status code more than once.',
    )
    ttl: Optional[int] = Field(
        default=None,
        description='The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s\n(30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.',
    )


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bucketRef: Union[BucketRef, BucketRef1] = Field(
        ..., description='Reference to the bucket.'
    )
    cdnPolicy: Optional[CdnPolicy] = Field(
        default=None, description='Cloud CDN configuration for this Backend Bucket.'
    )
    compressionMode: Optional[str] = Field(
        default=None,
        description='Compress text responses using Brotli or gzip compression, based on the client\'s Accept-Encoding header. Possible values: ["AUTOMATIC", "DISABLED"].',
    )
    customResponseHeaders: Optional[List[str]] = Field(
        default=None,
        description='Headers that the HTTP/S load balancer should add to proxied responses.',
    )
    description: Optional[str] = Field(
        default=None,
        description='An optional textual description of the resource; provided by the\nclient when the resource is created.',
    )
    edgeSecurityPolicy: Optional[str] = Field(
        default=None,
        description='The security policy associated with this backend bucket.',
    )
    enableCdn: Optional[bool] = Field(
        default=None, description='If true, enable Cloud CDN for this BackendBucket.'
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    creationTimestamp: Optional[str] = Field(
        default=None, description='Creation timestamp in RFC3339 text format.'
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )
    selfLink: Optional[str] = None
