# generated by datamodel-codegen:
#   filename:  monitoringdashboard_v1beta1.json
#   timestamp: 2024-03-18T21:08:25+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field


class Aggregation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    alignmentPeriod: Optional[str] = Field(
        default=None,
        description='The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.',
    )
    crossSeriesReducer: Optional[str] = Field(
        default=None,
        description='The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION',
    )
    groupByFields: Optional[List[str]] = Field(
        default=None,
        description='The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.',
    )
    perSeriesAligner: Optional[str] = Field(
        default=None,
        description='An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.',
    )


class ChartOptions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mode: Optional[str] = Field(
        default=None,
        description='The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS',
    )


class Column(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    weight: Optional[int] = Field(
        default=None,
        description='The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.',
    )
    widgets: Optional[List[Widget]] = Field(
        default=None,
        description='The display widgets arranged vertically in this column.',
    )


class ColumnLayout(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    columns: Optional[List[Column]] = Field(
        default=None, description='The columns of content to display.'
    )


class Condition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastTransitionTime: Optional[str] = Field(
        default=None,
        description='Last time the condition transitioned from one status to another.',
    )
    message: Optional[str] = Field(
        default=None,
        description='Human-readable message indicating details about last transition.',
    )
    reason: Optional[str] = Field(
        default=None,
        description="Unique, one-word, CamelCase reason for the condition's last transition.",
    )
    status: Optional[str] = Field(
        default=None,
        description='Status is the status of the condition. Can be True, False, Unknown.',
    )
    type: Optional[str] = Field(
        default=None, description='Type is the type of the condition.'
    )


class DataSet(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    legendTemplate: Optional[str] = Field(
        default=None,
        description="A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
    )
    minAlignmentPeriod: Optional[str] = Field(
        default=None,
        description='Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.',
    )
    plotType: Optional[str] = Field(
        default=None,
        description='How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP',
    )
    timeSeriesQuery: TimeSeriesQuery1 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class DataSet1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    legendTemplate: Optional[str] = Field(
        default=None,
        description="A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
    )
    minAlignmentPeriod: Optional[str] = Field(
        default=None,
        description='Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.',
    )
    plotType: Optional[str] = Field(
        default=None,
        description='How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP',
    )
    timeSeriesQuery: TimeSeriesQuery3 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class DataSet2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    legendTemplate: Optional[str] = Field(
        default=None,
        description="A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
    )
    minAlignmentPeriod: Optional[str] = Field(
        default=None,
        description='Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.',
    )
    plotType: Optional[str] = Field(
        default=None,
        description='How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP',
    )
    timeSeriesQuery: TimeSeriesQuery5 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class DataSet3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    legendTemplate: Optional[str] = Field(
        default=None,
        description="A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. ",
    )
    minAlignmentPeriod: Optional[str] = Field(
        default=None,
        description='Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.',
    )
    plotType: Optional[str] = Field(
        default=None,
        description='How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP',
    )
    timeSeriesQuery: TimeSeriesQuery7 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class Denominator(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Denominator7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class GaugeView(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lowerBound: Optional[float] = Field(
        default=None,
        description='The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.',
    )
    upperBound: Optional[float] = Field(
        default=None,
        description='The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.',
    )


class GridLayout(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    columns: Optional[int] = Field(
        default=None,
        description="The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.",
    )
    widgets: Optional[List[Widget1]] = Field(
        default=None,
        description='The informational elements that are arranged into the columns row-first.',
    )


class LogsPanel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    filter: Optional[str] = Field(
        default=None,
        description='A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.',
    )
    resourceNames: Optional[List[Union[ResourceNames, ResourceNames1]]] = None


class LogsPanel1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    filter: Optional[str] = Field(
        default=None,
        description='A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.',
    )
    resourceNames: Optional[List[Union[ResourceNames2, ResourceNames3]]] = None


class LogsPanel2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    filter: Optional[str] = Field(
        default=None,
        description='A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.',
    )
    resourceNames: Optional[List[Union[ResourceNames4, ResourceNames5]]] = None


class LogsPanel3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    filter: Optional[str] = Field(
        default=None,
        description='A filter that chooses which log entries to return. See [Advanced Logs Queries](https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries.',
    )
    resourceNames: Optional[List[Union[ResourceNames6, ResourceNames7]]] = None


class Model(BaseModel):
    apiVersion: Optional[str] = Field(
        default=None,
        description='apiVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        default=None,
        description='kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds',
    )
    metadata: Optional[Dict[str, Any]] = None
    spec: Spec
    status: Optional[Status] = None


class MosaicLayout(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    columns: Optional[int] = Field(
        default=None, description='The number of columns in the mosaic grid.'
    )
    tiles: Optional[List[Tile]] = Field(
        default=None, description='The tiles to display.'
    )


class Numerator(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class Numerator7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )


class PickTimeSeriesFilter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    direction: Optional[str] = Field(
        default=None,
        description='How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM',
    )
    numTimeSeries: Optional[int] = Field(
        default=None,
        description='How many time series to allow to pass through the filter.',
    )
    rankingMethod: Optional[str] = Field(
        default=None,
        description='`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST',
    )


class ProjectRef(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='The project id of the resource.\n\nAllowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ProjectRef1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='The project id of the resource.\n\nAllowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: Optional[str] = Field(
        default=None,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: str = Field(
        ...,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class ResourceNames7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    external: str = Field(
        ...,
        description='Allowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`).',
    )
    name: Optional[str] = Field(
        default=None,
        description='Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names',
    )
    namespace: Optional[str] = Field(
        default=None,
        description='Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/',
    )


class Row(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    weight: Optional[int] = Field(
        default=None,
        description='The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.',
    )
    widgets: Optional[List[Widget3]] = Field(
        default=None,
        description='The display widgets arranged horizontally in this row.',
    )


class RowLayout(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    rows: Optional[List[Row]] = Field(
        default=None, description='The rows of content to display.'
    )


class Scorecard(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gaugeView: Optional[GaugeView] = Field(
        default=None, description='Will cause the scorecard to show a gauge chart.'
    )
    sparkChartView: Optional[SparkChartView] = Field(
        default=None, description='Will cause the scorecard to show a spark chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None,
        description="The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
    )
    timeSeriesQuery: TimeSeriesQuery = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class Scorecard1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gaugeView: Optional[GaugeView] = Field(
        default=None, description='Will cause the scorecard to show a gauge chart.'
    )
    sparkChartView: Optional[SparkChartView] = Field(
        default=None, description='Will cause the scorecard to show a spark chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None,
        description="The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
    )
    timeSeriesQuery: TimeSeriesQuery2 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class Scorecard2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gaugeView: Optional[GaugeView] = Field(
        default=None, description='Will cause the scorecard to show a gauge chart.'
    )
    sparkChartView: Optional[SparkChartView] = Field(
        default=None, description='Will cause the scorecard to show a spark chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None,
        description="The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
    )
    timeSeriesQuery: TimeSeriesQuery4 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class Scorecard3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gaugeView: Optional[GaugeView] = Field(
        default=None, description='Will cause the scorecard to show a gauge chart.'
    )
    sparkChartView: Optional[SparkChartView] = Field(
        default=None, description='Will cause the scorecard to show a spark chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None,
        description="The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
    )
    timeSeriesQuery: TimeSeriesQuery6 = Field(
        ...,
        description='Required. Fields for querying time series data from the Stackdriver metrics API.',
    )


class SecondaryAggregation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    alignmentPeriod: Optional[str] = Field(
        default=None,
        description='The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored.',
    )
    crossSeriesReducer: Optional[str] = Field(
        default=None,
        description='The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION',
    )
    groupByFields: Optional[List[str]] = Field(
        default=None,
        description='The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored.',
    )
    perSeriesAligner: Optional[str] = Field(
        default=None,
        description='An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned.',
    )


class SparkChartView(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    minAlignmentPeriod: Optional[str] = Field(
        default=None,
        description='The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.',
    )
    sparkChartType: str = Field(
        ...,
        description='Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR',
    )


class Spec(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    columnLayout: Optional[ColumnLayout] = Field(
        default=None,
        description='The content is divided into equally spaced columns and the widgets are arranged vertically.',
    )
    displayName: str = Field(
        ..., description='Required. The mutable, human-readable name.'
    )
    gridLayout: Optional[GridLayout] = Field(
        default=None,
        description='Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles.',
    )
    mosaicLayout: Optional[MosaicLayout] = Field(
        default=None,
        description='The content is arranged as a grid of tiles, with each content widget occupying one or more tiles.',
    )
    projectRef: Union[ProjectRef, ProjectRef1] = Field(
        ..., description='Immutable. The Project that this resource belongs to.'
    )
    resourceID: Optional[str] = Field(
        default=None,
        description='Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default.',
    )
    rowLayout: Optional[RowLayout] = Field(
        default=None,
        description='The content is divided into equally spaced rows and the widgets are arranged horizontally.',
    )


class Status(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[Condition]] = Field(
        default=None,
        description="Conditions represent the latest available observation of the resource's current state.",
    )
    etag: Optional[str] = Field(
        default=None,
        description='\\`etag\\` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An \\`etag\\` is returned in the response to \\`GetDashboard\\`, and users are expected to put that etag in the request to \\`UpdateDashboard\\` to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation.',
    )
    observedGeneration: Optional[int] = Field(
        default=None,
        description='ObservedGeneration is the generation of the resource that was most recently observed by the Config Connector controller. If this is equal to metadata.generation, then that means that the current reported status reflects the most recent desired state of the resource.',
    )


class Text(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    content: Optional[str] = Field(
        default=None, description='The text content to be displayed.'
    )
    format: Optional[str] = Field(
        default=None,
        description='How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW',
    )


class Threshold(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Optional[str] = Field(
        default=None,
        description='The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED',
    )
    direction: Optional[str] = Field(
        default=None,
        description='The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW',
    )
    label: Optional[str] = Field(default=None, description='A label for the threshold.')
    value: Optional[float] = Field(
        default=None,
        description='The value of the threshold. The value should be defined in the native scale of the metric.',
    )


class Tile(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    height: Optional[int] = Field(
        default=None, description='The height of the tile, measured in grid squares.'
    )
    widget: Optional[Widget2] = Field(
        default=None, description='The informational widget contained in the tile.'
    )
    width: Optional[int] = Field(
        default=None, description='The width of the tile, measured in grid squares.'
    )
    xPos: Optional[int] = Field(
        default=None,
        description='The zero-indexed position of the tile in grid squares relative to the left edge of the grid.',
    )
    yPos: Optional[int] = Field(
        default=None,
        description='The zero-indexed position of the tile in grid squares relative to the top edge of the grid.',
    )


class TimeSeriesFilter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilter7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aggregation: Optional[Aggregation] = Field(
        default=None,
        description='By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.',
    )
    filter: str = Field(
        ...,
        description='Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query.',
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after `aggregation` is applied.',
    )


class TimeSeriesFilterRatio(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator1] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator1] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator2] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator2] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator3] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator3] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator4] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator4] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator5] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator5] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator6] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator6] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesFilterRatio7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    denominator: Optional[Denominator7] = Field(
        default=None, description='The denominator of the ratio.'
    )
    numerator: Optional[Numerator7] = Field(
        default=None, description='The numerator of the ratio.'
    )
    pickTimeSeriesFilter: Optional[PickTimeSeriesFilter] = Field(
        default=None, description='Ranking based time series filter.'
    )
    secondaryAggregation: Optional[SecondaryAggregation] = Field(
        default=None,
        description='Apply a second aggregation after the ratio is computed.',
    )


class TimeSeriesQuery(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter1] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio1] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter2] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio2] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter3] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio3] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter4] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio4] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter5] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio5] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter6] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio6] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class TimeSeriesQuery7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    timeSeriesFilter: Optional[TimeSeriesFilter7] = Field(
        default=None, description='Filter parameters to fetch time series.'
    )
    timeSeriesFilterRatio: Optional[TimeSeriesFilterRatio7] = Field(
        default=None,
        description='Parameters to fetch a ratio between two time series filters.',
    )
    timeSeriesQueryLanguage: Optional[str] = Field(
        default=None, description='A query used to fetch time series.'
    )
    unitOverride: Optional[str] = Field(
        default=None,
        description='The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`.',
    )


class Widget(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    blank: Optional[Dict[str, Any]] = Field(default=None, description='A blank space.')
    logsPanel: Optional[LogsPanel] = None
    scorecard: Optional[Scorecard] = Field(
        default=None, description='A scorecard summarizing time series data.'
    )
    text: Optional[Text] = Field(
        default=None, description='A raw string or markdown displaying textual content.'
    )
    title: Optional[str] = Field(
        default=None, description='Optional. The title of the widget.'
    )
    xyChart: Optional[XyChart] = Field(
        default=None, description='A chart of time series data.'
    )


class Widget1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    blank: Optional[Dict[str, Any]] = Field(default=None, description='A blank space.')
    logsPanel: Optional[LogsPanel1] = None
    scorecard: Optional[Scorecard1] = Field(
        default=None, description='A scorecard summarizing time series data.'
    )
    text: Optional[Text] = Field(
        default=None, description='A raw string or markdown displaying textual content.'
    )
    title: Optional[str] = Field(
        default=None, description='Optional. The title of the widget.'
    )
    xyChart: Optional[XyChart1] = Field(
        default=None, description='A chart of time series data.'
    )


class Widget2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    blank: Optional[Dict[str, Any]] = Field(default=None, description='A blank space.')
    logsPanel: Optional[LogsPanel2] = None
    scorecard: Optional[Scorecard2] = Field(
        default=None, description='A scorecard summarizing time series data.'
    )
    text: Optional[Text] = Field(
        default=None, description='A raw string or markdown displaying textual content.'
    )
    title: Optional[str] = Field(
        default=None, description='Optional. The title of the widget.'
    )
    xyChart: Optional[XyChart2] = Field(
        default=None, description='A chart of time series data.'
    )


class Widget3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    blank: Optional[Dict[str, Any]] = Field(default=None, description='A blank space.')
    logsPanel: Optional[LogsPanel3] = None
    scorecard: Optional[Scorecard3] = Field(
        default=None, description='A scorecard summarizing time series data.'
    )
    text: Optional[Text] = Field(
        default=None, description='A raw string or markdown displaying textual content.'
    )
    title: Optional[str] = Field(
        default=None, description='Optional. The title of the widget.'
    )
    xyChart: Optional[XyChart3] = Field(
        default=None, description='A chart of time series data.'
    )


class XAxis(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    label: Optional[str] = Field(default=None, description='The label of the axis.')
    scale: Optional[str] = Field(
        default=None,
        description='The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10',
    )


class XyChart(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    chartOptions: Optional[ChartOptions] = Field(
        default=None, description='Display options for the chart.'
    )
    dataSets: List[DataSet] = Field(
        ..., description='Required. The data displayed in this chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None, description='Threshold lines drawn horizontally across the chart.'
    )
    timeshiftDuration: Optional[str] = Field(
        default=None,
        description='The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.',
    )
    xAxis: Optional[XAxis] = Field(
        default=None, description='The properties applied to the X axis.'
    )
    yAxis: Optional[YAxis] = Field(
        default=None, description='The properties applied to the Y axis.'
    )


class XyChart1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    chartOptions: Optional[ChartOptions] = Field(
        default=None, description='Display options for the chart.'
    )
    dataSets: List[DataSet1] = Field(
        ..., description='Required. The data displayed in this chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None, description='Threshold lines drawn horizontally across the chart.'
    )
    timeshiftDuration: Optional[str] = Field(
        default=None,
        description='The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.',
    )
    xAxis: Optional[XAxis] = Field(
        default=None, description='The properties applied to the X axis.'
    )
    yAxis: Optional[YAxis] = Field(
        default=None, description='The properties applied to the Y axis.'
    )


class XyChart2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    chartOptions: Optional[ChartOptions] = Field(
        default=None, description='Display options for the chart.'
    )
    dataSets: List[DataSet2] = Field(
        ..., description='Required. The data displayed in this chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None, description='Threshold lines drawn horizontally across the chart.'
    )
    timeshiftDuration: Optional[str] = Field(
        default=None,
        description='The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.',
    )
    xAxis: Optional[XAxis] = Field(
        default=None, description='The properties applied to the X axis.'
    )
    yAxis: Optional[YAxis] = Field(
        default=None, description='The properties applied to the Y axis.'
    )


class XyChart3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    chartOptions: Optional[ChartOptions] = Field(
        default=None, description='Display options for the chart.'
    )
    dataSets: List[DataSet3] = Field(
        ..., description='Required. The data displayed in this chart.'
    )
    thresholds: Optional[List[Threshold]] = Field(
        default=None, description='Threshold lines drawn horizontally across the chart.'
    )
    timeshiftDuration: Optional[str] = Field(
        default=None,
        description='The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.',
    )
    xAxis: Optional[XAxis] = Field(
        default=None, description='The properties applied to the X axis.'
    )
    yAxis: Optional[YAxis] = Field(
        default=None, description='The properties applied to the Y axis.'
    )


class YAxis(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    label: Optional[str] = Field(default=None, description='The label of the axis.')
    scale: Optional[str] = Field(
        default=None,
        description='The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10',
    )
