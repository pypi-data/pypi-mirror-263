# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ApiExtensionDestination',
    'ApiExtensionTrigger',
    'AttributeGroupAttribute',
    'CartDiscountCustom',
    'CartDiscountTarget',
    'CartDiscountValue',
    'CartDiscountValueMoney',
    'CategoryAsset',
    'CategoryAssetSource',
    'CategoryAssetSourceDimensions',
    'CategoryCustom',
    'ChannelAddress',
    'ChannelCustom',
    'ChannelGeolocation',
    'CustomerGroupCustom',
    'DiscountCodeCustom',
    'ProductDiscountValue',
    'ProductDiscountValueMoney',
    'ProductTypeAttribute',
    'ProductTypeAttributeType',
    'ProductTypeAttributeTypeElementType2',
    'ProductTypeAttributeTypeElementType2LocalizedValue',
    'ProductTypeAttributeTypeElementType2Value',
    'ProductTypeAttributeTypeLocalizedValue',
    'ProductTypeAttributeTypeValue',
    'ProjectSettingsCarts',
    'ProjectSettingsExternalOauth',
    'ProjectSettingsMessages',
    'ProjectSettingsShippingRateCartClassificationValue',
    'ShippingMethodCustom',
    'ShippingZoneLocation',
    'ShippingZoneRateFreeAbove',
    'ShippingZoneRatePrice',
    'ShippingZoneRateShippingRatePriceTier',
    'ShippingZoneRateShippingRatePriceTierPrice',
    'ShippingZoneRateShippingRatePriceTierPriceFunction',
    'StoreCustom',
    'StoreProductSelection',
    'SubscriptionChange',
    'SubscriptionDestination',
    'SubscriptionFormat',
    'SubscriptionMessage',
    'TaxCategoryRateSubRate',
    'TypeField',
    'TypeFieldType',
    'TypeFieldTypeElementType2',
    'TypeFieldTypeElementType2LocalizedValue',
    'TypeFieldTypeElementType2Value',
    'TypeFieldTypeLocalizedValue',
    'TypeFieldTypeValue',
]

@pulumi.output_type
class ApiExtensionDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessSecret":
            suggest = "access_secret"
        elif key == "authorizationHeader":
            suggest = "authorization_header"
        elif key == "azureAuthentication":
            suggest = "azure_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiExtensionDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiExtensionDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiExtensionDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 access_secret: Optional[str] = None,
                 arn: Optional[str] = None,
                 authorization_header: Optional[str] = None,
                 azure_authentication: Optional[str] = None,
                 url: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_secret is not None:
            pulumi.set(__self__, "access_secret", access_secret)
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if authorization_header is not None:
            pulumi.set(__self__, "authorization_header", authorization_header)
        if azure_authentication is not None:
            pulumi.set(__self__, "azure_authentication", azure_authentication)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessSecret")
    def access_secret(self) -> Optional[str]:
        return pulumi.get(self, "access_secret")

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="authorizationHeader")
    def authorization_header(self) -> Optional[str]:
        return pulumi.get(self, "authorization_header")

    @property
    @pulumi.getter(name="azureAuthentication")
    def azure_authentication(self) -> Optional[str]:
        return pulumi.get(self, "azure_authentication")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class ApiExtensionTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypeId":
            suggest = "resource_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiExtensionTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiExtensionTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiExtensionTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Sequence[str],
                 resource_type_id: str,
                 condition: Optional[str] = None):
        """
        :param Sequence[str] actions: Currently, Create and Update are supported
        :param str resource_type_id: Currently, cart, order, payment, and customer are supported
        :param str condition: Valid predicate that controls the conditions under which the API Extension is called.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "resource_type_id", resource_type_id)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[str]:
        """
        Currently, Create and Update are supported
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="resourceTypeId")
    def resource_type_id(self) -> str:
        """
        Currently, cart, order, payment, and customer are supported
        """
        return pulumi.get(self, "resource_type_id")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        Valid predicate that controls the conditions under which the API Extension is called.
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class AttributeGroupAttribute(dict):
    def __init__(__self__, *,
                 key: str):
        """
        :param str key: The Attribute's name as given in its AttributeDefinition.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Attribute's name as given in its AttributeDefinition.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class CartDiscountCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CartDiscountCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CartDiscountCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CartDiscountCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class CartDiscountTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discountedQuantity":
            suggest = "discounted_quantity"
        elif key == "maxOccurrence":
            suggest = "max_occurrence"
        elif key == "selectionMode":
            suggest = "selection_mode"
        elif key == "triggerQuantity":
            suggest = "trigger_quantity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CartDiscountTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CartDiscountTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CartDiscountTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 discounted_quantity: Optional[int] = None,
                 max_occurrence: Optional[int] = None,
                 predicate: Optional[str] = None,
                 selection_mode: Optional[str] = None,
                 trigger_quantity: Optional[int] = None):
        """
        :param str type: Supports lineItems, customLineItems, multiBuyLineItems, multiBuyCustomLineItems, shipping or totalPrice
        :param int discounted_quantity: MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        :param int max_occurrence: MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        :param str predicate: LineItems, CustomLineItems, MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        :param str selection_mode: MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. Can be either Cheapest or MostExpensive. If set for another target the value will be ignored
        :param int trigger_quantity: MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        """
        pulumi.set(__self__, "type", type)
        if discounted_quantity is not None:
            pulumi.set(__self__, "discounted_quantity", discounted_quantity)
        if max_occurrence is not None:
            pulumi.set(__self__, "max_occurrence", max_occurrence)
        if predicate is not None:
            pulumi.set(__self__, "predicate", predicate)
        if selection_mode is not None:
            pulumi.set(__self__, "selection_mode", selection_mode)
        if trigger_quantity is not None:
            pulumi.set(__self__, "trigger_quantity", trigger_quantity)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Supports lineItems, customLineItems, multiBuyLineItems, multiBuyCustomLineItems, shipping or totalPrice
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="discountedQuantity")
    def discounted_quantity(self) -> Optional[int]:
        """
        MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        """
        return pulumi.get(self, "discounted_quantity")

    @property
    @pulumi.getter(name="maxOccurrence")
    def max_occurrence(self) -> Optional[int]:
        """
        MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        """
        return pulumi.get(self, "max_occurrence")

    @property
    @pulumi.getter
    def predicate(self) -> Optional[str]:
        """
        LineItems, CustomLineItems, MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        """
        return pulumi.get(self, "predicate")

    @property
    @pulumi.getter(name="selectionMode")
    def selection_mode(self) -> Optional[str]:
        """
        MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. Can be either Cheapest or MostExpensive. If set for another target the value will be ignored
        """
        return pulumi.get(self, "selection_mode")

    @property
    @pulumi.getter(name="triggerQuantity")
    def trigger_quantity(self) -> Optional[int]:
        """
        MultiBuyLineItems or MultiBuyCustomLineItems target specific fields. If set for another target the value will be ignored
        """
        return pulumi.get(self, "trigger_quantity")


@pulumi.output_type
class CartDiscountValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionChannelId":
            suggest = "distribution_channel_id"
        elif key == "productId":
            suggest = "product_id"
        elif key == "supplyChannelId":
            suggest = "supply_channel_id"
        elif key == "variantId":
            suggest = "variant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CartDiscountValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CartDiscountValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CartDiscountValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 distribution_channel_id: Optional[str] = None,
                 monies: Optional[Sequence['outputs.CartDiscountValueMoney']] = None,
                 permyriad: Optional[int] = None,
                 product_id: Optional[str] = None,
                 supply_channel_id: Optional[str] = None,
                 variant_id: Optional[int] = None):
        """
        :param str type: Currently supports absolute/relative/giftLineItem
        :param str distribution_channel_id: Channel must have the role ProductDistribution. Optional when value type is giftLineItem
        :param Sequence['CartDiscountValueMoneyArgs'] monies: Absolute discount specific fields
        :param int permyriad: Relative discount specific fields
        :param str product_id: ResourceIdentifier of a Product. Required when value type is giftLineItem
        :param str supply_channel_id: Channel must have the role InventorySupply. Optional when value type is giftLineItem
        :param int variant_id: ProductVariant of the Product. Required when value type is giftLineItem
        """
        pulumi.set(__self__, "type", type)
        if distribution_channel_id is not None:
            pulumi.set(__self__, "distribution_channel_id", distribution_channel_id)
        if monies is not None:
            pulumi.set(__self__, "monies", monies)
        if permyriad is not None:
            pulumi.set(__self__, "permyriad", permyriad)
        if product_id is not None:
            pulumi.set(__self__, "product_id", product_id)
        if supply_channel_id is not None:
            pulumi.set(__self__, "supply_channel_id", supply_channel_id)
        if variant_id is not None:
            pulumi.set(__self__, "variant_id", variant_id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Currently supports absolute/relative/giftLineItem
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="distributionChannelId")
    def distribution_channel_id(self) -> Optional[str]:
        """
        Channel must have the role ProductDistribution. Optional when value type is giftLineItem
        """
        return pulumi.get(self, "distribution_channel_id")

    @property
    @pulumi.getter
    def monies(self) -> Optional[Sequence['outputs.CartDiscountValueMoney']]:
        """
        Absolute discount specific fields
        """
        return pulumi.get(self, "monies")

    @property
    @pulumi.getter
    def permyriad(self) -> Optional[int]:
        """
        Relative discount specific fields
        """
        return pulumi.get(self, "permyriad")

    @property
    @pulumi.getter(name="productId")
    def product_id(self) -> Optional[str]:
        """
        ResourceIdentifier of a Product. Required when value type is giftLineItem
        """
        return pulumi.get(self, "product_id")

    @property
    @pulumi.getter(name="supplyChannelId")
    def supply_channel_id(self) -> Optional[str]:
        """
        Channel must have the role InventorySupply. Optional when value type is giftLineItem
        """
        return pulumi.get(self, "supply_channel_id")

    @property
    @pulumi.getter(name="variantId")
    def variant_id(self) -> Optional[int]:
        """
        ProductVariant of the Product. Required when value type is giftLineItem
        """
        return pulumi.get(self, "variant_id")


@pulumi.output_type
class CartDiscountValueMoney(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "centAmount":
            suggest = "cent_amount"
        elif key == "currencyCode":
            suggest = "currency_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CartDiscountValueMoney. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CartDiscountValueMoney.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CartDiscountValueMoney.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cent_amount: int,
                 currency_code: str):
        """
        :param int cent_amount: The amount in cents (the smallest indivisible unit of the currency)
        :param str currency_code: The currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)
        """
        pulumi.set(__self__, "cent_amount", cent_amount)
        pulumi.set(__self__, "currency_code", currency_code)

    @property
    @pulumi.getter(name="centAmount")
    def cent_amount(self) -> int:
        """
        The amount in cents (the smallest indivisible unit of the currency)
        """
        return pulumi.get(self, "cent_amount")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        """
        The currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)
        """
        return pulumi.get(self, "currency_code")


@pulumi.output_type
class CategoryAsset(dict):
    def __init__(__self__, *,
                 name: Mapping[str, Any],
                 description: Optional[Mapping[str, Any]] = None,
                 id: Optional[str] = None,
                 key: Optional[str] = None,
                 sources: Optional[Sequence['outputs.CategoryAssetSource']] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str key: Optional User-defined identifier for the asset. Asset keys are unique inside their container (in this case the category)
        :param Sequence['CategoryAssetSourceArgs'] sources: Array of AssetSource, Has at least one entry
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> Mapping[str, Any]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def description(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Optional User-defined identifier for the asset. Asset keys are unique inside their container (in this case the category)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.CategoryAssetSource']]:
        """
        Array of AssetSource, Has at least one entry
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class CategoryAssetSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CategoryAssetSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CategoryAssetSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CategoryAssetSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 content_type: Optional[str] = None,
                 dimensions: Optional['outputs.CategoryAssetSourceDimensions'] = None,
                 key: Optional[str] = None):
        """
        :param str key: Unique identifier, must be unique within the Asset
        """
        pulumi.set(__self__, "uri", uri)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional['outputs.CategoryAssetSourceDimensions']:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Unique identifier, must be unique within the Asset
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class CategoryAssetSourceDimensions(dict):
    def __init__(__self__, *,
                 h: int,
                 w: int):
        """
        :param int h: The height of the asset source
        :param int w: The width of the asset source
        """
        pulumi.set(__self__, "h", h)
        pulumi.set(__self__, "w", w)

    @property
    @pulumi.getter
    def h(self) -> int:
        """
        The height of the asset source
        """
        return pulumi.get(self, "h")

    @property
    @pulumi.getter
    def w(self) -> int:
        """
        The width of the asset source
        """
        return pulumi.get(self, "w")


@pulumi.output_type
class CategoryCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CategoryCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CategoryCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CategoryCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class ChannelAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalAddressInfo":
            suggest = "additional_address_info"
        elif key == "additionalStreetInfo":
            suggest = "additional_street_info"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "poBox":
            suggest = "po_box"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "streetName":
            suggest = "street_name"
        elif key == "streetNumber":
            suggest = "street_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country: str,
                 additional_address_info: Optional[str] = None,
                 additional_street_info: Optional[str] = None,
                 apartment: Optional[str] = None,
                 building: Optional[str] = None,
                 city: Optional[str] = None,
                 company: Optional[str] = None,
                 department: Optional[str] = None,
                 email: Optional[str] = None,
                 external_id: Optional[str] = None,
                 fax: Optional[str] = None,
                 first_name: Optional[str] = None,
                 id: Optional[str] = None,
                 key: Optional[str] = None,
                 last_name: Optional[str] = None,
                 mobile: Optional[str] = None,
                 phone: Optional[str] = None,
                 po_box: Optional[str] = None,
                 postal_code: Optional[str] = None,
                 region: Optional[str] = None,
                 salutation: Optional[str] = None,
                 state: Optional[str] = None,
                 street_name: Optional[str] = None,
                 street_number: Optional[str] = None,
                 title: Optional[str] = None):
        pulumi.set(__self__, "country", country)
        if additional_address_info is not None:
            pulumi.set(__self__, "additional_address_info", additional_address_info)
        if additional_street_info is not None:
            pulumi.set(__self__, "additional_street_info", additional_street_info)
        if apartment is not None:
            pulumi.set(__self__, "apartment", apartment)
        if building is not None:
            pulumi.set(__self__, "building", building)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if company is not None:
            pulumi.set(__self__, "company", company)
        if department is not None:
            pulumi.set(__self__, "department", department)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if fax is not None:
            pulumi.set(__self__, "fax", fax)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if phone is not None:
            pulumi.set(__self__, "phone", phone)
        if po_box is not None:
            pulumi.set(__self__, "po_box", po_box)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if salutation is not None:
            pulumi.set(__self__, "salutation", salutation)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if street_name is not None:
            pulumi.set(__self__, "street_name", street_name)
        if street_number is not None:
            pulumi.set(__self__, "street_number", street_number)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def country(self) -> str:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="additionalAddressInfo")
    def additional_address_info(self) -> Optional[str]:
        return pulumi.get(self, "additional_address_info")

    @property
    @pulumi.getter(name="additionalStreetInfo")
    def additional_street_info(self) -> Optional[str]:
        return pulumi.get(self, "additional_street_info")

    @property
    @pulumi.getter
    def apartment(self) -> Optional[str]:
        return pulumi.get(self, "apartment")

    @property
    @pulumi.getter
    def building(self) -> Optional[str]:
        return pulumi.get(self, "building")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def company(self) -> Optional[str]:
        return pulumi.get(self, "company")

    @property
    @pulumi.getter
    def department(self) -> Optional[str]:
        return pulumi.get(self, "department")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter
    def fax(self) -> Optional[str]:
        return pulumi.get(self, "fax")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def mobile(self) -> Optional[str]:
        return pulumi.get(self, "mobile")

    @property
    @pulumi.getter
    def phone(self) -> Optional[str]:
        return pulumi.get(self, "phone")

    @property
    @pulumi.getter(name="poBox")
    def po_box(self) -> Optional[str]:
        return pulumi.get(self, "po_box")

    @property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[str]:
        return pulumi.get(self, "postal_code")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def salutation(self) -> Optional[str]:
        return pulumi.get(self, "salutation")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="streetName")
    def street_name(self) -> Optional[str]:
        return pulumi.get(self, "street_name")

    @property
    @pulumi.getter(name="streetNumber")
    def street_number(self) -> Optional[str]:
        return pulumi.get(self, "street_number")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")


@pulumi.output_type
class ChannelCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class ChannelGeolocation(dict):
    def __init__(__self__, *,
                 coordinates: Sequence[float]):
        pulumi.set(__self__, "coordinates", coordinates)

    @property
    @pulumi.getter
    def coordinates(self) -> Sequence[float]:
        return pulumi.get(self, "coordinates")


@pulumi.output_type
class CustomerGroupCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomerGroupCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomerGroupCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomerGroupCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class DiscountCodeCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiscountCodeCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiscountCodeCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiscountCodeCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class ProductDiscountValue(dict):
    def __init__(__self__, *,
                 type: str,
                 monies: Optional[Sequence['outputs.ProductDiscountValueMoney']] = None,
                 permyriad: Optional[int] = None):
        """
        :param str type: Currently supports absolute/relative/external
        :param Sequence['ProductDiscountValueMoneyArgs'] monies: Absolute discount specific fields
        :param int permyriad: Relative discount specific fields
        """
        pulumi.set(__self__, "type", type)
        if monies is not None:
            pulumi.set(__self__, "monies", monies)
        if permyriad is not None:
            pulumi.set(__self__, "permyriad", permyriad)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Currently supports absolute/relative/external
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def monies(self) -> Optional[Sequence['outputs.ProductDiscountValueMoney']]:
        """
        Absolute discount specific fields
        """
        return pulumi.get(self, "monies")

    @property
    @pulumi.getter
    def permyriad(self) -> Optional[int]:
        """
        Relative discount specific fields
        """
        return pulumi.get(self, "permyriad")


@pulumi.output_type
class ProductDiscountValueMoney(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "centAmount":
            suggest = "cent_amount"
        elif key == "currencyCode":
            suggest = "currency_code"
        elif key == "fractionDigits":
            suggest = "fraction_digits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductDiscountValueMoney. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductDiscountValueMoney.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductDiscountValueMoney.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cent_amount: int,
                 currency_code: str,
                 fraction_digits: Optional[int] = None):
        """
        :param int cent_amount: The amount in cents (the smallest indivisible unit of the currency)
        :param str currency_code: The currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)
        :param int fraction_digits: The number of default fraction digits for the given currency, like 2 for EUR or 0 for JPY
        """
        pulumi.set(__self__, "cent_amount", cent_amount)
        pulumi.set(__self__, "currency_code", currency_code)
        if fraction_digits is not None:
            pulumi.set(__self__, "fraction_digits", fraction_digits)

    @property
    @pulumi.getter(name="centAmount")
    def cent_amount(self) -> int:
        """
        The amount in cents (the smallest indivisible unit of the currency)
        """
        return pulumi.get(self, "cent_amount")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        """
        The currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)
        """
        return pulumi.get(self, "currency_code")

    @property
    @pulumi.getter(name="fractionDigits")
    def fraction_digits(self) -> Optional[int]:
        """
        The number of default fraction digits for the given currency, like 2 for EUR or 0 for JPY
        """
        return pulumi.get(self, "fraction_digits")


@pulumi.output_type
class ProductTypeAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputHint":
            suggest = "input_hint"
        elif key == "inputTip":
            suggest = "input_tip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductTypeAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductTypeAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductTypeAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Mapping[str, Any],
                 name: str,
                 type: 'outputs.ProductTypeAttributeType',
                 constraint: Optional[str] = None,
                 input_hint: Optional[str] = None,
                 input_tip: Optional[Mapping[str, Any]] = None,
                 required: Optional[bool] = None,
                 searchable: Optional[bool] = None):
        """
        :param Mapping[str, Any] label: A human-readable label for the attribute
        :param str name: The unique name of the attribute used in the API. The name must be between two and 256 characters long and can contain the ASCII letters A to Z in lowercase or uppercase, digits, underscores (_) and the hyphen-minus (-).
               When using the same name for an attribute in two or more product types all fields of the AttributeDefinition of this attribute need to be the same across the product types, otherwise an AttributeDefinitionAlreadyExists error code will be returned. An exception to this are the values of an enum or lenum type and sets thereof
        :param 'ProductTypeAttributeTypeArgs' type: [AttributeType](https://docs.commercetools.com/api/projects/productTypes#attributetype)
        :param str constraint: Describes how an attribute or a set of attributes should be validated across all variants of a product. See also [Attribute Constraint](https://docs.commercetools.com/api/projects/productTypes#attributeconstraint-enum)
        :param str input_hint: Provides a visual representation type for this attribute. only relevant for text-based attribute types like TextType and LocalizableTextType
        :param Mapping[str, Any] input_tip: Additional information about the attribute that aids content managers when setting product details
        :param bool required: Whether the attribute is required to have a value
        :param bool searchable: Whether the attribute's values should generally be activated in product search
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if constraint is not None:
            pulumi.set(__self__, "constraint", constraint)
        if input_hint is not None:
            pulumi.set(__self__, "input_hint", input_hint)
        if input_tip is not None:
            pulumi.set(__self__, "input_tip", input_tip)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if searchable is not None:
            pulumi.set(__self__, "searchable", searchable)

    @property
    @pulumi.getter
    def label(self) -> Mapping[str, Any]:
        """
        A human-readable label for the attribute
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique name of the attribute used in the API. The name must be between two and 256 characters long and can contain the ASCII letters A to Z in lowercase or uppercase, digits, underscores (_) and the hyphen-minus (-).
        When using the same name for an attribute in two or more product types all fields of the AttributeDefinition of this attribute need to be the same across the product types, otherwise an AttributeDefinitionAlreadyExists error code will be returned. An exception to this are the values of an enum or lenum type and sets thereof
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> 'outputs.ProductTypeAttributeType':
        """
        [AttributeType](https://docs.commercetools.com/api/projects/productTypes#attributetype)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def constraint(self) -> Optional[str]:
        """
        Describes how an attribute or a set of attributes should be validated across all variants of a product. See also [Attribute Constraint](https://docs.commercetools.com/api/projects/productTypes#attributeconstraint-enum)
        """
        return pulumi.get(self, "constraint")

    @property
    @pulumi.getter(name="inputHint")
    def input_hint(self) -> Optional[str]:
        """
        Provides a visual representation type for this attribute. only relevant for text-based attribute types like TextType and LocalizableTextType
        """
        return pulumi.get(self, "input_hint")

    @property
    @pulumi.getter(name="inputTip")
    def input_tip(self) -> Optional[Mapping[str, Any]]:
        """
        Additional information about the attribute that aids content managers when setting product details
        """
        return pulumi.get(self, "input_tip")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether the attribute is required to have a value
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def searchable(self) -> Optional[bool]:
        """
        Whether the attribute's values should generally be activated in product search
        """
        return pulumi.get(self, "searchable")


@pulumi.output_type
class ProductTypeAttributeType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ElementType2":
            suggest = "element_type2"
        elif key == "localizedValues":
            suggest = "localized_values"
        elif key == "referenceTypeId":
            suggest = "reference_type_id"
        elif key == "typeReference":
            suggest = "type_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductTypeAttributeType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductTypeAttributeType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductTypeAttributeType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 element_type2: Optional['outputs.ProductTypeAttributeTypeElementType2'] = None,
                 localized_values: Optional[Sequence['outputs.ProductTypeAttributeTypeLocalizedValue']] = None,
                 reference_type_id: Optional[str] = None,
                 type_reference: Optional[str] = None,
                 values: Optional[Sequence['outputs.ProductTypeAttributeTypeValue']] = None):
        """
        :param str name: Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it
        :param Sequence['ProductTypeAttributeTypeLocalizedValueArgs'] localized_values: Localized values for the `lenum` type.
        :param str reference_type_id: Resource type the Custom Field can reference. Required when type is `reference`
        :param str type_reference: Reference to another product type. Required when type is `nested`.
        :param Sequence['ProductTypeAttributeTypeValueArgs'] values: Values for the `enum` type.
        """
        pulumi.set(__self__, "name", name)
        if element_type2 is not None:
            pulumi.set(__self__, "element_type2", element_type2)
        if localized_values is not None:
            pulumi.set(__self__, "localized_values", localized_values)
        if reference_type_id is not None:
            pulumi.set(__self__, "reference_type_id", reference_type_id)
        if type_reference is not None:
            pulumi.set(__self__, "type_reference", type_reference)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ElementType2")
    def element_type2(self) -> Optional['outputs.ProductTypeAttributeTypeElementType2']:
        return pulumi.get(self, "element_type2")

    @property
    @pulumi.getter(name="localizedValues")
    def localized_values(self) -> Optional[Sequence['outputs.ProductTypeAttributeTypeLocalizedValue']]:
        """
        Localized values for the `lenum` type.
        """
        return pulumi.get(self, "localized_values")

    @property
    @pulumi.getter(name="referenceTypeId")
    def reference_type_id(self) -> Optional[str]:
        """
        Resource type the Custom Field can reference. Required when type is `reference`
        """
        return pulumi.get(self, "reference_type_id")

    @property
    @pulumi.getter(name="typeReference")
    def type_reference(self) -> Optional[str]:
        """
        Reference to another product type. Required when type is `nested`.
        """
        return pulumi.get(self, "type_reference")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.ProductTypeAttributeTypeValue']]:
        """
        Values for the `enum` type.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProductTypeAttributeTypeElementType2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localizedValues":
            suggest = "localized_values"
        elif key == "referenceTypeId":
            suggest = "reference_type_id"
        elif key == "typeReference":
            suggest = "type_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductTypeAttributeTypeElementType2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductTypeAttributeTypeElementType2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductTypeAttributeTypeElementType2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 localized_values: Optional[Sequence['outputs.ProductTypeAttributeTypeElementType2LocalizedValue']] = None,
                 reference_type_id: Optional[str] = None,
                 type_reference: Optional[str] = None,
                 values: Optional[Sequence['outputs.ProductTypeAttributeTypeElementType2Value']] = None):
        """
        :param str name: Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it
        :param Sequence['ProductTypeAttributeTypeElementType2LocalizedValueArgs'] localized_values: Localized values for the `lenum` type.
        :param str reference_type_id: Resource type the Custom Field can reference. Required when type is `reference`
        :param str type_reference: Reference to another product type. Required when type is `nested`.
        :param Sequence['ProductTypeAttributeTypeElementType2ValueArgs'] values: Values for the `enum` type.
        """
        pulumi.set(__self__, "name", name)
        if localized_values is not None:
            pulumi.set(__self__, "localized_values", localized_values)
        if reference_type_id is not None:
            pulumi.set(__self__, "reference_type_id", reference_type_id)
        if type_reference is not None:
            pulumi.set(__self__, "type_reference", type_reference)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="localizedValues")
    def localized_values(self) -> Optional[Sequence['outputs.ProductTypeAttributeTypeElementType2LocalizedValue']]:
        """
        Localized values for the `lenum` type.
        """
        return pulumi.get(self, "localized_values")

    @property
    @pulumi.getter(name="referenceTypeId")
    def reference_type_id(self) -> Optional[str]:
        """
        Resource type the Custom Field can reference. Required when type is `reference`
        """
        return pulumi.get(self, "reference_type_id")

    @property
    @pulumi.getter(name="typeReference")
    def type_reference(self) -> Optional[str]:
        """
        Reference to another product type. Required when type is `nested`.
        """
        return pulumi.get(self, "type_reference")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.ProductTypeAttributeTypeElementType2Value']]:
        """
        Values for the `enum` type.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ProductTypeAttributeTypeElementType2LocalizedValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: Mapping[str, Any]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> Mapping[str, Any]:
        return pulumi.get(self, "label")


@pulumi.output_type
class ProductTypeAttributeTypeElementType2Value(dict):
    def __init__(__self__, *,
                 key: str,
                 label: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


@pulumi.output_type
class ProductTypeAttributeTypeLocalizedValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: Mapping[str, Any]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> Mapping[str, Any]:
        return pulumi.get(self, "label")


@pulumi.output_type
class ProductTypeAttributeTypeValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


@pulumi.output_type
class ProjectSettingsCarts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryTaxRateFallbackEnabled":
            suggest = "country_tax_rate_fallback_enabled"
        elif key == "deleteDaysAfterLastModification":
            suggest = "delete_days_after_last_modification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSettingsCarts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSettingsCarts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSettingsCarts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 country_tax_rate_fallback_enabled: Optional[bool] = None,
                 delete_days_after_last_modification: Optional[int] = None):
        """
        :param bool country_tax_rate_fallback_enabled: Indicates if country - no state tax rate fallback should be used when a shipping address state is not explicitly covered in the rates lists of all tax categories of a cart line items
        :param int delete_days_after_last_modification: Number - Optional The default value for the deleteDaysAfterLastModification parameter of the CartDraft. Initially set to 90 for projects created after December 2019.
        """
        if country_tax_rate_fallback_enabled is not None:
            pulumi.set(__self__, "country_tax_rate_fallback_enabled", country_tax_rate_fallback_enabled)
        if delete_days_after_last_modification is not None:
            pulumi.set(__self__, "delete_days_after_last_modification", delete_days_after_last_modification)

    @property
    @pulumi.getter(name="countryTaxRateFallbackEnabled")
    def country_tax_rate_fallback_enabled(self) -> Optional[bool]:
        """
        Indicates if country - no state tax rate fallback should be used when a shipping address state is not explicitly covered in the rates lists of all tax categories of a cart line items
        """
        return pulumi.get(self, "country_tax_rate_fallback_enabled")

    @property
    @pulumi.getter(name="deleteDaysAfterLastModification")
    def delete_days_after_last_modification(self) -> Optional[int]:
        """
        Number - Optional The default value for the deleteDaysAfterLastModification parameter of the CartDraft. Initially set to 90 for projects created after December 2019.
        """
        return pulumi.get(self, "delete_days_after_last_modification")


@pulumi.output_type
class ProjectSettingsExternalOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationHeader":
            suggest = "authorization_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSettingsExternalOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSettingsExternalOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSettingsExternalOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_header: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str authorization_header: Partially hidden on retrieval
        """
        if authorization_header is not None:
            pulumi.set(__self__, "authorization_header", authorization_header)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="authorizationHeader")
    def authorization_header(self) -> Optional[str]:
        """
        Partially hidden on retrieval
        """
        return pulumi.get(self, "authorization_header")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class ProjectSettingsMessages(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteDaysAfterCreation":
            suggest = "delete_days_after_creation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectSettingsMessages. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectSettingsMessages.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectSettingsMessages.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_days_after_creation: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        :param int delete_days_after_creation: Specifies the number of days each Message should be available via the Messages Query API
        :param bool enabled: When true the creation of messages on the Messages Query HTTP API is enabled
        """
        if delete_days_after_creation is not None:
            pulumi.set(__self__, "delete_days_after_creation", delete_days_after_creation)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="deleteDaysAfterCreation")
    def delete_days_after_creation(self) -> Optional[int]:
        """
        Specifies the number of days each Message should be available via the Messages Query API
        """
        return pulumi.get(self, "delete_days_after_creation")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When true the creation of messages on the Messages Query HTTP API is enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ProjectSettingsShippingRateCartClassificationValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: Optional[Mapping[str, str]] = None):
        """
        :param str key: [Resource Type ID](https://docs.commercetools.com/api/projects/Projects#changeProject)
        """
        pulumi.set(__self__, "key", key)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        [Resource Type ID](https://docs.commercetools.com/api/projects/Projects#changeProject)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "label")


@pulumi.output_type
class ShippingMethodCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingMethodCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingMethodCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingMethodCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class ShippingZoneLocation(dict):
    def __init__(__self__, *,
                 country: str,
                 state: Optional[str] = None):
        """
        :param str country: A two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
        """
        pulumi.set(__self__, "country", country)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        A two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class ShippingZoneRateFreeAbove(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "centAmount":
            suggest = "cent_amount"
        elif key == "currencyCode":
            suggest = "currency_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingZoneRateFreeAbove. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingZoneRateFreeAbove.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingZoneRateFreeAbove.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cent_amount: int,
                 currency_code: str):
        """
        :param int cent_amount: The amount in cents (the smallest indivisible unit of the currency)
        :param str currency_code: The currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)
        """
        pulumi.set(__self__, "cent_amount", cent_amount)
        pulumi.set(__self__, "currency_code", currency_code)

    @property
    @pulumi.getter(name="centAmount")
    def cent_amount(self) -> int:
        """
        The amount in cents (the smallest indivisible unit of the currency)
        """
        return pulumi.get(self, "cent_amount")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        """
        The currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217)
        """
        return pulumi.get(self, "currency_code")


@pulumi.output_type
class ShippingZoneRatePrice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "centAmount":
            suggest = "cent_amount"
        elif key == "currencyCode":
            suggest = "currency_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingZoneRatePrice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingZoneRatePrice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingZoneRatePrice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cent_amount: int,
                 currency_code: str):
        pulumi.set(__self__, "cent_amount", cent_amount)
        pulumi.set(__self__, "currency_code", currency_code)

    @property
    @pulumi.getter(name="centAmount")
    def cent_amount(self) -> int:
        return pulumi.get(self, "cent_amount")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        return pulumi.get(self, "currency_code")


@pulumi.output_type
class ShippingZoneRateShippingRatePriceTier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumCentAmount":
            suggest = "minimum_cent_amount"
        elif key == "priceFunction":
            suggest = "price_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingZoneRateShippingRatePriceTier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingZoneRateShippingRatePriceTier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingZoneRateShippingRatePriceTier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 minimum_cent_amount: Optional[int] = None,
                 price: Optional['outputs.ShippingZoneRateShippingRatePriceTierPrice'] = None,
                 price_function: Optional['outputs.ShippingZoneRateShippingRatePriceTierPriceFunction'] = None,
                 score: Optional[int] = None,
                 value: Optional[str] = None):
        """
        :param str type: CartValue, CartScore or CartClassification
        :param int minimum_cent_amount: If type is CartValue this represents the cent amount of the tier
        :param 'ShippingZoneRateShippingRatePriceTierPriceArgs' price: The price of the score, value or minimum_cent_amount tier
        :param 'ShippingZoneRateShippingRatePriceTierPriceFunctionArgs' price_function: If type is CartScore. Allows to calculate a price dynamically for the score.
        :param int score: If type is CartScore. Sets a fixed price for this score value
        :param str value: If type is CartClassification, must be a valid key of the CartClassification
        """
        pulumi.set(__self__, "type", type)
        if minimum_cent_amount is not None:
            pulumi.set(__self__, "minimum_cent_amount", minimum_cent_amount)
        if price is not None:
            pulumi.set(__self__, "price", price)
        if price_function is not None:
            pulumi.set(__self__, "price_function", price_function)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        CartValue, CartScore or CartClassification
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="minimumCentAmount")
    def minimum_cent_amount(self) -> Optional[int]:
        """
        If type is CartValue this represents the cent amount of the tier
        """
        return pulumi.get(self, "minimum_cent_amount")

    @property
    @pulumi.getter
    def price(self) -> Optional['outputs.ShippingZoneRateShippingRatePriceTierPrice']:
        """
        The price of the score, value or minimum_cent_amount tier
        """
        return pulumi.get(self, "price")

    @property
    @pulumi.getter(name="priceFunction")
    def price_function(self) -> Optional['outputs.ShippingZoneRateShippingRatePriceTierPriceFunction']:
        """
        If type is CartScore. Allows to calculate a price dynamically for the score.
        """
        return pulumi.get(self, "price_function")

    @property
    @pulumi.getter
    def score(self) -> Optional[int]:
        """
        If type is CartScore. Sets a fixed price for this score value
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        If type is CartClassification, must be a valid key of the CartClassification
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShippingZoneRateShippingRatePriceTierPrice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "centAmount":
            suggest = "cent_amount"
        elif key == "currencyCode":
            suggest = "currency_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingZoneRateShippingRatePriceTierPrice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingZoneRateShippingRatePriceTierPrice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingZoneRateShippingRatePriceTierPrice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cent_amount: int,
                 currency_code: str):
        pulumi.set(__self__, "cent_amount", cent_amount)
        pulumi.set(__self__, "currency_code", currency_code)

    @property
    @pulumi.getter(name="centAmount")
    def cent_amount(self) -> int:
        return pulumi.get(self, "cent_amount")

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        return pulumi.get(self, "currency_code")


@pulumi.output_type
class ShippingZoneRateShippingRatePriceTierPriceFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currencyCode":
            suggest = "currency_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShippingZoneRateShippingRatePriceTierPriceFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShippingZoneRateShippingRatePriceTierPriceFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShippingZoneRateShippingRatePriceTierPriceFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 currency_code: str,
                 function: str):
        pulumi.set(__self__, "currency_code", currency_code)
        pulumi.set(__self__, "function", function)

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> str:
        return pulumi.get(self, "currency_code")

    @property
    @pulumi.getter
    def function(self) -> str:
        return pulumi.get(self, "function")


@pulumi.output_type
class StoreCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeId":
            suggest = "type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StoreCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StoreCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StoreCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_id: str,
                 fields: Optional[Mapping[str, Any]] = None):
        """
        :param Mapping[str, Any] fields: Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        pulumi.set(__self__, "type_id", type_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="typeId")
    def type_id(self) -> str:
        return pulumi.get(self, "type_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Mapping[str, Any]]:
        """
        Custom fields for this resource. Note that the values need to be provided as JSON encoded strings: `my-value = jsonencode({"key": "value"})`
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class StoreProductSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "productSelectionId":
            suggest = "product_selection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StoreProductSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StoreProductSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StoreProductSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 product_selection_id: str):
        """
        :param bool active: If true, all Products assigned to this Product Selection are part of the Store's assortment
        :param str product_selection_id: Resource Identifier of a ProductSelection
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "product_selection_id", product_selection_id)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        If true, all Products assigned to this Product Selection are part of the Store's assortment
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter(name="productSelectionId")
    def product_selection_id(self) -> str:
        """
        Resource Identifier of a ProductSelection
        """
        return pulumi.get(self, "product_selection_id")


@pulumi.output_type
class SubscriptionChange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypeIds":
            suggest = "resource_type_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionChange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionChange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionChange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type_ids: Sequence[str]):
        """
        :param Sequence[str] resource_type_ids: [Resource Type ID](https://docs.commercetools.com/api/projects/subscriptions#changesubscription)
        """
        pulumi.set(__self__, "resource_type_ids", resource_type_ids)

    @property
    @pulumi.getter(name="resourceTypeIds")
    def resource_type_ids(self) -> Sequence[str]:
        """
        [Resource Type ID](https://docs.commercetools.com/api/projects/subscriptions#changesubscription)
        """
        return pulumi.get(self, "resource_type_ids")


@pulumi.output_type
class SubscriptionDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessSecret":
            suggest = "access_secret"
        elif key == "accountId":
            suggest = "account_id"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "bootstrapServer":
            suggest = "bootstrap_server"
        elif key == "connectionString":
            suggest = "connection_string"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "queueUrl":
            suggest = "queue_url"
        elif key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 access_secret: Optional[str] = None,
                 account_id: Optional[str] = None,
                 acks: Optional[str] = None,
                 api_key: Optional[str] = None,
                 api_secret: Optional[str] = None,
                 bootstrap_server: Optional[str] = None,
                 connection_string: Optional[str] = None,
                 key: Optional[str] = None,
                 project_id: Optional[str] = None,
                 queue_url: Optional[str] = None,
                 region: Optional[str] = None,
                 topic: Optional[str] = None,
                 topic_arn: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str type: The type of the destination. See [Destination](https://docs.commercetools.com/api/projects/subscriptions#destination) for more information
        :param str access_key: The access key of the SQS queue, SNS topic or EventBridge topic
        :param str access_secret: The access secret of the SQS queue, SNS topic or EventBridge topic
        :param str account_id: The AWS account ID of the SNS topic or EventBridge topic
        :param str acks: The acks value of the Confluent Cloud topic
        :param str api_key: The API key of the Confluent Cloud topic
        :param str api_secret: The API secret of the Confluent Cloud topic
        :param str bootstrap_server: The bootstrap server of the Confluent Cloud topic
        :param str connection_string: The connection string of the Azure Service Bus
        :param str key: The key of the Confluent Cloud topic
        :param str project_id: The project ID of the Google Cloud Pub/Sub
        :param str queue_url: The URL of the SQS queue
        :param str region: The region of the SQS queue, SNS topic or EventBridge topic
        :param str topic: The topic of the Google Cloud Pub/Sub or Confluent Cloud topic
        :param str topic_arn: The ARN of the SNS topic
        :param str uri: The URI of the EventGrid topic
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_secret is not None:
            pulumi.set(__self__, "access_secret", access_secret)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if acks is not None:
            pulumi.set(__self__, "acks", acks)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)
        if bootstrap_server is not None:
            pulumi.set(__self__, "bootstrap_server", bootstrap_server)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if topic_arn is not None:
            pulumi.set(__self__, "topic_arn", topic_arn)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the destination. See [Destination](https://docs.commercetools.com/api/projects/subscriptions#destination) for more information
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The access key of the SQS queue, SNS topic or EventBridge topic
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessSecret")
    def access_secret(self) -> Optional[str]:
        """
        The access secret of the SQS queue, SNS topic or EventBridge topic
        """
        return pulumi.get(self, "access_secret")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        The AWS account ID of the SNS topic or EventBridge topic
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def acks(self) -> Optional[str]:
        """
        The acks value of the Confluent Cloud topic
        """
        return pulumi.get(self, "acks")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key of the Confluent Cloud topic
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[str]:
        """
        The API secret of the Confluent Cloud topic
        """
        return pulumi.get(self, "api_secret")

    @property
    @pulumi.getter(name="bootstrapServer")
    def bootstrap_server(self) -> Optional[str]:
        """
        The bootstrap server of the Confluent Cloud topic
        """
        return pulumi.get(self, "bootstrap_server")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        The connection string of the Azure Service Bus
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the Confluent Cloud topic
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The project ID of the Google Cloud Pub/Sub
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[str]:
        """
        The URL of the SQS queue
        """
        return pulumi.get(self, "queue_url")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region of the SQS queue, SNS topic or EventBridge topic
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        The topic of the Google Cloud Pub/Sub or Confluent Cloud topic
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> Optional[str]:
        """
        The ARN of the SNS topic
        """
        return pulumi.get(self, "topic_arn")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The URI of the EventGrid topic
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class SubscriptionFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudEventsVersion":
            suggest = "cloud_events_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_events_version: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str cloud_events_version: For CloudEvents
        """
        if cloud_events_version is not None:
            pulumi.set(__self__, "cloud_events_version", cloud_events_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudEventsVersion")
    def cloud_events_version(self) -> Optional[str]:
        """
        For CloudEvents
        """
        return pulumi.get(self, "cloud_events_version")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SubscriptionMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypeId":
            suggest = "resource_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type_id: str,
                 types: Sequence[str]):
        """
        :param str resource_type_id: [Resource Type ID](https://docs.commercetools.com/api/projects/subscriptions#changesubscription)
        :param Sequence[str] types: types must contain valid message types for this resource, for example for resource type product the message type ProductPublished is valid. If no types of messages are given, the subscription is valid for all messages of this resource
        """
        pulumi.set(__self__, "resource_type_id", resource_type_id)
        pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter(name="resourceTypeId")
    def resource_type_id(self) -> str:
        """
        [Resource Type ID](https://docs.commercetools.com/api/projects/subscriptions#changesubscription)
        """
        return pulumi.get(self, "resource_type_id")

    @property
    @pulumi.getter
    def types(self) -> Sequence[str]:
        """
        types must contain valid message types for this resource, for example for resource type product the message type ProductPublished is valid. If no types of messages are given, the subscription is valid for all messages of this resource
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class TaxCategoryRateSubRate(dict):
    def __init__(__self__, *,
                 amount: float,
                 name: str):
        """
        :param float amount: Number Percentage in the range of [0..1]
        """
        pulumi.set(__self__, "amount", amount)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def amount(self) -> float:
        """
        Number Percentage in the range of [0..1]
        """
        return pulumi.get(self, "amount")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class TypeField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputHint":
            suggest = "input_hint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TypeField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TypeField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TypeField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Mapping[str, Any],
                 name: str,
                 type: 'outputs.TypeFieldType',
                 input_hint: Optional[str] = None,
                 required: Optional[bool] = None):
        """
        :param Mapping[str, Any] label: A human-readable label for the field
        :param str name: The name of the field.
               The name must be between two and 36 characters long and can contain the ASCII letters A to Z in lowercase or uppercase, digits, underscores (_) and the hyphen-minus (-).
               The name must be unique for a given resource type ID. In case there is a field with the same name in another type it has to have the same FieldType also
        :param 'TypeFieldTypeArgs' type: Describes the [type](https://docs.commercetools.com/api/projects/types#fieldtype) of the field
        :param str input_hint: [TextInputHint](https://docs.commercetools.com/api/projects/types#textinputhint) Provides a visual representation type for this field. It is only relevant for string-based field types like StringType and LocalizedStringType
        :param bool required: Whether the field is required to have a value
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if input_hint is not None:
            pulumi.set(__self__, "input_hint", input_hint)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def label(self) -> Mapping[str, Any]:
        """
        A human-readable label for the field
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the field.
        The name must be between two and 36 characters long and can contain the ASCII letters A to Z in lowercase or uppercase, digits, underscores (_) and the hyphen-minus (-).
        The name must be unique for a given resource type ID. In case there is a field with the same name in another type it has to have the same FieldType also
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> 'outputs.TypeFieldType':
        """
        Describes the [type](https://docs.commercetools.com/api/projects/types#fieldtype) of the field
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="inputHint")
    def input_hint(self) -> Optional[str]:
        """
        [TextInputHint](https://docs.commercetools.com/api/projects/types#textinputhint) Provides a visual representation type for this field. It is only relevant for string-based field types like StringType and LocalizedStringType
        """
        return pulumi.get(self, "input_hint")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether the field is required to have a value
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class TypeFieldType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ElementType2":
            suggest = "element_type2"
        elif key == "localizedValues":
            suggest = "localized_values"
        elif key == "referenceTypeId":
            suggest = "reference_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TypeFieldType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TypeFieldType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TypeFieldType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 element_type2: Optional['outputs.TypeFieldTypeElementType2'] = None,
                 localized_values: Optional[Sequence['outputs.TypeFieldTypeLocalizedValue']] = None,
                 reference_type_id: Optional[str] = None,
                 values: Optional[Sequence['outputs.TypeFieldTypeValue']] = None):
        """
        :param str name: Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it.
        :param Sequence['TypeFieldTypeLocalizedValueArgs'] localized_values: Localized values for the `lenum` type.
        :param str reference_type_id: Resource type the Custom Field can reference. Required when type is `Reference`
        :param Sequence['TypeFieldTypeValueArgs'] values: Values for the `enum` type.
        """
        pulumi.set(__self__, "name", name)
        if element_type2 is not None:
            pulumi.set(__self__, "element_type2", element_type2)
        if localized_values is not None:
            pulumi.set(__self__, "localized_values", localized_values)
        if reference_type_id is not None:
            pulumi.set(__self__, "reference_type_id", reference_type_id)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ElementType2")
    def element_type2(self) -> Optional['outputs.TypeFieldTypeElementType2']:
        return pulumi.get(self, "element_type2")

    @property
    @pulumi.getter(name="localizedValues")
    def localized_values(self) -> Optional[Sequence['outputs.TypeFieldTypeLocalizedValue']]:
        """
        Localized values for the `lenum` type.
        """
        return pulumi.get(self, "localized_values")

    @property
    @pulumi.getter(name="referenceTypeId")
    def reference_type_id(self) -> Optional[str]:
        """
        Resource type the Custom Field can reference. Required when type is `Reference`
        """
        return pulumi.get(self, "reference_type_id")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TypeFieldTypeValue']]:
        """
        Values for the `enum` type.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class TypeFieldTypeElementType2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localizedValues":
            suggest = "localized_values"
        elif key == "referenceTypeId":
            suggest = "reference_type_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TypeFieldTypeElementType2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TypeFieldTypeElementType2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TypeFieldTypeElementType2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 localized_values: Optional[Sequence['outputs.TypeFieldTypeElementType2LocalizedValue']] = None,
                 reference_type_id: Optional[str] = None,
                 values: Optional[Sequence['outputs.TypeFieldTypeElementType2Value']] = None):
        """
        :param str name: Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it.
        :param Sequence['TypeFieldTypeElementType2LocalizedValueArgs'] localized_values: Localized values for the `lenum` type.
        :param str reference_type_id: Resource type the Custom Field can reference. Required when type is `Reference`
        :param Sequence['TypeFieldTypeElementType2ValueArgs'] values: Values for the `enum` type.
        """
        pulumi.set(__self__, "name", name)
        if localized_values is not None:
            pulumi.set(__self__, "localized_values", localized_values)
        if reference_type_id is not None:
            pulumi.set(__self__, "reference_type_id", reference_type_id)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field type. Some types require extra fields to be set. Note that changing the type after creating is not supported. You need to delete the attribute and re-add it.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="localizedValues")
    def localized_values(self) -> Optional[Sequence['outputs.TypeFieldTypeElementType2LocalizedValue']]:
        """
        Localized values for the `lenum` type.
        """
        return pulumi.get(self, "localized_values")

    @property
    @pulumi.getter(name="referenceTypeId")
    def reference_type_id(self) -> Optional[str]:
        """
        Resource type the Custom Field can reference. Required when type is `Reference`
        """
        return pulumi.get(self, "reference_type_id")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.TypeFieldTypeElementType2Value']]:
        """
        Values for the `enum` type.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class TypeFieldTypeElementType2LocalizedValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: Mapping[str, Any]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> Mapping[str, Any]:
        return pulumi.get(self, "label")


@pulumi.output_type
class TypeFieldTypeElementType2Value(dict):
    def __init__(__self__, *,
                 key: str,
                 label: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


@pulumi.output_type
class TypeFieldTypeLocalizedValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: Mapping[str, Any]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> Mapping[str, Any]:
        return pulumi.get(self, "label")


@pulumi.output_type
class TypeFieldTypeValue(dict):
    def __init__(__self__, *,
                 key: str,
                 label: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")


